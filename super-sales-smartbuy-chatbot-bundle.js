/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[0].use[2]!./src/style.scss":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[0].use[2]!./src/style.scss ***!
  \*************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.super-sales-chat-container .chat-app button.outline-button {\n  align-items: center;\n  background-color: #fff;\n  border: 1px solid;\n  border-radius: 8px;\n  box-sizing: border-box;\n  color: #f44e6c;\n  display: flex;\n  font-size: 16px;\n  font-weight: 500;\n  justify-content: space-between;\n  line-height: 22px;\n  margin: 4px 0;\n  padding: 10px 12px;\n  position: relative;\n  width: 100%;\n  word-break: break-word;\n}\n.super-sales-chat-container .chat-app button.outline-button p {\n  margin: 0;\n  max-width: 250px;\n  text-align: start;\n}\n.super-sales-chat-container .chat-app button.outline-button svg {\n  height: 20px;\n  width: 20px;\n}\n.super-sales-chat-container .chat-app button.OrderLookup__cancelV2, .super-sales-chat-container .chat-app button.OrderLookup__lookupBtn {\n  background-color: #fff;\n  border: 1px solid #2c6ecb;\n  border-radius: 20px;\n  box-sizing: border-box;\n  color: #2c6ecb;\n  cursor: pointer;\n  display: flex;\n  flex-shrink: 0;\n  margin: 12px 16px 0 auto;\n  max-width: 274px;\n  overflow-wrap: break-word;\n  padding: 8px 12px;\n  text-align: left;\n}\n.super-sales-chat-container .chat-app .OrderLookup__findOrder {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  margin: 16px;\n}\n.super-sales-chat-container .chat-app .OrderLookup__button {\n  margin: 0 12px;\n}\n.super-sales-chat-container .chat-app .OrderLookup__button:nth-of-type(2) {\n  margin-top: 8px;\n}\n.super-sales-chat-container .chat-app .OrderLookup__button:last-of-type {\n  margin-bottom: 8px;\n}\n.super-sales-chat-container .chat-app button.OrderLookup__find {\n  background-color: #fff;\n  border-radius: 12px;\n  color: #2c6ecb;\n  padding: 16px 0;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .chat-app button.OrderLookup__find:hover {\n  background-color: #1f5199;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .chat-app button.OrderLookup__find--is-mobile {\n  background-color: #2c6ecb;\n  color: var(#000000);\n  padding-bottom: 22px;\n  padding-top: 12px;\n}\n.super-sales-chat-container .chat-view button.OrderLookup__find--is-mobile {\n  padding-bottom: 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper {\n  margin: -56px 0 0;\n}\n.super-sales-chat-container .composer-bar-wrapper.composer-bar-interstitialView .composer-bar-form {\n  padding-bottom: 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper.composer-bar-interstitialView .composer-bar-form .composer-bar__warning-limit {\n  bottom: 24px;\n  margin-bottom: 0;\n  position: absolute;\n}\n.super-sales-chat-container .composer-bar-wrapper.composer-bar-interstitialView .composer-bar-form .composer-bar__box {\n  flex-direction: row;\n}\n.super-sales-chat-container .composer-bar-wrapper.composer-bar-media-disabled .composer-bar-form .composer-bar__box {\n  flex-direction: row;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form {\n  background-color: #fff;\n  border-radius: 8px;\n  display: flex;\n  flex-direction: column;\n  margin: 0 12px 4px;\n  position: relative;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__footer {\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: space-between;\n  margin-top: 16px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__box {\n  border: 1px solid #d2d5d9;\n  border-radius: 8px;\n  box-shadow: none;\n  display: flex;\n  flex-direction: column;\n  min-height: 44px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__box:focus-within {\n  border-color: #42474c;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form textarea {\n  border: 0;\n  border-radius: 8px;\n  color: #4b5158;\n  flex-grow: 1;\n  line-height: 20px;\n  outline: none;\n  overflow: hidden auto;\n  overflow: hidden;\n  padding: 12px;\n  resize: none;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form textarea.reached-limit {\n  margin-bottom: 24px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form textarea::placeholder {\n  color: #a0a4a9;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__upload {\n  align-self: flex-end;\n  margin-bottom: 12px;\n  padding: 0 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__image-container {\n  padding: 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__footer-button {\n  align-self: center;\n  display: flex;\n  padding: 0 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__footer-button:disabled svg {\n  fill: #cdcdcf;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__footer-button.multiple-lines {\n  align-self: flex-end;\n  margin-bottom: 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__footer-button svg {\n  stroke: none;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form.form-multiple-lines .composer-bar__footer-button {\n  align-self: flex-end;\n  margin-bottom: 12px;\n}\n.super-sales-chat-container .composer-bar-wrapper .composer-bar-form .composer-bar__warning-limit {\n  color: #6d7175;\n  font-size: 13px;\n  margin: -16px 12px 8px;\n}\n.super-sales-chat-container .OrderLookup__button + .composer-bar-wrapper {\n  margin-top: 4px;\n}\n.super-sales-chat-container .composer-bar__footer-message {\n  align-items: center;\n  display: flex;\n}\n.super-sales-chat-container .composer-bar__footer-message .loading-ui__spinner {\n  border: 2px solid #f3f3f3;\n  border-top-color: #000;\n  height: 15px;\n  margin: 0;\n  width: 15px;\n}\n.super-sales-chat-container .composer-bar__footer-message .composer-bar__footer-message__updating-text {\n  margin-left: 8px;\n}\n.super-sales-chat-container .signUp-button {\n  margin: 0 12px 8px;\n}\n.super-sales-chat-container .chat-app button.outline-button.center-text {\n  justify-content: center;\n}\n.super-sales-chat-container .loading-message {\n  display: flex;\n  padding: 5px 0;\n}\n.super-sales-chat-container .loading-circle {\n  background-color: #5c5f62;\n  border-radius: 50%;\n  height: 6px;\n  width: 6px;\n}\n.super-sales-chat-container .loading-circle.one {\n  animation: pulseAnimationOne 1s infinite;\n  margin-left: 14px;\n  margin-right: 2px;\n}\n.super-sales-chat-container .loading-circle.two {\n  animation: pulseAnimationTwo 1s infinite;\n  margin-left: 2px;\n  margin-right: 2px;\n}\n.super-sales-chat-container .loading-circle.three {\n  animation: pulseAnimationThree 1s infinite;\n  margin-left: 2px;\n  margin-right: 14px;\n}\n@keyframes pulseAnimationOne {\n  0% {\n    background-color: #8c9196;\n  }\n  25% {\n    background-color: #5c5f62;\n  }\n  50% {\n    background-color: #8c9196;\n  }\n  to {\n    background-color: #8c9196;\n  }\n}\n@keyframes pulseAnimationTwo {\n  0% {\n    background-color: #8c9196;\n  }\n  25% {\n    background-color: #8c9196;\n  }\n  50% {\n    background-color: #5c5f62;\n  }\n  to {\n    background-color: #8c9196;\n  }\n}\n@keyframes pulseAnimationThree {\n  0% {\n    background-color: #8c9196;\n  }\n  25% {\n    background-color: #8c9196;\n  }\n  50% {\n    background-color: #8c9196;\n  }\n  to {\n    background-color: #5c5f62;\n  }\n}\n.super-sales-chat-container .loading-ui {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  margin: auto;\n  min-height: 265px;\n  scrollbar-color: transparent transparent;\n  text-align: center;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.super-sales-chat-container .loading-ui::-webkit-scrollbar {\n  display: none;\n}\n.super-sales-chat-container .loading-ui__spinner {\n  animation: shopify-chat-spin 0.6s linear infinite;\n  border: 6px solid #f3f3f3;\n  border-radius: 50%;\n  border-top-color: #0089d3;\n  height: 30px;\n  margin: auto;\n  width: 30px;\n}\n.super-sales-chat-container .chat-header__info {\n  align-items: center;\n  display: flex;\n  flex: 1;\n  flex-direction: row;\n  position: relative;\n}\n.super-sales-chat-container .chat-header__info button {\n  left: 2px;\n  position: absolute;\n}\n.super-sales-chat-container .chat-header__info button:focus, .super-sales-chat-container .chat-header__info button:hover {\n  filter: brightness(90%);\n  opacity: 1;\n}\n.super-sales-chat-container .chat-header__info svg {\n  height: 14px;\n  width: 19px;\n}\n.super-sales-chat-container .chat-header--is-mobile .chat-header__info button {\n  position: relative;\n  top: 0;\n}\n.super-sales-chat-container .chat-header__text {\n  flex: 1;\n  padding: 8px 28px;\n}\n.super-sales-chat-container .chat-header__title {\n  box-sizing: border-box;\n  color: var(#000000);\n  flex: 1;\n  font-size: 18px;\n  font-weight: 600;\n  line-height: 20px;\n  margin: 0;\n  text-align: center;\n  word-wrap: break-word;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  line-clamp: 2;\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.super-sales-chat-container .product-card span {\n  margin-left: 0 !important;\n  margin-right: 0 !important;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--primary {\n  align-items: center;\n  border-radius: 8px;\n  display: flex;\n  font-size: 16px;\n  font-weight: 600;\n  justify-content: center;\n  line-height: 20px;\n  margin-bottom: 8px;\n  padding: 16px;\n  width: 100%;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--primary:hover {\n  background-color: #353535;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--primary:disabled {\n  background-color: #f1f1f1;\n  color: #8c9196;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--primary:not(:disabled) {\n  background-color: #1a1a1a;\n  color: var(#000000);\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--secondary {\n  align-items: center;\n  background-color: #f6f6f7;\n  border-radius: 8px;\n  color: #1a1a1a;\n  display: flex;\n  font-size: 16px;\n  font-weight: 600;\n  justify-content: center;\n  line-height: 20px;\n  margin-bottom: 8px;\n  padding: 16px;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n  width: 100%;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--secondary:hover {\n  background-color: #e7e7e7;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--secondary.product-added-cart {\n  color: #008060;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--secondary.product-added-cart svg {\n  margin-right: 8px;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--cancel {\n  font-size: 14px;\n  font-weight: 400;\n  text-decoration: underline;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--selected-variant-container {\n  align-items: start;\n  display: flex;\n  flex-direction: column;\n  justify-content: start;\n  margin-bottom: 12px;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--selected-variant {\n  font-size: 14px;\n  line-height: 21px;\n  margin-bottom: 8px;\n  text-decoration: underline;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--out-of-stock {\n  align-items: center;\n  border-radius: 8px;\n  display: flex;\n  font-size: 16px;\n  font-weight: 600;\n  justify-content: center;\n  line-height: 20px;\n  margin-bottom: 8px;\n  padding: 16px;\n  width: 100%;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--out-of-stock:disabled {\n  background-color: #ebecef;\n  color: #87909b;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--stroke {\n  align-items: center;\n  background-color: unset;\n  border-radius: 8px;\n  display: flex;\n  font-size: 16px;\n  font-weight: 600;\n  justify-content: center;\n  line-height: 20px;\n  margin-bottom: 8px;\n  padding: 16px;\n  width: 100%;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--stroke:hover {\n  background-color: #f1f2f4;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--stroke:disabled {\n  border: 1px solid #d2d5d8;\n  color: #8c9196;\n}\n.super-sales-chat-container .product-card .product-card-action-bar__button--stroke:not(:disabled) {\n  border: 1px solid #dde0e4;\n  color: #1a1a1a;\n  -webkit-transition: border-color 0.3s ease-in-out;\n  transition: border-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .product-card-action-bar__header {\n  align-items: center;\n  color: #1a1a1a;\n  display: flex;\n  justify-content: space-between;\n  line-height: 21px;\n  margin-bottom: 12px;\n}\n.super-sales-chat-container .product-card-action-bar__header button {\n  width: auto;\n}\n.super-sales-chat-container .product-card-action-bar__header--title {\n  font-size: 14px;\n  font-weight: 600;\n}\n.super-sales-chat-container .product-card-action-bar__error {\n  color: #d72c0d;\n  display: flex;\n  justify-content: center;\n  text-align: center;\n}\n.super-sales-chat-container .product-card__action-bar--container {\n  padding: 12px 16px 0;\n}\n.super-sales-chat-container .product-card__product-details {\n  align-items: start;\n  padding: 16px 16px 0;\n}\n.super-sales-chat-container .chat-messages--next .product-card__product-details {\n  padding: 12px 12px 16px;\n}\n.super-sales-chat-container .product-card__product-details-title {\n  cursor: pointer;\n  font-weight: 600;\n}\n.super-sales-chat-container .product-card__product-details-title:hover {\n  text-decoration: underline;\n}\n.super-sales-chat-container .product-card__product-details-price {\n  font-size: 14px;\n}\n.super-sales-chat-container .product-card__product-image {\n  border-radius: 8px;\n  cursor: pointer;\n  height: 100px;\n  margin-bottom: 12px;\n  object-fit: cover;\n  width: 100px;\n}\n.super-sales-chat-container .loading-ui {\n  padding: 16px 0;\n}\n.super-sales-chat-container .chat-messages__link {\n  background-color: unset;\n  color: #fff;\n  cursor: pointer;\n  overflow-wrap: anywhere;\n  text-decoration: underline;\n}\n.super-sales-chat-container .message-bubble-incoming .chat-messages__link {\n  color: #000;\n}\n.super-sales-chat-container .message-error {\n  align-self: flex-end;\n  color: #d72c0d;\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 1.7em;\n  position: relative;\n}\n.super-sales-chat-container .message-error .retry {\n  text-decoration: underline;\n}\n.super-sales-chat-container .message-error .retry:hover {\n  cursor: pointer;\n}\n.super-sales-chat-container .message-error__spinner {\n  animation: shopify-chat-spin 0.6s linear infinite;\n  border: 2px solid #f3f3f3;\n  border-radius: 50%;\n  border-top-color: #0089d3;\n  display: inline-block;\n  height: 10px;\n  margin-left: 8px;\n  width: 10px;\n}\n.super-sales-chat-container .chat-messages__message .chat-messages__message--product-image-container {\n  float: left;\n  padding: 2px 10px 0 0;\n}\n.super-sales-chat-container .chat-messages__message .chat-messages__message--product-image-container .chat-messages__message-product-image {\n  border-radius: 12px;\n  width: 100px;\n}\n.super-sales-chat-container .discount-card-container {\n  margin: 16px 16px 8px;\n}\n.super-sales-chat-container .discount-card__discount-details-title {\n  font-size: 16px;\n  font-weight: 600;\n  line-height: 20px;\n}\n.super-sales-chat-container .discount-card-info {\n  color: #616a75;\n  font-size: 14px;\n  padding-top: 12px;\n}\n.super-sales-chat-container .discount-card .discount-card__button--primary, .super-sales-chat-container .discount-card__loading-spinner-container {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n.super-sales-chat-container .discount-card .discount-card__button--primary {\n  background-color: var(#6a6a6a);\n  border-radius: 8px;\n  font-size: 16px;\n  font-weight: 600;\n  height: 44px;\n  line-height: 24px;\n  margin-top: 12px;\n  padding: 16px;\n  width: 100%;\n}\n.super-sales-chat-container .discount-card .discount-card__button--primary:hover {\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .discount-card .discount-card__button--primary:disabled {\n  background-color: #f1f1f1;\n  color: #8c9196;\n}\n.super-sales-chat-container .discount-card .discount-card__button--primary:not(:disabled) {\n  color: #fff;\n  -webkit-transition: background-color 0.3s ease-in-out;\n  transition: background-color 0.3s ease-in-out;\n}\n.super-sales-chat-container .attachment-image {\n  border-top-left-radius: 12px;\n  border-top-right-radius: 12px;\n  max-height: 480px;\n  max-width: 240px;\n}\n.super-sales-chat-container .attachment-image__loading {\n  align-items: center;\n  display: flex;\n  padding: 8px;\n}\n.super-sales-chat-container .attachment-image__loading .attachment-image__loading__spinner {\n  border: 2px solid #f3f3f3;\n  border-top-color: #000;\n  height: 15px;\n  width: 15px;\n}\n.super-sales-chat-container .attachment-video {\n  border-top-left-radius: 12px;\n  border-top-right-radius: 12px;\n  max-height: 480px;\n  max-width: 240px;\n}\n.super-sales-chat-container .attachment-video__loading {\n  align-items: center;\n  display: flex;\n  margin: 14px;\n  padding: 4px;\n}\n.super-sales-chat-container .attachment-video__loading .attachment-video__loading__spinner {\n  border: 2px solid #f3f3f3;\n  border-top-color: #000;\n  height: 15px;\n  width: 15px;\n}\n.super-sales-chat-container .attachment-video__loading .attachment-video__loading__processing-text {\n  margin-left: 8px;\n  margin-right: 8px;\n}\n.super-sales-chat-container .date-header {\n  color: #6d7175;\n  font-size: 13px;\n  line-height: 18px;\n  margin-bottom: 8px;\n  margin-top: 20px;\n  text-align: center;\n}\n.super-sales-chat-container .avatar {\n  color: #6e7175;\n  flex-shrink: 0;\n}\n.super-sales-chat-container .avatar-custom {\n  color: #6e7175;\n  flex-shrink: 0;\n}\n.super-sales-chat-container .avatar-custom svg path:nth-child(2) {\n  fill: var(#000000);\n}\n.super-sales-chat-container .avatarProfile {\n  border-radius: 50%;\n  height: 24px;\n  width: 24px;\n}\n.super-sales-chat-container .avatarOne {\n  background-color: #c530c5;\n}\n.super-sales-chat-container .avatarOne .p {\n  color: #380738;\n}\n.super-sales-chat-container .avatarTwo {\n  background-color: #38faa3;\n}\n.super-sales-chat-container .avatarTwo .p {\n  color: #0c5132;\n}\n.super-sales-chat-container .avatarThree {\n  background-color: #2ce0d4;\n}\n.super-sales-chat-container .avatarThree .p {\n  color: #033c39;\n}\n.super-sales-chat-container .avatarFour {\n  background-color: #51c0ff;\n}\n.super-sales-chat-container .avatarFour .p {\n  color: #002133;\n}\n.super-sales-chat-container .avatarFive {\n  background-color: #fd4b92;\n}\n.super-sales-chat-container .avatarFive .p {\n  color: #4d0b25;\n}\n.super-sales-chat-container .message-bubble {\n  border-radius: 12px;\n  overflow-wrap: break-word;\n  padding: 10px 0 8px;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  font-size: 16px;\n  line-height: 20px;\n  max-width: 300px;\n  text-align: start;\n}\n.super-sales-chat-container .message-bubble:last-of-type:not(.updated) {\n  animation-duration: 0.5s;\n  animation-name: shopify-chat-fade-in;\n  margin-bottom: 0;\n}\n.super-sales-chat-container .message-bubble span {\n  display: block;\n  margin-left: 16px;\n  margin-right: 16px;\n}\n.super-sales-chat-container .message-bubble-incoming {\n  align-self: flex-start;\n  background-color: #eeeef1;\n}\n.super-sales-chat-container .message-bubble-incoming.disabled-text {\n  color: rgba(0, 0, 0, 0.4);\n}\n.super-sales-chat-container .message-bubble-outgoing {\n  align-self: flex-end;\n  background-color: #a0a0a0;\n  color: var(#000000);\n}\n.super-sales-chat-container .message-bubble-outgoing.disabled-text {\n  color: hsla(0, 0%, 100%, 0.6);\n}\n.super-sales-chat-container .message-bubble.attachment {\n  border: none;\n  padding: 0 0 8px;\n}\n.super-sales-chat-container .message-bubble.attachment .chat-message__error {\n  margin: 12px 14px 0;\n  text-decoration: none;\n}\n.super-sales-chat-container .message-bubble.attachment .timestamp {\n  margin: 2px 14px;\n}\n.super-sales-chat-container .message-bubble.attachment.disabled-text {\n  opacity: 0.5;\n}\n.super-sales-chat-container .message-bubble.product-card {\n  flex-grow: 1;\n  max-width: 100%;\n}\n.super-sales-chat-container .message-bubble.discount-card, .super-sales-chat-container .message-bubble.product-card {\n  background-color: #fff;\n  border: 1px solid #dde0e4;\n  padding: 0;\n}\n.super-sales-chat-container .message-container {\n  display: flex;\n  max-width: 80%;\n}\n.super-sales-chat-container .message-container-incoming {\n  align-items: end;\n  align-self: flex-start;\n  gap: 8px;\n  margin: 12px auto 0 12px;\n  max-width: 272px;\n}\n.super-sales-chat-container .message-container-outgoing {\n  align-self: flex-end;\n  flex-direction: column;\n  margin: 12px 12px 0 auto;\n}\n.super-sales-chat-container .message-container-outgoing + .message-container-outgoing {\n  margin-top: 8px;\n}\n.super-sales-chat-container .message-container.discount-card, .super-sales-chat-container .message-container.product-card {\n  align-self: auto;\n  margin-right: 12px;\n  max-width: 80%;\n}\n.super-sales-chat-container .timestamp {\n  color: var(#000000);\n  font-size: 14px;\n  line-height: 22px;\n  margin: 4px 16px 0;\n  opacity: 0.85;\n  text-align: left;\n}\n.super-sales-chat-container .timestamp.team {\n  color: #6d7175;\n  opacity: 1;\n}\n.super-sales-chat-container .discount-card .timestamp, .super-sales-chat-container .product-card .timestamp {\n  padding-bottom: 12px;\n}\n.super-sales-chat-container .message-prompt {\n  color: #6d7175;\n  font-size: 13px;\n  line-height: 17px;\n  margin: 16px 0 4px;\n  padding: 0 42px;\n  text-align: center;\n}\n.super-sales-chat-container .chat-messages__message, .super-sales-chat-container .chat-messages__order-lookup {\n  border-radius: 12px;\n  display: block;\n  max-width: 240px;\n  overflow-wrap: break-word;\n  padding: 10px 0 8px;\n  position: relative;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  font-size: 16px;\n  line-height: 20px;\n  text-align: start;\n}\n.super-sales-chat-container .chat-messages__message span, .super-sales-chat-container .chat-messages__order-lookup span {\n  display: block;\n  margin-left: 14px;\n  margin-right: 14px;\n}\n.super-sales-chat-container .chat-messages__message.isIE11, .super-sales-chat-container .chat-messages__order-lookup.isIE11 {\n  flex: 1 0 auto !important;\n  flex-flow: column wrap;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message {\n  background-color: #eeeef1;\n  margin: 12px auto 0 42px;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message + .__message--incoming-message {\n  margin-top: 8px;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message + .chat-messages__message--order-lookup {\n  background-color: #fff;\n  border-color: #41688e;\n  color: #41688e;\n  cursor: pointer;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message + .chat-messages__message--incoming-message {\n  margin-top: 8px;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message + .chat-messages__message--outgoing-message {\n  margin-top: 12px;\n}\n.super-sales-chat-container .chat-messages__message--incoming-message--loading {\n  margin: 12px auto 0 12px;\n}\n.super-sales-chat-container .chat-messages__message--outgoing-message {\n  background-color: rgba(53, 128, 230, 0.13);\n}\n.super-sales-chat-container .chat-messages--next .chat-messages__message--outgoing-message {\n  color: var(#000000);\n  margin: 12px 12px 0 auto;\n}\n.super-sales-chat-container .chat-messages__message--outgoing-message {\n  color: var(#000000);\n  margin: 12px 12px 0 auto;\n}\n.super-sales-chat-container .chat-messages__message--outgoing-message + .chat-messages__message--outgoing-message {\n  margin-top: 8px;\n}\n.super-sales-chat-container .chat-messages__message--outgoing-message + .chat-messages__message--incoming-message {\n  margin-top: 12px;\n}\n.super-sales-chat-container .chat-messages__shop-name {\n  font-size: 16px;\n  font-weight: 600;\n  margin-bottom: 2px;\n  margin-left: 14px;\n  margin-right: 14px;\n}\n.super-sales-chat-container .product-card .chat-messages__shop-name {\n  padding: 8px 12px 0;\n}\n.super-sales-chat-container .OrderLookup__form .customer-info-form__input, .super-sales-chat-container .customer-info-form .customer-info-form__input, .super-sales-chat-container .sign-up-form .customer-info-form__input {\n  -webkit-appearance: none;\n  background: none;\n  border: 1px solid #e4e5e7;\n  border-radius: 8px;\n  box-sizing: border-box;\n  padding: 12px;\n  width: 100%;\n}\n.super-sales-chat-container .OrderLookup__form .customer-info-form__input:focus, .super-sales-chat-container .customer-info-form .customer-info-form__input:focus, .super-sales-chat-container .sign-up-form .customer-info-form__input:focus {\n  border: 1px solid #42474c;\n  outline: none;\n}\n.super-sales-chat-container .customer-info-form__subtext {\n  align-self: flex-start;\n  font-size: 13px;\n  margin-top: 4px;\n}\n.super-sales-chat-container .customer-info-form__subtext button {\n  cursor: pointer;\n  text-decoration: underline;\n}\n.super-sales-chat-container .customer-info-form__input-wrapper.customer-info-form__error input.customer-info-form__input {\n  background-color: #fff4f4;\n  border: 1.5px solid #fd5749;\n}\n.super-sales-chat-container .customer-info-form__input-wrapper.customer-info-form__error .customer-info-form__subtext {\n  color: #d72c0d;\n}\n.super-sales-chat-container .customer-info-form__input-wrapper.customer-info-form__warning input.customer-info-form__input {\n  background-color: #fff5ea;\n  border: 1.5px solid #b98900;\n}\n.super-sales-chat-container .customer-info-form__input-wrapper.customer-info-form__warning .customer-info-form__subtext {\n  color: #916a00;\n}\n.super-sales-chat-container .hover-effect-button {\n  border-radius: 8px;\n  font-weight: 600;\n  overflow: hidden;\n  position: relative;\n  width: 100%;\n}\n.super-sales-chat-container .hover-effect-button .label {\n  color: var(#000000);\n  font-weight: 500;\n  position: relative;\n  z-index: 2;\n}\n.super-sales-chat-container .hover-effect-button .background {\n  bottom: 0;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1;\n}\n.super-sales-chat-container .hover-effect-button:disabled {\n  background-color: #eeeef1;\n}\n.super-sales-chat-container .hover-effect-button:disabled .label {\n  color: #8c9196;\n}\n.super-sales-chat-container .hover-effect-button:focus:not(:disabled) .background, .super-sales-chat-container .hover-effect-button:hover:not(:disabled) .background {\n  filter: brightness(0.9);\n}\n.super-sales-chat-container .chat-app button.hover-effect-button {\n  line-height: 22px;\n  padding: 11px 12px;\n}\n.super-sales-chat-container .info-modal__wrapper {\n  align-items: center;\n  display: flex;\n  height: calc(100% - 60px);\n  justify-content: center;\n  position: absolute;\n  top: 59px;\n  width: 360px;\n  z-index: 2;\n}\n.super-sales-chat-container .info-modal__wrapper.is-mobile {\n  height: calc(100% - 60px);\n  width: 100%;\n}\n.super-sales-chat-container .info-modal__wrapper.checkout-page {\n  height: calc(100% - 60px);\n}\n.super-sales-chat-container .info-modal__wrapper .info-modal {\n  background-color: #fff;\n  border-radius: 0 0 12px 12px;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  overflow-y: auto;\n  padding: 0 12px;\n  position: absolute;\n  width: 100%;\n}\n.super-sales-chat-container .info-modal__wrapper .info-modal .info-modal__header {\n  margin-bottom: 18px;\n  margin-top: 0;\n  text-align: center;\n}\n.super-sales-chat-container .info-modal__wrapper .info-modal .info-modal__header .info-modal__header-text {\n  font-size: 18px;\n  font-weight: 600;\n  line-height: 20px;\n  margin-bottom: 2px;\n  padding: 0;\n}\n.super-sales-chat-container .info-modal__wrapper .info-modal .info-modal__header .info-modal__subheader-text {\n  color: #6d7175;\n  font-size: 16px;\n}\n.super-sales-chat-container .info-modal__wrapper .info-modal .info-modal__body {\n  display: flex;\n  flex: 1;\n}\n.super-sales-chat-container .sign-up-form {\n  display: flex;\n  flex: 1;\n}\n.super-sales-chat-container .sign-up-form__online-container {\n  flex: 1;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n.super-sales-chat-container .sign-up-form__online-content {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  flex-grow: 1;\n}\n.super-sales-chat-container .sign-up-form__online-header-section {\n  margin-bottom: 24px;\n  margin-top: 24px;\n  text-align: center;\n}\n.super-sales-chat-container .sign-up-form__online-header {\n  font-size: 20px;\n  font-weight: 600;\n  padding: 0 0 10px;\n}\n.super-sales-chat-container .sign-up-form__online-header-subtext {\n  font-size: 16px;\n}\n.super-sales-chat-container .sign-up-form__input-container {\n  margin-bottom: 10px;\n  margin-top: 24px;\n}\n.super-sales-chat-container .sign-up-form__input-wrapper {\n  margin-bottom: 8px;\n}\n.super-sales-chat-container .sign-up-form__start-conversation-cta {\n  background-color: #fff;\n  padding-bottom: 12px;\n}\n.super-sales-chat-container .sign-up-form button.sign-up-form__button {\n  background: #0089d3;\n  border: none;\n  border-radius: 4px;\n  color: var(#000000);\n  display: block;\n  padding: 12px 0;\n  width: 100%;\n  border-radius: 12px;\n  font-weight: 600;\n}\n.super-sales-chat-container .sign-up-form button.sign-up-form__button:disabled {\n  background: rgba(0, 137, 211, 0.35);\n}\n.super-sales-chat-container .sign-up-form button.sign-up-form__button:not(:disabled):hover {\n  background: #2a8ee7;\n  opacity: 0.8;\n}\n.super-sales-chat-container .sign-up-form button.sign-up-form__button:focus {\n  opacity: 0.8;\n  outline: none;\n}\n.super-sales-chat-container .sign-up-form button.sign-up-form__button:disabled {\n  opacity: 0.5;\n}\n.super-sales-chat-container .sign-up-form__spinner {\n  animation: shopify-chat-spin 0.6s linear infinite;\n  border: 2px solid #f3f3f3;\n  border-radius: 50%;\n  border-top-color: #0089d3;\n  display: inline-block;\n  height: 10px;\n  margin-right: 8px;\n  width: 10px;\n}\n.super-sales-chat-container .chat-app--is-mobile .sign-up-form__start-conversation-cta {\n  background-color: #fff;\n  height: 44px;\n  width: 100%;\n}\n.super-sales-chat-container .customer-info-form__checkbox-wrapper {\n  align-items: flex-start;\n  column-gap: 10px;\n  display: flex;\n  margin-bottom: 16px;\n  padding-top: 10px;\n}\n.super-sales-chat-container .customer-info-form__checkbox-wrapper input {\n  flex-shrink: 0;\n  height: 18px;\n  width: 18px;\n}\n.super-sales-chat-container .customer-info-form {\n  display: flex;\n  flex: 1;\n}\n.super-sales-chat-container .customer-info-form__online-container {\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n  height: 100%;\n  justify-content: space-between;\n}\n.super-sales-chat-container .customer-info-form__online-content {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  justify-content: space-between;\n}\n.super-sales-chat-container .customer-info-form__online-header-section {\n  margin-bottom: 24px;\n  margin-top: 24px;\n  text-align: center;\n}\n.super-sales-chat-container .customer-info-form__online-header {\n  font-size: 20px;\n  font-weight: 600;\n  padding: 0 0 10px;\n}\n.super-sales-chat-container .customer-info-form__online-header-subtext {\n  font-size: 16px;\n}\n.super-sales-chat-container .customer-info-form__input-container {\n  margin-bottom: 10px;\n  margin-top: 24px;\n}\n.super-sales-chat-container .customer-info-form__input-wrapper {\n  margin-bottom: 8px;\n}\n.super-sales-chat-container .customer-info-form__error {\n  color: #d72c0d;\n}\n.super-sales-chat-container .customer-info-form__start-conversation-cta {\n  background-color: #fff;\n  padding-bottom: 12px;\n}\n.super-sales-chat-container .customer-info-form button.customer-info-form__button {\n  background: #0089d3;\n  border: none;\n  border-radius: 4px;\n  color: var(#000000);\n  display: block;\n  padding: 12px 0;\n  width: 100%;\n  border-radius: 12px;\n  font-weight: 600;\n}\n.super-sales-chat-container .customer-info-form button.customer-info-form__button:disabled {\n  background: rgba(0, 137, 211, 0.35);\n}\n.super-sales-chat-container .customer-info-form button.customer-info-form__button:not(:disabled):hover {\n  background: #2a8ee7;\n  opacity: 0.8;\n}\n.super-sales-chat-container .customer-info-form button.customer-info-form__button:focus {\n  opacity: 0.8;\n  outline: none;\n}\n.super-sales-chat-container .customer-info-form button.customer-info-form__button:disabled {\n  opacity: 0.5;\n}\n.super-sales-chat-container .customer-info-form__spinner {\n  animation: shopify-chat-spin 0.6s linear infinite;\n  border: 2px solid #f3f3f3;\n  border-radius: 50%;\n  border-top-color: #0089d3;\n  display: inline-block;\n  height: 10px;\n  margin-right: 8px;\n  width: 10px;\n}\n.super-sales-chat-container .chat-app--is-mobile .customer-info-form__start-conversation-cta {\n  background-color: #fff;\n  height: 44px;\n  width: 100%;\n}\n.super-sales-chat-container .chat-ui {\n  border-radius: 12px;\n  box-shadow: 0 0 7px 0 rgba(0, 0, 0, 0.15);\n  color: #212b36;\n  display: flex;\n  flex-direction: column;\n  margin: 0 auto;\n  overflow-y: auto;\n  width: 100%;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.super-sales-chat-container .chat-ui::-webkit-scrollbar {\n  display: none;\n}\n.super-sales-chat-container .chat-ui.loading {\n  background-color: #fff;\n}\n@media (min-width: 769px) {\n  .super-sales-chat-container .chat-ui {\n    animation-duration: 0.25s;\n    animation-name: fade-in-down;\n  }\n}\n.super-sales-chat-container .chat-ui--is-mobile {\n  border-radius: 0;\n  height: 100vh;\n  margin: 0;\n  width: 100vw;\n}\n.super-sales-chat-container .banner {\n  align-items: flex-start;\n  background-color: #fff4f4;\n  color: #202223;\n  display: flex;\n  font-size: 14px;\n  font-weight: 600;\n  padding: 10px;\n}\n.super-sales-chat-container .banner p {\n  margin: 0;\n  padding: 0 10px;\n}\n.super-sales-chat-container .banner-metadata-content {\n  display: flex;\n}\n.super-sales-chat-container .warning-icon {\n  color: #d72c0d;\n}\n.super-sales-chat-container .cancel-button, .super-sales-chat-container .warning-icon {\n  height: 20px;\n  width: 20px;\n}\n.super-sales-chat-container .icon-container {\n  overflow: visible;\n}\n.super-sales-chat-container .banner-justify-center {\n  justify-content: center;\n}\n.super-sales-chat-container .banner-justify-space-between {\n  justify-content: space-between;\n}\n.super-sales-chat-container .interstitial-view__instant-answers-list {\n  align-items: center;\n  background-color: #fff;\n  border-radius: 0 0 12px 12px;\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  overflow: auto;\n  overflow: initial;\n  padding: 0 12px 12px;\n}\n.super-sales-chat-container .interstitial-view__instant-answers-list--empty {\n  justify-content: center;\n}\n.super-sales-chat-container .interstitial-view__instant-answers-list .with-conversation {\n  font-size: 16px;\n  margin-top: 20px;\n}\n.super-sales-chat-container .chat-app button.instant-answers-list__prompt {\n  border-bottom: 1px solid #e8e9eb;\n  color: #3580e6;\n  cursor: pointer;\n  font-size: 16px;\n  line-height: 22px;\n  margin: 4px 0;\n  padding: 10px 12px;\n  word-break: break-word;\n}\n.super-sales-chat-container .chat-app button.instant-answers-list__prompt p {\n  margin: 0;\n  text-align: start;\n}\n.super-sales-chat-container .instant-answers {\n  color: #202223;\n  font-size: 1em;\n  font-weight: 600;\n  margin: 8px auto 16px;\n  text-align: center;\n}\n.super-sales-chat-container .chat-app button.interstitial-view__return-to-chat {\n  align-items: center;\n  align-self: center;\n  background-color: hsla(0, 0%, 100%, 0.25);\n  border-radius: 12px;\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);\n  color: #fff;\n  display: flex;\n  font-weight: 600;\n  height: 44px;\n  justify-content: center;\n  margin-bottom: 24px;\n  width: 100%;\n}\n.super-sales-chat-container .chat-app button.interstitial-view__return-to-chat:hover {\n  background-color: hsla(0, 0%, 100%, 0.35);\n}\n.super-sales-chat-container .chat-app button.interstitial-view__return-to-chat .forward-arrow {\n  margin-left: 14px;\n}\n.super-sales-chat-container .return-to-chat-wrapper .hover-effect-button .label {\n  font-size: 16px;\n  font-weight: 500;\n}\n.super-sales-chat-container .return-to-chat-wrapper .hover-effect-button .background {\n  filter: brightness(0.8);\n}\n.super-sales-chat-container .return-to-chat-wrapper .hover-effect-button:focus:not(:disabled) .background, .super-sales-chat-container .return-to-chat-wrapper .hover-effect-button:hover:not(:disabled) .background {\n  filter: brightness(0.7);\n}\n.super-sales-chat-container .interstitial-view__welcome {\n  background: linear-gradient(180deg, transparent 0, transparent 50%, #fff 0, #fff);\n  display: flex;\n  flex-direction: column;\n  height: auto;\n  mask-image: radial-gradient(circle, #fff 100%, #000 0);\n  min-height: fit-content;\n}\n.super-sales-chat-container .interstitial-view__welcome.is-mobile {\n  border-radius: 0;\n}\n.super-sales-chat-container .interstitial-view__welcome [name=closeChat] {\n  color: var(#000000);\n  display: flex;\n  margin: 20px 24px 0 auto;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  justify-content: center;\n  overflow-y: hidden;\n  padding: 20px 16px 76px;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info.checkout-page {\n  text-align: left;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info.is-mobile h2 {\n  margin-top: 0;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info-heading {\n  display: flex;\n  justify-content: left;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info-heading h2 {\n  color: var(#000000);\n  font-size: 20px;\n  font-weight: 600;\n  margin-bottom: 4px;\n  margin-top: 0;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info-heading [name=closeChat] {\n  margin: 0 0 0 auto;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info-heading [name=closeChat] .chat-header__close_button_mobile {\n  height: 24px;\n  width: 24px;\n}\n.super-sales-chat-container .interstitial-view__welcome .store-info p {\n  color: var(#000000);\n  font-size: 16px;\n  line-height: 22px;\n  margin: 0;\n  max-height: none;\n  overflow-y: initial;\n  white-space: break-spaces;\n}\n.super-sales-chat-container .interstitial-view__welcome .return-to-chat-wrapper {\n  margin: -56px 12px 12px;\n}\n.super-sales-chat-container .interstitial-view__welcome .return-to-chat-wrapper.checkout-page button {\n  border: 1px solid #fff;\n}\n.super-sales-chat-container .interstitial-view {\n  border-radius: 12px;\n  max-height: 600px;\n  position: relative;\n}\n.super-sales-chat-container .interstitial-view.is-mobile {\n  background-color: #fff;\n  border-radius: 0;\n  margin: 0;\n  max-height: 100vh;\n  width: 100vw;\n}\n.super-sales-chat-container .error-chat-unavailable {\n  align-items: center;\n  background: #fff;\n  box-sizing: border-box;\n  justify-content: center;\n  padding: 0 2rem;\n  text-align: center;\n}\n.super-sales-chat-container .error-chat-unavailable h2 {\n  color: #000;\n  font-size: 1rem;\n  font-weight: 600;\n  margin: 0 0 2px;\n}\n.super-sales-chat-container .error-chat-unavailable p {\n  color: #6d7175;\n  margin: 0 0 24px;\n}\n.super-sales-chat-container .chat-app .error-chat-unavailable .outline-button {\n  width: auto;\n}\n.super-sales-chat-container .error-chat-unavailable .btn-close {\n  height: 24px;\n  position: absolute;\n  right: 24px;\n  top: 20px;\n  width: 24px;\n}\n@keyframes shopify-chat-fade-in {\n  0% {\n    opacity: 0.5;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes shopify-chat-slide-up {\n  0% {\n    margin-bottom: 0;\n  }\n  to {\n    padding-bottom: 16px;\n  }\n}\n@keyframes shopify-chat-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(1turn);\n  }\n}\n@keyframes fade-in-down {\n  0% {\n    opacity: 0;\n    transform: translateY(-1.25em);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n.super-sales-chat-container body {\n  margin: 0;\n  position: relative;\n}\n.super-sales-chat-container input, .super-sales-chat-container textarea {\n  font-size: 16px !important;\n}\n.super-sales-chat-container .white-background {\n  background-color: #fff;\n}\n.super-sales-chat-container .chat-app {\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;\n  font-stretch: normal;\n  font-style: normal;\n  letter-spacing: 0;\n  line-height: normal;\n  text-transform: none;\n  -webkit-font-smoothing: antialiased;\n}\n.super-sales-chat-container .chat-app html {\n  font-family: sans-serif;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n}\n.super-sales-chat-container .chat-app body {\n  margin: 0;\n}\n.super-sales-chat-container .chat-app article, .super-sales-chat-container .chat-app aside, .super-sales-chat-container .chat-app details, .super-sales-chat-container .chat-app figcaption, .super-sales-chat-container .chat-app figure, .super-sales-chat-container .chat-app footer, .super-sales-chat-container .chat-app header, .super-sales-chat-container .chat-app hgroup, .super-sales-chat-container .chat-app main, .super-sales-chat-container .chat-app menu, .super-sales-chat-container .chat-app nav, .super-sales-chat-container .chat-app section, .super-sales-chat-container .chat-app summary {\n  display: block;\n}\n.super-sales-chat-container .chat-app audio, .super-sales-chat-container .chat-app canvas, .super-sales-chat-container .chat-app progress, .super-sales-chat-container .chat-app video {\n  display: inline-block;\n  vertical-align: baseline;\n}\n.super-sales-chat-container .chat-app audio:not([controls]) {\n  display: none;\n  height: 0;\n}\n.super-sales-chat-container .chat-app [hidden], .super-sales-chat-container .chat-app template {\n  display: none;\n}\n.super-sales-chat-container .chat-app a {\n  background-color: transparent;\n}\n.super-sales-chat-container .chat-app a:active, .super-sales-chat-container .chat-app a:hover {\n  outline: 0;\n}\n.super-sales-chat-container .chat-app abbr[title] {\n  border-bottom: 1px dotted;\n}\n.super-sales-chat-container .chat-app b, .super-sales-chat-container .chat-app strong {\n  font-weight: 700;\n}\n.super-sales-chat-container .chat-app dfn {\n  font-style: italic;\n}\n.super-sales-chat-container .chat-app h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n.super-sales-chat-container .chat-app mark {\n  background: #ff0;\n  color: #000;\n}\n.super-sales-chat-container .chat-app small {\n  font-size: 80%;\n}\n.super-sales-chat-container .chat-app sub {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n.super-sales-chat-container .chat-app sup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n  top: -0.5em;\n}\n.super-sales-chat-container .chat-app sub {\n  bottom: -0.25em;\n}\n.super-sales-chat-container .chat-app img {\n  border: 0;\n}\n.super-sales-chat-container .chat-app svg:not(:root) {\n  overflow: hidden;\n}\n.super-sales-chat-container .chat-app figure {\n  margin: 1em 40px;\n}\n.super-sales-chat-container .chat-app hr {\n  box-sizing: content-box;\n  height: 0;\n}\n.super-sales-chat-container .chat-app pre {\n  overflow: auto;\n}\n.super-sales-chat-container .chat-app code, .super-sales-chat-container .chat-app kbd, .super-sales-chat-container .chat-app pre, .super-sales-chat-container .chat-app samp {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n.super-sales-chat-container .chat-app button, .super-sales-chat-container .chat-app input, .super-sales-chat-container .chat-app optgroup, .super-sales-chat-container .chat-app select, .super-sales-chat-container .chat-app textarea {\n  color: inherit;\n  font: inherit;\n  margin: 0;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app button {\n  overflow: visible;\n  text-transform: none;\n}\n.super-sales-chat-container .chat-app select {\n  text-transform: none;\n}\n.super-sales-chat-container .chat-app button, .super-sales-chat-container .chat-app html input[type=button] {\n  -webkit-appearance: button;\n  cursor: pointer;\n}\n.super-sales-chat-container .chat-app input[type=reset], .super-sales-chat-container .chat-app input[type=submit] {\n  -webkit-appearance: button;\n  cursor: pointer;\n}\n.super-sales-chat-container .chat-app button[disabled], .super-sales-chat-container .chat-app html input[disabled] {\n  cursor: default;\n}\n.super-sales-chat-container .chat-app button::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app input {\n  line-height: normal;\n}\n.super-sales-chat-container .chat-app input::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app input[type=checkbox], .super-sales-chat-container .chat-app input[type=radio] {\n  box-sizing: border-box;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app input[type=number]::-webkit-inner-spin-button, .super-sales-chat-container .chat-app input[type=number]::-webkit-outer-spin-button {\n  height: auto;\n}\n.super-sales-chat-container .chat-app input[type=search] {\n  -webkit-appearance: textfield;\n  box-sizing: content-box;\n}\n.super-sales-chat-container .chat-app input[type=search]::-webkit-search-cancel-button, .super-sales-chat-container .chat-app input[type=search]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n.super-sales-chat-container .chat-app fieldset {\n  border: 1px solid silver;\n  margin: 0;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app legend {\n  border: 0;\n  padding: 0;\n}\n.super-sales-chat-container .chat-app textarea {\n  overflow: auto;\n}\n.super-sales-chat-container .chat-app optgroup {\n  font-weight: 700;\n}\n.super-sales-chat-container .chat-app table {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n.super-sales-chat-container .chat-app td, .super-sales-chat-container .chat-app th {\n  padding: 0;\n}\n.super-sales-chat-container .chat-app .chat-app--close-button {\n  align-items: center;\n  animation-duration: 0.25s;\n  animation-name: shopify-chat-fade-in;\n  border-radius: 50%;\n  color: var(#000000);\n  display: flex;\n  font-size: 24px;\n  font-weight: 240;\n  height: 60px;\n  justify-content: center;\n  margin-top: 16px;\n  width: 60px;\n}\n.super-sales-chat-container .chat-app .chat-app--close-button-bottom-right {\n  margin-left: auto;\n}\n.super-sales-chat-container .chat-app--is-open > div {\n  animation-duration: 0.25s;\n  animation-name: fade-in-down;\n}\n.super-sales-chat-container .chat-app--is-open:not(.chat-app--is-mobile) {\n  margin: 0 6px;\n}\n.super-sales-chat-container .chat-app--is-mobile {\n  margin: 0;\n}\n.super-sales-chat-container .chat-app--is-mobile .chat-notification {\n  right: 0;\n  top: -6px;\n}\n.super-sales-chat-container .chat-app--close-button--red, .super-sales-chat-container .chat-header--red, .super-sales-chat-container .chat-toggle--red {\n  background-color: #e55338;\n}\n.super-sales-chat-container .chat-app--close-button--orange, .super-sales-chat-container .chat-header--orange, .super-sales-chat-container .chat-toggle--orange {\n  background-color: #e5801e;\n}\n.super-sales-chat-container .chat-app--close-button--yellow, .super-sales-chat-container .chat-header--yellow, .super-sales-chat-container .chat-toggle--yellow {\n  background-color: #eab311;\n}\n.super-sales-chat-container .chat-app--close-button--green, .super-sales-chat-container .chat-header--green, .super-sales-chat-container .chat-toggle--green {\n  background-color: #58bf32;\n}\n.super-sales-chat-container .chat-app--close-button--blue, .super-sales-chat-container .chat-header--blue, .super-sales-chat-container .chat-toggle--blue {\n  background-color: #2a8ee7;\n}\n.super-sales-chat-container .chat-app--close-button--purple, .super-sales-chat-container .chat-header--purple, .super-sales-chat-container .chat-toggle--purple {\n  background-color: #5459c1;\n}\n.super-sales-chat-container .chat-app--close-button--pink, .super-sales-chat-container .chat-header--pink, .super-sales-chat-container .chat-toggle--pink {\n  background-color: #e950a6;\n}\n.super-sales-chat-container .chat-app--close-button--grey, .super-sales-chat-container .chat-header--grey, .super-sales-chat-container .chat-toggle--grey {\n  background-color: #909fab;\n}\n.super-sales-chat-container .chat-app--close-button--black, .super-sales-chat-container .chat-header--black, .super-sales-chat-container .chat-toggle--black {\n  background-color: #202a36;\n}\n.super-sales-chat-container button {\n  background: none;\n  border: none;\n  outline: none;\n}\n.super-sales-chat-container button.chat-toggle {\n  border: 1px solid transparent;\n  border-radius: 30px;\n  cursor: pointer;\n  display: flex;\n  height: 60px;\n  margin: 0 6px;\n  width: 60px;\n}\n.super-sales-chat-container button.chat-toggle svg {\n  flex-shrink: 0;\n  height: 48px;\n  width: auto;\n}\n.super-sales-chat-container button.chat-toggle svg path {\n  fill: var(#000000);\n}\n.super-sales-chat-container button.chat-toggle .chat-title {\n  font-size: 24px;\n  margin: 0 auto;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--icon-button {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--icon-button.icon-only svg, .super-sales-chat-container button.chat-toggle.chat-toggle--icon-button.mobile-only svg {\n  height: 58px;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button {\n  align-items: center;\n  border: none;\n  border-radius: 16px;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.15);\n  color: var(#000000);\n  display: flex;\n  font-size: 1.5rem;\n  font-weight: 600;\n  height: 60px;\n  line-height: 2rem;\n  max-width: fit-content;\n  padding: 0 12px 0 3px;\n  width: auto;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button.text-only {\n  height: 60px;\n  padding: 0 17px;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title {\n  align-items: center;\n  display: flex;\n  height: 30px;\n  max-height: 40px;\n  overflow: hidden;\n  white-space: nowrap;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(el), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(vi) {\n  font-size: 0.85rem;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(hr), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(hr-HR) {\n  font-size: 0.87rem;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(hu), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(ms) {\n  font-size: 0.89rem;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(fr), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(id), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(ja), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(ko), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(lt), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(lt-LT), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(nl), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(pt-PT), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(sk), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(sk-SK), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(tr) {\n  font-size: 1rem;\n}\n.super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(de), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(it), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(sl), .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title:lang(sl-SI) {\n  font-size: 1.25rem;\n}\n@supports (-webkit-touch-callout: none) {\n  .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title {\n    align-items: center;\n    display: flex;\n    height: 20px;\n    overflow: visible;\n  }\n}\n.super-sales-chat-container .chat-toogle--animation-button {\n  animation-duration: 0.25s;\n  animation-name: shopify-chat-fade-in;\n}\n.super-sales-chat-container .OrderLookup {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n}\n.super-sales-chat-container .OrderLookup__lookupBtnTitle {\n  color: #637381;\n  font-size: 13px;\n  margin-top: 4px;\n  text-align: right;\n}\n.super-sales-chat-container button.OrderLookup__cancel {\n  color: #2c6ecb;\n  padding: 12px 0;\n}\n.super-sales-chat-container .OrderLookup__form {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n.super-sales-chat-container .OrderLookup__formGroup {\n  display: flex;\n  flex-direction: column;\n  margin: 16px 16px 0;\n}\n.super-sales-chat-container .OrderLookup__formGroup:nth-child(2) {\n  margin-top: 24px;\n}\n.super-sales-chat-container .OrderLookup__formGroup label {\n  font-size: 15px;\n  font-weight: 500;\n}\n.super-sales-chat-container .OrderLookup__formGroup input {\n  -webkit-appearance: none;\n  border: 1px solid #d2d5d9;\n  border-radius: 22px;\n  margin-top: 10px;\n  padding: 12px 16px;\n}\n.super-sales-chat-container .OrderLookup__formGroup input::placeholder {\n  color: #c4c9d5;\n  font-size: 15px;\n  opacity: 0.84;\n}\n.super-sales-chat-container .OrderLookup__formGroup input:focus {\n  outline: none;\n}\n.super-sales-chat-container .OrderLookup__submit {\n  background-color: #fff;\n  color: var(#000000);\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  justify-content: flex-end;\n  margin-top: 16px;\n  padding-bottom: 12px;\n}\n.super-sales-chat-container input[type=number].OrderLookup__orderNumberField::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.super-sales-chat-container .OrderLookup__submit--is-mobile input {\n  border-radius: 4px;\n}\n.super-sales-chat-container .OrderLookup__error {\n  color: #ee2f53;\n  font-size: 14px;\n  margin: 16px 16px 0;\n}\n.super-sales-chat-container .OrderLookup__errorList {\n  list-style-type: none;\n  padding: 0;\n}\n.super-sales-chat-container .chat-notification {\n  background: #ee2f53;\n  border-radius: 30px;\n  color: var(#000000);\n  display: block;\n  font-size: 12px;\n  font-weight: 700;\n  height: 22px;\n  line-height: 22px;\n  position: absolute;\n  right: 0;\n  top: -7px;\n  width: 22px;\n}\n.super-sales-chat-container .chat-notification.text-button {\n  margin-left: 10px;\n  position: static;\n  width: 27px;\n}\n.super-sales-chat-container .chat-notification--limit {\n  width: 28px;\n}\n.super-sales-chat-container .chat-header {\n  border-top-left-radius: 12px;\n  border-top-right-radius: 12px;\n  display: flex;\n  height: auto;\n  justify-content: space-between;\n  padding: 12px;\n  z-index: 3;\n}\n.super-sales-chat-container .chat-header button, .super-sales-chat-container .chat-header.text-button {\n  color: var(#000000);\n}\n.super-sales-chat-container .chat-header button {\n  margin-top: 3px;\n}\n.super-sales-chat-container .chat-header--is-mobile {\n  border-radius: 0;\n}\n.super-sales-chat-container .chat-header__close_button_mobile {\n  color: inherit;\n  height: 20px;\n  width: 20px;\n}\n.super-sales-chat-container .chat-main-body {\n  background-color: #fff;\n  border-bottom-left-radius: 12px;\n  border-bottom-right-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n.super-sales-chat-container .chat-banner {\n  background-color: #f8f9f9;\n  color: #212b36;\n  display: flex;\n  font-size: 12px;\n  justify-content: center;\n  padding: 2% 3%;\n}\n.super-sales-chat-container .chat-banner__text--opening {\n  font-weight: 700;\n}\n.super-sales-chat-container .chat-banner--highlighted {\n  background-color: #ffefd2;\n}\n.super-sales-chat-container .chat-banner__icon {\n  margin-right: 6px;\n}\n.super-sales-chat-container .chat-messages {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  height: 287px;\n  justify-content: flex-end;\n  overflow-y: scroll;\n  scrollbar-color: transparent transparent;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.super-sales-chat-container .chat-messages::-webkit-scrollbar {\n  display: none;\n  width: 0 !important;\n}\n.super-sales-chat-container .chat-messages__list {\n  background-color: #fff;\n  display: flex;\n  flex-flow: column nowrap;\n  margin: 0;\n  overflow-y: scroll;\n  overscroll-behavior: contain;\n  padding: 0;\n  position: relative;\n  scrollbar-color: transparent transparent;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.super-sales-chat-container .chat-messages__list::-webkit-scrollbar {\n  display: none;\n}\n.super-sales-chat-container .chat-messages__list > div:last-of-type {\n  animation-duration: 0.5s;\n  animation-name: shopify-chat-slide-up;\n  padding-bottom: 16px;\n}\n.super-sales-chat-container .automated-message__label {\n  color: #a0a4a9;\n  font-size: 11px;\n  margin-top: 4px;\n  padding-bottom: 8px;\n  padding-left: 20px;\n  text-align: left;\n}\n.super-sales-chat-container .chat-messages__container {\n  display: block;\n  line-height: 20px;\n  overflow-wrap: break-word;\n  padding-top: 4px;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  display: flex;\n  flex-direction: column;\n}\n.super-sales-chat-container .chat-view .chat-main-body {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.super-sales-chat-container .chat-view .chat-messages {\n  height: 100px;\n}\n.super-sales-chat-container .chat-view .chat-messages li:first-child {\n  margin-top: 26px;\n}\n.super-sales-chat-container .chat-view .chat-messages li:last-of-type + .automated-message__label {\n  margin-bottom: 0;\n  padding-bottom: 0;\n}\n.super-sales-chat-container .chat-view .chat-messages__list > div:last-of-type {\n  animation-name: none;\n  padding-bottom: 6px;\n}\n.super-sales-chat-container .chat-view .composer-bar-wrapper {\n  margin-bottom: 8px;\n  margin-top: 8px;\n}\n\n#chat-button {\n  position: fixed;\n  bottom: 20px;\n  right: 20px;\n  background-color: #007bff;\n  color: #fff;\n  padding: 10px 20px;\n  border-radius: 50px;\n  cursor: pointer;\n  z-index: 1000;\n}\n#chat-button.hidden {\n  display: none;\n}\n\n#chat-widget {\n  transition: width 0.3s ease;\n  border-radius: 22px;\n  position: fixed;\n  bottom: 86px;\n  right: 20px;\n  width: 25%;\n  height: 80%;\n  border-width: 1px;\n  border-style: solid;\n  background-color: #fff;\n  display: flex;\n  flex-direction: column;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n}\n#chat-widget.hidden {\n  display: none;\n}\n\n#chat-widget.expanded {\n  width: calc(60% - 60px) !important;\n  height: 85%;\n}\n\n#chat-widget.shrunk {\n  width: 25% !important;\n  height: 80%;\n}\n\n#resizeWidgetButton {\n  display: flex;\n}\n\n@media (max-width: 800px) {\n  #resizeWidgetButton {\n    display: none;\n  }\n  #chat-widget {\n    bottom: 10px !important;\n    right: 10px !important;\n    left: 10px !important;\n    width: calc(100% - 20px) !important;\n    height: calc(100% - 1.5rem) !important;\n    border-radius: 15px !important;\n  }\n  #chat-widget.expanded {\n    width: calc(100% - 20px) !important;\n    height: calc(100% - 1.5rem) !important;\n  }\n  #chat-widget.shrunk {\n    width: calc(100% - 20px) !important;\n    height: calc(100% - 1.5rem) !important;\n  }\n  #chat-input {\n    width: calc(85% - 8px);\n  }\n  #chat-input.expanded {\n    width: calc(85% - 8px);\n  }\n  #chat-input.shrunk {\n    width: calc(85% - 8px);\n  }\n}\n@media (min-width: 801px) and (max-width: 1200px) {\n  #resizeWidgetButton {\n    display: flex;\n  }\n  #chat-widget {\n    width: calc(50% - 60px) !important;\n    transition: width 0.3s ease;\n  }\n  #chat-widget.expanded {\n    width: calc(70% - 60px) !important;\n  }\n  #chat-widget.shrunk {\n    width: calc(50% - 60px) !important;\n  }\n  #chat-input {\n    width: calc(85% - 8px);\n  }\n  #chat-input.expanded {\n    width: calc(90% - 8px);\n  }\n  #chat-input.shrunk {\n    width: calc(85% - 8px);\n  }\n}\n#chat-header {\n  min-height: 3rem;\n  background-color: #007bff;\n  color: #fff;\n  padding: 1rem;\n  text-align: center;\n  position: relative;\n  cursor: pointer;\n  border-top-right-radius: 20px;\n  border-top-left-radius: 20px;\n  font-weight: bold;\n}\n\n#chat-messages {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  padding: 10px;\n  overflow-y: auto;\n}\n\n.message-container {\n  margin-bottom: 10px;\n  display: flex;\n  flex-direction: column;\n  word-wrap: break-word;\n}\n\n.user-info {\n  display: flex;\n  align-items: center;\n}\n\n.user-name {\n  margin-right: 10px;\n  font-weight: bold;\n  color: #6d7175;\n}\n\n.user-avatar {\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n  object-fit: cover;\n}\n\n.user-message {\n  display: flex;\n  margin-left: auto;\n  max-width: 80%;\n  align-self: flex-end;\n  background-color: #e6f2ff;\n  padding: 8px 12px;\n  border-radius: 8px;\n}\n\n.admin-message {\n  align-self: flex-start;\n  background-color: #f0f0f0;\n  padding: 8px 12px;\n  border-radius: 8px;\n  max-width: 80%;\n}\n\n.message-time {\n  align-self: flex-end;\n  font-size: 12px;\n}\n\n#chat-input-container {\n  display: flex;\n  align-items: flex-end; /* Changed from center to flex-end */\n  padding: 8px;\n}\n#chat-input-container.hidden {\n  display: none;\n}\n\n.hidden {\n  display: none !important;\n}\n\n#chat-input {\n  border: 0.1px solid #d2d5d9;\n  border-radius: 14px;\n  padding: 10px;\n  margin-right: 8px; /* Changed from margin to margin-right */\n  width: calc(85% - 8px); /* Adjusted to account for the right margin */\n  outline-color: #cdcdcf;\n  resize: none;\n  overflow: hidden;\n  min-height: 38px;\n  max-height: 150px; /* Add a max height to prevent excessive growth */\n  line-height: 20px;\n  font-family: inherit; /* Ensure consistent font */\n  font-size: inherit; /* Ensure consistent font size */\n  box-sizing: border-box;\n}\n#chat-input.expanded {\n  width: calc(90% - 8px);\n}\n#chat-input.shrunk {\n  width: calc(85% - 8px);\n}\n\n#send-button {\n  align-self: flex-end; /* Align the button to the bottom */\n  margin-bottom: 8px;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n  margin-left: auto;\n  margin-right: 12px;\n}\n\n#send-button i {\n  font-size: 1.2em;\n  color: #007bff;\n}\n\n#loading-spinner {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 10px;\n  font-size: 16px;\n  color: #555;\n  margin: 0 43%;\n}\n\n.super-sales-chat-container .chat-app {\n  position: fixed !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  z-index: 1000 !important;\n}\n.super-sales-chat-container .chat-app .chat-app--close-button {\n  margin-top: 16px !important;\n  margin-right: 12px !important;\n}\n.super-sales-chat-container .chat-app--is-open:not(.chat-app--is-mobile) {\n  margin: 14px 10px !important;\n}\n.super-sales-chat-container .chat-app--close-button {\n  align-items: center;\n  animation-duration: 0.25s;\n  animation-name: shopify-chat-fade-in;\n  border-radius: 50%;\n  display: flex;\n  font-size: 24px;\n  font-weight: 240;\n  height: 60px;\n  justify-content: center;\n  margin-top: 16px;\n  width: 60px;\n  border: none;\n  cursor: pointer;\n  background-color: #007bff;\n  color: #fff;\n}\n.super-sales-chat-container .chat-header-menu-item {\n  width: 100% !important;\n  padding: 8px 16px !important;\n  border: none !important;\n  background: transparent !important;\n  text-align: left !important;\n  cursor: pointer !important;\n  font-size: 14px !important;\n  color: #000 !important;\n  transition: background-color 0.2s !important;\n}\n\n/* Thumbnails container */\n.thumbnails-container {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 10px;\n}\n\n/* Placeholder for loading image */\n.thumbnail-placeholder {\n  width: 100px;\n  height: 100px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: #f0f0f0;\n  border-radius: 8px;\n  position: relative;\n  margin: 0.5rem 0;\n}\n\n/* Loading spinner */\n.loading-spinner {\n  display: flex !important;\n  border: 4px solid #f3f3f3; /* Light grey */\n  border-top: 4px solid #3498db; /* Blue */\n  border-radius: 50%;\n  width: 24px;\n  height: 24px;\n  animation: spin 1s linear infinite;\n  margin: 1rem;\n}\n\n/* Animation for spinner */\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n/* Thumbnail image */\n.thumbnail-image {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  border-radius: 8px;\n  cursor: pointer;\n}\n\n.typing-indicator {\n  font-style: italic;\n  margin: 0 1rem;\n}\n\n.quick-reply {\n  background: unset;\n  cursor: pointer;\n}\n\n.hidden-placeholder {\n  visibility: hidden !important;\n}\n\n.powered-by-banner {\n  font-size: 12px;\n  display: flex;\n  justify-content: center;\n  margin: 0.2rem 5rem 0.5rem 5rem;\n  border-radius: 5px;\n  cursor: pointer;\n  color: var(--text-color);\n}\n.powered-by-banner:hover {\n  color: var(--secondary-text-color);\n}\n\n.chat-header-content {\n  display: flex;\n  align-items: center;\n  padding: 8px 16px;\n  border-bottom: 1px solid #eee;\n  justify-content: space-between;\n}\n.chat-header-content .header-left-section {\n  display: flex;\n  align-items: center;\n}\n.chat-header-content .header-left-section .avatar-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.chat-header-content .header-left-section .avatar-container .agent-avatar {\n  width: 45px;\n  height: 45px;\n  border-radius: 50%;\n  background: white;\n  padding: 0.15rem;\n}\n.chat-header-content .header-left-section .agent-info {\n  margin-left: 12px;\n}\n.chat-header-content .header-left-section .agent-info .agent-name {\n  font-weight: 600;\n}\n.chat-header-content .header-left-section .agent-info .agent-status {\n  font-size: 12px;\n}\n.chat-header-content .header-left-section .status-indicator {\n  position: absolute;\n  top: 40px;\n  left: 54px;\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n  border: 2px solid white;\n  background-color: gray;\n}\n.chat-header-content .header-controls {\n  display: flex;\n  align-items: center;\n}\n.chat-header-content .header-controls .header-control-btn {\n  background: transparent;\n  border: none;\n  padding: 8px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 4px;\n  transition: background-color 0.2s;\n}\n.chat-header-content .header-controls .header-control-btn:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n.chat-header-content .header-controls .menu-container {\n  position: relative;\n}\n.chat-header-content .header-controls .menu-container .menu-dropdown {\n  position: absolute;\n  top: 100%;\n  right: 0;\n  background: #fff;\n  border-radius: 8px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n  min-width: 160px;\n  z-index: 1000;\n  margin-top: 4px;\n}\n.chat-header-content .header-controls .menu-container .menu-dropdown.hidden {\n  display: none;\n}\n.chat-header-content .header-controls .menu-container .menu-dropdown .chat-header-menu-item {\n  width: 100%;\n  background-color: transparent;\n  border: none;\n  padding: 8px 16px;\n  text-align: left;\n  cursor: pointer;\n  color: #000;\n  font-size: 14px;\n}\n.chat-header-content .header-controls .menu-container .menu-dropdown .chat-header-menu-item:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n\n.hidden {\n  display: none !important;\n}\n\n.str-chat__message-input .str-chat__send-button svg {\n  width: calc(var(--str-chat__spacing-px) * 32);\n  height: calc(var(--str-chat__spacing-px) * 32);\n}\n\n.str-chat * {\n  font-family: var(--str-chat__font-family);\n  box-sizing: border-box;\n}\n\n.super-sales-chat-container .chat-app a {\n  color: -webkit-link !important;\n  cursor: pointer !important;\n}\n.super-sales-chat-container .chat-app a:visited {\n  color: -webkit-link !important;\n  cursor: pointer !important;\n}\n.super-sales-chat-container .smart-buy-chat-header {\n  min-height: 2.5rem;\n  box-shadow: rgba(0, 0, 0, 0.1) 0 2px 4px 1px !important;\n}\n.super-sales-chat-container .chat-header-content {\n  cursor: pointer;\n  border-top-right-radius: 22px;\n  border-top-left-radius: 22px;\n}\n@media (min-width: 801px) and (max-width: 1200px) {\n  .super-sales-chat-container .chat-header-content {\n    border-top-right-radius: 22px;\n    border-top-left-radius: 22px;\n  }\n  .super-sales-chat-container .message-container {\n    max-width: 80%;\n  }\n}\n@media (max-width: 800px) {\n  .super-sales-chat-container .chat-header-content {\n    border-top-right-radius: 14px;\n    border-top-left-radius: 14px;\n  }\n}\n.super-sales-chat-container .smart-buy-quick-reply {\n  background-color: unset !important;\n  border-width: 2px !important;\n  border-style: solid !important;\n}\n\n@media (max-width: 800px) {\n  .super-sales-chat-container button.chat-toggle.chat-toggle--text-button .chat-title {\n    display: none !important;\n  }\n  .super-sales-chat-container button.chat-toggle.chat-toggle--text-button {\n    padding: 6px !important;\n    border-radius: 50% !important;\n  }\n}\n/* Modal overlay to darken the background */\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgba(0, 0, 0, 0.8);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n  overflow: hidden; /* Prevents scrolling when modal is open */\n}\n\n/* Modal content for full-size image */\n.modal-content {\n  position: relative;\n  background-color: #fff;\n  padding: 10px;\n  border-radius: 10px;\n  max-width: 90vw; /* Limit width to 90% of viewport */\n  max-height: 90vh; /* Limit height to 90% of viewport */\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);\n  overflow: hidden;\n}\n\n/* Full-size image inside the modal */\n.full-size-image {\n  width: auto;\n  height: auto;\n  max-width: 100%; /* Ensures the image scales within the modal width */\n  max-height: 100%; /* Ensures the image scales within the modal height */\n  object-fit: contain; /* Ensures the image doesn't get cropped */\n  border-radius: 8px;\n  display: block;\n}\n\n/* Close button for the modal */\n.modal-close {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  background-color: transparent;\n  border: none;\n  font-size: 1.5rem;\n  cursor: pointer;\n  color: #333;\n}\n\n.modal-image-container {\n  display: flex;\n  max-width: inherit;\n  max-height: inherit;\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/styles/smart-buy-styles.scss\",\"webpack://./src/style.scss\",\"webpack://./src/styles/widget.scss\",\"webpack://./src/styles/vars.scss\",\"webpack://./src/styles/stream-chat-overrides.scss\",\"webpack://./src/styles/smart-buy-overrides.scss\",\"webpack://./src/styles/modal-styles.scss\"],\"names\":[],\"mappings\":\"AAIM;EACE,mBAAA;EACA,sBAAA;EACA,iBAAA;EACA,kBAAA;EACA,sBAAA;EACA,cAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,8BAAA;EACA,iBAAA;EACA,aAAA;EACA,kBAAA;EACA,kBAAA;EACA,WAAA;EACA,sBAAA;ACHR;ADKQ;EACE,SAAA;EACA,gBAAA;EACA,iBAAA;ACHV;ADMQ;EACE,YAAA;EACA,WAAA;ACJV;ADQM;EACE,sBAAA;EACA,yBAAA;EACA,mBAAA;EACA,sBAAA;EACA,cAAA;EACA,eAAA;EACA,aAAA;EACA,cAAA;EACA,wBAAA;EACA,gBAAA;EACA,yBAAA;EACA,iBAAA;EACA,gBAAA;ACNR;ADUI;EACE,aAAA;EACA,sBAAA;EACA,uBAAA;EACA,YAAA;ACRN;ADWI;EACE,cAAA;ACTN;ADWM;EACE,eAAA;ACTR;ADYM;EACE,kBAAA;ACVR;ADeM;EACE,sBAAA;EACA,mBAAA;EACA,cAAA;EACA,eAAA;EACA,qDAAA;EACA,6CAAA;ACbR;ADeQ;EACE,yBAAA;EACA,qDAAA;EACA,6CAAA;ACbV;ADiBM;EACE,yBAAA;EACA,mBAAA;EACA,oBAAA;EACA,iBAAA;ACfR;ADoBE;EACE,oBAAA;AClBJ;ADqBE;EACE,iBAAA;ACnBJ;ADqBI;EACE,oBAAA;ACnBN;ADqBM;EACE,YAAA;EACA,gBAAA;EACA,kBAAA;ACnBR;ADsBM;EACE,mBAAA;ACpBR;ADwBI;EACE,mBAAA;ACtBN;ADyBI;EACE,sBAAA;EACA,kBAAA;EACA,aAAA;EACA,sBAAA;EACA,kBAAA;EACA,kBAAA;ACvBN;ADyBM;EACE,aAAA;EACA,2BAAA;EACA,8BAAA;EACA,gBAAA;ACvBR;AD0BM;EACE,yBAAA;EACA,kBAAA;EACA,gBAAA;EACA,aAAA;EACA,sBAAA;EACA,gBAAA;ACxBR;AD0BQ;EACE,qBAAA;ACxBV;AD4BM;EACE,SAAA;EACA,kBAAA;EACA,cAAA;EACA,YAAA;EACA,iBAAA;EACA,aAAA;EACA,qBAAA;EACA,gBAAA;EACA,aAAA;EACA,YAAA;AC1BR;AD4BQ;EACE,mBAAA;AC1BV;AD6BQ;EACE,cAAA;AC3BV;AD+BM;EACE,oBAAA;EACA,mBAAA;EACA,eAAA;AC7BR;ADgCM;EACE,aAAA;AC9BR;ADiCM;EACE,kBAAA;EACA,aAAA;EACA,eAAA;AC/BR;ADiCQ;EACE,aAAA;AC/BV;ADkCQ;EACE,oBAAA;EACA,mBAAA;AChCV;ADmCQ;EACE,YAAA;ACjCV;ADqCM;EACE,oBAAA;EACA,mBAAA;ACnCR;ADsCM;EACE,cAAA;EACA,eAAA;EACA,sBAAA;ACpCR;ADyCE;EACE,eAAA;ACvCJ;AD0CE;EACE,mBAAA;EACA,aAAA;ACxCJ;AD0CI;EACE,yBAAA;EACA,sBAAA;EACA,YAAA;EACA,SAAA;EACA,WAAA;ACxCN;AD2CI;EACE,gBAAA;ACzCN;AD6CE;EACE,kBAAA;AC3CJ;AD8CE;EACE,uBAAA;AC5CJ;AD+CE;EACE,aAAA;EACA,cAAA;AC7CJ;ADgDE;EACE,yBAAA;EACA,kBAAA;EACA,WAAA;EACA,UAAA;AC9CJ;ADgDI;EACE,wCAAA;EACA,iBAAA;EACA,iBAAA;AC9CN;ADiDI;EACE,wCAAA;EACA,gBAAA;EACA,iBAAA;AC/CN;ADkDI;EACE,0CAAA;EACA,gBAAA;EACA,kBAAA;AChDN;ADoDE;EACE;IACE,yBAAA;EClDJ;EDqDE;IACE,yBAAA;ECnDJ;EDsDE;IACE,yBAAA;ECpDJ;EDuDE;IACE,yBAAA;ECrDJ;AACF;ADwDE;EACE;IACE,yBAAA;ECtDJ;EDyDE;IACE,yBAAA;ECvDJ;ED0DE;IACE,yBAAA;ECxDJ;ED2DE;IACE,yBAAA;ECzDJ;AACF;AD4DE;EACE;IACE,yBAAA;EC1DJ;ED6DE;IACE,yBAAA;EC3DJ;ED8DE;IACE,yBAAA;EC5DJ;ED+DE;IACE,yBAAA;EC7DJ;AACF;ADgEE;EACE,aAAA;EACA,sBAAA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;EACA,wCAAA;EACA,kBAAA;EACA,wBAAA;EACA,qBAAA;AC9DJ;ADgEI;EACE,aAAA;AC9DN;ADkEE;EACE,iDAAA;EACA,yBAAA;EACA,kBAAA;EACA,yBAAA;EACA,YAAA;EACA,YAAA;EACA,WAAA;AChEJ;ADmEE;EACE,mBAAA;EACA,aAAA;EACA,OAAA;EACA,mBAAA;EACA,kBAAA;ACjEJ;ADmEI;EACE,SAAA;EACA,kBAAA;ACjEN;ADmEM;EACE,uBAAA;EACA,UAAA;ACjER;ADqEI;EACE,YAAA;EACA,WAAA;ACnEN;ADuEE;EACE,kBAAA;EACA,MAAA;ACrEJ;ADwEE;EACE,OAAA;EACA,iBAAA;ACtEJ;ADyEE;EACE,sBAAA;EACA,mBAAA;EACA,OAAA;EACA,eAAA;EACA,gBAAA;EACA,iBAAA;EACA,SAAA;EACA,kBAAA;EACA,qBAAA;EACA,oBAAA;EACA,qBAAA;EACA,aAAA;EACA,4BAAA;EACA,oBAAA;EACA,gBAAA;EACA,uBAAA;ACvEJ;AD2EI;EACE,yBAAA;EACA,0BAAA;ACzEN;AD4EI;EACE,mBAAA;EACA,kBAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,uBAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,WAAA;AC1EN;AD4EM;EACE,yBAAA;EACA,qDAAA;EACA,6CAAA;AC1ER;AD6EM;EACE,yBAAA;EACA,cAAA;AC3ER;AD8EM;EACE,yBAAA;EACA,mBAAA;EACA,qDAAA;EACA,6CAAA;AC5ER;ADgFI;EACE,mBAAA;EACA,yBAAA;EACA,kBAAA;EACA,cAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,uBAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,qDAAA;EACA,6CAAA;EACA,WAAA;AC9EN;ADgFM;EACE,yBAAA;EACA,qDAAA;EACA,6CAAA;AC9ER;ADiFM;EACE,cAAA;AC/ER;ADiFQ;EACE,iBAAA;AC/EV;ADoFI;EACE,eAAA;EACA,gBAAA;EACA,0BAAA;AClFN;ADqFI;EACE,kBAAA;EACA,aAAA;EACA,sBAAA;EACA,sBAAA;EACA,mBAAA;ACnFN;ADsFI;EACE,eAAA;EACA,iBAAA;EACA,kBAAA;EACA,0BAAA;ACpFN;ADuFI;EACE,mBAAA;EACA,kBAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,uBAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,WAAA;ACrFN;ADuFM;EACE,yBAAA;EACA,cAAA;ACrFR;ADyFI;EACE,mBAAA;EACA,uBAAA;EACA,kBAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,uBAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,WAAA;ACvFN;ADyFM;EACE,yBAAA;EACA,qDAAA;EACA,6CAAA;ACvFR;AD0FM;EACE,yBAAA;EACA,cAAA;ACxFR;AD2FM;EACE,yBAAA;EACA,cAAA;EACA,iDAAA;EACA,yCAAA;ACzFR;AD8FE;EACE,mBAAA;EACA,cAAA;EACA,aAAA;EACA,8BAAA;EACA,iBAAA;EACA,mBAAA;AC5FJ;AD8FI;EACE,WAAA;AC5FN;ADgGE;EACE,eAAA;EACA,gBAAA;AC9FJ;ADiGE;EACE,cAAA;EACA,aAAA;EACA,uBAAA;EACA,kBAAA;AC/FJ;ADkGE;EACE,oBAAA;AChGJ;ADmGE;EACE,kBAAA;EACA,oBAAA;ACjGJ;ADoGE;EACE,uBAAA;AClGJ;ADqGE;EACE,eAAA;EACA,gBAAA;ACnGJ;ADqGI;EACE,0BAAA;ACnGN;ADuGE;EACE,eAAA;ACrGJ;ADwGE;EACE,kBAAA;EACA,eAAA;EACA,aAAA;EACA,mBAAA;EACA,iBAAA;EACA,YAAA;ACtGJ;ADyGE;EACE,eAAA;ACvGJ;AD0GE;EACE,uBAAA;EACA,WAAA;EACA,eAAA;EACA,uBAAA;EACA,0BAAA;ACxGJ;AD2GE;EACE,WAAA;ACzGJ;AD4GE;EACE,oBAAA;EACA,cAAA;EACA,eAAA;EACA,gBAAA;EACA,kBAAA;EACA,kBAAA;AC1GJ;AD4GI;EACE,0BAAA;AC1GN;AD4GM;EACE,eAAA;AC1GR;AD+GE;EACE,iDAAA;EACA,yBAAA;EACA,kBAAA;EACA,yBAAA;EACA,qBAAA;EACA,YAAA;EACA,gBAAA;EACA,WAAA;AC7GJ;ADgHE;EACE,WAAA;EACA,qBAAA;AC9GJ;ADgHI;EACE,mBAAA;EACA,YAAA;AC9GN;ADkHE;EACE,qBAAA;AChHJ;ADmHE;EACE,eAAA;EACA,gBAAA;EACA,iBAAA;ACjHJ;ADoHE;EACE,cAAA;EACA,eAAA;EACA,iBAAA;AClHJ;ADqHE;EACE,mBAAA;EACA,aAAA;EACA,uBAAA;ACnHJ;ADsHE;EACE,8BAAA;EACA,kBAAA;EACA,eAAA;EACA,gBAAA;EACA,YAAA;EACA,iBAAA;EACA,gBAAA;EACA,aAAA;EACA,WAAA;ACpHJ;ADsHI;EACE,qDAAA;EACA,6CAAA;ACpHN;ADuHI;EACE,yBAAA;EACA,cAAA;ACrHN;ADwHI;EACE,WAAA;EACA,qDAAA;EACA,6CAAA;ACtHN;AD0HE;EACE,4BAAA;EACA,6BAAA;EACA,iBAAA;EACA,gBAAA;ACxHJ;AD2HE;EACE,mBAAA;EACA,aAAA;EACA,YAAA;ACzHJ;AD2HI;EACE,yBAAA;EACA,sBAAA;EACA,YAAA;EACA,WAAA;ACzHN;AD6HE;EACE,4BAAA;EACA,6BAAA;EACA,iBAAA;EACA,gBAAA;AC3HJ;AD8HE;EACE,mBAAA;EACA,aAAA;EACA,YAAA;EACA,YAAA;AC5HJ;AD8HI;EACE,yBAAA;EACA,sBAAA;EACA,YAAA;EACA,WAAA;AC5HN;AD+HI;EACE,gBAAA;EACA,iBAAA;AC7HN;ADiIE;EACE,cAAA;EACA,eAAA;EACA,iBAAA;EACA,kBAAA;EACA,gBAAA;EACA,kBAAA;AC/HJ;ADkIE;EACE,cAAA;EACA,cAAA;AChIJ;ADmIE;EACE,cAAA;EACA,cAAA;ACjIJ;ADmII;EACE,kBAAA;ACjIN;ADqIE;EACE,kBAAA;EACA,YAAA;EACA,WAAA;ACnIJ;ADsIE;EACE,yBAAA;ACpIJ;ADsII;EACE,cAAA;ACpIN;ADwIE;EACE,yBAAA;ACtIJ;ADwII;EACE,cAAA;ACtIN;AD0IE;EACE,yBAAA;ACxIJ;AD0II;EACE,cAAA;ACxIN;AD4IE;EACE,yBAAA;AC1IJ;AD4II;EACE,cAAA;AC1IN;AD8IE;EACE,yBAAA;AC5IJ;AD8II;EACE,cAAA;AC5IN;ADgJE;EACE,mBAAA;EACA,yBAAA;EACA,mBAAA;EACA,qBAAA;EACA,qBAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;EACA,iBAAA;AC9IJ;ADgJI;EACE,wBAAA;EACA,oCAAA;EACA,gBAAA;AC9IN;ADiJI;EACE,cAAA;EACA,iBAAA;EACA,kBAAA;AC/IN;ADmJE;EACE,sBAAA;EACA,yBAAA;ACjJJ;ADmJI;EACE,yBAAA;ACjJN;ADqJE;EACE,oBAAA;EACA,yBAAA;EACA,mBAAA;ACnJJ;ADqJI;EACE,6BAAA;ACnJN;ADwJI;EACE,YAAA;EACA,gBAAA;ACtJN;ADwJM;EACE,mBAAA;EACA,qBAAA;ACtJR;ADyJM;EACE,gBAAA;ACvJR;AD0JM;EACE,YAAA;ACxJR;AD4JI;EACE,YAAA;EACA,eAAA;AC1JN;AD6JI;EACE,sBAAA;EACA,yBAAA;EACA,UAAA;AC3JN;AD+JE;EACE,aAAA;EACA,cAAA;AC7JJ;ADgKE;EACE,gBAAA;EACA,sBAAA;EACA,QAAA;EACA,wBAAA;EACA,gBAAA;AC9JJ;ADiKE;EACE,oBAAA;EACA,sBAAA;EACA,wBAAA;AC/JJ;ADiKI;EACE,eAAA;AC/JN;ADoKI;EACE,gBAAA;EACA,kBAAA;EACA,cAAA;AClKN;ADsKE;EACE,mBAAA;EACA,eAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,gBAAA;ACpKJ;ADsKI;EACE,cAAA;EACA,UAAA;ACpKN;ADwKE;EACE,oBAAA;ACtKJ;ADyKE;EACE,cAAA;EACA,eAAA;EACA,iBAAA;EACA,kBAAA;EACA,eAAA;EACA,kBAAA;ACvKJ;AD0KE;EACE,mBAAA;EACA,cAAA;EACA,gBAAA;EACA,yBAAA;EACA,mBAAA;EACA,kBAAA;EACA,qBAAA;EACA,qBAAA;EACA,eAAA;EACA,iBAAA;EACA,iBAAA;ACxKJ;AD2KE;EACE,cAAA;EACA,iBAAA;EACA,kBAAA;ACzKJ;AD4KE;EACE,yBAAA;EACA,sBAAA;AC1KJ;AD6KE;EACE,yBAAA;EACA,wBAAA;AC3KJ;AD8KM;EACE,eAAA;AC5KR;AD+KM;EACE,sBAAA;EACA,qBAAA;EACA,cAAA;EACA,eAAA;AC7KR;ADgLM;EACE,eAAA;AC9KR;ADiLM;EACE,gBAAA;AC/KR;ADoLE;EACE,wBAAA;AClLJ;ADqLE;EACE,0CAAA;ACnLJ;ADsLE;EACE,mBAAA;EACA,wBAAA;ACpLJ;ADuLE;EACE,mBAAA;EACA,wBAAA;ACrLJ;ADwLM;EACE,eAAA;ACtLR;ADyLM;EACE,gBAAA;ACvLR;AD4LE;EACE,eAAA;EACA,gBAAA;EACA,kBAAA;EACA,iBAAA;EACA,kBAAA;AC1LJ;AD6LE;EACE,mBAAA;AC3LJ;AD8LE;EACE,wBAAA;EACA,gBAAA;EACA,yBAAA;EACA,kBAAA;EACA,sBAAA;EACA,aAAA;EACA,WAAA;AC5LJ;AD+LE;EACE,yBAAA;EACA,aAAA;AC7LJ;ADgME;EACE,sBAAA;EACA,eAAA;EACA,eAAA;AC9LJ;ADgMI;EACE,eAAA;EACA,0BAAA;AC9LN;ADoMM;EACE,yBAAA;EACA,2BAAA;AClMR;ADqMM;EACE,cAAA;ACnMR;ADwMM;EACE,yBAAA;EACA,2BAAA;ACtMR;ADyMM;EACE,cAAA;ACvMR;AD4ME;EACE,kBAAA;EACA,gBAAA;EACA,gBAAA;EACA,kBAAA;EACA,WAAA;AC1MJ;AD4MI;EACE,mBAAA;EACA,gBAAA;EACA,kBAAA;EACA,UAAA;AC1MN;AD6MI;EACE,SAAA;EACA,OAAA;EACA,kBAAA;EACA,QAAA;EACA,MAAA;EACA,UAAA;AC3MN;AD8MI;EACE,yBAAA;AC5MN;AD8MM;EACE,cAAA;AC5MR;ADgNI;EACE,uBAAA;AC9MN;ADkNE;EACE,iBAAA;EACA,kBAAA;AChNJ;ADmNE;EACE,mBAAA;EACA,aAAA;EACA,yBAAA;EACA,uBAAA;EACA,kBAAA;EACA,SAAA;EACA,YAAA;EACA,UAAA;ACjNJ;ADmNI;EACE,yBAAA;EACA,WAAA;ACjNN;ADoNI;EACE,yBAAA;AClNN;ADqNI;EACE,sBAAA;EACA,4BAAA;EACA,sBAAA;EACA,aAAA;EACA,sBAAA;EACA,YAAA;EACA,gBAAA;EACA,eAAA;EACA,kBAAA;EACA,WAAA;ACnNN;ADqNM;EACE,mBAAA;EACA,aAAA;EACA,kBAAA;ACnNR;ADqNQ;EACE,eAAA;EACA,gBAAA;EACA,iBAAA;EACA,kBAAA;EACA,UAAA;ACnNV;ADsNQ;EACE,cAAA;EACA,eAAA;ACpNV;ADwNM;EACE,aAAA;EACA,OAAA;ACtNR;AD2NE;EACE,aAAA;EACA,OAAA;ACzNJ;AD4NE;EACE,OAAA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;EACA,8BAAA;AC1NJ;AD6NE;EACE,aAAA;EACA,sBAAA;EACA,8BAAA;EACA,YAAA;AC3NJ;AD8NE;EACE,mBAAA;EACA,gBAAA;EACA,kBAAA;AC5NJ;AD+NE;EACE,eAAA;EACA,gBAAA;EACA,iBAAA;AC7NJ;ADgOE;EACE,eAAA;AC9NJ;ADiOE;EACE,mBAAA;EACA,gBAAA;AC/NJ;ADkOE;EACE,kBAAA;AChOJ;ADmOE;EACE,sBAAA;EACA,oBAAA;ACjOJ;ADoOE;EACE,mBAAA;EACA,YAAA;EACA,kBAAA;EACA,mBAAA;EACA,cAAA;EACA,eAAA;EACA,WAAA;EAgBA,mBAAA;EACA,gBAAA;ACjPJ;ADkOI;EACE,mCAAA;AChON;ADmOI;EACE,mBAAA;EACA,YAAA;ACjON;ADoOI;EACE,YAAA;EACA,aAAA;AClON;ADwOI;EACE,YAAA;ACtON;AD0OE;EACE,iDAAA;EACA,yBAAA;EACA,kBAAA;EACA,yBAAA;EACA,qBAAA;EACA,YAAA;EACA,iBAAA;EACA,WAAA;ACxOJ;AD2OE;EACE,sBAAA;EACA,YAAA;EACA,WAAA;ACzOJ;AD4OE;EACE,uBAAA;EACA,gBAAA;EACA,aAAA;EACA,mBAAA;EACA,iBAAA;AC1OJ;AD4OI;EACE,cAAA;EACA,YAAA;EACA,WAAA;AC1ON;AD8OE;EACE,aAAA;EACA,OAAA;AC5OJ;AD+OE;EACE,aAAA;EACA,OAAA;EACA,sBAAA;EACA,YAAA;EACA,8BAAA;AC7OJ;ADgPE;EACE,aAAA;EACA,sBAAA;EACA,YAAA;EACA,8BAAA;AC9OJ;ADiPE;EACE,mBAAA;EACA,gBAAA;EACA,kBAAA;AC/OJ;ADkPE;EACE,eAAA;EACA,gBAAA;EACA,iBAAA;AChPJ;ADmPE;EACE,eAAA;ACjPJ;ADoPE;EACE,mBAAA;EACA,gBAAA;AClPJ;ADqPE;EACE,kBAAA;ACnPJ;ADsPE;EACE,cAAA;ACpPJ;ADuPE;EACE,sBAAA;EACA,oBAAA;ACrPJ;ADwPE;EACE,mBAAA;EACA,YAAA;EACA,kBAAA;EACA,mBAAA;EACA,cAAA;EACA,eAAA;EACA,WAAA;EAgBA,mBAAA;EACA,gBAAA;ACrQJ;ADsPI;EACE,mCAAA;ACpPN;ADuPI;EACE,mBAAA;EACA,YAAA;ACrPN;ADwPI;EACE,YAAA;EACA,aAAA;ACtPN;AD4PI;EACE,YAAA;AC1PN;AD8PE;EACE,iDAAA;EACA,yBAAA;EACA,kBAAA;EACA,yBAAA;EACA,qBAAA;EACA,YAAA;EACA,iBAAA;EACA,WAAA;AC5PJ;AD+PE;EACE,sBAAA;EACA,YAAA;EACA,WAAA;AC7PJ;ADgQE;EACE,mBAAA;EACA,yCAAA;EACA,cAAA;EACA,aAAA;EACA,sBAAA;EACA,cAAA;EACA,gBAAA;EACA,WAAA;EACA,wBAAA;EACA,qBAAA;AC9PJ;ADgQI;EACE,aAAA;AC9PN;ADiQI;EACE,sBAAA;AC/PN;ADmQE;EACE;IACE,yBAAA;IACA,4BAAA;ECjQJ;AACF;ADoQE;EACE,gBAAA;EACA,aAAA;EACA,SAAA;EACA,YAAA;AClQJ;ADqQE;EACE,uBAAA;EACA,yBAAA;EACA,cAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,aAAA;ACnQJ;ADqQI;EACE,SAAA;EACA,eAAA;ACnQN;ADuQE;EACE,aAAA;ACrQJ;ADwQE;EACE,cAAA;ACtQJ;ADyQE;EACE,YAAA;EACA,WAAA;ACvQJ;AD0QE;EACE,iBAAA;ACxQJ;AD2QE;EACE,uBAAA;ACzQJ;AD4QE;EACE,8BAAA;AC1QJ;AD6QE;EACE,mBAAA;EACA,sBAAA;EACA,4BAAA;EACA,aAAA;EACA,sBAAA;EACA,YAAA;EACA,cAAA;EACA,iBAAA;EACA,oBAAA;AC3QJ;AD8QE;EACE,uBAAA;AC5QJ;AD+QE;EACE,eAAA;EACA,gBAAA;AC7QJ;ADgRE;EACE,gCAAA;EACA,cAAA;EACA,eAAA;EACA,eAAA;EACA,iBAAA;EACA,aAAA;EACA,kBAAA;EACA,sBAAA;AC9QJ;ADgRI;EACE,SAAA;EACA,iBAAA;AC9QN;ADkRE;EACE,cAAA;EACA,cAAA;EACA,gBAAA;EACA,qBAAA;EACA,kBAAA;AChRJ;ADmRE;EACE,mBAAA;EACA,kBAAA;EACA,yCAAA;EACA,mBAAA;EACA,0CAAA;EACA,WAAA;EACA,aAAA;EACA,gBAAA;EACA,YAAA;EACA,uBAAA;EACA,mBAAA;EACA,WAAA;ACjRJ;ADmRI;EACE,yCAAA;ACjRN;ADoRI;EACE,iBAAA;AClRN;ADuRI;EACE,eAAA;EACA,gBAAA;ACrRN;ADwRI;EACE,uBAAA;ACtRN;ADyRI;EACE,uBAAA;ACvRN;AD2RE;EACE,iFAAA;EACA,aAAA;EACA,sBAAA;EACA,YAAA;EACA,sDAAA;EAEA,uBAAA;AC1RJ;AD4RI;EACE,gBAAA;AC1RN;AD6RI;EACE,mBAAA;EACA,aAAA;EACA,wBAAA;AC3RN;AD8RI;EACE,aAAA;EACA,sBAAA;EACA,YAAA;EACA,uBAAA;EACA,kBAAA;EACA,uBAAA;AC5RN;AD8RM;EACE,gBAAA;AC5RR;AD+RM;EACE,aAAA;AC7RR;ADiSI;EACE,aAAA;EACA,qBAAA;AC/RN;ADiSM;EACE,mBAAA;EACA,eAAA;EACA,gBAAA;EACA,kBAAA;EACA,aAAA;AC/RR;ADkSM;EACE,kBAAA;AChSR;ADkSQ;EACE,YAAA;EACA,WAAA;AChSV;ADqSI;EACE,mBAAA;EACA,eAAA;EACA,iBAAA;EACA,SAAA;EACA,gBAAA;EACA,mBAAA;EACA,yBAAA;ACnSN;ADsSI;EACE,uBAAA;ACpSN;ADsSM;EACE,sBAAA;ACpSR;ADySE;EACE,mBAAA;EACA,iBAAA;EACA,kBAAA;ACvSJ;ADySI;EACE,sBAAA;EACA,gBAAA;EACA,SAAA;EACA,iBAAA;EACA,YAAA;ACvSN;AD2SE;EACE,mBAAA;EACA,gBAAA;EACA,sBAAA;EACA,uBAAA;EACA,eAAA;EACA,kBAAA;ACzSJ;AD2SI;EACE,WAAA;EACA,eAAA;EACA,gBAAA;EACA,eAAA;ACzSN;AD4SI;EACE,cAAA;EACA,gBAAA;AC1SN;AD8SE;EACE,WAAA;AC5SJ;AD+SE;EACE,YAAA;EACA,kBAAA;EACA,WAAA;EACA,SAAA;EACA,WAAA;AC7SJ;ADgTE;EACE;IACE,YAAA;EC9SJ;EDiTE;IACE,UAAA;EC/SJ;AACF;ADkTE;EACE;IACE,gBAAA;EChTJ;EDmTE;IACE,oBAAA;ECjTJ;AACF;ADoTE;EACE;IACE,uBAAA;EClTJ;EDqTE;IACE,wBAAA;ECnTJ;AACF;ADsTE;EACE;IACE,UAAA;IACA,8BAAA;ECpTJ;EDuTE;IACE,UAAA;IACA,wBAAA;ECrTJ;AACF;ADyUE;EACE,SAAA;EACA,kBAAA;ACvUJ;AD0UE;EACE,0BAAA;ACxUJ;AD2UE;EACE,sBAAA;ACzUJ;AD4UE;EACE,kJAAA;EACA,oBAAA;EACA,kBAAA;EACA,iBAAA;EACA,mBAAA;EACA,oBAAA;EACA,mCAAA;AC1UJ;AD4UI;EACE,uBAAA;EACA,0BAAA;EACA,8BAAA;AC1UN;AD6UI;EACE,SAAA;AC3UN;AD8UI;EACE,cAAA;AC5UN;AD+UI;EACE,qBAAA;EACA,wBAAA;AC7UN;ADgVI;EACE,aAAA;EACA,SAAA;AC9UN;ADiVI;EACE,aAAA;AC/UN;ADkVI;EACE,6BAAA;AChVN;ADkVM;EACE,UAAA;AChVR;ADoVI;EACE,yBAAA;AClVN;ADqVI;EACE,gBAAA;ACnVN;ADsVI;EACE,kBAAA;ACpVN;ADuVI;EACE,cAAA;EACA,gBAAA;ACrVN;ADwVI;EACE,gBAAA;EACA,WAAA;ACtVN;ADyVI;EACE,cAAA;ACvVN;AD0VI;EACE,cAAA;EACA,cAAA;EACA,kBAAA;EACA,wBAAA;ACxVN;AD2VI;EACE,cAAA;EACA,cAAA;EACA,kBAAA;EACA,wBAAA;EACA,WAAA;ACzVN;AD4VI;EACE,eAAA;AC1VN;AD6VI;EACE,SAAA;AC3VN;AD8VI;EACE,gBAAA;AC5VN;AD+VI;EACE,gBAAA;AC7VN;ADgWI;EACE,uBAAA;EACA,SAAA;AC9VN;ADiWI;EACE,cAAA;AC/VN;ADkWI;EACE,iCAAA;EACA,cAAA;AChWN;ADmWI;EACE,cAAA;EACA,aAAA;EACA,SAAA;EACA,UAAA;ACjWN;ADoWI;EACE,iBAAA;EACA,oBAAA;AClWN;ADqWI;EACE,oBAAA;ACnWN;ADsWI;EACE,0BAAA;EACA,eAAA;ACpWN;ADwWM;EACE,0BAAA;EACA,eAAA;ACtWR;AD0WI;EACE,eAAA;ACxWN;AD2WI;EACE,SAAA;EACA,UAAA;ACzWN;AD4WI;EAME,mBAAA;AC/WN;AD0WM;EACE,SAAA;EACA,UAAA;ACxWR;AD6WM;EACE,sBAAA;EACA,UAAA;AC3WR;AD+WQ;EACE,YAAA;AC7WV;ADiXM;EACE,6BAAA;EACA,uBAAA;AC/WR;ADiXQ;EACE,wBAAA;AC/WV;ADoXI;EACE,wBAAA;EACA,SAAA;EACA,UAAA;AClXN;ADqXI;EACE,SAAA;EACA,UAAA;ACnXN;ADsXI;EACE,cAAA;ACpXN;ADuXI;EACE,gBAAA;ACrXN;ADwXI;EACE,yBAAA;EACA,iBAAA;ACtXN;ADyXI;EACE,UAAA;ACvXN;AD0XI;EACE,mBAAA;EACA,yBAAA;EACA,oCAAA;EACA,kBAAA;EACA,mBAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,YAAA;EACA,uBAAA;EACA,gBAAA;EACA,WAAA;ACxXN;AD2XI;EACE,iBAAA;ACzXN;AD8XI;EACE,yBAAA;EACA,4BAAA;AC5XN;AD+XI;EACE,aAAA;AC7XN;ADiYE;EACE,SAAA;AC/XJ;ADiYI;EACE,QAAA;EACA,SAAA;AC/XN;ADmYE;EACE,yBAAA;ACjYJ;ADoYE;EACE,yBAAA;AClYJ;ADqYE;EACE,yBAAA;ACnYJ;ADsYE;EACE,yBAAA;ACpYJ;ADuYE;EACE,yBAAA;ACrYJ;ADwYE;EACE,yBAAA;ACtYJ;ADyYE;EACE,yBAAA;ACvYJ;AD0YE;EACE,yBAAA;ACxYJ;AD2YE;EACE,yBAAA;ACzYJ;AD4YE;EACE,gBAAA;EACA,YAAA;EACA,aAAA;AC1YJ;AD4YI;EACE,6BAAA;EACA,mBAAA;EACA,eAAA;EACA,aAAA;EACA,YAAA;EACA,aAAA;EACA,WAAA;AC1YN;AD4YM;EACE,cAAA;EACA,YAAA;EACA,WAAA;AC1YR;AD4YQ;EACE,kBAAA;AC1YV;AD8YM;EACE,eAAA;EACA,cAAA;AC5YR;AD+YM;EACE,mBAAA;EACA,aAAA;EACA,uBAAA;AC7YR;AD+YQ;EACE,YAAA;AC7YV;ADiZM;EACE,mBAAA;EACA,YAAA;EACA,mBAAA;EACA,uCAAA;EACA,mBAAA;EACA,aAAA;EACA,iBAAA;EACA,gBAAA;EACA,YAAA;EACA,iBAAA;EACA,sBAAA;EACA,qBAAA;EACA,WAAA;AC/YR;ADqZQ;EACE,YAAA;EACA,eAAA;ACnZV;ADsZQ;EACE,mBAAA;EACA,aAAA;EACA,YAAA;EACA,gBAAA;EACA,gBAAA;EACA,mBAAA;ACpZV;ADsZU;EACE,kBAAA;ACpZZ;ADuZU;EACE,kBAAA;ACrZZ;ADwZU;EACE,kBAAA;ACtZZ;ADyZU;EACE,eAAA;ACvZZ;AD0ZU;EACE,kBAAA;ACxZZ;AD+ZE;EACE;IACE,mBAAA;IACA,aAAA;IACA,YAAA;IACA,iBAAA;EC7ZJ;AACF;ADgaE;EACE,yBAAA;EACA,oCAAA;AC9ZJ;ADiaE;EACE,aAAA;EACA,sBAAA;EACA,YAAA;EACA,WAAA;AC/ZJ;ADkaE;EACE,cAAA;EACA,eAAA;EACA,eAAA;EACA,iBAAA;AChaJ;ADmaE;EACE,cAAA;EACA,eAAA;ACjaJ;ADoaE;EACE,aAAA;EACA,sBAAA;EACA,YAAA;AClaJ;ADqaE;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;ACnaJ;ADqaI;EACE,gBAAA;ACnaN;ADsaI;EACE,eAAA;EACA,gBAAA;ACpaN;ADuaI;EACE,wBAAA;EACA,yBAAA;EACA,mBAAA;EACA,gBAAA;EACA,kBAAA;ACraN;ADuaM;EACE,cAAA;EACA,eAAA;EACA,aAAA;ACraR;ADwaM;EACE,aAAA;ACtaR;AD2aE;EACE,sBAAA;EACA,mBAAA;EACA,aAAA;EACA,sBAAA;EACA,YAAA;EACA,yBAAA;EACA,gBAAA;EACA,oBAAA;ACzaJ;AD4aE;EACE,wBAAA;EACA,SAAA;AC1aJ;AD6aE;EACE,kBAAA;AC3aJ;AD8aE;EACE,cAAA;EACA,eAAA;EACA,mBAAA;AC5aJ;AD+aE;EACE,qBAAA;EACA,UAAA;AC7aJ;ADgbE;EACE,mBAAA;EACA,mBAAA;EACA,mBAAA;EACA,cAAA;EACA,eAAA;EACA,gBAAA;EACA,YAAA;EACA,iBAAA;EACA,kBAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;AC9aJ;ADgbI;EACE,iBAAA;EACA,gBAAA;EACA,WAAA;AC9aN;ADkbE;EACE,WAAA;AChbJ;ADmbE;EACE,4BAAA;EACA,6BAAA;EACA,aAAA;EACA,YAAA;EACA,8BAAA;EACA,aAAA;EACA,UAAA;ACjbJ;ADmbI;EACE,mBAAA;ACjbN;ADobI;EACE,eAAA;AClbN;ADsbE;EACE,gBAAA;ACpbJ;ADubE;EACE,cAAA;EACA,YAAA;EACA,WAAA;ACrbJ;ADwbE;EACE,sBAAA;EACA,+BAAA;EACA,gCAAA;EACA,aAAA;EACA,sBAAA;EACA,YAAA;ACtbJ;ADybE;EACE,yBAAA;EACA,cAAA;EACA,aAAA;EACA,eAAA;EACA,uBAAA;EACA,cAAA;ACvbJ;AD0bE;EACE,gBAAA;ACxbJ;AD2bE;EACE,yBAAA;ACzbJ;AD4bE;EACE,iBAAA;AC1bJ;AD6bE;EACE,aAAA;EACA,sBAAA;EACA,YAAA;EACA,aAAA;EACA,yBAAA;EACA,kBAAA;EACA,wCAAA;EACA,wBAAA;EACA,qBAAA;AC3bJ;AD6bI;EACE,aAAA;EACA,mBAAA;AC3bN;AD+bE;EACE,sBAAA;EACA,aAAA;EACA,wBAAA;EACA,SAAA;EACA,kBAAA;EACA,4BAAA;EACA,UAAA;EACA,kBAAA;EACA,wCAAA;EACA,wBAAA;EACA,qBAAA;AC7bJ;AD+bI;EACE,aAAA;AC7bN;ADgcI;EACE,wBAAA;EACA,qCAAA;EACA,oBAAA;AC9bN;ADkcE;EACE,cAAA;EACA,eAAA;EACA,eAAA;EACA,mBAAA;EACA,kBAAA;EACA,gBAAA;AChcJ;ADmcE;EACE,cAAA;EACA,iBAAA;EACA,yBAAA;EACA,gBAAA;EACA,qBAAA;EACA,qBAAA;EACA,aAAA;EACA,sBAAA;ACjcJ;ADqcI;EACE,4BAAA;EACA,6BAAA;ACncN;ADscI;EACE,aAAA;ACpcN;ADucQ;EACE,gBAAA;ACrcV;ADwcQ;EACE,gBAAA;EACA,iBAAA;ACtcV;AD2cI;EACE,oBAAA;EACA,mBAAA;ACzcN;AD4cI;EACE,kBAAA;EACA,eAAA;AC1cN;;ACt6DA;EACE,eAAA;EACA,YAAA;EACA,WAAA;EACA,yBAAA;EACA,WAAA;EACA,kBAAA;EACA,mBAAA;EACA,eAAA;EACA,aAAA;ADy6DF;ACv6DE;EACE,aAAA;ADy6DJ;;ACr6DA;EACE,2BAAA;EACA,mBAAA;EACA,eAAA;EACA,YAAA;EACA,WAAA;EACA,UAAA;EACA,WAAA;EACA,iBAAA;EACA,mBAAA;EACA,sBAAA;EACA,aAAA;EACA,sBAAA;EACA,uCAAA;EACA,aAAA;ADw6DF;ACt6DE;EACE,aAAA;ADw6DJ;;ACp6DA;EACE,kCAAA;EACA,WAAA;ADu6DF;;ACp6DA;EACE,qBAAA;EACA,WAAA;ADu6DF;;ACp6DA;EACE,aAAA;ADu6DF;;ACn6DA;EACE;IACE,aAAA;EDs6DF;ECp6DA;IACE,uBAAA;IACA,sBAAA;IACA,qBAAA;IACA,mCAAA;IACA,sCAAA;IACA,8BAAA;EDs6DF;ECp6DE;IACE,mCAAA;IACA,sCAAA;EDs6DJ;ECn6DE;IACE,mCAAA;IACA,sCAAA;EDq6DJ;ECj6DA;IACE,sBAAA;EDm6DF;ECj6DE;IACE,sBAAA;EDm6DJ;ECh6DE;IACE,sBAAA;EDk6DJ;AACF;AC75DA;EACE;IACE,aAAA;ED+5DF;EC75DA;IACE,kCAAA;IACA,2BAAA;ED+5DF;EC75DE;IACE,kCAAA;ED+5DJ;EC55DE;IACE,kCAAA;ED85DJ;EC15DA;IACE,sBAAA;ED45DF;EC15DE;IACE,sBAAA;ED45DJ;ECz5DE;IACE,sBAAA;ED25DJ;AACF;ACr5DA;EACE,gBAAA;EACA,yBAAA;EACA,WAAA;EACA,aAAA;EACA,kBAAA;EACA,kBAAA;EACA,eAAA;EACA,6BAAA;EACA,4BAAA;EACA,iBAAA;ADu5DF;;ACp5DA;EACE,aAAA;EACA,sBAAA;EACA,OAAA;EACA,aAAA;EACA,gBAAA;ADu5DF;;ACp5DA;EACE,mBAAA;EACA,aAAA;EACA,sBAAA;EACA,qBAAA;ADu5DF;;ACp5DA;EACE,aAAA;EACA,mBAAA;ADu5DF;;ACp5DA;EACE,kBAAA;EACA,iBAAA;EACA,cAAA;ADu5DF;;ACp5DA;EACE,WAAA;EACA,YAAA;EACA,kBAAA;EACA,iBAAA;ADu5DF;;ACp5DA;EACE,aAAA;EACA,iBAAA;EACA,cAAA;EACA,oBAAA;EACA,yBAAA;EACA,iBAAA;EACA,kBAAA;ADu5DF;;ACp5DA;EACE,sBAAA;EACA,yBAAA;EACA,iBAAA;EACA,kBAAA;EACA,cAAA;ADu5DF;;ACp5DA;EACE,oBAAA;EACA,eAAA;ADu5DF;;ACp5DA;EACE,aAAA;EACA,qBAAA,EAAA,oCAAA;EACA,YAAA;ADu5DF;ACr5DE;EACE,aAAA;ADu5DJ;;ACn5DA;EACE,wBAAA;ADs5DF;;ACn5DA;EACE,2BAAA;EACA,mBAAA;EACA,aAAA;EACA,iBAAA,EAAA,wCAAA;EACA,sBAAA,EAAA,6CAAA;EACA,sBAAA;EACA,YAAA;EACA,gBAAA;EACA,gBAAA;EACA,iBAAA,EAAA,iDAAA;EACA,iBAAA;EACA,oBAAA,EAAA,2BAAA;EACA,kBAAA,EAAA,gCAAA;EACA,sBAAA;ADs5DF;ACp5DE;EACE,sBAAA;ADs5DJ;ACn5DE;EACE,sBAAA;ADq5DJ;;ACj5DA;EACE,oBAAA,EAAA,mCAAA;EACA,kBAAA;EACA,uBAAA;EACA,YAAA;EACA,eAAA;EACA,iBAAA;EACA,kBAAA;ADo5DF;;ACj5DA;EACE,gBAAA;EACA,cAAA;ADo5DF;;ACj5DA;EACE,aAAA;EACA,mBAAA;EACA,uBAAA;EACA,aAAA;EACA,eAAA;EACA,WAAA;EACA,aAAA;ADo5DF;;ACh5DE;EACE,0BAAA;EACA,mBAAA;EACA,oBAAA;EACA,wBAAA;ADm5DJ;ACh5DE;EACE,2BAAA;EACA,6BAAA;ADk5DJ;AC/4DE;EACE,4BAAA;ADi5DJ;AC94DE;EACE,mBAAA;EACA,yBAAA;EACA,oCAAA;EACA,kBAAA;EACA,aAAA;EACA,eAAA;EACA,gBAAA;EACA,YAAA;EACA,uBAAA;EACA,gBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,yBChNiB;EDiNjB,WCjRO;AFiqEX;AC54DE;EACE,sBAAA;EACA,4BAAA;EACA,uBAAA;EACA,kCAAA;EACA,2BAAA;EACA,0BAAA;EACA,0BAAA;EACA,sBAAA;EACA,4CAAA;AD84DJ;;ACz4DA,yBAAA;AACA;EACE,aAAA;EACA,eAAA;EACA,SAAA;AD44DF;;ACz4DA,kCAAA;AACA;EACE,YAAA;EACA,aAAA;EACA,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,yBAAA;EACA,kBAAA;EACA,kBAAA;EACA,gBAAA;AD44DF;;ACz4DA,oBAAA;AACA;EACE,wBAAA;EACA,yBAAA,EAAA,eAAA;EACA,6BAAA,EAAA,SAAA;EACA,kBAAA;EACA,WAAA;EACA,YAAA;EACA,kCAAA;EACA,YAAA;AD44DF;;ACz4DA,0BAAA;AACA;EACE;IACE,uBAAA;ED44DF;EC14DA;IACE,yBAAA;ED44DF;AACF;ACz4DA,oBAAA;AACA;EACE,WAAA;EACA,YAAA;EACA,iBAAA;EACA,kBAAA;EACA,eAAA;AD24DF;;ACx4DA;EACE,kBAAA;EACA,cAAA;AD24DF;;ACx4DA;EACE,iBAAA;EACA,eAAA;AD24DF;;ACx4DA;EACE,6BAAA;AD24DF;;ACx4DA;EACE,eAAA;EACA,aAAA;EACA,uBAAA;EACA,+BAAA;EACA,kBAAA;EACA,eAAA;EACA,wBAAA;AD24DF;ACz4DE;EACE,kCAAA;AD24DJ;;ACv4DA;EACE,aAAA;EACA,mBAAA;EACA,iBAAA;EACA,6BAAA;EACA,8BAAA;AD04DF;ACx4DE;EACE,aAAA;EACA,mBAAA;AD04DJ;ACx4DI;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;AD04DN;ACx4DM;EACE,WAAA;EACA,YAAA;EACA,kBAAA;EACA,iBAAA;EACA,gBAAA;AD04DR;ACt4DI;EACE,iBAAA;ADw4DN;ACt4DM;EACE,gBAAA;ADw4DR;ACr4DM;EACE,eAAA;ADu4DR;ACn4DI;EACE,kBAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,kBAAA;EACA,uBAAA;EACA,sBAAA;ADq4DN;ACj4DE;EACE,aAAA;EACA,mBAAA;ADm4DJ;ACj4DI;EACE,uBAAA;EACA,YAAA;EACA,YAAA;EACA,eAAA;EACA,aAAA;EACA,mBAAA;EACA,uBAAA;EACA,kBAAA;EACA,iCAAA;ADm4DN;ACj4DM;EACE,qCAAA;ADm4DR;AC/3DI;EACE,kBAAA;ADi4DN;AC/3DM;EACE,kBAAA;EACA,SAAA;EACA,QAAA;EACA,gBAAA;EACA,kBAAA;EACA,yCAAA;EACA,gBAAA;EACA,aAAA;EACA,eAAA;ADi4DR;AC/3DQ;EACE,aAAA;ADi4DV;AC93DQ;EACE,WAAA;EACA,6BAAA;EACA,YAAA;EACA,iBAAA;EACA,gBAAA;EACA,eAAA;EACA,WAAA;EACA,eAAA;ADg4DV;AC93DU;EACE,qCAAA;ADg4DZ;;ACx3DA;EACE,wBAAA;AD23DF;;AGr2EA;EACE,6CAAA;EACA,8CAAA;AHw2EF;;AGp2EA;EACE,yCAAA;EACA,sBAAA;AHu2EF;;AI52EI;EACE,8BAAA;EACA,0BAAA;AJ+2EN;AI52EI;EACE,8BAAA;EACA,0BAAA;AJ82EN;AI12EE;EACE,kBAAA;EACA,uDAAA;AJ42EJ;AIz2EE;EACE,eAAA;EACA,6BAAA;EACA,4BAAA;AJ22EJ;AIx2EE;EACE;IACE,6BAAA;IACA,4BAAA;EJ02EJ;EIv2EE;IACE,cAAA;EJy2EJ;AACF;AIt2EE;EACE;IACE,6BAAA;IACA,4BAAA;EJw2EJ;AACF;AIj2EE;EACE,kCAAA;EACA,4BAAA;EACA,8BAAA;AJm2EJ;;AI/1EA;EACE;IACE,wBAAA;EJk2EF;EI/1EA;IACE,uBAAA;IACA,6BAAA;EJi2EF;AACF;AK/5EA,2CAAA;AACA;EACE,eAAA;EACA,MAAA;EACA,OAAA;EACA,YAAA;EACA,aAAA;EACA,oCAAA;EACA,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,aAAA;EACA,gBAAA,EAAA,0CAAA;ALi6EF;;AK95EA,sCAAA;AACA;EACE,kBAAA;EACA,sBAAA;EACA,aAAA;EACA,mBAAA;EACA,eAAA,EAAA,mCAAA;EACA,gBAAA,EAAA,oCAAA;EACA,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,2CAAA;EACA,gBAAA;ALi6EF;;AK95EA,qCAAA;AACA;EACE,WAAA;EACA,YAAA;EACA,eAAA,EAAA,oDAAA;EACA,gBAAA,EAAA,qDAAA;EACA,mBAAA,EAAA,0CAAA;EACA,kBAAA;EACA,cAAA;ALi6EF;;AK95EA,+BAAA;AACA;EACE,kBAAA;EACA,SAAA;EACA,WAAA;EACA,6BAAA;EACA,YAAA;EACA,iBAAA;EACA,eAAA;EACA,WAAA;ALi6EF;;AK95EA;EACE,aAAA;EACA,kBAAA;EACA,mBAAA;ALi6EF\",\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMF0udXNlWzJdIS4vc3JjL3N0eWxlLnNjc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUuc2Nzcz9iMTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5vdXRsaW5lLWJ1dHRvbiB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGNvbG9yOiAjZjQ0ZTZjO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmb250LXNpemU6IDE2cHg7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgbGluZS1oZWlnaHQ6IDIycHg7XG4gIG1hcmdpbjogNHB4IDA7XG4gIHBhZGRpbmc6IDEwcHggMTJweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYnV0dG9uLm91dGxpbmUtYnV0dG9uIHAge1xuICBtYXJnaW46IDA7XG4gIG1heC13aWR0aDogMjUwcHg7XG4gIHRleHQtYWxpZ246IHN0YXJ0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24ub3V0bGluZS1idXR0b24gc3ZnIHtcbiAgaGVpZ2h0OiAyMHB4O1xuICB3aWR0aDogMjBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYnV0dG9uLk9yZGVyTG9va3VwX19jYW5jZWxWMiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24uT3JkZXJMb29rdXBfX2xvb2t1cEJ0biB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMyYzZlY2I7XG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGNvbG9yOiAjMmM2ZWNiO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtc2hyaW5rOiAwO1xuICBtYXJnaW46IDEycHggMTZweCAwIGF1dG87XG4gIG1heC13aWR0aDogMjc0cHg7XG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHBhZGRpbmc6IDhweCAxMnB4O1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCAuT3JkZXJMb29rdXBfX2ZpbmRPcmRlciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBtYXJnaW46IDE2cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIC5PcmRlckxvb2t1cF9fYnV0dG9uIHtcbiAgbWFyZ2luOiAwIDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIC5PcmRlckxvb2t1cF9fYnV0dG9uOm50aC1vZi10eXBlKDIpIHtcbiAgbWFyZ2luLXRvcDogOHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCAuT3JkZXJMb29rdXBfX2J1dHRvbjpsYXN0LW9mLXR5cGUge1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5PcmRlckxvb2t1cF9fZmluZCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gIGNvbG9yOiAjMmM2ZWNiO1xuICBwYWRkaW5nOiAxNnB4IDA7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5PcmRlckxvb2t1cF9fZmluZDpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMxZjUxOTk7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5PcmRlckxvb2t1cF9fZmluZC0taXMtbW9iaWxlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJjNmVjYjtcbiAgY29sb3I6IHZhcigjMDAwMDAwKTtcbiAgcGFkZGluZy1ib3R0b206IDIycHg7XG4gIHBhZGRpbmctdG9wOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXZpZXcgYnV0dG9uLk9yZGVyTG9va3VwX19maW5kLS1pcy1tb2JpbGUge1xuICBwYWRkaW5nLWJvdHRvbTogMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIge1xuICBtYXJnaW46IC01NnB4IDAgMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIuY29tcG9zZXItYmFyLWludGVyc3RpdGlhbFZpZXcgLmNvbXBvc2VyLWJhci1mb3JtIHtcbiAgcGFkZGluZy1ib3R0b206IDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyLmNvbXBvc2VyLWJhci1pbnRlcnN0aXRpYWxWaWV3IC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX193YXJuaW5nLWxpbWl0IHtcbiAgYm90dG9tOiAyNHB4O1xuICBtYXJnaW4tYm90dG9tOiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyLmNvbXBvc2VyLWJhci1pbnRlcnN0aXRpYWxWaWV3IC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19ib3gge1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jb21wb3Nlci1iYXItd3JhcHBlci5jb21wb3Nlci1iYXItbWVkaWEtZGlzYWJsZWQgLmNvbXBvc2VyLWJhci1mb3JtIC5jb21wb3Nlci1iYXJfX2JveCB7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWFyZ2luOiAwIDEycHggNHB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19mb290ZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgbWFyZ2luLXRvcDogMTZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIgLmNvbXBvc2VyLWJhci1mb3JtIC5jb21wb3Nlci1iYXJfX2JveCB7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNkMmQ1ZDk7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgYm94LXNoYWRvdzogbm9uZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWluLWhlaWdodDogNDRweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIgLmNvbXBvc2VyLWJhci1mb3JtIC5jb21wb3Nlci1iYXJfX2JveDpmb2N1cy13aXRoaW4ge1xuICBib3JkZXItY29sb3I6ICM0MjQ3NGM7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSB0ZXh0YXJlYSB7XG4gIGJvcmRlcjogMDtcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xuICBjb2xvcjogIzRiNTE1ODtcbiAgZmxleC1ncm93OiAxO1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgb3V0bGluZTogbm9uZTtcbiAgb3ZlcmZsb3c6IGhpZGRlbiBhdXRvO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBwYWRkaW5nOiAxMnB4O1xuICByZXNpemU6IG5vbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSB0ZXh0YXJlYS5yZWFjaGVkLWxpbWl0IHtcbiAgbWFyZ2luLWJvdHRvbTogMjRweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIgLmNvbXBvc2VyLWJhci1mb3JtIHRleHRhcmVhOjpwbGFjZWhvbGRlciB7XG4gIGNvbG9yOiAjYTBhNGE5O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jb21wb3Nlci1iYXItd3JhcHBlciAuY29tcG9zZXItYmFyLWZvcm0gLmNvbXBvc2VyLWJhcl9fdXBsb2FkIHtcbiAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gIG1hcmdpbi1ib3R0b206IDEycHg7XG4gIHBhZGRpbmc6IDAgMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIgLmNvbXBvc2VyLWJhci1mb3JtIC5jb21wb3Nlci1iYXJfX2ltYWdlLWNvbnRhaW5lciB7XG4gIHBhZGRpbmc6IDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19mb290ZXItYnV0dG9uIHtcbiAgYWxpZ24tc2VsZjogY2VudGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBwYWRkaW5nOiAwIDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19mb290ZXItYnV0dG9uOmRpc2FibGVkIHN2ZyB7XG4gIGZpbGw6ICNjZGNkY2Y7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19mb290ZXItYnV0dG9uLm11bHRpcGxlLWxpbmVzIHtcbiAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gIG1hcmdpbi1ib3R0b206IDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhci13cmFwcGVyIC5jb21wb3Nlci1iYXItZm9ybSAuY29tcG9zZXItYmFyX19mb290ZXItYnV0dG9uIHN2ZyB7XG4gIHN0cm9rZTogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY29tcG9zZXItYmFyLXdyYXBwZXIgLmNvbXBvc2VyLWJhci1mb3JtLmZvcm0tbXVsdGlwbGUtbGluZXMgLmNvbXBvc2VyLWJhcl9fZm9vdGVyLWJ1dHRvbiB7XG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICBtYXJnaW4tYm90dG9tOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jb21wb3Nlci1iYXItd3JhcHBlciAuY29tcG9zZXItYmFyLWZvcm0gLmNvbXBvc2VyLWJhcl9fd2FybmluZy1saW1pdCB7XG4gIGNvbG9yOiAjNmQ3MTc1O1xuICBmb250LXNpemU6IDEzcHg7XG4gIG1hcmdpbjogLTE2cHggMTJweCA4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLk9yZGVyTG9va3VwX19idXR0b24gKyAuY29tcG9zZXItYmFyLXdyYXBwZXIge1xuICBtYXJnaW4tdG9wOiA0cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNvbXBvc2VyLWJhcl9fZm9vdGVyLW1lc3NhZ2Uge1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBkaXNwbGF5OiBmbGV4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jb21wb3Nlci1iYXJfX2Zvb3Rlci1tZXNzYWdlIC5sb2FkaW5nLXVpX19zcGlubmVyIHtcbiAgYm9yZGVyOiAycHggc29saWQgI2YzZjNmMztcbiAgYm9yZGVyLXRvcC1jb2xvcjogIzAwMDtcbiAgaGVpZ2h0OiAxNXB4O1xuICBtYXJnaW46IDA7XG4gIHdpZHRoOiAxNXB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jb21wb3Nlci1iYXJfX2Zvb3Rlci1tZXNzYWdlIC5jb21wb3Nlci1iYXJfX2Zvb3Rlci1tZXNzYWdlX191cGRhdGluZy10ZXh0IHtcbiAgbWFyZ2luLWxlZnQ6IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuc2lnblVwLWJ1dHRvbiB7XG4gIG1hcmdpbjogMCAxMnB4IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYnV0dG9uLm91dGxpbmUtYnV0dG9uLmNlbnRlci10ZXh0IHtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmxvYWRpbmctbWVzc2FnZSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBhZGRpbmc6IDVweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5sb2FkaW5nLWNpcmNsZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1YzVmNjI7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgaGVpZ2h0OiA2cHg7XG4gIHdpZHRoOiA2cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmxvYWRpbmctY2lyY2xlLm9uZSB7XG4gIGFuaW1hdGlvbjogcHVsc2VBbmltYXRpb25PbmUgMXMgaW5maW5pdGU7XG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xuICBtYXJnaW4tcmlnaHQ6IDJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubG9hZGluZy1jaXJjbGUudHdvIHtcbiAgYW5pbWF0aW9uOiBwdWxzZUFuaW1hdGlvblR3byAxcyBpbmZpbml0ZTtcbiAgbWFyZ2luLWxlZnQ6IDJweDtcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmxvYWRpbmctY2lyY2xlLnRocmVlIHtcbiAgYW5pbWF0aW9uOiBwdWxzZUFuaW1hdGlvblRocmVlIDFzIGluZmluaXRlO1xuICBtYXJnaW4tbGVmdDogMnB4O1xuICBtYXJnaW4tcmlnaHQ6IDE0cHg7XG59XG5Aa2V5ZnJhbWVzIHB1bHNlQW5pbWF0aW9uT25lIHtcbiAgMCUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM4YzkxOTY7XG4gIH1cbiAgMjUlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWM1ZjYyO1xuICB9XG4gIDUwJSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzhjOTE5NjtcbiAgfVxuICB0byB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzhjOTE5NjtcbiAgfVxufVxuQGtleWZyYW1lcyBwdWxzZUFuaW1hdGlvblR3byB7XG4gIDAlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGM5MTk2O1xuICB9XG4gIDI1JSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzhjOTE5NjtcbiAgfVxuICA1MCUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1YzVmNjI7XG4gIH1cbiAgdG8ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM4YzkxOTY7XG4gIH1cbn1cbkBrZXlmcmFtZXMgcHVsc2VBbmltYXRpb25UaHJlZSB7XG4gIDAlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGM5MTk2O1xuICB9XG4gIDI1JSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzhjOTE5NjtcbiAgfVxuICA1MCUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM4YzkxOTY7XG4gIH1cbiAgdG8ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1YzVmNjI7XG4gIH1cbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubG9hZGluZy11aSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBtYXJnaW46IGF1dG87XG4gIG1pbi1oZWlnaHQ6IDI2NXB4O1xuICBzY3JvbGxiYXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZTtcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5sb2FkaW5nLXVpOjotd2Via2l0LXNjcm9sbGJhciB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmxvYWRpbmctdWlfX3NwaW5uZXIge1xuICBhbmltYXRpb246IHNob3BpZnktY2hhdC1zcGluIDAuNnMgbGluZWFyIGluZmluaXRlO1xuICBib3JkZXI6IDZweCBzb2xpZCAjZjNmM2YzO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIGJvcmRlci10b3AtY29sb3I6ICMwMDg5ZDM7XG4gIGhlaWdodDogMzBweDtcbiAgbWFyZ2luOiBhdXRvO1xuICB3aWR0aDogMzBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXJfX2luZm8ge1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4OiAxO1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyX19pbmZvIGJ1dHRvbiB7XG4gIGxlZnQ6IDJweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlcl9faW5mbyBidXR0b246Zm9jdXMsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXJfX2luZm8gYnV0dG9uOmhvdmVyIHtcbiAgZmlsdGVyOiBicmlnaHRuZXNzKDkwJSk7XG4gIG9wYWNpdHk6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyX19pbmZvIHN2ZyB7XG4gIGhlaWdodDogMTRweDtcbiAgd2lkdGg6IDE5cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyLS1pcy1tb2JpbGUgLmNoYXQtaGVhZGVyX19pbmZvIGJ1dHRvbiB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdG9wOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlcl9fdGV4dCB7XG4gIGZsZXg6IDE7XG4gIHBhZGRpbmc6IDhweCAyOHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlcl9fdGl0bGUge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICBmbGV4OiAxO1xuICBmb250LXNpemU6IDE4cHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICBtYXJnaW46IDA7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgLXdlYmtpdC1saW5lLWNsYW1wOiAyO1xuICBsaW5lLWNsYW1wOiAyO1xuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xuICBib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCBzcGFuIHtcbiAgbWFyZ2luLWxlZnQ6IDAgIWltcG9ydGFudDtcbiAgbWFyZ2luLXJpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tcHJpbWFyeSB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBmb250LXdlaWdodDogNjAwO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbiAgcGFkZGluZzogMTZweDtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tcHJpbWFyeTpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMzNTM1MzU7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tcHJpbWFyeTpkaXNhYmxlZCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7XG4gIGNvbG9yOiAjOGM5MTk2O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXByaW1hcnk6bm90KDpkaXNhYmxlZCkge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWExYTFhO1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zcyBlYXNlLWluLW91dDtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXNlY29uZGFyeSB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmNmY2Zjc7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgY29sb3I6ICMxYTFhMWE7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG4gIHdpZHRoOiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXNlY29uZGFyeTpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlN2U3ZTc7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tc2Vjb25kYXJ5LnByb2R1Y3QtYWRkZWQtY2FydCB7XG4gIGNvbG9yOiAjMDA4MDYwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXNlY29uZGFyeS5wcm9kdWN0LWFkZGVkLWNhcnQgc3ZnIHtcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tY2FuY2VsIHtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBmb250LXdlaWdodDogNDAwO1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkIC5wcm9kdWN0LWNhcmQtYWN0aW9uLWJhcl9fYnV0dG9uLS1zZWxlY3RlZC12YXJpYW50LWNvbnRhaW5lciB7XG4gIGFsaWduLWl0ZW1zOiBzdGFydDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBzdGFydDtcbiAgbWFyZ2luLWJvdHRvbTogMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkIC5wcm9kdWN0LWNhcmQtYWN0aW9uLWJhcl9fYnV0dG9uLS1zZWxlY3RlZC12YXJpYW50IHtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBsaW5lLWhlaWdodDogMjFweDtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkIC5wcm9kdWN0LWNhcmQtYWN0aW9uLWJhcl9fYnV0dG9uLS1vdXQtb2Ytc3RvY2sge1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIHdpZHRoOiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLW91dC1vZi1zdG9jazpkaXNhYmxlZCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlYmVjZWY7XG4gIGNvbG9yOiAjODc5MDliO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXN0cm9rZSB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6IHVuc2V0O1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIHdpZHRoOiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19idXR0b24tLXN0cm9rZTpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMWYyZjQ7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tc3Ryb2tlOmRpc2FibGVkIHtcbiAgYm9yZGVyOiAxcHggc29saWQgI2QyZDVkODtcbiAgY29sb3I6ICM4YzkxOTY7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZCAucHJvZHVjdC1jYXJkLWFjdGlvbi1iYXJfX2J1dHRvbi0tc3Ryb2tlOm5vdCg6ZGlzYWJsZWQpIHtcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZTBlNDtcbiAgY29sb3I6ICMxYTFhMWE7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG4gIHRyYW5zaXRpb246IGJvcmRlci1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQtYWN0aW9uLWJhcl9faGVhZGVyIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgY29sb3I6ICMxYTFhMWE7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgbGluZS1oZWlnaHQ6IDIxcHg7XG4gIG1hcmdpbi1ib3R0b206IDEycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19oZWFkZXIgYnV0dG9uIHtcbiAgd2lkdGg6IGF1dG87XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZC1hY3Rpb24tYmFyX19oZWFkZXItLXRpdGxlIHtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBmb250LXdlaWdodDogNjAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQtYWN0aW9uLWJhcl9fZXJyb3Ige1xuICBjb2xvcjogI2Q3MmMwZDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkX19hY3Rpb24tYmFyLS1jb250YWluZXIge1xuICBwYWRkaW5nOiAxMnB4IDE2cHggMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkX19wcm9kdWN0LWRldGFpbHMge1xuICBhbGlnbi1pdGVtczogc3RhcnQ7XG4gIHBhZGRpbmc6IDE2cHggMTZweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzLS1uZXh0IC5wcm9kdWN0LWNhcmRfX3Byb2R1Y3QtZGV0YWlscyB7XG4gIHBhZGRpbmc6IDEycHggMTJweCAxNnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmRfX3Byb2R1Y3QtZGV0YWlscy10aXRsZSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkX19wcm9kdWN0LWRldGFpbHMtdGl0bGU6aG92ZXIge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkX19wcm9kdWN0LWRldGFpbHMtcHJpY2Uge1xuICBmb250LXNpemU6IDE0cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnByb2R1Y3QtY2FyZF9fcHJvZHVjdC1pbWFnZSB7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBoZWlnaHQ6IDEwMHB4O1xuICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuICBvYmplY3QtZml0OiBjb3ZlcjtcbiAgd2lkdGg6IDEwMHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5sb2FkaW5nLXVpIHtcbiAgcGFkZGluZzogMTZweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19saW5rIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdW5zZXQ7XG4gIGNvbG9yOiAjZmZmO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG92ZXJmbG93LXdyYXA6IGFueXdoZXJlO1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1idWJibGUtaW5jb21pbmcgLmNoYXQtbWVzc2FnZXNfX2xpbmsge1xuICBjb2xvcjogIzAwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1lcnJvciB7XG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICBjb2xvcjogI2Q3MmMwZDtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBmb250LXdlaWdodDogNDAwO1xuICBsaW5lLWhlaWdodDogMS43ZW07XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1lcnJvciAucmV0cnkge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1lcnJvciAucmV0cnk6aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtZXJyb3JfX3NwaW5uZXIge1xuICBhbmltYXRpb246IHNob3BpZnktY2hhdC1zcGluIDAuNnMgbGluZWFyIGluZmluaXRlO1xuICBib3JkZXI6IDJweCBzb2xpZCAjZjNmM2YzO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIGJvcmRlci10b3AtY29sb3I6ICMwMDg5ZDM7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgaGVpZ2h0OiAxMHB4O1xuICBtYXJnaW4tbGVmdDogOHB4O1xuICB3aWR0aDogMTBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZSAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0tcHJvZHVjdC1pbWFnZS1jb250YWluZXIge1xuICBmbG9hdDogbGVmdDtcbiAgcGFkZGluZzogMnB4IDEwcHggMCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1wcm9kdWN0LWltYWdlLWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS1wcm9kdWN0LWltYWdlIHtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgd2lkdGg6IDEwMHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5kaXNjb3VudC1jYXJkLWNvbnRhaW5lciB7XG4gIG1hcmdpbjogMTZweCAxNnB4IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuZGlzY291bnQtY2FyZF9fZGlzY291bnQtZGV0YWlscy10aXRsZSB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmRpc2NvdW50LWNhcmQtaW5mbyB7XG4gIGNvbG9yOiAjNjE2YTc1O1xuICBmb250LXNpemU6IDE0cHg7XG4gIHBhZGRpbmctdG9wOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5kaXNjb3VudC1jYXJkIC5kaXNjb3VudC1jYXJkX19idXR0b24tLXByaW1hcnksIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuZGlzY291bnQtY2FyZF9fbG9hZGluZy1zcGlubmVyLWNvbnRhaW5lciB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5kaXNjb3VudC1jYXJkIC5kaXNjb3VudC1jYXJkX19idXR0b24tLXByaW1hcnkge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoIzZhNmE2YSk7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBmb250LXdlaWdodDogNjAwO1xuICBoZWlnaHQ6IDQ0cHg7XG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICBtYXJnaW4tdG9wOiAxMnB4O1xuICBwYWRkaW5nOiAxNnB4O1xuICB3aWR0aDogMTAwJTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuZGlzY291bnQtY2FyZCAuZGlzY291bnQtY2FyZF9fYnV0dG9uLS1wcmltYXJ5OmhvdmVyIHtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZS1pbi1vdXQ7XG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zcyBlYXNlLWluLW91dDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuZGlzY291bnQtY2FyZCAuZGlzY291bnQtY2FyZF9fYnV0dG9uLS1wcmltYXJ5OmRpc2FibGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YxZjFmMTtcbiAgY29sb3I6ICM4YzkxOTY7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmRpc2NvdW50LWNhcmQgLmRpc2NvdW50LWNhcmRfX2J1dHRvbi0tcHJpbWFyeTpub3QoOmRpc2FibGVkKSB7XG4gIGNvbG9yOiAjZmZmO1xuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zcyBlYXNlLWluLW91dDtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2UtaW4tb3V0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdHRhY2htZW50LWltYWdlIHtcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMTJweDtcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDEycHg7XG4gIG1heC1oZWlnaHQ6IDQ4MHB4O1xuICBtYXgtd2lkdGg6IDI0MHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdHRhY2htZW50LWltYWdlX19sb2FkaW5nIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgZGlzcGxheTogZmxleDtcbiAgcGFkZGluZzogOHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdHRhY2htZW50LWltYWdlX19sb2FkaW5nIC5hdHRhY2htZW50LWltYWdlX19sb2FkaW5nX19zcGlubmVyIHtcbiAgYm9yZGVyOiAycHggc29saWQgI2YzZjNmMztcbiAgYm9yZGVyLXRvcC1jb2xvcjogIzAwMDtcbiAgaGVpZ2h0OiAxNXB4O1xuICB3aWR0aDogMTVweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXR0YWNobWVudC12aWRlbyB7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDEycHg7XG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxMnB4O1xuICBtYXgtaGVpZ2h0OiA0ODBweDtcbiAgbWF4LXdpZHRoOiAyNDBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXR0YWNobWVudC12aWRlb19fbG9hZGluZyB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1hcmdpbjogMTRweDtcbiAgcGFkZGluZzogNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdHRhY2htZW50LXZpZGVvX19sb2FkaW5nIC5hdHRhY2htZW50LXZpZGVvX19sb2FkaW5nX19zcGlubmVyIHtcbiAgYm9yZGVyOiAycHggc29saWQgI2YzZjNmMztcbiAgYm9yZGVyLXRvcC1jb2xvcjogIzAwMDtcbiAgaGVpZ2h0OiAxNXB4O1xuICB3aWR0aDogMTVweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXR0YWNobWVudC12aWRlb19fbG9hZGluZyAuYXR0YWNobWVudC12aWRlb19fbG9hZGluZ19fcHJvY2Vzc2luZy10ZXh0IHtcbiAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmRhdGUtaGVhZGVyIHtcbiAgY29sb3I6ICM2ZDcxNzU7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbiAgbWFyZ2luLXRvcDogMjBweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdmF0YXIge1xuICBjb2xvcjogIzZlNzE3NTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF2YXRhci1jdXN0b20ge1xuICBjb2xvcjogIzZlNzE3NTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF2YXRhci1jdXN0b20gc3ZnIHBhdGg6bnRoLWNoaWxkKDIpIHtcbiAgZmlsbDogdmFyKCMwMDAwMDApO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdmF0YXJQcm9maWxlIHtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBoZWlnaHQ6IDI0cHg7XG4gIHdpZHRoOiAyNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdmF0YXJPbmUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzUzMGM1O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5hdmF0YXJPbmUgLnAge1xuICBjb2xvcjogIzM4MDczODtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXZhdGFyVHdvIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzM4ZmFhMztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXZhdGFyVHdvIC5wIHtcbiAgY29sb3I6ICMwYzUxMzI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF2YXRhclRocmVlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJjZTBkNDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXZhdGFyVGhyZWUgLnAge1xuICBjb2xvcjogIzAzM2MzOTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXZhdGFyRm91ciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1MWMwZmY7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF2YXRhckZvdXIgLnAge1xuICBjb2xvcjogIzAwMjEzMztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYXZhdGFyRml2ZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZDRiOTI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF2YXRhckZpdmUgLnAge1xuICBjb2xvcjogIzRkMGIyNTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1idWJibGUge1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xuICBwYWRkaW5nOiAxMHB4IDAgOHB4O1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgbWF4LXdpZHRoOiAzMDBweDtcbiAgdGV4dC1hbGlnbjogc3RhcnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtYnViYmxlOmxhc3Qtb2YtdHlwZTpub3QoLnVwZGF0ZWQpIHtcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjVzO1xuICBhbmltYXRpb24tbmFtZTogc2hvcGlmeS1jaGF0LWZhZGUtaW47XG4gIG1hcmdpbi1ib3R0b206IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtYnViYmxlIHNwYW4ge1xuICBkaXNwbGF5OiBibG9jaztcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7XG4gIG1hcmdpbi1yaWdodDogMTZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1idWJibGUtaW5jb21pbmcge1xuICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlZWYxO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS1pbmNvbWluZy5kaXNhYmxlZC10ZXh0IHtcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1idWJibGUtb3V0Z29pbmcge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2EwYTBhMDtcbiAgY29sb3I6IHZhcigjMDAwMDAwKTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1idWJibGUtb3V0Z29pbmcuZGlzYWJsZWQtdGV4dCB7XG4gIGNvbG9yOiBoc2xhKDAsIDAlLCAxMDAlLCAwLjYpO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS5hdHRhY2htZW50IHtcbiAgYm9yZGVyOiBub25lO1xuICBwYWRkaW5nOiAwIDAgOHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS5hdHRhY2htZW50IC5jaGF0LW1lc3NhZ2VfX2Vycm9yIHtcbiAgbWFyZ2luOiAxMnB4IDE0cHggMDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS5hdHRhY2htZW50IC50aW1lc3RhbXAge1xuICBtYXJnaW46IDJweCAxNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS5hdHRhY2htZW50LmRpc2FibGVkLXRleHQge1xuICBvcGFjaXR5OiAwLjU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtYnViYmxlLnByb2R1Y3QtY2FyZCB7XG4gIGZsZXgtZ3JvdzogMTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWJ1YmJsZS5kaXNjb3VudC1jYXJkLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtYnViYmxlLnByb2R1Y3QtY2FyZCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZGUwZTQ7XG4gIHBhZGRpbmc6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtY29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgbWF4LXdpZHRoOiA4MCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLm1lc3NhZ2UtY29udGFpbmVyLWluY29taW5nIHtcbiAgYWxpZ24taXRlbXM6IGVuZDtcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgZ2FwOiA4cHg7XG4gIG1hcmdpbjogMTJweCBhdXRvIDAgMTJweDtcbiAgbWF4LXdpZHRoOiAyNzJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1jb250YWluZXItb3V0Z29pbmcge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWFyZ2luOiAxMnB4IDEycHggMCBhdXRvO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWNvbnRhaW5lci1vdXRnb2luZyArIC5tZXNzYWdlLWNvbnRhaW5lci1vdXRnb2luZyB7XG4gIG1hcmdpbi10b3A6IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1jb250YWluZXIuZGlzY291bnQtY2FyZCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLWNvbnRhaW5lci5wcm9kdWN0LWNhcmQge1xuICBhbGlnbi1zZWxmOiBhdXRvO1xuICBtYXJnaW4tcmlnaHQ6IDEycHg7XG4gIG1heC13aWR0aDogODAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC50aW1lc3RhbXAge1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICBmb250LXNpemU6IDE0cHg7XG4gIGxpbmUtaGVpZ2h0OiAyMnB4O1xuICBtYXJnaW46IDRweCAxNnB4IDA7XG4gIG9wYWNpdHk6IDAuODU7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnRpbWVzdGFtcC50ZWFtIHtcbiAgY29sb3I6ICM2ZDcxNzU7XG4gIG9wYWNpdHk6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmRpc2NvdW50LWNhcmQgLnRpbWVzdGFtcCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5wcm9kdWN0LWNhcmQgLnRpbWVzdGFtcCB7XG4gIHBhZGRpbmctYm90dG9tOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5tZXNzYWdlLXByb21wdCB7XG4gIGNvbG9yOiAjNmQ3MTc1O1xuICBmb250LXNpemU6IDEzcHg7XG4gIGxpbmUtaGVpZ2h0OiAxN3B4O1xuICBtYXJnaW46IDE2cHggMCA0cHg7XG4gIHBhZGRpbmc6IDAgNDJweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWVzc2FnZXNfX29yZGVyLWxvb2t1cCB7XG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtYXgtd2lkdGg6IDI0MHB4O1xuICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkO1xuICBwYWRkaW5nOiAxMHB4IDAgOHB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICBmb250LXNpemU6IDE2cHg7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICB0ZXh0LWFsaWduOiBzdGFydDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZSBzcGFuLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWVzc2FnZXNfX29yZGVyLWxvb2t1cCBzcGFuIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xuICBtYXJnaW4tcmlnaHQ6IDE0cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWVzc2FnZXNfX21lc3NhZ2UuaXNJRTExLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWVzc2FnZXNfX29yZGVyLWxvb2t1cC5pc0lFMTEge1xuICBmbGV4OiAxIDAgYXV0byAhaW1wb3J0YW50O1xuICBmbGV4LWZsb3c6IGNvbHVtbiB3cmFwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1pbmNvbWluZy1tZXNzYWdlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZWVmMTtcbiAgbWFyZ2luOiAxMnB4IGF1dG8gMCA0MnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1pbmNvbWluZy1tZXNzYWdlICsgLl9fbWVzc2FnZS0taW5jb21pbmctbWVzc2FnZSB7XG4gIG1hcmdpbi10b3A6IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0taW5jb21pbmctbWVzc2FnZSArIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1vcmRlci1sb29rdXAge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBib3JkZXItY29sb3I6ICM0MTY4OGU7XG4gIGNvbG9yOiAjNDE2ODhlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWVzc2FnZXNfX21lc3NhZ2UtLWluY29taW5nLW1lc3NhZ2UgKyAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0taW5jb21pbmctbWVzc2FnZSB7XG4gIG1hcmdpbi10b3A6IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0taW5jb21pbmctbWVzc2FnZSArIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1vdXRnb2luZy1tZXNzYWdlIHtcbiAgbWFyZ2luLXRvcDogMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0taW5jb21pbmctbWVzc2FnZS0tbG9hZGluZyB7XG4gIG1hcmdpbjogMTJweCBhdXRvIDAgMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0tb3V0Z29pbmctbWVzc2FnZSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNTMsIDEyOCwgMjMwLCAwLjEzKTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlcy0tbmV4dCAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0tb3V0Z29pbmctbWVzc2FnZSB7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIG1hcmdpbjogMTJweCAxMnB4IDAgYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0tb3V0Z29pbmctbWVzc2FnZSB7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIG1hcmdpbjogMTJweCAxMnB4IDAgYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbWVzc2FnZS0tb3V0Z29pbmctbWVzc2FnZSArIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1vdXRnb2luZy1tZXNzYWdlIHtcbiAgbWFyZ2luLXRvcDogOHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19tZXNzYWdlLS1vdXRnb2luZy1tZXNzYWdlICsgLmNoYXQtbWVzc2FnZXNfX21lc3NhZ2UtLWluY29taW5nLW1lc3NhZ2Uge1xuICBtYXJnaW4tdG9wOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19zaG9wLW5hbWUge1xuICBmb250LXNpemU6IDE2cHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIG1hcmdpbi1ib3R0b206IDJweDtcbiAgbWFyZ2luLWxlZnQ6IDE0cHg7XG4gIG1hcmdpbi1yaWdodDogMTRweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucHJvZHVjdC1jYXJkIC5jaGF0LW1lc3NhZ2VzX19zaG9wLW5hbWUge1xuICBwYWRkaW5nOiA4cHggMTJweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZm9ybSAuY3VzdG9tZXItaW5mby1mb3JtX19pbnB1dCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm0gLmN1c3RvbWVyLWluZm8tZm9ybV9faW5wdXQsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuc2lnbi11cC1mb3JtIC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0IHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICBiYWNrZ3JvdW5kOiBub25lO1xuICBib3JkZXI6IDFweCBzb2xpZCAjZTRlNWU3O1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIHBhZGRpbmc6IDEycHg7XG4gIHdpZHRoOiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZm9ybSAuY3VzdG9tZXItaW5mby1mb3JtX19pbnB1dDpmb2N1cywgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm0gLmN1c3RvbWVyLWluZm8tZm9ybV9faW5wdXQ6Zm9jdXMsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuc2lnbi11cC1mb3JtIC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0OmZvY3VzIHtcbiAgYm9yZGVyOiAxcHggc29saWQgIzQyNDc0YztcbiAgb3V0bGluZTogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19zdWJ0ZXh0IHtcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBtYXJnaW4tdG9wOiA0cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9fc3VidGV4dCBidXR0b24ge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0LXdyYXBwZXIuY3VzdG9tZXItaW5mby1mb3JtX19lcnJvciBpbnB1dC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjRmNDtcbiAgYm9yZGVyOiAxLjVweCBzb2xpZCAjZmQ1NzQ5O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0LXdyYXBwZXIuY3VzdG9tZXItaW5mby1mb3JtX19lcnJvciAuY3VzdG9tZXItaW5mby1mb3JtX19zdWJ0ZXh0IHtcbiAgY29sb3I6ICNkNzJjMGQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9faW5wdXQtd3JhcHBlci5jdXN0b21lci1pbmZvLWZvcm1fX3dhcm5pbmcgaW5wdXQuY3VzdG9tZXItaW5mby1mb3JtX19pbnB1dCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY1ZWE7XG4gIGJvcmRlcjogMS41cHggc29saWQgI2I5ODkwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19pbnB1dC13cmFwcGVyLmN1c3RvbWVyLWluZm8tZm9ybV9fd2FybmluZyAuY3VzdG9tZXItaW5mby1mb3JtX19zdWJ0ZXh0IHtcbiAgY29sb3I6ICM5MTZhMDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmhvdmVyLWVmZmVjdC1idXR0b24ge1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmhvdmVyLWVmZmVjdC1idXR0b24gLmxhYmVsIHtcbiAgY29sb3I6IHZhcigjMDAwMDAwKTtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiAyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5ob3Zlci1lZmZlY3QtYnV0dG9uIC5iYWNrZ3JvdW5kIHtcbiAgYm90dG9tOiAwO1xuICBsZWZ0OiAwO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAwO1xuICB0b3A6IDA7XG4gIHotaW5kZXg6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmhvdmVyLWVmZmVjdC1idXR0b246ZGlzYWJsZWQge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlZWYxO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5ob3Zlci1lZmZlY3QtYnV0dG9uOmRpc2FibGVkIC5sYWJlbCB7XG4gIGNvbG9yOiAjOGM5MTk2O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5ob3Zlci1lZmZlY3QtYnV0dG9uOmZvY3VzOm5vdCg6ZGlzYWJsZWQpIC5iYWNrZ3JvdW5kLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmhvdmVyLWVmZmVjdC1idXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkgLmJhY2tncm91bmQge1xuICBmaWx0ZXI6IGJyaWdodG5lc3MoMC45KTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYnV0dG9uLmhvdmVyLWVmZmVjdC1idXR0b24ge1xuICBsaW5lLWhlaWdodDogMjJweDtcbiAgcGFkZGluZzogMTFweCAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbmZvLW1vZGFsX193cmFwcGVyIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgZGlzcGxheTogZmxleDtcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA2MHB4KTtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA1OXB4O1xuICB3aWR0aDogMzYwcHg7XG4gIHotaW5kZXg6IDI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmluZm8tbW9kYWxfX3dyYXBwZXIuaXMtbW9iaWxlIHtcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA2MHB4KTtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmluZm8tbW9kYWxfX3dyYXBwZXIuY2hlY2tvdXQtcGFnZSB7XG4gIGhlaWdodDogY2FsYygxMDAlIC0gNjBweCk7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmluZm8tbW9kYWxfX3dyYXBwZXIgLmluZm8tbW9kYWwge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBib3JkZXItcmFkaXVzOiAwIDAgMTJweCAxMnB4O1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG92ZXJmbG93LXk6IGF1dG87XG4gIHBhZGRpbmc6IDAgMTJweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMTAwJTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW5mby1tb2RhbF9fd3JhcHBlciAuaW5mby1tb2RhbCAuaW5mby1tb2RhbF9faGVhZGVyIHtcbiAgbWFyZ2luLWJvdHRvbTogMThweDtcbiAgbWFyZ2luLXRvcDogMDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbmZvLW1vZGFsX193cmFwcGVyIC5pbmZvLW1vZGFsIC5pbmZvLW1vZGFsX19oZWFkZXIgLmluZm8tbW9kYWxfX2hlYWRlci10ZXh0IHtcbiAgZm9udC1zaXplOiAxOHB4O1xuICBmb250LXdlaWdodDogNjAwO1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICBwYWRkaW5nOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbmZvLW1vZGFsX193cmFwcGVyIC5pbmZvLW1vZGFsIC5pbmZvLW1vZGFsX19oZWFkZXIgLmluZm8tbW9kYWxfX3N1YmhlYWRlci10ZXh0IHtcbiAgY29sb3I6ICM2ZDcxNzU7XG4gIGZvbnQtc2l6ZTogMTZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW5mby1tb2RhbF9fd3JhcHBlciAuaW5mby1tb2RhbCAuaW5mby1tb2RhbF9fYm9keSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXg6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXg6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybV9fb25saW5lLWNvbnRhaW5lciB7XG4gIGZsZXg6IDE7XG4gIGhlaWdodDogMTAwJTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm1fX29ubGluZS1jb250ZW50IHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBmbGV4LWdyb3c6IDE7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybV9fb25saW5lLWhlYWRlci1zZWN0aW9uIHtcbiAgbWFyZ2luLWJvdHRvbTogMjRweDtcbiAgbWFyZ2luLXRvcDogMjRweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm1fX29ubGluZS1oZWFkZXIge1xuICBmb250LXNpemU6IDIwcHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIHBhZGRpbmc6IDAgMCAxMHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm1fX29ubGluZS1oZWFkZXItc3VidGV4dCB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuc2lnbi11cC1mb3JtX19pbnB1dC1jb250YWluZXIge1xuICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICBtYXJnaW4tdG9wOiAyNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm1fX2lucHV0LXdyYXBwZXIge1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybV9fc3RhcnQtY29udmVyc2F0aW9uLWN0YSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIHBhZGRpbmctYm90dG9tOiAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm0gYnV0dG9uLnNpZ24tdXAtZm9ybV9fYnV0dG9uIHtcbiAgYmFja2dyb3VuZDogIzAwODlkMztcbiAgYm9yZGVyOiBub25lO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwYWRkaW5nOiAxMnB4IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBmb250LXdlaWdodDogNjAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5zaWduLXVwLWZvcm0gYnV0dG9uLnNpZ24tdXAtZm9ybV9fYnV0dG9uOmRpc2FibGVkIHtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAxMzcsIDIxMSwgMC4zNSk7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybSBidXR0b24uc2lnbi11cC1mb3JtX19idXR0b246bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICBiYWNrZ3JvdW5kOiAjMmE4ZWU3O1xuICBvcGFjaXR5OiAwLjg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybSBidXR0b24uc2lnbi11cC1mb3JtX19idXR0b246Zm9jdXMge1xuICBvcGFjaXR5OiAwLjg7XG4gIG91dGxpbmU6IG5vbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybSBidXR0b24uc2lnbi11cC1mb3JtX19idXR0b246ZGlzYWJsZWQge1xuICBvcGFjaXR5OiAwLjU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNpZ24tdXAtZm9ybV9fc3Bpbm5lciB7XG4gIGFuaW1hdGlvbjogc2hvcGlmeS1jaGF0LXNwaW4gMC42cyBsaW5lYXIgaW5maW5pdGU7XG4gIGJvcmRlcjogMnB4IHNvbGlkICNmM2YzZjM7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgYm9yZGVyLXRvcC1jb2xvcjogIzAwODlkMztcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBoZWlnaHQ6IDEwcHg7XG4gIG1hcmdpbi1yaWdodDogOHB4O1xuICB3aWR0aDogMTBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWlzLW1vYmlsZSAuc2lnbi11cC1mb3JtX19zdGFydC1jb252ZXJzYXRpb24tY3RhIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgaGVpZ2h0OiA0NHB4O1xuICB3aWR0aDogMTAwJTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19jaGVja2JveC13cmFwcGVyIHtcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gIGNvbHVtbi1nYXA6IDEwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gIHBhZGRpbmctdG9wOiAxMHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX2NoZWNrYm94LXdyYXBwZXIgaW5wdXQge1xuICBmbGV4LXNocmluazogMDtcbiAgaGVpZ2h0OiAxOHB4O1xuICB3aWR0aDogMThweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleDogMTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19vbmxpbmUtY29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleDogMTtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgaGVpZ2h0OiAxMDAlO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9fb25saW5lLWNvbnRlbnQge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBmbGV4LWdyb3c6IDE7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19vbmxpbmUtaGVhZGVyLXNlY3Rpb24ge1xuICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuICBtYXJnaW4tdG9wOiAyNHB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9fb25saW5lLWhlYWRlciB7XG4gIGZvbnQtc2l6ZTogMjBweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgcGFkZGluZzogMCAwIDEwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9fb25saW5lLWhlYWRlci1zdWJ0ZXh0IHtcbiAgZm9udC1zaXplOiAxNnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX2lucHV0LWNvbnRhaW5lciB7XG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gIG1hcmdpbi10b3A6IDI0cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmN1c3RvbWVyLWluZm8tZm9ybV9faW5wdXQtd3JhcHBlciB7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtX19lcnJvciB7XG4gIGNvbG9yOiAjZDcyYzBkO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX3N0YXJ0LWNvbnZlcnNhdGlvbi1jdGEge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBwYWRkaW5nLWJvdHRvbTogMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtIGJ1dHRvbi5jdXN0b21lci1pbmZvLWZvcm1fX2J1dHRvbiB7XG4gIGJhY2tncm91bmQ6ICMwMDg5ZDM7XG4gIGJvcmRlcjogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcGFkZGluZzogMTJweCAwO1xuICB3aWR0aDogMTAwJTtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY3VzdG9tZXItaW5mby1mb3JtIGJ1dHRvbi5jdXN0b21lci1pbmZvLWZvcm1fX2J1dHRvbjpkaXNhYmxlZCB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMTM3LCAyMTEsIDAuMzUpO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm0gYnV0dG9uLmN1c3RvbWVyLWluZm8tZm9ybV9fYnV0dG9uOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgYmFja2dyb3VuZDogIzJhOGVlNztcbiAgb3BhY2l0eTogMC44O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm0gYnV0dG9uLmN1c3RvbWVyLWluZm8tZm9ybV9fYnV0dG9uOmZvY3VzIHtcbiAgb3BhY2l0eTogMC44O1xuICBvdXRsaW5lOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm0gYnV0dG9uLmN1c3RvbWVyLWluZm8tZm9ybV9fYnV0dG9uOmRpc2FibGVkIHtcbiAgb3BhY2l0eTogMC41O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jdXN0b21lci1pbmZvLWZvcm1fX3NwaW5uZXIge1xuICBhbmltYXRpb246IHNob3BpZnktY2hhdC1zcGluIDAuNnMgbGluZWFyIGluZmluaXRlO1xuICBib3JkZXI6IDJweCBzb2xpZCAjZjNmM2YzO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIGJvcmRlci10b3AtY29sb3I6ICMwMDg5ZDM7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgaGVpZ2h0OiAxMHB4O1xuICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgd2lkdGg6IDEwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwLS1pcy1tb2JpbGUgLmN1c3RvbWVyLWluZm8tZm9ybV9fc3RhcnQtY29udmVyc2F0aW9uLWN0YSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGhlaWdodDogNDRweDtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdWkge1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBib3gtc2hhZG93OiAwIDAgN3B4IDAgcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgY29sb3I6ICMyMTJiMzY7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG1hcmdpbjogMCBhdXRvO1xuICBvdmVyZmxvdy15OiBhdXRvO1xuICB3aWR0aDogMTAwJTtcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xuICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdWk6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC11aS5sb2FkaW5nIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbn1cbkBtZWRpYSAobWluLXdpZHRoOiA3NjlweCkge1xuICAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdWkge1xuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4yNXM7XG4gICAgYW5pbWF0aW9uLW5hbWU6IGZhZGUtaW4tZG93bjtcbiAgfVxufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXVpLS1pcy1tb2JpbGUge1xuICBib3JkZXItcmFkaXVzOiAwO1xuICBoZWlnaHQ6IDEwMHZoO1xuICBtYXJnaW46IDA7XG4gIHdpZHRoOiAxMDB2dztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYmFubmVyIHtcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY0ZjQ7XG4gIGNvbG9yOiAjMjAyMjIzO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmb250LXNpemU6IDE0cHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIHBhZGRpbmc6IDEwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmJhbm5lciBwIHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwIDEwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmJhbm5lci1tZXRhZGF0YS1jb250ZW50IHtcbiAgZGlzcGxheTogZmxleDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAud2FybmluZy1pY29uIHtcbiAgY29sb3I6ICNkNzJjMGQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNhbmNlbC1idXR0b24sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAud2FybmluZy1pY29uIHtcbiAgaGVpZ2h0OiAyMHB4O1xuICB3aWR0aDogMjBweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaWNvbi1jb250YWluZXIge1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuYmFubmVyLWp1c3RpZnktY2VudGVyIHtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmJhbm5lci1qdXN0aWZ5LXNwYWNlLWJldHdlZW4ge1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmludGVyc3RpdGlhbC12aWV3X19pbnN0YW50LWFuc3dlcnMtbGlzdCB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDAgMCAxMnB4IDEycHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZsZXgtZ3JvdzogMTtcbiAgb3ZlcmZsb3c6IGF1dG87XG4gIG92ZXJmbG93OiBpbml0aWFsO1xuICBwYWRkaW5nOiAwIDEycHggMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX2luc3RhbnQtYW5zd2Vycy1saXN0LS1lbXB0eSB7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19faW5zdGFudC1hbnN3ZXJzLWxpc3QgLndpdGgtY29udmVyc2F0aW9uIHtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBtYXJnaW4tdG9wOiAyMHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24uaW5zdGFudC1hbnN3ZXJzLWxpc3RfX3Byb21wdCB7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZThlOWViO1xuICBjb2xvcjogIzM1ODBlNjtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBmb250LXNpemU6IDE2cHg7XG4gIGxpbmUtaGVpZ2h0OiAyMnB4O1xuICBtYXJnaW46IDRweCAwO1xuICBwYWRkaW5nOiAxMHB4IDEycHg7XG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5pbnN0YW50LWFuc3dlcnMtbGlzdF9fcHJvbXB0IHAge1xuICBtYXJnaW46IDA7XG4gIHRleHQtYWxpZ246IHN0YXJ0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnN0YW50LWFuc3dlcnMge1xuICBjb2xvcjogIzIwMjIyMztcbiAgZm9udC1zaXplOiAxZW07XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIG1hcmdpbjogOHB4IGF1dG8gMTZweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24uaW50ZXJzdGl0aWFsLXZpZXdfX3JldHVybi10by1jaGF0IHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYWxpZ24tc2VsZjogY2VudGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2xhKDAsIDAlLCAxMDAlLCAwLjI1KTtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgYm94LXNoYWRvdzogMCA1cHggMTVweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xuICBjb2xvcjogI2ZmZjtcbiAgZGlzcGxheTogZmxleDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgaGVpZ2h0OiA0NHB4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgbWFyZ2luLWJvdHRvbTogMjRweDtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbi5pbnRlcnN0aXRpYWwtdmlld19fcmV0dXJuLXRvLWNoYXQ6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2xhKDAsIDAlLCAxMDAlLCAwLjM1KTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYnV0dG9uLmludGVyc3RpdGlhbC12aWV3X19yZXR1cm4tdG8tY2hhdCAuZm9yd2FyZC1hcnJvdyB7XG4gIG1hcmdpbi1sZWZ0OiAxNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5yZXR1cm4tdG8tY2hhdC13cmFwcGVyIC5ob3Zlci1lZmZlY3QtYnV0dG9uIC5sYWJlbCB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAucmV0dXJuLXRvLWNoYXQtd3JhcHBlciAuaG92ZXItZWZmZWN0LWJ1dHRvbiAuYmFja2dyb3VuZCB7XG4gIGZpbHRlcjogYnJpZ2h0bmVzcygwLjgpO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5yZXR1cm4tdG8tY2hhdC13cmFwcGVyIC5ob3Zlci1lZmZlY3QtYnV0dG9uOmZvY3VzOm5vdCg6ZGlzYWJsZWQpIC5iYWNrZ3JvdW5kLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnJldHVybi10by1jaGF0LXdyYXBwZXIgLmhvdmVyLWVmZmVjdC1idXR0b246aG92ZXI6bm90KDpkaXNhYmxlZCkgLmJhY2tncm91bmQge1xuICBmaWx0ZXI6IGJyaWdodG5lc3MoMC43KTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUge1xuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCB0cmFuc3BhcmVudCAwLCB0cmFuc3BhcmVudCA1MCUsICNmZmYgMCwgI2ZmZik7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogYXV0bztcbiAgbWFzay1pbWFnZTogcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgI2ZmZiAxMDAlLCAjMDAwIDApO1xuICBtaW4taGVpZ2h0OiBmaXQtY29udGVudDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUuaXMtbW9iaWxlIHtcbiAgYm9yZGVyLXJhZGl1czogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUgW25hbWU9Y2xvc2VDaGF0XSB7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1hcmdpbjogMjBweCAyNHB4IDAgYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUgLnN0b3JlLWluZm8ge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBmbGV4LWdyb3c6IDE7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBvdmVyZmxvdy15OiBoaWRkZW47XG4gIHBhZGRpbmc6IDIwcHggMTZweCA3NnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19fd2VsY29tZSAuc3RvcmUtaW5mby5jaGVja291dC1wYWdlIHtcbiAgdGV4dC1hbGlnbjogbGVmdDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUgLnN0b3JlLWluZm8uaXMtbW9iaWxlIGgyIHtcbiAgbWFyZ2luLXRvcDogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUgLnN0b3JlLWluZm8taGVhZGluZyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogbGVmdDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXdfX3dlbGNvbWUgLnN0b3JlLWluZm8taGVhZGluZyBoMiB7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIGZvbnQtc2l6ZTogMjBweDtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICBtYXJnaW4tdG9wOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19fd2VsY29tZSAuc3RvcmUtaW5mby1oZWFkaW5nIFtuYW1lPWNsb3NlQ2hhdF0ge1xuICBtYXJnaW46IDAgMCAwIGF1dG87XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmludGVyc3RpdGlhbC12aWV3X193ZWxjb21lIC5zdG9yZS1pbmZvLWhlYWRpbmcgW25hbWU9Y2xvc2VDaGF0XSAuY2hhdC1oZWFkZXJfX2Nsb3NlX2J1dHRvbl9tb2JpbGUge1xuICBoZWlnaHQ6IDI0cHg7XG4gIHdpZHRoOiAyNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19fd2VsY29tZSAuc3RvcmUtaW5mbyBwIHtcbiAgY29sb3I6IHZhcigjMDAwMDAwKTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMjJweDtcbiAgbWFyZ2luOiAwO1xuICBtYXgtaGVpZ2h0OiBub25lO1xuICBvdmVyZmxvdy15OiBpbml0aWFsO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19fd2VsY29tZSAucmV0dXJuLXRvLWNoYXQtd3JhcHBlciB7XG4gIG1hcmdpbjogLTU2cHggMTJweCAxMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5pbnRlcnN0aXRpYWwtdmlld19fd2VsY29tZSAucmV0dXJuLXRvLWNoYXQtd3JhcHBlci5jaGVja291dC1wYWdlIGJ1dHRvbiB7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmludGVyc3RpdGlhbC12aWV3IHtcbiAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgbWF4LWhlaWdodDogNjAwcHg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuaW50ZXJzdGl0aWFsLXZpZXcuaXMtbW9iaWxlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogMDtcbiAgbWFyZ2luOiAwO1xuICBtYXgtaGVpZ2h0OiAxMDB2aDtcbiAgd2lkdGg6IDEwMHZ3O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5lcnJvci1jaGF0LXVuYXZhaWxhYmxlIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBhZGRpbmc6IDAgMnJlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5lcnJvci1jaGF0LXVuYXZhaWxhYmxlIGgyIHtcbiAgY29sb3I6ICMwMDA7XG4gIGZvbnQtc2l6ZTogMXJlbTtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbWFyZ2luOiAwIDAgMnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5lcnJvci1jaGF0LXVuYXZhaWxhYmxlIHAge1xuICBjb2xvcjogIzZkNzE3NTtcbiAgbWFyZ2luOiAwIDAgMjRweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgLmVycm9yLWNoYXQtdW5hdmFpbGFibGUgLm91dGxpbmUtYnV0dG9uIHtcbiAgd2lkdGg6IGF1dG87XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmVycm9yLWNoYXQtdW5hdmFpbGFibGUgLmJ0bi1jbG9zZSB7XG4gIGhlaWdodDogMjRweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICByaWdodDogMjRweDtcbiAgdG9wOiAyMHB4O1xuICB3aWR0aDogMjRweDtcbn1cbkBrZXlmcmFtZXMgc2hvcGlmeS1jaGF0LWZhZGUtaW4ge1xuICAwJSB7XG4gICAgb3BhY2l0eTogMC41O1xuICB9XG4gIHRvIHtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG59XG5Aa2V5ZnJhbWVzIHNob3BpZnktY2hhdC1zbGlkZS11cCB7XG4gIDAlIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG4gIHRvIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcbiAgfVxufVxuQGtleWZyYW1lcyBzaG9waWZ5LWNoYXQtc3BpbiB7XG4gIDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuICB0byB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMXR1cm4pO1xuICB9XG59XG5Aa2V5ZnJhbWVzIGZhZGUtaW4tZG93biB7XG4gIDAlIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMS4yNWVtKTtcbiAgfVxuICB0byB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG4gIH1cbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBib2R5IHtcbiAgbWFyZ2luOiAwO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgaW5wdXQsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciB0ZXh0YXJlYSB7XG4gIGZvbnQtc2l6ZTogMTZweCAhaW1wb3J0YW50O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC53aGl0ZS1iYWNrZ3JvdW5kIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAge1xuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTZWdvZSBVSSwgUm9ib3RvLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmLCBBcHBsZSBDb2xvciBFbW9qaSwgU2Vnb2UgVUkgRW1vamksIFNlZ29lIFVJIFN5bWJvbDtcbiAgZm9udC1zdHJldGNoOiBub3JtYWw7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgbGV0dGVyLXNwYWNpbmc6IDA7XG4gIGxpbmUtaGVpZ2h0OiBub3JtYWw7XG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaHRtbCB7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBib2R5IHtcbiAgbWFyZ2luOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBhcnRpY2xlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGFzaWRlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGRldGFpbHMsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgZmlnY2FwdGlvbiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBmaWd1cmUsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgZm9vdGVyLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGhlYWRlciwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBoZ3JvdXAsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgbWFpbiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBtZW51LCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIG5hdiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBzZWN0aW9uLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHN1bW1hcnkge1xuICBkaXNwbGF5OiBibG9jaztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYXVkaW8sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgY2FudmFzLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHByb2dyZXNzLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHZpZGVvIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGF1ZGlvOm5vdChbY29udHJvbHNdKSB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIGhlaWdodDogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgW2hpZGRlbl0sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgdGVtcGxhdGUge1xuICBkaXNwbGF5OiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBhIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGE6YWN0aXZlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGE6aG92ZXIge1xuICBvdXRsaW5lOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBhYmJyW3RpdGxlXSB7XG4gIGJvcmRlci1ib3R0b206IDFweCBkb3R0ZWQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGIsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgc3Ryb25nIHtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgZGZuIHtcbiAgZm9udC1zdHlsZTogaXRhbGljO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBoMSB7XG4gIGZvbnQtc2l6ZTogMmVtO1xuICBtYXJnaW46IDAuNjdlbSAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBtYXJrIHtcbiAgYmFja2dyb3VuZDogI2ZmMDtcbiAgY29sb3I6ICMwMDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHNtYWxsIHtcbiAgZm9udC1zaXplOiA4MCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHN1YiB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHN1cCB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG4gIHRvcDogLTAuNWVtO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBzdWIge1xuICBib3R0b206IC0wLjI1ZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGltZyB7XG4gIGJvcmRlcjogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgc3ZnOm5vdCg6cm9vdCkge1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBmaWd1cmUge1xuICBtYXJnaW46IDFlbSA0MHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBociB7XG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICBoZWlnaHQ6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHByZSB7XG4gIG92ZXJmbG93OiBhdXRvO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBjb2RlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGtiZCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBwcmUsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgc2FtcCB7XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTtcbiAgZm9udC1zaXplOiAxZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGJ1dHRvbiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBpbnB1dCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBvcHRncm91cCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBzZWxlY3QsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgdGV4dGFyZWEge1xuICBjb2xvcjogaW5oZXJpdDtcbiAgZm9udDogaW5oZXJpdDtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24ge1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHNlbGVjdCB7XG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b24sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaHRtbCBpbnB1dFt0eXBlPWJ1dHRvbl0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBpbnB1dFt0eXBlPXJlc2V0XSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBpbnB1dFt0eXBlPXN1Ym1pdF0ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b25bZGlzYWJsZWRdLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGh0bWwgaW5wdXRbZGlzYWJsZWRdIHtcbiAgY3Vyc29yOiBkZWZhdWx0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIge1xuICBib3JkZXI6IDA7XG4gIHBhZGRpbmc6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGlucHV0IHtcbiAgbGluZS1oZWlnaHQ6IG5vcm1hbDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaW5wdXQ6Oi1tb3otZm9jdXMtaW5uZXIge1xuICBib3JkZXI6IDA7XG4gIHBhZGRpbmc6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGlucHV0W3R5cGU9Y2hlY2tib3hdLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGlucHV0W3R5cGU9cmFkaW9dIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgcGFkZGluZzogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gIGhlaWdodDogYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaW5wdXRbdHlwZT1zZWFyY2hdIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBpbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgaW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBmaWVsZHNldCB7XG4gIGJvcmRlcjogMXB4IHNvbGlkIHNpbHZlcjtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCBsZWdlbmQge1xuICBib3JkZXI6IDA7XG4gIHBhZGRpbmc6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIHRleHRhcmVhIHtcbiAgb3ZlcmZsb3c6IGF1dG87XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIG9wdGdyb3VwIHtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgdGFibGUge1xuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICBib3JkZXItc3BhY2luZzogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgdGQsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgdGgge1xuICBwYWRkaW5nOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbiB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4yNXM7XG4gIGFuaW1hdGlvbi1uYW1lOiBzaG9waWZ5LWNoYXQtZmFkZS1pbjtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmb250LXNpemU6IDI0cHg7XG4gIGZvbnQtd2VpZ2h0OiAyNDA7XG4gIGhlaWdodDogNjBweDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIG1hcmdpbi10b3A6IDE2cHg7XG4gIHdpZHRoOiA2MHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbi1ib3R0b20tcmlnaHQge1xuICBtYXJnaW4tbGVmdDogYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWlzLW9wZW4gPiBkaXYge1xuICBhbmltYXRpb24tZHVyYXRpb246IDAuMjVzO1xuICBhbmltYXRpb24tbmFtZTogZmFkZS1pbi1kb3duO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcC0taXMtb3Blbjpub3QoLmNoYXQtYXBwLS1pcy1tb2JpbGUpIHtcbiAgbWFyZ2luOiAwIDZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWlzLW1vYmlsZSB7XG4gIG1hcmdpbjogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWlzLW1vYmlsZSAuY2hhdC1ub3RpZmljYXRpb24ge1xuICByaWdodDogMDtcbiAgdG9wOiAtNnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcC0tY2xvc2UtYnV0dG9uLS1yZWQsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXItLXJlZCwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXRvZ2dsZS0tcmVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U1NTMzODtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbi0tb3JhbmdlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyLS1vcmFuZ2UsIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC10b2dnbGUtLW9yYW5nZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlNTgwMWU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwLS1jbG9zZS1idXR0b24tLXllbGxvdywgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci0teWVsbG93LCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdG9nZ2xlLS15ZWxsb3cge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWFiMzExO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcC0tY2xvc2UtYnV0dG9uLS1ncmVlbiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci0tZ3JlZW4sIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC10b2dnbGUtLWdyZWVuIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzU4YmYzMjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbi0tYmx1ZSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci0tYmx1ZSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXRvZ2dsZS0tYmx1ZSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICMyYThlZTc7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwLS1jbG9zZS1idXR0b24tLXB1cnBsZSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci0tcHVycGxlLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdG9nZ2xlLS1wdXJwbGUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNTQ1OWMxO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcC0tY2xvc2UtYnV0dG9uLS1waW5rLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyLS1waW5rLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdG9nZ2xlLS1waW5rIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U5NTBhNjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbi0tZ3JleSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci0tZ3JleSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXRvZ2dsZS0tZ3JleSB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM5MDlmYWI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwLS1jbG9zZS1idXR0b24tLWJsYWNrLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyLS1ibGFjaywgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXRvZ2dsZS0tYmxhY2sge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjAyYTM2O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbiB7XG4gIGJhY2tncm91bmQ6IG5vbmU7XG4gIGJvcmRlcjogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUge1xuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgYm9yZGVyLXJhZGl1czogMzBweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBoZWlnaHQ6IDYwcHg7XG4gIG1hcmdpbjogMCA2cHg7XG4gIHdpZHRoOiA2MHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZSBzdmcge1xuICBmbGV4LXNocmluazogMDtcbiAgaGVpZ2h0OiA0OHB4O1xuICB3aWR0aDogYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUgc3ZnIHBhdGgge1xuICBmaWxsOiB2YXIoIzAwMDAwMCk7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlIC5jaGF0LXRpdGxlIHtcbiAgZm9udC1zaXplOiAyNHB4O1xuICBtYXJnaW46IDAgYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLWljb24tYnV0dG9uIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS1pY29uLWJ1dHRvbi5pY29uLW9ubHkgc3ZnLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS1pY29uLWJ1dHRvbi5tb2JpbGUtb25seSBzdmcge1xuICBoZWlnaHQ6IDU4cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiB7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJvcmRlcjogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgYm94LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuMTUpO1xuICBjb2xvcjogdmFyKCMwMDAwMDApO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmb250LXNpemU6IDEuNXJlbTtcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgaGVpZ2h0OiA2MHB4O1xuICBsaW5lLWhlaWdodDogMnJlbTtcbiAgbWF4LXdpZHRoOiBmaXQtY29udGVudDtcbiAgcGFkZGluZzogMCAxMnB4IDAgM3B4O1xuICB3aWR0aDogYXV0bztcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uLnRleHQtb25seSB7XG4gIGhlaWdodDogNjBweDtcbiAgcGFkZGluZzogMCAxN3B4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGUge1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIG1heC1oZWlnaHQ6IDQwcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGVsKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyh2aSkge1xuICBmb250LXNpemU6IDAuODVyZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGhyKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhoci1IUikge1xuICBmb250LXNpemU6IDAuODdyZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGh1KSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhtcykge1xuICBmb250LXNpemU6IDAuODlyZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGZyKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhpZCksIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlOmxhbmcoamEpLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGtvKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhsdCksIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlOmxhbmcobHQtTFQpLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKG5sKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhwdC1QVCksIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlOmxhbmcoc2spLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKHNrLVNLKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyh0cikge1xuICBmb250LXNpemU6IDFyZW07XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKGRlKSwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24gLmNoYXQtdGl0bGU6bGFuZyhpdCksIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlOmxhbmcoc2wpLCAuc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLmNoYXQtdG9nZ2xlLmNoYXQtdG9nZ2xlLS10ZXh0LWJ1dHRvbiAuY2hhdC10aXRsZTpsYW5nKHNsLVNJKSB7XG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcbn1cbkBzdXBwb3J0cyAoLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lKSB7XG4gIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICB9XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdG9vZ2xlLS1hbmltYXRpb24tYnV0dG9uIHtcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjI1cztcbiAgYW5pbWF0aW9uLW5hbWU6IHNob3BpZnktY2hhdC1mYWRlLWluO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDEwMCU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLk9yZGVyTG9va3VwX19sb29rdXBCdG5UaXRsZSB7XG4gIGNvbG9yOiAjNjM3MzgxO1xuICBmb250LXNpemU6IDEzcHg7XG4gIG1hcmdpbi10b3A6IDRweDtcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgYnV0dG9uLk9yZGVyTG9va3VwX19jYW5jZWwge1xuICBjb2xvcjogIzJjNmVjYjtcbiAgcGFkZGluZzogMTJweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZm9ybSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogMTAwJTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuT3JkZXJMb29rdXBfX2Zvcm1Hcm91cCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG1hcmdpbjogMTZweCAxNnB4IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLk9yZGVyTG9va3VwX19mb3JtR3JvdXA6bnRoLWNoaWxkKDIpIHtcbiAgbWFyZ2luLXRvcDogMjRweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuT3JkZXJMb29rdXBfX2Zvcm1Hcm91cCBsYWJlbCB7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuT3JkZXJMb29rdXBfX2Zvcm1Hcm91cCBpbnB1dCB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgYm9yZGVyOiAxcHggc29saWQgI2QyZDVkOTtcbiAgYm9yZGVyLXJhZGl1czogMjJweDtcbiAgbWFyZ2luLXRvcDogMTBweDtcbiAgcGFkZGluZzogMTJweCAxNnB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZm9ybUdyb3VwIGlucHV0OjpwbGFjZWhvbGRlciB7XG4gIGNvbG9yOiAjYzRjOWQ1O1xuICBmb250LXNpemU6IDE1cHg7XG4gIG9wYWNpdHk6IDAuODQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLk9yZGVyTG9va3VwX19mb3JtR3JvdXAgaW5wdXQ6Zm9jdXMge1xuICBvdXRsaW5lOiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fc3VibWl0IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgY29sb3I6IHZhcigjMDAwMDAwKTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgZmxleC1ncm93OiAxO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICBtYXJnaW4tdG9wOiAxNnB4O1xuICBwYWRkaW5nLWJvdHRvbTogMTJweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBpbnB1dFt0eXBlPW51bWJlcl0uT3JkZXJMb29rdXBfX29yZGVyTnVtYmVyRmllbGQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gIG1hcmdpbjogMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuT3JkZXJMb29rdXBfX3N1Ym1pdC0taXMtbW9iaWxlIGlucHV0IHtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZXJyb3Ige1xuICBjb2xvcjogI2VlMmY1MztcbiAgZm9udC1zaXplOiAxNHB4O1xuICBtYXJnaW46IDE2cHggMTZweCAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5PcmRlckxvb2t1cF9fZXJyb3JMaXN0IHtcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICBwYWRkaW5nOiAwO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW5vdGlmaWNhdGlvbiB7XG4gIGJhY2tncm91bmQ6ICNlZTJmNTM7XG4gIGJvcmRlci1yYWRpdXM6IDMwcHg7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBmb250LXNpemU6IDEycHg7XG4gIGZvbnQtd2VpZ2h0OiA3MDA7XG4gIGhlaWdodDogMjJweDtcbiAgbGluZS1oZWlnaHQ6IDIycHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDA7XG4gIHRvcDogLTdweDtcbiAgd2lkdGg6IDIycHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbm90aWZpY2F0aW9uLnRleHQtYnV0dG9uIHtcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XG4gIHBvc2l0aW9uOiBzdGF0aWM7XG4gIHdpZHRoOiAyN3B4O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW5vdGlmaWNhdGlvbi0tbGltaXQge1xuICB3aWR0aDogMjhweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXIge1xuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxMnB4O1xuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMTJweDtcbiAgZGlzcGxheTogZmxleDtcbiAgaGVpZ2h0OiBhdXRvO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIHBhZGRpbmc6IDEycHg7XG4gIHotaW5kZXg6IDM7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyIGJ1dHRvbiwgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci50ZXh0LWJ1dHRvbiB7XG4gIGNvbG9yOiB2YXIoIzAwMDAwMCk7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyIGJ1dHRvbiB7XG4gIG1hcmdpbi10b3A6IDNweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXItLWlzLW1vYmlsZSB7XG4gIGJvcmRlci1yYWRpdXM6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtaGVhZGVyX19jbG9zZV9idXR0b25fbW9iaWxlIHtcbiAgY29sb3I6IGluaGVyaXQ7XG4gIGhlaWdodDogMjBweDtcbiAgd2lkdGg6IDIwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtbWFpbi1ib2R5IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMTJweDtcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDEycHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGhlaWdodDogMTAwJTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1iYW5uZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWY5O1xuICBjb2xvcjogIzIxMmIzNjtcbiAgZGlzcGxheTogZmxleDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgcGFkZGluZzogMiUgMyU7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYmFubmVyX190ZXh0LS1vcGVuaW5nIHtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1iYW5uZXItLWhpZ2hsaWdodGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZWZkMjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1iYW5uZXJfX2ljb24ge1xuICBtYXJnaW4tcmlnaHQ6IDZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlcyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZsZXgtZ3JvdzogMTtcbiAgaGVpZ2h0OiAyODdweDtcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICBzY3JvbGxiYXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xuICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7XG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlczo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICBkaXNwbGF5OiBub25lO1xuICB3aWR0aDogMCAhaW1wb3J0YW50O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19saXN0IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xuICBtYXJnaW46IDA7XG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgb3ZlcnNjcm9sbC1iZWhhdmlvcjogY29udGFpbjtcbiAgcGFkZGluZzogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBzY3JvbGxiYXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xuICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7XG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1tZXNzYWdlc19fbGlzdDo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICBkaXNwbGF5OiBub25lO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19saXN0ID4gZGl2Omxhc3Qtb2YtdHlwZSB7XG4gIGFuaW1hdGlvbi1kdXJhdGlvbjogMC41cztcbiAgYW5pbWF0aW9uLW5hbWU6IHNob3BpZnktY2hhdC1zbGlkZS11cDtcbiAgcGFkZGluZy1ib3R0b206IDE2cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmF1dG9tYXRlZC1tZXNzYWdlX19sYWJlbCB7XG4gIGNvbG9yOiAjYTBhNGE5O1xuICBmb250LXNpemU6IDExcHg7XG4gIG1hcmdpbi10b3A6IDRweDtcbiAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LW1lc3NhZ2VzX19jb250YWluZXIge1xuICBkaXNwbGF5OiBibG9jaztcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHBhZGRpbmctdG9wOiA0cHg7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LXZpZXcgLmNoYXQtbWFpbi1ib2R5IHtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdmlldyAuY2hhdC1tZXNzYWdlcyB7XG4gIGhlaWdodDogMTAwcHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdmlldyAuY2hhdC1tZXNzYWdlcyBsaTpmaXJzdC1jaGlsZCB7XG4gIG1hcmdpbi10b3A6IDI2cHg7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdmlldyAuY2hhdC1tZXNzYWdlcyBsaTpsYXN0LW9mLXR5cGUgKyAuYXV0b21hdGVkLW1lc3NhZ2VfX2xhYmVsIHtcbiAgbWFyZ2luLWJvdHRvbTogMDtcbiAgcGFkZGluZy1ib3R0b206IDA7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtdmlldyAuY2hhdC1tZXNzYWdlc19fbGlzdCA+IGRpdjpsYXN0LW9mLXR5cGUge1xuICBhbmltYXRpb24tbmFtZTogbm9uZTtcbiAgcGFkZGluZy1ib3R0b206IDZweDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC12aWV3IC5jb21wb3Nlci1iYXItd3JhcHBlciB7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbiAgbWFyZ2luLXRvcDogOHB4O1xufVxuXG4jY2hhdC1idXR0b24ge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGJvdHRvbTogMjBweDtcbiAgcmlnaHQ6IDIwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDdiZmY7XG4gIGNvbG9yOiAjZmZmO1xuICBwYWRkaW5nOiAxMHB4IDIwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgei1pbmRleDogMTAwMDtcbn1cbiNjaGF0LWJ1dHRvbi5oaWRkZW4ge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4jY2hhdC13aWRnZXQge1xuICB0cmFuc2l0aW9uOiB3aWR0aCAwLjNzIGVhc2U7XG4gIGJvcmRlci1yYWRpdXM6IDIycHg7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgYm90dG9tOiA4NnB4O1xuICByaWdodDogMjBweDtcbiAgd2lkdGg6IDI1JTtcbiAgaGVpZ2h0OiA4MCU7XG4gIGJvcmRlci13aWR0aDogMXB4O1xuICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gIHotaW5kZXg6IDEwMDA7XG59XG4jY2hhdC13aWRnZXQuaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuI2NoYXQtd2lkZ2V0LmV4cGFuZGVkIHtcbiAgd2lkdGg6IGNhbGMoNjAlIC0gNjBweCkgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiA4NSU7XG59XG5cbiNjaGF0LXdpZGdldC5zaHJ1bmsge1xuICB3aWR0aDogMjUlICFpbXBvcnRhbnQ7XG4gIGhlaWdodDogODAlO1xufVxuXG4jcmVzaXplV2lkZ2V0QnV0dG9uIHtcbiAgZGlzcGxheTogZmxleDtcbn1cblxuQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSB7XG4gICNyZXNpemVXaWRnZXRCdXR0b24ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbiAgI2NoYXQtd2lkZ2V0IHtcbiAgICBib3R0b206IDEwcHggIWltcG9ydGFudDtcbiAgICByaWdodDogMTBweCAhaW1wb3J0YW50O1xuICAgIGxlZnQ6IDEwcHggIWltcG9ydGFudDtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gMjBweCkgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEuNXJlbSkgIWltcG9ydGFudDtcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4ICFpbXBvcnRhbnQ7XG4gIH1cbiAgI2NoYXQtd2lkZ2V0LmV4cGFuZGVkIHtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gMjBweCkgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEuNXJlbSkgIWltcG9ydGFudDtcbiAgfVxuICAjY2hhdC13aWRnZXQuc2hydW5rIHtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gMjBweCkgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDEuNXJlbSkgIWltcG9ydGFudDtcbiAgfVxuICAjY2hhdC1pbnB1dCB7XG4gICAgd2lkdGg6IGNhbGMoODUlIC0gOHB4KTtcbiAgfVxuICAjY2hhdC1pbnB1dC5leHBhbmRlZCB7XG4gICAgd2lkdGg6IGNhbGMoODUlIC0gOHB4KTtcbiAgfVxuICAjY2hhdC1pbnB1dC5zaHJ1bmsge1xuICAgIHdpZHRoOiBjYWxjKDg1JSAtIDhweCk7XG4gIH1cbn1cbkBtZWRpYSAobWluLXdpZHRoOiA4MDFweCkgYW5kIChtYXgtd2lkdGg6IDEyMDBweCkge1xuICAjcmVzaXplV2lkZ2V0QnV0dG9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG4gICNjaGF0LXdpZGdldCB7XG4gICAgd2lkdGg6IGNhbGMoNTAlIC0gNjBweCkgIWltcG9ydGFudDtcbiAgICB0cmFuc2l0aW9uOiB3aWR0aCAwLjNzIGVhc2U7XG4gIH1cbiAgI2NoYXQtd2lkZ2V0LmV4cGFuZGVkIHtcbiAgICB3aWR0aDogY2FsYyg3MCUgLSA2MHB4KSAhaW1wb3J0YW50O1xuICB9XG4gICNjaGF0LXdpZGdldC5zaHJ1bmsge1xuICAgIHdpZHRoOiBjYWxjKDUwJSAtIDYwcHgpICFpbXBvcnRhbnQ7XG4gIH1cbiAgI2NoYXQtaW5wdXQge1xuICAgIHdpZHRoOiBjYWxjKDg1JSAtIDhweCk7XG4gIH1cbiAgI2NoYXQtaW5wdXQuZXhwYW5kZWQge1xuICAgIHdpZHRoOiBjYWxjKDkwJSAtIDhweCk7XG4gIH1cbiAgI2NoYXQtaW5wdXQuc2hydW5rIHtcbiAgICB3aWR0aDogY2FsYyg4NSUgLSA4cHgpO1xuICB9XG59XG4jY2hhdC1oZWFkZXIge1xuICBtaW4taGVpZ2h0OiAzcmVtO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmO1xuICBjb2xvcjogI2ZmZjtcbiAgcGFkZGluZzogMXJlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDIwcHg7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDIwcHg7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuXG4jY2hhdC1tZXNzYWdlcyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZsZXg6IDE7XG4gIHBhZGRpbmc6IDEwcHg7XG4gIG92ZXJmbG93LXk6IGF1dG87XG59XG5cbi5tZXNzYWdlLWNvbnRhaW5lciB7XG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbn1cblxuLnVzZXItaW5mbyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi51c2VyLW5hbWUge1xuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBjb2xvcjogIzZkNzE3NTtcbn1cblxuLnVzZXItYXZhdGFyIHtcbiAgd2lkdGg6IDMwcHg7XG4gIGhlaWdodDogMzBweDtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBvYmplY3QtZml0OiBjb3Zlcjtcbn1cblxuLnVzZXItbWVzc2FnZSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBtYXgtd2lkdGg6IDgwJTtcbiAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlNmYyZmY7XG4gIHBhZGRpbmc6IDhweCAxMnB4O1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG59XG5cbi5hZG1pbi1tZXNzYWdlIHtcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcbiAgcGFkZGluZzogOHB4IDEycHg7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgbWF4LXdpZHRoOiA4MCU7XG59XG5cbi5tZXNzYWdlLXRpbWUge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgZm9udC1zaXplOiAxMnB4O1xufVxuXG4jY2hhdC1pbnB1dC1jb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7IC8qIENoYW5nZWQgZnJvbSBjZW50ZXIgdG8gZmxleC1lbmQgKi9cbiAgcGFkZGluZzogOHB4O1xufVxuI2NoYXQtaW5wdXQtY29udGFpbmVyLmhpZGRlbiB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbi5oaWRkZW4ge1xuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG59XG5cbiNjaGF0LWlucHV0IHtcbiAgYm9yZGVyOiAwLjFweCBzb2xpZCAjZDJkNWQ5O1xuICBib3JkZXItcmFkaXVzOiAxNHB4O1xuICBwYWRkaW5nOiAxMHB4O1xuICBtYXJnaW4tcmlnaHQ6IDhweDsgLyogQ2hhbmdlZCBmcm9tIG1hcmdpbiB0byBtYXJnaW4tcmlnaHQgKi9cbiAgd2lkdGg6IGNhbGMoODUlIC0gOHB4KTsgLyogQWRqdXN0ZWQgdG8gYWNjb3VudCBmb3IgdGhlIHJpZ2h0IG1hcmdpbiAqL1xuICBvdXRsaW5lLWNvbG9yOiAjY2RjZGNmO1xuICByZXNpemU6IG5vbmU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIG1pbi1oZWlnaHQ6IDM4cHg7XG4gIG1heC1oZWlnaHQ6IDE1MHB4OyAvKiBBZGQgYSBtYXggaGVpZ2h0IHRvIHByZXZlbnQgZXhjZXNzaXZlIGdyb3d0aCAqL1xuICBsaW5lLWhlaWdodDogMjBweDtcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIEVuc3VyZSBjb25zaXN0ZW50IGZvbnQgKi9cbiAgZm9udC1zaXplOiBpbmhlcml0OyAvKiBFbnN1cmUgY29uc2lzdGVudCBmb250IHNpemUgKi9cbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbn1cbiNjaGF0LWlucHV0LmV4cGFuZGVkIHtcbiAgd2lkdGg6IGNhbGMoOTAlIC0gOHB4KTtcbn1cbiNjaGF0LWlucHV0LnNocnVuayB7XG4gIHdpZHRoOiBjYWxjKDg1JSAtIDhweCk7XG59XG5cbiNzZW5kLWJ1dHRvbiB7XG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kOyAvKiBBbGlnbiB0aGUgYnV0dG9uIHRvIHRoZSBib3R0b20gKi9cbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgYm9yZGVyOiBub25lO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBtYXJnaW4tcmlnaHQ6IDEycHg7XG59XG5cbiNzZW5kLWJ1dHRvbiBpIHtcbiAgZm9udC1zaXplOiAxLjJlbTtcbiAgY29sb3I6ICMwMDdiZmY7XG59XG5cbiNsb2FkaW5nLXNwaW5uZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgcGFkZGluZzogMTBweDtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBjb2xvcjogIzU1NTtcbiAgbWFyZ2luOiAwIDQzJTtcbn1cblxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCB7XG4gIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xuICByaWdodDogMCAhaW1wb3J0YW50O1xuICBib3R0b206IDAgIWltcG9ydGFudDtcbiAgei1pbmRleDogMTAwMCAhaW1wb3J0YW50O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcCAuY2hhdC1hcHAtLWNsb3NlLWJ1dHRvbiB7XG4gIG1hcmdpbi10b3A6IDE2cHggIWltcG9ydGFudDtcbiAgbWFyZ2luLXJpZ2h0OiAxMnB4ICFpbXBvcnRhbnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwLS1pcy1vcGVuOm5vdCguY2hhdC1hcHAtLWlzLW1vYmlsZSkge1xuICBtYXJnaW46IDE0cHggMTBweCAhaW1wb3J0YW50O1xufVxuLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWFwcC0tY2xvc2UtYnV0dG9uIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjI1cztcbiAgYW5pbWF0aW9uLW5hbWU6IHNob3BpZnktY2hhdC1mYWRlLWluO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZvbnQtc2l6ZTogMjRweDtcbiAgZm9udC13ZWlnaHQ6IDI0MDtcbiAgaGVpZ2h0OiA2MHB4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgbWFyZ2luLXRvcDogMTZweDtcbiAgd2lkdGg6IDYwcHg7XG4gIGJvcmRlcjogbm9uZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmO1xuICBjb2xvcjogI2ZmZjtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXItbWVudS1pdGVtIHtcbiAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgcGFkZGluZzogOHB4IDE2cHggIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDtcbiAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XG4gIGZvbnQtc2l6ZTogMTRweCAhaW1wb3J0YW50O1xuICBjb2xvcjogIzAwMCAhaW1wb3J0YW50O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMnMgIWltcG9ydGFudDtcbn1cblxuLyogVGh1bWJuYWlscyBjb250YWluZXIgKi9cbi50aHVtYm5haWxzLWNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtd3JhcDogd3JhcDtcbiAgZ2FwOiAxMHB4O1xufVxuXG4vKiBQbGFjZWhvbGRlciBmb3IgbG9hZGluZyBpbWFnZSAqL1xuLnRodW1ibmFpbC1wbGFjZWhvbGRlciB7XG4gIHdpZHRoOiAxMDBweDtcbiAgaGVpZ2h0OiAxMDBweDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7XG4gIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBtYXJnaW46IDAuNXJlbSAwO1xufVxuXG4vKiBMb2FkaW5nIHNwaW5uZXIgKi9cbi5sb2FkaW5nLXNwaW5uZXIge1xuICBkaXNwbGF5OiBmbGV4ICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogNHB4IHNvbGlkICNmM2YzZjM7IC8qIExpZ2h0IGdyZXkgKi9cbiAgYm9yZGVyLXRvcDogNHB4IHNvbGlkICMzNDk4ZGI7IC8qIEJsdWUgKi9cbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICB3aWR0aDogMjRweDtcbiAgaGVpZ2h0OiAyNHB4O1xuICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xuICBtYXJnaW46IDFyZW07XG59XG5cbi8qIEFuaW1hdGlvbiBmb3Igc3Bpbm5lciAqL1xuQGtleWZyYW1lcyBzcGluIHtcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICB9XG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gIH1cbn1cbi8qIFRodW1ibmFpbCBpbWFnZSAqL1xuLnRodW1ibmFpbC1pbWFnZSB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG9iamVjdC1maXQ6IGNvdmVyO1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLnR5cGluZy1pbmRpY2F0b3Ige1xuICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIG1hcmdpbjogMCAxcmVtO1xufVxuXG4ucXVpY2stcmVwbHkge1xuICBiYWNrZ3JvdW5kOiB1bnNldDtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4uaGlkZGVuLXBsYWNlaG9sZGVyIHtcbiAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG59XG5cbi5wb3dlcmVkLWJ5LWJhbm5lciB7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIG1hcmdpbjogMC4ycmVtIDVyZW0gMC41cmVtIDVyZW07XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG59XG4ucG93ZXJlZC1ieS1iYW5uZXI6aG92ZXIge1xuICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xufVxuXG4uY2hhdC1oZWFkZXItY29udGVudCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHBhZGRpbmc6IDhweCAxNnB4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1sZWZ0LXNlY3Rpb24ge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1sZWZ0LXNlY3Rpb24gLmF2YXRhci1jb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1sZWZ0LXNlY3Rpb24gLmF2YXRhci1jb250YWluZXIgLmFnZW50LWF2YXRhciB7XG4gIHdpZHRoOiA0NXB4O1xuICBoZWlnaHQ6IDQ1cHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgYmFja2dyb3VuZDogd2hpdGU7XG4gIHBhZGRpbmc6IDAuMTVyZW07XG59XG4uY2hhdC1oZWFkZXItY29udGVudCAuaGVhZGVyLWxlZnQtc2VjdGlvbiAuYWdlbnQtaW5mbyB7XG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1sZWZ0LXNlY3Rpb24gLmFnZW50LWluZm8gLmFnZW50LW5hbWUge1xuICBmb250LXdlaWdodDogNjAwO1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1sZWZ0LXNlY3Rpb24gLmFnZW50LWluZm8gLmFnZW50LXN0YXR1cyB7XG4gIGZvbnQtc2l6ZTogMTJweDtcbn1cbi5jaGF0LWhlYWRlci1jb250ZW50IC5oZWFkZXItbGVmdC1zZWN0aW9uIC5zdGF0dXMtaW5kaWNhdG9yIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDQwcHg7XG4gIGxlZnQ6IDU0cHg7XG4gIHdpZHRoOiAxMHB4O1xuICBoZWlnaHQ6IDEwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgYm9yZGVyOiAycHggc29saWQgd2hpdGU7XG4gIGJhY2tncm91bmQtY29sb3I6IGdyYXk7XG59XG4uY2hhdC1oZWFkZXItY29udGVudCAuaGVhZGVyLWNvbnRyb2xzIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5jaGF0LWhlYWRlci1jb250ZW50IC5oZWFkZXItY29udHJvbHMgLmhlYWRlci1jb250cm9sLWJ0biB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICBib3JkZXI6IG5vbmU7XG4gIHBhZGRpbmc6IDhweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMnM7XG59XG4uY2hhdC1oZWFkZXItY29udGVudCAuaGVhZGVyLWNvbnRyb2xzIC5oZWFkZXItY29udHJvbC1idG46aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1jb250cm9scyAubWVudS1jb250YWluZXIge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uY2hhdC1oZWFkZXItY29udGVudCAuaGVhZGVyLWNvbnRyb2xzIC5tZW51LWNvbnRhaW5lciAubWVudS1kcm9wZG93biB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAxMDAlO1xuICByaWdodDogMDtcbiAgYmFja2dyb3VuZDogI2ZmZjtcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xuICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgbWluLXdpZHRoOiAxNjBweDtcbiAgei1pbmRleDogMTAwMDtcbiAgbWFyZ2luLXRvcDogNHB4O1xufVxuLmNoYXQtaGVhZGVyLWNvbnRlbnQgLmhlYWRlci1jb250cm9scyAubWVudS1jb250YWluZXIgLm1lbnUtZHJvcGRvd24uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbi5jaGF0LWhlYWRlci1jb250ZW50IC5oZWFkZXItY29udHJvbHMgLm1lbnUtY29udGFpbmVyIC5tZW51LWRyb3Bkb3duIC5jaGF0LWhlYWRlci1tZW51LWl0ZW0ge1xuICB3aWR0aDogMTAwJTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJvcmRlcjogbm9uZTtcbiAgcGFkZGluZzogOHB4IDE2cHg7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgY29sb3I6ICMwMDA7XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cbi5jaGF0LWhlYWRlci1jb250ZW50IC5oZWFkZXItY29udHJvbHMgLm1lbnUtY29udGFpbmVyIC5tZW51LWRyb3Bkb3duIC5jaGF0LWhlYWRlci1tZW51LWl0ZW06aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xufVxuXG4uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xufVxuXG4uc3RyLWNoYXRfX21lc3NhZ2UtaW5wdXQgLnN0ci1jaGF0X19zZW5kLWJ1dHRvbiBzdmcge1xuICB3aWR0aDogY2FsYyh2YXIoLS1zdHItY2hhdF9fc3BhY2luZy1weCkgKiAzMik7XG4gIGhlaWdodDogY2FsYyh2YXIoLS1zdHItY2hhdF9fc3BhY2luZy1weCkgKiAzMik7XG59XG5cbi5zdHItY2hhdCAqIHtcbiAgZm9udC1mYW1pbHk6IHZhcigtLXN0ci1jaGF0X19mb250LWZhbWlseSk7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG59XG5cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1hcHAgYSB7XG4gIGNvbG9yOiAtd2Via2l0LWxpbmsgIWltcG9ydGFudDtcbiAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLmNoYXQtYXBwIGE6dmlzaXRlZCB7XG4gIGNvbG9yOiAtd2Via2l0LWxpbmsgIWltcG9ydGFudDtcbiAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNtYXJ0LWJ1eS1jaGF0LWhlYWRlciB7XG4gIG1pbi1oZWlnaHQ6IDIuNXJlbTtcbiAgYm94LXNoYWRvdzogcmdiYSgwLCAwLCAwLCAwLjEpIDAgMnB4IDRweCAxcHggIWltcG9ydGFudDtcbn1cbi5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAuY2hhdC1oZWFkZXItY29udGVudCB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDIycHg7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDIycHg7XG59XG5AbWVkaWEgKG1pbi13aWR0aDogODAxcHgpIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpIHtcbiAgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci1jb250ZW50IHtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMjJweDtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAyMnB4O1xuICB9XG4gIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciAubWVzc2FnZS1jb250YWluZXIge1xuICAgIG1heC13aWR0aDogODAlO1xuICB9XG59XG5AbWVkaWEgKG1heC13aWR0aDogODAwcHgpIHtcbiAgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIC5jaGF0LWhlYWRlci1jb250ZW50IHtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMTRweDtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxNHB4O1xuICB9XG59XG4uc3VwZXItc2FsZXMtY2hhdC1jb250YWluZXIgLnNtYXJ0LWJ1eS1xdWljay1yZXBseSB7XG4gIGJhY2tncm91bmQtY29sb3I6IHVuc2V0ICFpbXBvcnRhbnQ7XG4gIGJvcmRlci13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gIGJvcmRlci1zdHlsZTogc29saWQgIWltcG9ydGFudDtcbn1cblxuQG1lZGlhIChtYXgtd2lkdGg6IDgwMHB4KSB7XG4gIC5zdXBlci1zYWxlcy1jaGF0LWNvbnRhaW5lciBidXR0b24uY2hhdC10b2dnbGUuY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uIC5jaGF0LXRpdGxlIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cbiAgLnN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyIGJ1dHRvbi5jaGF0LXRvZ2dsZS5jaGF0LXRvZ2dsZS0tdGV4dC1idXR0b24ge1xuICAgIHBhZGRpbmc6IDZweCAhaW1wb3J0YW50O1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJSAhaW1wb3J0YW50O1xuICB9XG59XG4vKiBNb2RhbCBvdmVybGF5IHRvIGRhcmtlbiB0aGUgYmFja2dyb3VuZCAqL1xuLm1vZGFsLW92ZXJsYXkge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB6LWluZGV4OiAxMDAwO1xuICBvdmVyZmxvdzogaGlkZGVuOyAvKiBQcmV2ZW50cyBzY3JvbGxpbmcgd2hlbiBtb2RhbCBpcyBvcGVuICovXG59XG5cbi8qIE1vZGFsIGNvbnRlbnQgZm9yIGZ1bGwtc2l6ZSBpbWFnZSAqL1xuLm1vZGFsLWNvbnRlbnQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIHBhZGRpbmc6IDEwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XG4gIG1heC13aWR0aDogOTB2dzsgLyogTGltaXQgd2lkdGggdG8gOTAlIG9mIHZpZXdwb3J0ICovXG4gIG1heC1oZWlnaHQ6IDkwdmg7IC8qIExpbWl0IGhlaWdodCB0byA5MCUgb2Ygdmlld3BvcnQgKi9cbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJveC1zaGFkb3c6IDBweCA0cHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi8qIEZ1bGwtc2l6ZSBpbWFnZSBpbnNpZGUgdGhlIG1vZGFsICovXG4uZnVsbC1zaXplLWltYWdlIHtcbiAgd2lkdGg6IGF1dG87XG4gIGhlaWdodDogYXV0bztcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiBFbnN1cmVzIHRoZSBpbWFnZSBzY2FsZXMgd2l0aGluIHRoZSBtb2RhbCB3aWR0aCAqL1xuICBtYXgtaGVpZ2h0OiAxMDAlOyAvKiBFbnN1cmVzIHRoZSBpbWFnZSBzY2FsZXMgd2l0aGluIHRoZSBtb2RhbCBoZWlnaHQgKi9cbiAgb2JqZWN0LWZpdDogY29udGFpbjsgLyogRW5zdXJlcyB0aGUgaW1hZ2UgZG9lc24ndCBnZXQgY3JvcHBlZCAqL1xuICBib3JkZXItcmFkaXVzOiA4cHg7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4vKiBDbG9zZSBidXR0b24gZm9yIHRoZSBtb2RhbCAqL1xuLm1vZGFsLWNsb3NlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDEwcHg7XG4gIHJpZ2h0OiAxMHB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgYm9yZGVyOiBub25lO1xuICBmb250LXNpemU6IDEuNXJlbTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogIzMzMztcbn1cblxuLm1vZGFsLWltYWdlLWNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1heC13aWR0aDogaW5oZXJpdDtcbiAgbWF4LWhlaWdodDogaW5oZXJpdDtcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvc21hcnQtYnV5LXN0eWxlcy5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGUuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy93aWRnZXQuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy92YXJzLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvc3RyZWFtLWNoYXQtb3ZlcnJpZGVzLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvc21hcnQtYnV5LW92ZXJyaWRlcy5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL21vZGFsLXN0eWxlcy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUlNO0VBQ0UsbUJBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxzQkFBQTtFQUNBLGNBQUE7RUFDQSxhQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsOEJBQUE7RUFDQSxpQkFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLHNCQUFBO0FDSFI7QURLUTtFQUNFLFNBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0FDSFY7QURNUTtFQUNFLFlBQUE7RUFDQSxXQUFBO0FDSlY7QURRTTtFQUNFLHNCQUFBO0VBQ0EseUJBQUE7RUFDQSxtQkFBQTtFQUNBLHNCQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0VBQ0EsY0FBQTtFQUNBLHdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSx5QkFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7QUNOUjtBRFVJO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsdUJBQUE7RUFDQSxZQUFBO0FDUk47QURXSTtFQUNFLGNBQUE7QUNUTjtBRFdNO0VBQ0UsZUFBQTtBQ1RSO0FEWU07RUFDRSxrQkFBQTtBQ1ZSO0FEZU07RUFDRSxzQkFBQTtFQUNBLG1CQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7RUFDQSxxREFBQTtFQUNBLDZDQUFBO0FDYlI7QURlUTtFQUNFLHlCQUFBO0VBQ0EscURBQUE7RUFDQSw2Q0FBQTtBQ2JWO0FEaUJNO0VBQ0UseUJBQUE7RUFDQSxtQkFBQTtFQUNBLG9CQUFBO0VBQ0EsaUJBQUE7QUNmUjtBRG9CRTtFQUNFLG9CQUFBO0FDbEJKO0FEcUJFO0VBQ0UsaUJBQUE7QUNuQko7QURxQkk7RUFDRSxvQkFBQTtBQ25CTjtBRHFCTTtFQUNFLFlBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0FDbkJSO0FEc0JNO0VBQ0UsbUJBQUE7QUNwQlI7QUR3Qkk7RUFDRSxtQkFBQTtBQ3RCTjtBRHlCSTtFQUNFLHNCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxrQkFBQTtFQUNBLGtCQUFBO0FDdkJOO0FEeUJNO0VBQ0UsYUFBQTtFQUNBLDJCQUFBO0VBQ0EsOEJBQUE7RUFDQSxnQkFBQTtBQ3ZCUjtBRDBCTTtFQUNFLHlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLGdCQUFBO0FDeEJSO0FEMEJRO0VBQ0UscUJBQUE7QUN4QlY7QUQ0Qk07RUFDRSxTQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsYUFBQTtFQUNBLHFCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtBQzFCUjtBRDRCUTtFQUNFLG1CQUFBO0FDMUJWO0FENkJRO0VBQ0UsY0FBQTtBQzNCVjtBRCtCTTtFQUNFLG9CQUFBO0VBQ0EsbUJBQUE7RUFDQSxlQUFBO0FDN0JSO0FEZ0NNO0VBQ0UsYUFBQTtBQzlCUjtBRGlDTTtFQUNFLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLGVBQUE7QUMvQlI7QURpQ1E7RUFDRSxhQUFBO0FDL0JWO0FEa0NRO0VBQ0Usb0JBQUE7RUFDQSxtQkFBQTtBQ2hDVjtBRG1DUTtFQUNFLFlBQUE7QUNqQ1Y7QURxQ007RUFDRSxvQkFBQTtFQUNBLG1CQUFBO0FDbkNSO0FEc0NNO0VBQ0UsY0FBQTtFQUNBLGVBQUE7RUFDQSxzQkFBQTtBQ3BDUjtBRHlDRTtFQUNFLGVBQUE7QUN2Q0o7QUQwQ0U7RUFDRSxtQkFBQTtFQUNBLGFBQUE7QUN4Q0o7QUQwQ0k7RUFDRSx5QkFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0FDeENOO0FEMkNJO0VBQ0UsZ0JBQUE7QUN6Q047QUQ2Q0U7RUFDRSxrQkFBQTtBQzNDSjtBRDhDRTtFQUNFLHVCQUFBO0FDNUNKO0FEK0NFO0VBQ0UsYUFBQTtFQUNBLGNBQUE7QUM3Q0o7QURnREU7RUFDRSx5QkFBQTtFQUNBLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLFVBQUE7QUM5Q0o7QURnREk7RUFDRSx3Q0FBQTtFQUNBLGlCQUFBO0VBQ0EsaUJBQUE7QUM5Q047QURpREk7RUFDRSx3Q0FBQTtFQUNBLGdCQUFBO0VBQ0EsaUJBQUE7QUMvQ047QURrREk7RUFDRSwwQ0FBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7QUNoRE47QURvREU7RUFDRTtJQUNFLHlCQUFBO0VDbERKO0VEcURFO0lBQ0UseUJBQUE7RUNuREo7RURzREU7SUFDRSx5QkFBQTtFQ3BESjtFRHVERTtJQUNFLHlCQUFBO0VDckRKO0FBQ0Y7QUR3REU7RUFDRTtJQUNFLHlCQUFBO0VDdERKO0VEeURFO0lBQ0UseUJBQUE7RUN2REo7RUQwREU7SUFDRSx5QkFBQTtFQ3hESjtFRDJERTtJQUNFLHlCQUFBO0VDekRKO0FBQ0Y7QUQ0REU7RUFDRTtJQUNFLHlCQUFBO0VDMURKO0VENkRFO0lBQ0UseUJBQUE7RUMzREo7RUQ4REU7SUFDRSx5QkFBQTtFQzVESjtFRCtERTtJQUNFLHlCQUFBO0VDN0RKO0FBQ0Y7QURnRUU7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSx1QkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLHdDQUFBO0VBQ0Esa0JBQUE7RUFDQSx3QkFBQTtFQUNBLHFCQUFBO0FDOURKO0FEZ0VJO0VBQ0UsYUFBQTtBQzlETjtBRGtFRTtFQUNFLGlEQUFBO0VBQ0EseUJBQUE7RUFDQSxrQkFBQTtFQUNBLHlCQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0FDaEVKO0FEbUVFO0VBQ0UsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsT0FBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7QUNqRUo7QURtRUk7RUFDRSxTQUFBO0VBQ0Esa0JBQUE7QUNqRU47QURtRU07RUFDRSx1QkFBQTtFQUNBLFVBQUE7QUNqRVI7QURxRUk7RUFDRSxZQUFBO0VBQ0EsV0FBQTtBQ25FTjtBRHVFRTtFQUNFLGtCQUFBO0VBQ0EsTUFBQTtBQ3JFSjtBRHdFRTtFQUNFLE9BQUE7RUFDQSxpQkFBQTtBQ3RFSjtBRHlFRTtFQUNFLHNCQUFBO0VBQ0EsbUJBQUE7RUFDQSxPQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsaUJBQUE7RUFDQSxTQUFBO0VBQ0Esa0JBQUE7RUFDQSxxQkFBQTtFQUNBLG9CQUFBO0VBQ0EscUJBQUE7RUFDQSxhQUFBO0VBQ0EsNEJBQUE7RUFDQSxvQkFBQTtFQUNBLGdCQUFBO0VBQ0EsdUJBQUE7QUN2RUo7QUQyRUk7RUFDRSx5QkFBQTtFQUNBLDBCQUFBO0FDekVOO0FENEVJO0VBQ0UsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLGFBQUE7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSx1QkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0EsV0FBQTtBQzFFTjtBRDRFTTtFQUNFLHlCQUFBO0VBQ0EscURBQUE7RUFDQSw2Q0FBQTtBQzFFUjtBRDZFTTtFQUNFLHlCQUFBO0VBQ0EsY0FBQTtBQzNFUjtBRDhFTTtFQUNFLHlCQUFBO0VBQ0EsbUJBQUE7RUFDQSxxREFBQTtFQUNBLDZDQUFBO0FDNUVSO0FEZ0ZJO0VBQ0UsbUJBQUE7RUFDQSx5QkFBQTtFQUNBLGtCQUFBO0VBQ0EsY0FBQTtFQUNBLGFBQUE7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSx1QkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0EscURBQUE7RUFDQSw2Q0FBQTtFQUNBLFdBQUE7QUM5RU47QURnRk07RUFDRSx5QkFBQTtFQUNBLHFEQUFBO0VBQ0EsNkNBQUE7QUM5RVI7QURpRk07RUFDRSxjQUFBO0FDL0VSO0FEaUZRO0VBQ0UsaUJBQUE7QUMvRVY7QURvRkk7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSwwQkFBQTtBQ2xGTjtBRHFGSTtFQUNFLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0Esc0JBQUE7RUFDQSxtQkFBQTtBQ25GTjtBRHNGSTtFQUNFLGVBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsMEJBQUE7QUNwRk47QUR1Rkk7RUFDRSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLHVCQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtFQUNBLGFBQUE7RUFDQSxXQUFBO0FDckZOO0FEdUZNO0VBQ0UseUJBQUE7RUFDQSxjQUFBO0FDckZSO0FEeUZJO0VBQ0UsbUJBQUE7RUFDQSx1QkFBQTtFQUNBLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLHVCQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtFQUNBLGFBQUE7RUFDQSxXQUFBO0FDdkZOO0FEeUZNO0VBQ0UseUJBQUE7RUFDQSxxREFBQTtFQUNBLDZDQUFBO0FDdkZSO0FEMEZNO0VBQ0UseUJBQUE7RUFDQSxjQUFBO0FDeEZSO0FEMkZNO0VBQ0UseUJBQUE7RUFDQSxjQUFBO0VBQ0EsaURBQUE7RUFDQSx5Q0FBQTtBQ3pGUjtBRDhGRTtFQUNFLG1CQUFBO0VBQ0EsY0FBQTtFQUNBLGFBQUE7RUFDQSw4QkFBQTtFQUNBLGlCQUFBO0VBQ0EsbUJBQUE7QUM1Rko7QUQ4Rkk7RUFDRSxXQUFBO0FDNUZOO0FEZ0dFO0VBQ0UsZUFBQTtFQUNBLGdCQUFBO0FDOUZKO0FEaUdFO0VBQ0UsY0FBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtFQUNBLGtCQUFBO0FDL0ZKO0FEa0dFO0VBQ0Usb0JBQUE7QUNoR0o7QURtR0U7RUFDRSxrQkFBQTtFQUNBLG9CQUFBO0FDakdKO0FEb0dFO0VBQ0UsdUJBQUE7QUNsR0o7QURxR0U7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7QUNuR0o7QURxR0k7RUFDRSwwQkFBQTtBQ25HTjtBRHVHRTtFQUNFLGVBQUE7QUNyR0o7QUR3R0U7RUFDRSxrQkFBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxpQkFBQTtFQUNBLFlBQUE7QUN0R0o7QUR5R0U7RUFDRSxlQUFBO0FDdkdKO0FEMEdFO0VBQ0UsdUJBQUE7RUFDQSxXQUFBO0VBQ0EsZUFBQTtFQUNBLHVCQUFBO0VBQ0EsMEJBQUE7QUN4R0o7QUQyR0U7RUFDRSxXQUFBO0FDekdKO0FENEdFO0VBQ0Usb0JBQUE7RUFDQSxjQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxrQkFBQTtBQzFHSjtBRDRHSTtFQUNFLDBCQUFBO0FDMUdOO0FENEdNO0VBQ0UsZUFBQTtBQzFHUjtBRCtHRTtFQUNFLGlEQUFBO0VBQ0EseUJBQUE7RUFDQSxrQkFBQTtFQUNBLHlCQUFBO0VBQ0EscUJBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxXQUFBO0FDN0dKO0FEZ0hFO0VBQ0UsV0FBQTtFQUNBLHFCQUFBO0FDOUdKO0FEZ0hJO0VBQ0UsbUJBQUE7RUFDQSxZQUFBO0FDOUdOO0FEa0hFO0VBQ0UscUJBQUE7QUNoSEo7QURtSEU7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtBQ2pISjtBRG9IRTtFQUNFLGNBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7QUNsSEo7QURxSEU7RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtBQ25ISjtBRHNIRTtFQUNFLDhCQUFBO0VBQ0Esa0JBQUE7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7RUFDQSxXQUFBO0FDcEhKO0FEc0hJO0VBQ0UscURBQUE7RUFDQSw2Q0FBQTtBQ3BITjtBRHVISTtFQUNFLHlCQUFBO0VBQ0EsY0FBQTtBQ3JITjtBRHdISTtFQUNFLFdBQUE7RUFDQSxxREFBQTtFQUNBLDZDQUFBO0FDdEhOO0FEMEhFO0VBQ0UsNEJBQUE7RUFDQSw2QkFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7QUN4SEo7QUQySEU7RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0FDekhKO0FEMkhJO0VBQ0UseUJBQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0FDekhOO0FENkhFO0VBQ0UsNEJBQUE7RUFDQSw2QkFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7QUMzSEo7QUQ4SEU7RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtBQzVISjtBRDhISTtFQUNFLHlCQUFBO0VBQ0Esc0JBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtBQzVITjtBRCtISTtFQUNFLGdCQUFBO0VBQ0EsaUJBQUE7QUM3SE47QURpSUU7RUFDRSxjQUFBO0VBQ0EsZUFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0FDL0hKO0FEa0lFO0VBQ0UsY0FBQTtFQUNBLGNBQUE7QUNoSUo7QURtSUU7RUFDRSxjQUFBO0VBQ0EsY0FBQTtBQ2pJSjtBRG1JSTtFQUNFLGtCQUFBO0FDaklOO0FEcUlFO0VBQ0Usa0JBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtBQ25JSjtBRHNJRTtFQUNFLHlCQUFBO0FDcElKO0FEc0lJO0VBQ0UsY0FBQTtBQ3BJTjtBRHdJRTtFQUNFLHlCQUFBO0FDdElKO0FEd0lJO0VBQ0UsY0FBQTtBQ3RJTjtBRDBJRTtFQUNFLHlCQUFBO0FDeElKO0FEMElJO0VBQ0UsY0FBQTtBQ3hJTjtBRDRJRTtFQUNFLHlCQUFBO0FDMUlKO0FENElJO0VBQ0UsY0FBQTtBQzFJTjtBRDhJRTtFQUNFLHlCQUFBO0FDNUlKO0FEOElJO0VBQ0UsY0FBQTtBQzVJTjtBRGdKRTtFQUNFLG1CQUFBO0VBQ0EseUJBQUE7RUFDQSxtQkFBQTtFQUNBLHFCQUFBO0VBQ0EscUJBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0FDOUlKO0FEZ0pJO0VBQ0Usd0JBQUE7RUFDQSxvQ0FBQTtFQUNBLGdCQUFBO0FDOUlOO0FEaUpJO0VBQ0UsY0FBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7QUMvSU47QURtSkU7RUFDRSxzQkFBQTtFQUNBLHlCQUFBO0FDakpKO0FEbUpJO0VBQ0UseUJBQUE7QUNqSk47QURxSkU7RUFDRSxvQkFBQTtFQUNBLHlCQUFBO0VBQ0EsbUJBQUE7QUNuSko7QURxSkk7RUFDRSw2QkFBQTtBQ25KTjtBRHdKSTtFQUNFLFlBQUE7RUFDQSxnQkFBQTtBQ3RKTjtBRHdKTTtFQUNFLG1CQUFBO0VBQ0EscUJBQUE7QUN0SlI7QUR5Sk07RUFDRSxnQkFBQTtBQ3ZKUjtBRDBKTTtFQUNFLFlBQUE7QUN4SlI7QUQ0Skk7RUFDRSxZQUFBO0VBQ0EsZUFBQTtBQzFKTjtBRDZKSTtFQUNFLHNCQUFBO0VBQ0EseUJBQUE7RUFDQSxVQUFBO0FDM0pOO0FEK0pFO0VBQ0UsYUFBQTtFQUNBLGNBQUE7QUM3Sko7QURnS0U7RUFDRSxnQkFBQTtFQUNBLHNCQUFBO0VBQ0EsUUFBQTtFQUNBLHdCQUFBO0VBQ0EsZ0JBQUE7QUM5Sko7QURpS0U7RUFDRSxvQkFBQTtFQUNBLHNCQUFBO0VBQ0Esd0JBQUE7QUMvSko7QURpS0k7RUFDRSxlQUFBO0FDL0pOO0FEb0tJO0VBQ0UsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLGNBQUE7QUNsS047QURzS0U7RUFDRSxtQkFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsYUFBQTtFQUNBLGdCQUFBO0FDcEtKO0FEc0tJO0VBQ0UsY0FBQTtFQUNBLFVBQUE7QUNwS047QUR3S0U7RUFDRSxvQkFBQTtBQ3RLSjtBRHlLRTtFQUNFLGNBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtFQUNBLGVBQUE7RUFDQSxrQkFBQTtBQ3ZLSjtBRDBLRTtFQUNFLG1CQUFBO0VBQ0EsY0FBQTtFQUNBLGdCQUFBO0VBQ0EseUJBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EscUJBQUE7RUFDQSxxQkFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLGlCQUFBO0FDeEtKO0FEMktFO0VBQ0UsY0FBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7QUN6S0o7QUQ0S0U7RUFDRSx5QkFBQTtFQUNBLHNCQUFBO0FDMUtKO0FENktFO0VBQ0UseUJBQUE7RUFDQSx3QkFBQTtBQzNLSjtBRDhLTTtFQUNFLGVBQUE7QUM1S1I7QUQrS007RUFDRSxzQkFBQTtFQUNBLHFCQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7QUM3S1I7QURnTE07RUFDRSxlQUFBO0FDOUtSO0FEaUxNO0VBQ0UsZ0JBQUE7QUMvS1I7QURvTEU7RUFDRSx3QkFBQTtBQ2xMSjtBRHFMRTtFQUNFLDBDQUFBO0FDbkxKO0FEc0xFO0VBQ0UsbUJBQUE7RUFDQSx3QkFBQTtBQ3BMSjtBRHVMRTtFQUNFLG1CQUFBO0VBQ0Esd0JBQUE7QUNyTEo7QUR3TE07RUFDRSxlQUFBO0FDdExSO0FEeUxNO0VBQ0UsZ0JBQUE7QUN2TFI7QUQ0TEU7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7QUMxTEo7QUQ2TEU7RUFDRSxtQkFBQTtBQzNMSjtBRDhMRTtFQUNFLHdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSx5QkFBQTtFQUNBLGtCQUFBO0VBQ0Esc0JBQUE7RUFDQSxhQUFBO0VBQ0EsV0FBQTtBQzVMSjtBRCtMRTtFQUNFLHlCQUFBO0VBQ0EsYUFBQTtBQzdMSjtBRGdNRTtFQUNFLHNCQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7QUM5TEo7QURnTUk7RUFDRSxlQUFBO0VBQ0EsMEJBQUE7QUM5TE47QURvTU07RUFDRSx5QkFBQTtFQUNBLDJCQUFBO0FDbE1SO0FEcU1NO0VBQ0UsY0FBQTtBQ25NUjtBRHdNTTtFQUNFLHlCQUFBO0VBQ0EsMkJBQUE7QUN0TVI7QUR5TU07RUFDRSxjQUFBO0FDdk1SO0FENE1FO0VBQ0Usa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxXQUFBO0FDMU1KO0FENE1JO0VBQ0UsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0EsVUFBQTtBQzFNTjtBRDZNSTtFQUNFLFNBQUE7RUFDQSxPQUFBO0VBQ0Esa0JBQUE7RUFDQSxRQUFBO0VBQ0EsTUFBQTtFQUNBLFVBQUE7QUMzTU47QUQ4TUk7RUFDRSx5QkFBQTtBQzVNTjtBRDhNTTtFQUNFLGNBQUE7QUM1TVI7QURnTkk7RUFDRSx1QkFBQTtBQzlNTjtBRGtORTtFQUNFLGlCQUFBO0VBQ0Esa0JBQUE7QUNoTko7QURtTkU7RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSx5QkFBQTtFQUNBLHVCQUFBO0VBQ0Esa0JBQUE7RUFDQSxTQUFBO0VBQ0EsWUFBQTtFQUNBLFVBQUE7QUNqTko7QURtTkk7RUFDRSx5QkFBQTtFQUNBLFdBQUE7QUNqTk47QURvTkk7RUFDRSx5QkFBQTtBQ2xOTjtBRHFOSTtFQUNFLHNCQUFBO0VBQ0EsNEJBQUE7RUFDQSxzQkFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSxrQkFBQTtFQUNBLFdBQUE7QUNuTk47QURxTk07RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtBQ25OUjtBRHFOUTtFQUNFLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxVQUFBO0FDbk5WO0FEc05RO0VBQ0UsY0FBQTtFQUNBLGVBQUE7QUNwTlY7QUR3Tk07RUFDRSxhQUFBO0VBQ0EsT0FBQTtBQ3ROUjtBRDJORTtFQUNFLGFBQUE7RUFDQSxPQUFBO0FDek5KO0FENE5FO0VBQ0UsT0FBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSw4QkFBQTtBQzFOSjtBRDZORTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLDhCQUFBO0VBQ0EsWUFBQTtBQzNOSjtBRDhORTtFQUNFLG1CQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtBQzVOSjtBRCtORTtFQUNFLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0FDN05KO0FEZ09FO0VBQ0UsZUFBQTtBQzlOSjtBRGlPRTtFQUNFLG1CQUFBO0VBQ0EsZ0JBQUE7QUMvTko7QURrT0U7RUFDRSxrQkFBQTtBQ2hPSjtBRG1PRTtFQUNFLHNCQUFBO0VBQ0Esb0JBQUE7QUNqT0o7QURvT0U7RUFDRSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxrQkFBQTtFQUNBLG1CQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7RUFDQSxXQUFBO0VBZ0JBLG1CQUFBO0VBQ0EsZ0JBQUE7QUNqUEo7QURrT0k7RUFDRSxtQ0FBQTtBQ2hPTjtBRG1PSTtFQUNFLG1CQUFBO0VBQ0EsWUFBQTtBQ2pPTjtBRG9PSTtFQUNFLFlBQUE7RUFDQSxhQUFBO0FDbE9OO0FEd09JO0VBQ0UsWUFBQTtBQ3RPTjtBRDBPRTtFQUNFLGlEQUFBO0VBQ0EseUJBQUE7RUFDQSxrQkFBQTtFQUNBLHlCQUFBO0VBQ0EscUJBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxXQUFBO0FDeE9KO0FEMk9FO0VBQ0Usc0JBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtBQ3pPSjtBRDRPRTtFQUNFLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxpQkFBQTtBQzFPSjtBRDRPSTtFQUNFLGNBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtBQzFPTjtBRDhPRTtFQUNFLGFBQUE7RUFDQSxPQUFBO0FDNU9KO0FEK09FO0VBQ0UsYUFBQTtFQUNBLE9BQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSw4QkFBQTtBQzdPSjtBRGdQRTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSw4QkFBQTtBQzlPSjtBRGlQRTtFQUNFLG1CQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtBQy9PSjtBRGtQRTtFQUNFLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0FDaFBKO0FEbVBFO0VBQ0UsZUFBQTtBQ2pQSjtBRG9QRTtFQUNFLG1CQUFBO0VBQ0EsZ0JBQUE7QUNsUEo7QURxUEU7RUFDRSxrQkFBQTtBQ25QSjtBRHNQRTtFQUNFLGNBQUE7QUNwUEo7QUR1UEU7RUFDRSxzQkFBQTtFQUNBLG9CQUFBO0FDclBKO0FEd1BFO0VBQ0UsbUJBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7RUFDQSxtQkFBQTtFQUNBLGNBQUE7RUFDQSxlQUFBO0VBQ0EsV0FBQTtFQWdCQSxtQkFBQTtFQUNBLGdCQUFBO0FDclFKO0FEc1BJO0VBQ0UsbUNBQUE7QUNwUE47QUR1UEk7RUFDRSxtQkFBQTtFQUNBLFlBQUE7QUNyUE47QUR3UEk7RUFDRSxZQUFBO0VBQ0EsYUFBQTtBQ3RQTjtBRDRQSTtFQUNFLFlBQUE7QUMxUE47QUQ4UEU7RUFDRSxpREFBQTtFQUNBLHlCQUFBO0VBQ0Esa0JBQUE7RUFDQSx5QkFBQTtFQUNBLHFCQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsV0FBQTtBQzVQSjtBRCtQRTtFQUNFLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUM3UEo7QURnUUU7RUFDRSxtQkFBQTtFQUNBLHlDQUFBO0VBQ0EsY0FBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLGNBQUE7RUFDQSxnQkFBQTtFQUNBLFdBQUE7RUFDQSx3QkFBQTtFQUNBLHFCQUFBO0FDOVBKO0FEZ1FJO0VBQ0UsYUFBQTtBQzlQTjtBRGlRSTtFQUNFLHNCQUFBO0FDL1BOO0FEbVFFO0VBQ0U7SUFDRSx5QkFBQTtJQUNBLDRCQUFBO0VDalFKO0FBQ0Y7QURvUUU7RUFDRSxnQkFBQTtFQUNBLGFBQUE7RUFDQSxTQUFBO0VBQ0EsWUFBQTtBQ2xRSjtBRHFRRTtFQUNFLHVCQUFBO0VBQ0EseUJBQUE7RUFDQSxjQUFBO0VBQ0EsYUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7QUNuUUo7QURxUUk7RUFDRSxTQUFBO0VBQ0EsZUFBQTtBQ25RTjtBRHVRRTtFQUNFLGFBQUE7QUNyUUo7QUR3UUU7RUFDRSxjQUFBO0FDdFFKO0FEeVFFO0VBQ0UsWUFBQTtFQUNBLFdBQUE7QUN2UUo7QUQwUUU7RUFDRSxpQkFBQTtBQ3hRSjtBRDJRRTtFQUNFLHVCQUFBO0FDelFKO0FENFFFO0VBQ0UsOEJBQUE7QUMxUUo7QUQ2UUU7RUFDRSxtQkFBQTtFQUNBLHNCQUFBO0VBQ0EsNEJBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxZQUFBO0VBQ0EsY0FBQTtFQUNBLGlCQUFBO0VBQ0Esb0JBQUE7QUMzUUo7QUQ4UUU7RUFDRSx1QkFBQTtBQzVRSjtBRCtRRTtFQUNFLGVBQUE7RUFDQSxnQkFBQTtBQzdRSjtBRGdSRTtFQUNFLGdDQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSxzQkFBQTtBQzlRSjtBRGdSSTtFQUNFLFNBQUE7RUFDQSxpQkFBQTtBQzlRTjtBRGtSRTtFQUNFLGNBQUE7RUFDQSxjQUFBO0VBQ0EsZ0JBQUE7RUFDQSxxQkFBQTtFQUNBLGtCQUFBO0FDaFJKO0FEbVJFO0VBQ0UsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLHlDQUFBO0VBQ0EsbUJBQUE7RUFDQSwwQ0FBQTtFQUNBLFdBQUE7RUFDQSxhQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQkFBQTtFQUNBLFdBQUE7QUNqUko7QURtUkk7RUFDRSx5Q0FBQTtBQ2pSTjtBRG9SSTtFQUNFLGlCQUFBO0FDbFJOO0FEdVJJO0VBQ0UsZUFBQTtFQUNBLGdCQUFBO0FDclJOO0FEd1JJO0VBQ0UsdUJBQUE7QUN0Uk47QUR5Ukk7RUFDRSx1QkFBQTtBQ3ZSTjtBRDJSRTtFQUNFLGlGQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLHNEQUFBO0VBRUEsdUJBQUE7QUMxUko7QUQ0Ukk7RUFDRSxnQkFBQTtBQzFSTjtBRDZSSTtFQUNFLG1CQUFBO0VBQ0EsYUFBQTtFQUNBLHdCQUFBO0FDM1JOO0FEOFJJO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLHVCQUFBO0VBQ0Esa0JBQUE7RUFDQSx1QkFBQTtBQzVSTjtBRDhSTTtFQUNFLGdCQUFBO0FDNVJSO0FEK1JNO0VBQ0UsYUFBQTtBQzdSUjtBRGlTSTtFQUNFLGFBQUE7RUFDQSxxQkFBQTtBQy9STjtBRGlTTTtFQUNFLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0FDL1JSO0FEa1NNO0VBQ0Usa0JBQUE7QUNoU1I7QURrU1E7RUFDRSxZQUFBO0VBQ0EsV0FBQTtBQ2hTVjtBRHFTSTtFQUNFLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLGlCQUFBO0VBQ0EsU0FBQTtFQUNBLGdCQUFBO0VBQ0EsbUJBQUE7RUFDQSx5QkFBQTtBQ25TTjtBRHNTSTtFQUNFLHVCQUFBO0FDcFNOO0FEc1NNO0VBQ0Usc0JBQUE7QUNwU1I7QUR5U0U7RUFDRSxtQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7QUN2U0o7QUR5U0k7RUFDRSxzQkFBQTtFQUNBLGdCQUFBO0VBQ0EsU0FBQTtFQUNBLGlCQUFBO0VBQ0EsWUFBQTtBQ3ZTTjtBRDJTRTtFQUNFLG1CQUFBO0VBQ0EsZ0JBQUE7RUFDQSxzQkFBQTtFQUNBLHVCQUFBO0VBQ0EsZUFBQTtFQUNBLGtCQUFBO0FDelNKO0FEMlNJO0VBQ0UsV0FBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7QUN6U047QUQ0U0k7RUFDRSxjQUFBO0VBQ0EsZ0JBQUE7QUMxU047QUQ4U0U7RUFDRSxXQUFBO0FDNVNKO0FEK1NFO0VBQ0UsWUFBQTtFQUNBLGtCQUFBO0VBQ0EsV0FBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0FDN1NKO0FEZ1RFO0VBQ0U7SUFDRSxZQUFBO0VDOVNKO0VEaVRFO0lBQ0UsVUFBQTtFQy9TSjtBQUNGO0FEa1RFO0VBQ0U7SUFDRSxnQkFBQTtFQ2hUSjtFRG1URTtJQUNFLG9CQUFBO0VDalRKO0FBQ0Y7QURvVEU7RUFDRTtJQUNFLHVCQUFBO0VDbFRKO0VEcVRFO0lBQ0Usd0JBQUE7RUNuVEo7QUFDRjtBRHNURTtFQUNFO0lBQ0UsVUFBQTtJQUNBLDhCQUFBO0VDcFRKO0VEdVRFO0lBQ0UsVUFBQTtJQUNBLHdCQUFBO0VDclRKO0FBQ0Y7QUR5VUU7RUFDRSxTQUFBO0VBQ0Esa0JBQUE7QUN2VUo7QUQwVUU7RUFDRSwwQkFBQTtBQ3hVSjtBRDJVRTtFQUNFLHNCQUFBO0FDelVKO0FENFVFO0VBQ0Usa0pBQUE7RUFDQSxvQkFBQTtFQUNBLGtCQUFBO0VBQ0EsaUJBQUE7RUFDQSxtQkFBQTtFQUNBLG9CQUFBO0VBQ0EsbUNBQUE7QUMxVUo7QUQ0VUk7RUFDRSx1QkFBQTtFQUNBLDBCQUFBO0VBQ0EsOEJBQUE7QUMxVU47QUQ2VUk7RUFDRSxTQUFBO0FDM1VOO0FEOFVJO0VBQ0UsY0FBQTtBQzVVTjtBRCtVSTtFQUNFLHFCQUFBO0VBQ0Esd0JBQUE7QUM3VU47QURnVkk7RUFDRSxhQUFBO0VBQ0EsU0FBQTtBQzlVTjtBRGlWSTtFQUNFLGFBQUE7QUMvVU47QURrVkk7RUFDRSw2QkFBQTtBQ2hWTjtBRGtWTTtFQUNFLFVBQUE7QUNoVlI7QURvVkk7RUFDRSx5QkFBQTtBQ2xWTjtBRHFWSTtFQUNFLGdCQUFBO0FDblZOO0FEc1ZJO0VBQ0Usa0JBQUE7QUNwVk47QUR1Vkk7RUFDRSxjQUFBO0VBQ0EsZ0JBQUE7QUNyVk47QUR3Vkk7RUFDRSxnQkFBQTtFQUNBLFdBQUE7QUN0Vk47QUR5Vkk7RUFDRSxjQUFBO0FDdlZOO0FEMFZJO0VBQ0UsY0FBQTtFQUNBLGNBQUE7RUFDQSxrQkFBQTtFQUNBLHdCQUFBO0FDeFZOO0FEMlZJO0VBQ0UsY0FBQTtFQUNBLGNBQUE7RUFDQSxrQkFBQTtFQUNBLHdCQUFBO0VBQ0EsV0FBQTtBQ3pWTjtBRDRWSTtFQUNFLGVBQUE7QUMxVk47QUQ2Vkk7RUFDRSxTQUFBO0FDM1ZOO0FEOFZJO0VBQ0UsZ0JBQUE7QUM1Vk47QUQrVkk7RUFDRSxnQkFBQTtBQzdWTjtBRGdXSTtFQUNFLHVCQUFBO0VBQ0EsU0FBQTtBQzlWTjtBRGlXSTtFQUNFLGNBQUE7QUMvVk47QURrV0k7RUFDRSxpQ0FBQTtFQUNBLGNBQUE7QUNoV047QURtV0k7RUFDRSxjQUFBO0VBQ0EsYUFBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0FDaldOO0FEb1dJO0VBQ0UsaUJBQUE7RUFDQSxvQkFBQTtBQ2xXTjtBRHFXSTtFQUNFLG9CQUFBO0FDbldOO0FEc1dJO0VBQ0UsMEJBQUE7RUFDQSxlQUFBO0FDcFdOO0FEd1dNO0VBQ0UsMEJBQUE7RUFDQSxlQUFBO0FDdFdSO0FEMFdJO0VBQ0UsZUFBQTtBQ3hXTjtBRDJXSTtFQUNFLFNBQUE7RUFDQSxVQUFBO0FDeldOO0FENFdJO0VBTUUsbUJBQUE7QUMvV047QUQwV007RUFDRSxTQUFBO0VBQ0EsVUFBQTtBQ3hXUjtBRDZXTTtFQUNFLHNCQUFBO0VBQ0EsVUFBQTtBQzNXUjtBRCtXUTtFQUNFLFlBQUE7QUM3V1Y7QURpWE07RUFDRSw2QkFBQTtFQUNBLHVCQUFBO0FDL1dSO0FEaVhRO0VBQ0Usd0JBQUE7QUMvV1Y7QURvWEk7RUFDRSx3QkFBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0FDbFhOO0FEcVhJO0VBQ0UsU0FBQTtFQUNBLFVBQUE7QUNuWE47QURzWEk7RUFDRSxjQUFBO0FDcFhOO0FEdVhJO0VBQ0UsZ0JBQUE7QUNyWE47QUR3WEk7RUFDRSx5QkFBQTtFQUNBLGlCQUFBO0FDdFhOO0FEeVhJO0VBQ0UsVUFBQTtBQ3ZYTjtBRDBYSTtFQUNFLG1CQUFBO0VBQ0EseUJBQUE7RUFDQSxvQ0FBQTtFQUNBLGtCQUFBO0VBQ0EsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxXQUFBO0FDeFhOO0FEMlhJO0VBQ0UsaUJBQUE7QUN6WE47QUQ4WEk7RUFDRSx5QkFBQTtFQUNBLDRCQUFBO0FDNVhOO0FEK1hJO0VBQ0UsYUFBQTtBQzdYTjtBRGlZRTtFQUNFLFNBQUE7QUMvWEo7QURpWUk7RUFDRSxRQUFBO0VBQ0EsU0FBQTtBQy9YTjtBRG1ZRTtFQUNFLHlCQUFBO0FDallKO0FEb1lFO0VBQ0UseUJBQUE7QUNsWUo7QURxWUU7RUFDRSx5QkFBQTtBQ25ZSjtBRHNZRTtFQUNFLHlCQUFBO0FDcFlKO0FEdVlFO0VBQ0UseUJBQUE7QUNyWUo7QUR3WUU7RUFDRSx5QkFBQTtBQ3RZSjtBRHlZRTtFQUNFLHlCQUFBO0FDdllKO0FEMFlFO0VBQ0UseUJBQUE7QUN4WUo7QUQyWUU7RUFDRSx5QkFBQTtBQ3pZSjtBRDRZRTtFQUNFLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7QUMxWUo7QUQ0WUk7RUFDRSw2QkFBQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0VBQ0EsYUFBQTtFQUNBLFdBQUE7QUMxWU47QUQ0WU07RUFDRSxjQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUMxWVI7QUQ0WVE7RUFDRSxrQkFBQTtBQzFZVjtBRDhZTTtFQUNFLGVBQUE7RUFDQSxjQUFBO0FDNVlSO0FEK1lNO0VBQ0UsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsdUJBQUE7QUM3WVI7QUQrWVE7RUFDRSxZQUFBO0FDN1lWO0FEaVpNO0VBQ0UsbUJBQUE7RUFDQSxZQUFBO0VBQ0EsbUJBQUE7RUFDQSx1Q0FBQTtFQUNBLG1CQUFBO0VBQ0EsYUFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxzQkFBQTtFQUNBLHFCQUFBO0VBQ0EsV0FBQTtBQy9ZUjtBRHFaUTtFQUNFLFlBQUE7RUFDQSxlQUFBO0FDblpWO0FEc1pRO0VBQ0UsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxtQkFBQTtBQ3BaVjtBRHNaVTtFQUNFLGtCQUFBO0FDcFpaO0FEdVpVO0VBQ0Usa0JBQUE7QUNyWlo7QUR3WlU7RUFDRSxrQkFBQTtBQ3RaWjtBRHlaVTtFQUNFLGVBQUE7QUN2Wlo7QUQwWlU7RUFDRSxrQkFBQTtBQ3haWjtBRCtaRTtFQUNFO0lBQ0UsbUJBQUE7SUFDQSxhQUFBO0lBQ0EsWUFBQTtJQUNBLGlCQUFBO0VDN1pKO0FBQ0Y7QURnYUU7RUFDRSx5QkFBQTtFQUNBLG9DQUFBO0FDOVpKO0FEaWFFO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUMvWko7QURrYUU7RUFDRSxjQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtBQ2hhSjtBRG1hRTtFQUNFLGNBQUE7RUFDQSxlQUFBO0FDamFKO0FEb2FFO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtBQ2xhSjtBRHFhRTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLG1CQUFBO0FDbmFKO0FEcWFJO0VBQ0UsZ0JBQUE7QUNuYU47QURzYUk7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7QUNwYU47QUR1YUk7RUFDRSx3QkFBQTtFQUNBLHlCQUFBO0VBQ0EsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0FDcmFOO0FEdWFNO0VBQ0UsY0FBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0FDcmFSO0FEd2FNO0VBQ0UsYUFBQTtBQ3RhUjtBRDJhRTtFQUNFLHNCQUFBO0VBQ0EsbUJBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxZQUFBO0VBQ0EseUJBQUE7RUFDQSxnQkFBQTtFQUNBLG9CQUFBO0FDemFKO0FENGFFO0VBQ0Usd0JBQUE7RUFDQSxTQUFBO0FDMWFKO0FENmFFO0VBQ0Usa0JBQUE7QUMzYUo7QUQ4YUU7RUFDRSxjQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0FDNWFKO0FEK2FFO0VBQ0UscUJBQUE7RUFDQSxVQUFBO0FDN2FKO0FEZ2JFO0VBQ0UsbUJBQUE7RUFDQSxtQkFBQTtFQUNBLG1CQUFBO0VBQ0EsY0FBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0FDOWFKO0FEZ2JJO0VBQ0UsaUJBQUE7RUFDQSxnQkFBQTtFQUNBLFdBQUE7QUM5YU47QURrYkU7RUFDRSxXQUFBO0FDaGJKO0FEbWJFO0VBQ0UsNEJBQUE7RUFDQSw2QkFBQTtFQUNBLGFBQUE7RUFDQSxZQUFBO0VBQ0EsOEJBQUE7RUFDQSxhQUFBO0VBQ0EsVUFBQTtBQ2piSjtBRG1iSTtFQUNFLG1CQUFBO0FDamJOO0FEb2JJO0VBQ0UsZUFBQTtBQ2xiTjtBRHNiRTtFQUNFLGdCQUFBO0FDcGJKO0FEdWJFO0VBQ0UsY0FBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0FDcmJKO0FEd2JFO0VBQ0Usc0JBQUE7RUFDQSwrQkFBQTtFQUNBLGdDQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtBQ3RiSjtBRHliRTtFQUNFLHlCQUFBO0VBQ0EsY0FBQTtFQUNBLGFBQUE7RUFDQSxlQUFBO0VBQ0EsdUJBQUE7RUFDQSxjQUFBO0FDdmJKO0FEMGJFO0VBQ0UsZ0JBQUE7QUN4Yko7QUQyYkU7RUFDRSx5QkFBQTtBQ3piSjtBRDRiRTtFQUNFLGlCQUFBO0FDMWJKO0FENmJFO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSx5QkFBQTtFQUNBLGtCQUFBO0VBQ0Esd0NBQUE7RUFDQSx3QkFBQTtFQUNBLHFCQUFBO0FDM2JKO0FENmJJO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0FDM2JOO0FEK2JFO0VBQ0Usc0JBQUE7RUFDQSxhQUFBO0VBQ0Esd0JBQUE7RUFDQSxTQUFBO0VBQ0Esa0JBQUE7RUFDQSw0QkFBQTtFQUNBLFVBQUE7RUFDQSxrQkFBQTtFQUNBLHdDQUFBO0VBQ0Esd0JBQUE7RUFDQSxxQkFBQTtBQzdiSjtBRCtiSTtFQUNFLGFBQUE7QUM3Yk47QURnY0k7RUFDRSx3QkFBQTtFQUNBLHFDQUFBO0VBQ0Esb0JBQUE7QUM5Yk47QURrY0U7RUFDRSxjQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZ0JBQUE7QUNoY0o7QURtY0U7RUFDRSxjQUFBO0VBQ0EsaUJBQUE7RUFDQSx5QkFBQTtFQUNBLGdCQUFBO0VBQ0EscUJBQUE7RUFDQSxxQkFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtBQ2pjSjtBRHFjSTtFQUNFLDRCQUFBO0VBQ0EsNkJBQUE7QUNuY047QURzY0k7RUFDRSxhQUFBO0FDcGNOO0FEdWNRO0VBQ0UsZ0JBQUE7QUNyY1Y7QUR3Y1E7RUFDRSxnQkFBQTtFQUNBLGlCQUFBO0FDdGNWO0FEMmNJO0VBQ0Usb0JBQUE7RUFDQSxtQkFBQTtBQ3pjTjtBRDRjSTtFQUNFLGtCQUFBO0VBQ0EsZUFBQTtBQzFjTjs7QUN0NkRBO0VBQ0UsZUFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0VBQ0EseUJBQUE7RUFDQSxXQUFBO0VBQ0Esa0JBQUE7RUFDQSxtQkFBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0FEeTZERjtBQ3Y2REU7RUFDRSxhQUFBO0FEeTZESjs7QUNyNkRBO0VBQ0UsMkJBQUE7RUFDQSxtQkFBQTtFQUNBLGVBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtFQUNBLFVBQUE7RUFDQSxXQUFBO0VBQ0EsaUJBQUE7RUFDQSxtQkFBQTtFQUNBLHNCQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsdUNBQUE7RUFDQSxhQUFBO0FEdzZERjtBQ3Q2REU7RUFDRSxhQUFBO0FEdzZESjs7QUNwNkRBO0VBQ0Usa0NBQUE7RUFDQSxXQUFBO0FEdTZERjs7QUNwNkRBO0VBQ0UscUJBQUE7RUFDQSxXQUFBO0FEdTZERjs7QUNwNkRBO0VBQ0UsYUFBQTtBRHU2REY7O0FDbjZEQTtFQUNFO0lBQ0UsYUFBQTtFRHM2REY7RUNwNkRBO0lBQ0UsdUJBQUE7SUFDQSxzQkFBQTtJQUNBLHFCQUFBO0lBQ0EsbUNBQUE7SUFDQSxzQ0FBQTtJQUNBLDhCQUFBO0VEczZERjtFQ3A2REU7SUFDRSxtQ0FBQTtJQUNBLHNDQUFBO0VEczZESjtFQ242REU7SUFDRSxtQ0FBQTtJQUNBLHNDQUFBO0VEcTZESjtFQ2o2REE7SUFDRSxzQkFBQTtFRG02REY7RUNqNkRFO0lBQ0Usc0JBQUE7RURtNkRKO0VDaDZERTtJQUNFLHNCQUFBO0VEazZESjtBQUNGO0FDNzVEQTtFQUNFO0lBQ0UsYUFBQTtFRCs1REY7RUM3NURBO0lBQ0Usa0NBQUE7SUFDQSwyQkFBQTtFRCs1REY7RUM3NURFO0lBQ0Usa0NBQUE7RUQrNURKO0VDNTVERTtJQUNFLGtDQUFBO0VEODVESjtFQzE1REE7SUFDRSxzQkFBQTtFRDQ1REY7RUMxNURFO0lBQ0Usc0JBQUE7RUQ0NURKO0VDejVERTtJQUNFLHNCQUFBO0VEMjVESjtBQUNGO0FDcjVEQTtFQUNFLGdCQUFBO0VBQ0EseUJBQUE7RUFDQSxXQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxlQUFBO0VBQ0EsNkJBQUE7RUFDQSw0QkFBQTtFQUNBLGlCQUFBO0FEdTVERjs7QUNwNURBO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsT0FBQTtFQUNBLGFBQUE7RUFDQSxnQkFBQTtBRHU1REY7O0FDcDVEQTtFQUNFLG1CQUFBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EscUJBQUE7QUR1NURGOztBQ3A1REE7RUFDRSxhQUFBO0VBQ0EsbUJBQUE7QUR1NURGOztBQ3A1REE7RUFDRSxrQkFBQTtFQUNBLGlCQUFBO0VBQ0EsY0FBQTtBRHU1REY7O0FDcDVEQTtFQUNFLFdBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7RUFDQSxpQkFBQTtBRHU1REY7O0FDcDVEQTtFQUNFLGFBQUE7RUFDQSxpQkFBQTtFQUNBLGNBQUE7RUFDQSxvQkFBQTtFQUNBLHlCQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtBRHU1REY7O0FDcDVEQTtFQUNFLHNCQUFBO0VBQ0EseUJBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsY0FBQTtBRHU1REY7O0FDcDVEQTtFQUNFLG9CQUFBO0VBQ0EsZUFBQTtBRHU1REY7O0FDcDVEQTtFQUNFLGFBQUE7RUFDQSxxQkFBQSxFQUFBLG9DQUFBO0VBQ0EsWUFBQTtBRHU1REY7QUNyNURFO0VBQ0UsYUFBQTtBRHU1REo7O0FDbjVEQTtFQUNFLHdCQUFBO0FEczVERjs7QUNuNURBO0VBQ0UsMkJBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxpQkFBQSxFQUFBLHdDQUFBO0VBQ0Esc0JBQUEsRUFBQSw2Q0FBQTtFQUNBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQSxFQUFBLGlEQUFBO0VBQ0EsaUJBQUE7RUFDQSxvQkFBQSxFQUFBLDJCQUFBO0VBQ0Esa0JBQUEsRUFBQSxnQ0FBQTtFQUNBLHNCQUFBO0FEczVERjtBQ3A1REU7RUFDRSxzQkFBQTtBRHM1REo7QUNuNURFO0VBQ0Usc0JBQUE7QURxNURKOztBQ2o1REE7RUFDRSxvQkFBQSxFQUFBLG1DQUFBO0VBQ0Esa0JBQUE7RUFDQSx1QkFBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtBRG81REY7O0FDajVEQTtFQUNFLGdCQUFBO0VBQ0EsY0FBQTtBRG81REY7O0FDajVEQTtFQUNFLGFBQUE7RUFDQSxtQkFBQTtFQUNBLHVCQUFBO0VBQ0EsYUFBQTtFQUNBLGVBQUE7RUFDQSxXQUFBO0VBQ0EsYUFBQTtBRG81REY7O0FDaDVERTtFQUNFLDBCQUFBO0VBQ0EsbUJBQUE7RUFDQSxvQkFBQTtFQUNBLHdCQUFBO0FEbTVESjtBQ2g1REU7RUFDRSwyQkFBQTtFQUNBLDZCQUFBO0FEazVESjtBQy80REU7RUFDRSw0QkFBQTtBRGk1REo7QUM5NERFO0VBQ0UsbUJBQUE7RUFDQSx5QkFBQTtFQUNBLG9DQUFBO0VBQ0Esa0JBQUE7RUFDQSxhQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsWUFBQTtFQUNBLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7RUFDQSx5QkNoTmlCO0VEaU5qQixXQ2pSTztBRmlxRVg7QUM1NERFO0VBQ0Usc0JBQUE7RUFDQSw0QkFBQTtFQUNBLHVCQUFBO0VBQ0Esa0NBQUE7RUFDQSwyQkFBQTtFQUNBLDBCQUFBO0VBQ0EsMEJBQUE7RUFDQSxzQkFBQTtFQUNBLDRDQUFBO0FEODRESjs7QUN6NERBLHlCQUFBO0FBQ0E7RUFDRSxhQUFBO0VBQ0EsZUFBQTtFQUNBLFNBQUE7QUQ0NERGOztBQ3o0REEsa0NBQUE7QUFDQTtFQUNFLFlBQUE7RUFDQSxhQUFBO0VBQ0EsYUFBQTtFQUNBLHVCQUFBO0VBQ0EsbUJBQUE7RUFDQSx5QkFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtBRDQ0REY7O0FDejREQSxvQkFBQTtBQUNBO0VBQ0Usd0JBQUE7RUFDQSx5QkFBQSxFQUFBLGVBQUE7RUFDQSw2QkFBQSxFQUFBLFNBQUE7RUFDQSxrQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0Esa0NBQUE7RUFDQSxZQUFBO0FENDRERjs7QUN6NERBLDBCQUFBO0FBQ0E7RUFDRTtJQUNFLHVCQUFBO0VENDRERjtFQzE0REE7SUFDRSx5QkFBQTtFRDQ0REY7QUFDRjtBQ3o0REEsb0JBQUE7QUFDQTtFQUNFLFdBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtFQUNBLGVBQUE7QUQyNERGOztBQ3g0REE7RUFDRSxrQkFBQTtFQUNBLGNBQUE7QUQyNERGOztBQ3g0REE7RUFDRSxpQkFBQTtFQUNBLGVBQUE7QUQyNERGOztBQ3g0REE7RUFDRSw2QkFBQTtBRDI0REY7O0FDeDREQTtFQUNFLGVBQUE7RUFDQSxhQUFBO0VBQ0EsdUJBQUE7RUFDQSwrQkFBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLHdCQUFBO0FEMjRERjtBQ3o0REU7RUFDRSxrQ0FBQTtBRDI0REo7O0FDdjREQTtFQUNFLGFBQUE7RUFDQSxtQkFBQTtFQUNBLGlCQUFBO0VBQ0EsNkJBQUE7RUFDQSw4QkFBQTtBRDA0REY7QUN4NERFO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0FEMDRESjtBQ3g0REk7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxtQkFBQTtBRDA0RE47QUN4NERNO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxrQkFBQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7QUQwNERSO0FDdDRESTtFQUNFLGlCQUFBO0FEdzRETjtBQ3Q0RE07RUFDRSxnQkFBQTtBRHc0RFI7QUNyNERNO0VBQ0UsZUFBQTtBRHU0RFI7QUNuNERJO0VBQ0Usa0JBQUE7RUFDQSxTQUFBO0VBQ0EsVUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7RUFDQSx1QkFBQTtFQUNBLHNCQUFBO0FEcTRETjtBQ2o0REU7RUFDRSxhQUFBO0VBQ0EsbUJBQUE7QURtNERKO0FDajRESTtFQUNFLHVCQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0EsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsdUJBQUE7RUFDQSxrQkFBQTtFQUNBLGlDQUFBO0FEbTRETjtBQ2o0RE07RUFDRSxxQ0FBQTtBRG00RFI7QUMvM0RJO0VBQ0Usa0JBQUE7QURpNEROO0FDLzNETTtFQUNFLGtCQUFBO0VBQ0EsU0FBQTtFQUNBLFFBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0EseUNBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7RUFDQSxlQUFBO0FEaTREUjtBQy8zRFE7RUFDRSxhQUFBO0FEaTREVjtBQzkzRFE7RUFDRSxXQUFBO0VBQ0EsNkJBQUE7RUFDQSxZQUFBO0VBQ0EsaUJBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSxXQUFBO0VBQ0EsZUFBQTtBRGc0RFY7QUM5M0RVO0VBQ0UscUNBQUE7QURnNERaOztBQ3gzREE7RUFDRSx3QkFBQTtBRDIzREY7O0FHcjJFQTtFQUNFLDZDQUFBO0VBQ0EsOENBQUE7QUh3MkVGOztBR3AyRUE7RUFDRSx5Q0FBQTtFQUNBLHNCQUFBO0FIdTJFRjs7QUk1MkVJO0VBQ0UsOEJBQUE7RUFDQSwwQkFBQTtBSisyRU47QUk1MkVJO0VBQ0UsOEJBQUE7RUFDQSwwQkFBQTtBSjgyRU47QUkxMkVFO0VBQ0Usa0JBQUE7RUFDQSx1REFBQTtBSjQyRUo7QUl6MkVFO0VBQ0UsZUFBQTtFQUNBLDZCQUFBO0VBQ0EsNEJBQUE7QUoyMkVKO0FJeDJFRTtFQUNFO0lBQ0UsNkJBQUE7SUFDQSw0QkFBQTtFSjAyRUo7RUl2MkVFO0lBQ0UsY0FBQTtFSnkyRUo7QUFDRjtBSXQyRUU7RUFDRTtJQUNFLDZCQUFBO0lBQ0EsNEJBQUE7RUp3MkVKO0FBQ0Y7QUlqMkVFO0VBQ0Usa0NBQUE7RUFDQSw0QkFBQTtFQUNBLDhCQUFBO0FKbTJFSjs7QUkvMUVBO0VBQ0U7SUFDRSx3QkFBQTtFSmsyRUY7RUkvMUVBO0lBQ0UsdUJBQUE7SUFDQSw2QkFBQTtFSmkyRUY7QUFDRjtBSy81RUEsMkNBQUE7QUFDQTtFQUNFLGVBQUE7RUFDQSxNQUFBO0VBQ0EsT0FBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0VBQ0Esb0NBQUE7RUFDQSxhQUFBO0VBQ0EsdUJBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxnQkFBQSxFQUFBLDBDQUFBO0FMaTZFRjs7QUs5NUVBLHNDQUFBO0FBQ0E7RUFDRSxrQkFBQTtFQUNBLHNCQUFBO0VBQ0EsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQSxFQUFBLG1DQUFBO0VBQ0EsZ0JBQUEsRUFBQSxvQ0FBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBQ0EsMkNBQUE7RUFDQSxnQkFBQTtBTGk2RUY7O0FLOTVFQSxxQ0FBQTtBQUNBO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxlQUFBLEVBQUEsb0RBQUE7RUFDQSxnQkFBQSxFQUFBLHFEQUFBO0VBQ0EsbUJBQUEsRUFBQSwwQ0FBQTtFQUNBLGtCQUFBO0VBQ0EsY0FBQTtBTGk2RUY7O0FLOTVFQSwrQkFBQTtBQUNBO0VBQ0Usa0JBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtFQUNBLDZCQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsZUFBQTtFQUNBLFdBQUE7QUxpNkVGOztBSzk1RUE7RUFDRSxhQUFBO0VBQ0Esa0JBQUE7RUFDQSxtQkFBQTtBTGk2RUZcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[0].use[2]!./src/style.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz9jNmFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2Y1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        crypto: {randomUUID: function() {throw Error('unsupported');}},\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            createElement: function() { return {}; },\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _set_prototype_of(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _is_native_function(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _wrap_native_super(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrap_native_super = function wrapNativeSuper(Class) {\n        if (Class === null || !_is_native_function(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _get_prototype_of(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _set_prototype_of(Wrapper, Class);\n    };\n    return _wrap_native_super(Class);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nfunction _create_for_of_iterator_helper_loose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) {\n                return {\n                    done: true\n                };\n            }\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction _ts_values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField = function(obj, key, value) {\n    return __defNormalProp(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar _a;\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1 = function(obj, key, value) {\n    return __defNormalProp$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar NodeType$3 = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType$3 || {});\nvar testableAccessors$1 = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods$1 = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype$1 = {};\nvar isAngularZonePresent$1 = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype$1(key) {\n    if (untaintedBasePrototype$1[key]) return untaintedBasePrototype$1[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {\n        untaintedBasePrototype$1[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype$1[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache$1 = {};\nfunction getUntaintedAccessor$1(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache$1[cacheKey]) return untaintedAccessorCache$1[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache$1[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache$1 = {};\nfunction getUntaintedMethod$1(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache$1[cacheKey]) return untaintedMethodCache$1[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache$1[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentElement\");\n}\nfunction textContent$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"textContent\");\n}\nfunction contains$1(n2, other) {\n    return getUntaintedMethod$1(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode$1(n2) {\n    return getUntaintedMethod$1(\"Node\", n2, \"getRootNode\")();\n}\nfunction host$1(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor$1(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets$1(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot$1(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor$1(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor$1() {\n    return getUntaintedPrototype$1(\"MutationObserver\").constructor;\n}\nvar index$1 = {\n    childNodes: childNodes$1,\n    parentNode: parentNode$1,\n    parentElement: parentElement$1,\n    textContent: textContent$1,\n    contains: contains$1,\n    getRootNode: getRootNode$1,\n    host: host$1,\n    styleSheets: styleSheets$1,\n    shadowRoot: shadowRoot$1,\n    querySelector: querySelector$1,\n    querySelectorAll: querySelectorAll$1,\n    mutationObserver: mutationObserverCtor$1\n};\nfunction isElement(n2) {\n    return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n    var hostEl = // anchor and textarea elements also have a `host` property\n    // but only shadow roots have a `mode` property\n    n2 && \"host\" in n2 && \"mode\" in n2 && index$1.host(n2) || null;\n    return Boolean(hostEl && \"shadowRoot\" in hostEl && index$1.shadowRoot(hostEl) === n2);\n}\nfunction isNativeShadowDom(shadowRoot2) {\n    return Object.prototype.toString.call(shadowRoot2) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule2) {\n    var cssText = rule2.cssText;\n    if (cssText.split('\"').length < 3) return cssText;\n    var statement = [\n        \"@import\",\n        \"url(\" + JSON.stringify(rule2.href) + \")\"\n    ];\n    if (rule2.layerName === \"\") {\n        statement.push(\"layer\");\n    } else if (rule2.layerName) {\n        statement.push(\"layer(\" + rule2.layerName + \")\");\n    }\n    if (rule2.supportsText) {\n        statement.push(\"supports(\" + rule2.supportsText + \")\");\n    }\n    if (rule2.media.length) {\n        statement.push(rule2.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n    try {\n        var rules2 = s2.rules || s2.cssRules;\n        if (!rules2) {\n            return null;\n        }\n        var sheetHref = s2.href;\n        if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {\n            sheetHref = s2.ownerNode.ownerDocument.location.href;\n        }\n        var stringifiedRules = Array.from(rules2, function(rule2) {\n            return stringifyRule(rule2, sheetHref);\n        }).join(\"\");\n        return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule2, sheetHref) {\n    if (isCSSImportRule(rule2)) {\n        var importStringified;\n        try {\n            importStringified = // we can access the imported stylesheet rules directly\n            stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n            escapeImportStatement(rule2);\n        } catch (error) {\n            importStringified = rule2.cssText;\n        }\n        if (rule2.styleSheet.href) {\n            return absolutifyURLs(importStringified, rule2.styleSheet.href);\n        }\n        return importStringified;\n    } else {\n        var ruleStringified = rule2.cssText;\n        if (isCSSStyleRule(rule2) && rule2.selectorText.includes(\":\")) {\n            ruleStringified = fixSafariColons(ruleStringified);\n        }\n        if (sheetHref) {\n            return absolutifyURLs(ruleStringified, sheetHref);\n        }\n        return ruleStringified;\n    }\n}\nfunction fixSafariColons(cssStringified) {\n    var regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule2) {\n    return \"styleSheet\" in rule2;\n}\nfunction isCSSStyleRule(rule2) {\n    return \"selectorText\" in rule2;\n}\nvar Mirror = /*#__PURE__*/ function() {\n    function Mirror() {\n        __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n        __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n    }\n    var _proto = Mirror.prototype;\n    _proto.getId = function getId(n2) {\n        var _a2;\n        if (!n2) return -1;\n        var id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;\n        return id != null ? id : -1;\n    };\n    _proto.getNode = function getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    };\n    _proto.getIds = function getIds() {\n        return Array.from(this.idNodeMap.keys());\n    };\n    _proto.getMeta = function getMeta(n2) {\n        return this.nodeMetaMap.get(n2) || null;\n    };\n    // removes the node from idNodeMap\n    // doesn't remove the node from nodeMetaMap\n    _proto.removeNodeFromMap = function removeNodeFromMap(n2) {\n        var _this = this;\n        var id = this.getId(n2);\n        this.idNodeMap.delete(id);\n        if (n2.childNodes) {\n            n2.childNodes.forEach(function(childNode) {\n                return _this.removeNodeFromMap(childNode);\n            });\n        }\n    };\n    _proto.has = function has(id) {\n        return this.idNodeMap.has(id);\n    };\n    _proto.hasNode = function hasNode(node2) {\n        return this.nodeMetaMap.has(node2);\n    };\n    _proto.add = function add(n2, meta) {\n        var id = meta.id;\n        this.idNodeMap.set(id, n2);\n        this.nodeMetaMap.set(n2, meta);\n    };\n    _proto.replace = function replace(id, n2) {\n        var oldNode = this.getNode(id);\n        if (oldNode) {\n            var meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n2, meta);\n        }\n        this.idNodeMap.set(id, n2);\n    };\n    _proto.reset = function reset() {\n        this.idNodeMap = /* @__PURE__ */ new Map();\n        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    };\n    return Mirror;\n}();\nfunction createMirror$2() {\n    return new Mirror();\n}\nfunction maskInputValue(param) {\n    var element = param.element, maskInputOptions = param.maskInputOptions, tagName = param.tagName, type = param.type, value = param.value, maskInputFn = param.maskInputFn;\n    var text = value || \"\";\n    var actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nvar ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    var ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    var chunkSize = 50;\n    for(var x2 = 0; x2 < canvas.width; x2 += chunkSize){\n        for(var y = 0; y < canvas.height; y += chunkSize){\n            var getImageData = ctx.getImageData;\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            var pixelBuffer = new Uint32Array(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n            originalGetImageData.call(ctx, x2, y, Math.min(chunkSize, canvas.width - x2), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some(function(pixel) {\n                return pixel !== 0;\n            })) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    var type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var url;\n    try {\n        url = new URL(path, baseURL != null ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    var regex = /\\.([0-9a-z]+)(?:$)/i;\n    var match = url.pathname.match(regex);\n    var _ref;\n    return (_ref = match == null ? void 0 : match[1]) != null ? _ref : null;\n}\nfunction extractOrigin(url) {\n    var origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nvar URL_WWW_MATCH = /^www\\..*/i;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absolutifyURLs(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, function(origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === \"/\") {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split(\"/\");\n        var parts = filePath.split(\"/\");\n        stack.pop();\n        for(var _iterator = _create_for_of_iterator_helper_loose(parts), _step; !(_step = _iterator()).done;){\n            var part = _step.value;\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join(\"/\") + maybeQuote + \")\";\n    });\n}\nfunction normalizeCssString(cssText) {\n    return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\");\n}\nfunction splitCssText(cssText, style) {\n    var childNodes2 = Array.from(style.childNodes);\n    var splits = [];\n    if (childNodes2.length > 1 && cssText && typeof cssText === \"string\") {\n        var cssTextNorm = normalizeCssString(cssText);\n        for(var i2 = 1; i2 < childNodes2.length; i2++){\n            if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === \"string\") {\n                var textContentNorm = normalizeCssString(childNodes2[i2].textContent);\n                for(var j = 3; j < textContentNorm.length; j++){\n                    var bit = textContentNorm.substring(0, j);\n                    if (cssTextNorm.split(bit).length === 2) {\n                        var splitNorm = cssTextNorm.indexOf(bit);\n                        for(var k = splitNorm; k < cssText.length; k++){\n                            if (normalizeCssString(cssText.substring(0, k)).length === splitNorm) {\n                                splits.push(cssText.substring(0, k));\n                                cssText = cssText.substring(k);\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    splits.push(cssText);\n    return splits;\n}\nfunction markCssSplits(cssText, style) {\n    return splitCssText(cssText, style).join(\"/* rr_split */\");\n}\nvar _id = 1;\nvar tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName$1(element) {\n    if (_instanceof(element, HTMLFormElement)) {\n        return \"form\";\n    }\n    var processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nvar canvasService;\nvar canvasCtx;\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    var pos = 0;\n    function collectCharacters(regEx) {\n        var chars2;\n        var match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars2 = match[0];\n            pos += chars2.length;\n            return chars2;\n        }\n        return \"\";\n    }\n    var output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        var url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            var descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            var inParens = false;\n            while(true){\n                var c2 = attributeValue.charAt(pos);\n                if (c2 === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c2 === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c2 === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c2 === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c2;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nvar cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n    var a2 = cachedDocument.get(doc);\n    if (!a2) {\n        a2 = doc.createElement(\"a\");\n        cachedDocument.set(doc, a2);\n    }\n    if (!customHref) {\n        customHref = \"\";\n    } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n        return customHref;\n    }\n    a2.setAttribute(\"href\", customHref);\n    return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absolutifyURLs(value, getHref(doc));\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(var eIndex = element.classList.length; eIndex--;){\n                var className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction classMatchesRegex(node2, regex, checkAncestors) {\n    if (!node2) return false;\n    if (node2.nodeType !== node2.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n    }\n    for(var eIndex = node2.classList.length; eIndex--;){\n        var className = node2.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n}\nfunction needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {\n    var el;\n    if (isElement(node2)) {\n        el = node2;\n        if (!index$1.childNodes(el).length) {\n            return false;\n        }\n    } else if (index$1.parentElement(node2) === null) {\n        return false;\n    } else {\n        el = index$1.parentElement(node2);\n    }\n    try {\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(\".\" + maskTextClass)) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        var timer = setTimeout(function() {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", function() {\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    var fired = false;\n    var styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    var timer = setTimeout(function() {\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", function() {\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, needsMask = options.needsMask, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var rootId = getRootId(doc, mirror2);\n    switch(n2.nodeType){\n        case n2.DOCUMENT_NODE:\n            if (n2.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: [],\n                    compatMode: n2.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: []\n                };\n            }\n        case n2.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType$3.DocumentType,\n                name: n2.name,\n                publicId: n2.publicId,\n                systemId: n2.systemId,\n                rootId: rootId\n            };\n        case n2.ELEMENT_NODE:\n            return serializeElementNode(n2, {\n                doc: doc,\n                blockClass: blockClass,\n                blockSelector: blockSelector,\n                inlineStylesheet: inlineStylesheet,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn,\n                dataURLOptions: dataURLOptions,\n                inlineImages: inlineImages,\n                recordCanvas: recordCanvas,\n                keepIframeSrcFn: keepIframeSrcFn,\n                newlyAddedElement: newlyAddedElement,\n                rootId: rootId\n            });\n        case n2.TEXT_NODE:\n            return serializeTextNode(n2, {\n                doc: doc,\n                needsMask: needsMask,\n                maskTextFn: maskTextFn,\n                rootId: rootId,\n                cssCaptured: cssCaptured\n            });\n        case n2.CDATA_SECTION_NODE:\n            return {\n                type: NodeType$3.CDATA,\n                textContent: \"\",\n                rootId: rootId\n            };\n        case n2.COMMENT_NODE:\n            return {\n                type: NodeType$3.Comment,\n                textContent: index$1.textContent(n2) || \"\",\n                rootId: rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror2) {\n    if (!mirror2.hasNode(doc)) return void 0;\n    var docId = mirror2.getId(doc);\n    return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n    var needsMask = options.needsMask, maskTextFn = options.maskTextFn, rootId = options.rootId, cssCaptured = options.cssCaptured;\n    var parent = index$1.parentNode(n2);\n    var parentTagName = parent && parent.tagName;\n    var textContent2 = \"\";\n    var isStyle = parentTagName === \"STYLE\" ? true : void 0;\n    var isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n    if (isScript) {\n        textContent2 = \"SCRIPT_PLACEHOLDER\";\n    } else if (!cssCaptured) {\n        textContent2 = index$1.textContent(n2);\n        if (isStyle && textContent2) {\n            textContent2 = absolutifyURLs(textContent2, getHref(options.doc));\n        }\n    }\n    if (!isStyle && !isScript && textContent2 && needsMask) {\n        textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType$3.Text,\n        textContent: textContent2 || \"\",\n        rootId: rootId\n    };\n}\nfunction serializeElementNode(n2, options) {\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, rootId = options.rootId;\n    var needBlock = _isBlockedElement(n2, blockClass, blockSelector);\n    var tagName = getValidTagName$1(n2);\n    var attributes = {};\n    var len = n2.attributes.length;\n    for(var i2 = 0; i2 < len; i2++){\n        var attr = n2.attributes[i2];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        var stylesheet = Array.from(doc.styleSheets).find(function(s2) {\n            return s2.href === n2.href;\n        });\n        var cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = cssText;\n        }\n    }\n    if (tagName === \"style\" && n2.sheet) {\n        var cssText1 = stringifyStylesheet(n2.sheet);\n        if (cssText1) {\n            if (n2.childNodes.length > 1) {\n                cssText1 = markCssSplits(cssText1, n2);\n            }\n            attributes._cssText = cssText1;\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        var value = n2.value;\n        var checked = n2.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n2,\n                type: getInputType(n2),\n                tagName: tagName,\n                value: value,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n2.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"dialog\" && n2.open) {\n        attributes.rr_open_mode = n2.matches(\"dialog:modal\") ? \"modal\" : \"non-modal\";\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n2.__context === \"2d\") {\n            if (!is2DCanvasBlank(n2)) {\n                attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n2)) {\n            var canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            var blankCanvas = doc.createElement(\"canvas\");\n            blankCanvas.width = n2.width;\n            blankCanvas.height = n2.height;\n            var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        var image = n2;\n        var imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n        var priorCrossOrigin = image.crossOrigin;\n        var recordInlineImage = function() {\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                if (image.crossOrigin !== \"anonymous\") {\n                    image.crossOrigin = \"anonymous\";\n                    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n                    else image.addEventListener(\"load\", recordInlineImage);\n                    return;\n                } else {\n                    console.warn(\"Cannot inline img src=\" + imageSrc + \"! Error: \" + err);\n                }\n            }\n            if (image.crossOrigin === \"anonymous\") {\n                priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n            }\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        var mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n2.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;\n        mediaAttributes.rr_mediaMuted = n2.muted;\n        mediaAttributes.rr_mediaLoop = n2.loop;\n        mediaAttributes.rr_mediaVolume = n2.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n2.scrollLeft) {\n            attributes.rr_scrollLeft = n2.scrollLeft;\n        }\n        if (n2.scrollTop) {\n            attributes.rr_scrollTop = n2.scrollTop;\n        }\n    }\n    if (needBlock) {\n        var _n2_getBoundingClientRect = n2.getBoundingClientRect(), width = _n2_getBoundingClientRect.width, height = _n2_getBoundingClientRect.height;\n        attributes = {\n            class: attributes.class,\n            rr_width: \"\" + width + \"px\",\n            rr_height: \"\" + height + \"px\"\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n2.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    var isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e2) {}\n    return {\n        type: NodeType$3.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n2) || void 0,\n        needBlock: needBlock,\n        rootId: rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === void 0 || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {\n        return true;\n    } else if (sn.type === NodeType$3.Element) {\n        if (slimDOMOptions.script && // script tag\n        (sn.tagName === \"script\" || // (module)preload link\n        sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") && sn.attributes.as === \"script\" || // prefetch link\n        sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n            lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _options_skipChild = options.skipChild, skipChild = _options_skipChild === void 0 ? false : _options_skipChild, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _options_iframeLoadTimeout = options.iframeLoadTimeout, iframeLoadTimeout = _options_iframeLoadTimeout === void 0 ? 5e3 : _options_iframeLoadTimeout, onStylesheetLoad = options.onStylesheetLoad, _options_stylesheetLoadTimeout = options.stylesheetLoadTimeout, stylesheetLoadTimeout = _options_stylesheetLoadTimeout === void 0 ? 5e3 : _options_stylesheetLoadTimeout, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var needsMask = options.needsMask;\n    var _options_preserveWhiteSpace = options.preserveWhiteSpace, preserveWhiteSpace = _options_preserveWhiteSpace === void 0 ? true : _options_preserveWhiteSpace;\n    if (!needsMask) {\n        var checkAncestors = needsMask === void 0;\n        needsMask = needMaskingText(n2, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    var _serializedNode = serializeNode(n2, {\n        doc: doc,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        needsMask: needsMask,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: newlyAddedElement,\n        cssCaptured: cssCaptured\n    });\n    if (!_serializedNode) {\n        console.warn(n2, \"not serialized\");\n        return null;\n    }\n    var id;\n    if (mirror2.hasNode(n2)) {\n        id = mirror2.getId(n2);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: id\n    });\n    mirror2.add(n2, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n2);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType$3.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        var shadowRootEl = index$1.shadowRoot(n2);\n        if (shadowRootEl && isNativeShadowDom(shadowRootEl)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            mirror: mirror2,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            needsMask: needsMask,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            onStylesheetLoad: onStylesheetLoad,\n            stylesheetLoadTimeout: stylesheetLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn,\n            cssCaptured: false\n        };\n        if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== void 0) ;\n        else {\n            if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === \"string\") {\n                bypassOptions.cssCaptured = true;\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(n2))), _step; !(_step = _iterator()).done;){\n                var childN = _step.value;\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        var shadowRootEl1 = null;\n        if (isElement(n2) && (shadowRootEl1 = index$1.shadowRoot(n2))) {\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(shadowRootEl1))), _step1; !(_step1 = _iterator1()).done;){\n                var childN1 = _step1.value;\n                var serializedChildNode1 = serializeNodeWithId(childN1, bypassOptions);\n                if (serializedChildNode1) {\n                    isNativeShadowDom(shadowRootEl1) && (serializedChildNode1.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode1);\n                }\n            }\n        }\n    }\n    var parent = index$1.parentNode(n2);\n    if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n2, function() {\n            var iframeDoc = n2.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n2, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n2, function() {\n            if (onStylesheetLoad) {\n                var serializedLinkNode = serializeNodeWithId(n2, {\n                    doc: doc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n2, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n2, options) {\n    var _ref = options || {}, tmp = _ref.mirror, mirror2 = tmp === void 0 ? new Mirror() : tmp, _ref_blockClass = _ref.blockClass, blockClass = _ref_blockClass === void 0 ? \"rr-block\" : _ref_blockClass, _ref_blockSelector = _ref.blockSelector, blockSelector = _ref_blockSelector === void 0 ? null : _ref_blockSelector, _ref_maskTextClass = _ref.maskTextClass, maskTextClass = _ref_maskTextClass === void 0 ? \"rr-mask\" : _ref_maskTextClass, _ref_maskTextSelector = _ref.maskTextSelector, maskTextSelector = _ref_maskTextSelector === void 0 ? null : _ref_maskTextSelector, _ref_inlineStylesheet = _ref.inlineStylesheet, inlineStylesheet = _ref_inlineStylesheet === void 0 ? true : _ref_inlineStylesheet, _ref_inlineImages = _ref.inlineImages, inlineImages = _ref_inlineImages === void 0 ? false : _ref_inlineImages, _ref_recordCanvas = _ref.recordCanvas, recordCanvas = _ref_recordCanvas === void 0 ? false : _ref_recordCanvas, _ref_maskAllInputs = _ref.maskAllInputs, maskAllInputs = _ref_maskAllInputs === void 0 ? false : _ref_maskAllInputs, maskTextFn = _ref.maskTextFn, maskInputFn = _ref.maskInputFn, _ref_slimDOM = _ref.slimDOM, slimDOM = _ref_slimDOM === void 0 ? false : _ref_slimDOM, dataURLOptions = _ref.dataURLOptions, preserveWhiteSpace = _ref.preserveWhiteSpace, onSerialize = _ref.onSerialize, onIframeLoad = _ref.onIframeLoad, iframeLoadTimeout = _ref.iframeLoadTimeout, onStylesheetLoad = _ref.onStylesheetLoad, stylesheetLoadTimeout = _ref.stylesheetLoadTimeout, _ref_keepIframeSrcFn = _ref.keepIframeSrcFn, keepIframeSrcFn = _ref_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _ref_keepIframeSrcFn;\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? // if true: set of sensible options that should not throw away any information\n    {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        // destructive\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n2, {\n        doc: n2,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        skipChild: false,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        slimDOMOptions: slimDOMOptions,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        preserveWhiteSpace: preserveWhiteSpace,\n        onSerialize: onSerialize,\n        onIframeLoad: onIframeLoad,\n        iframeLoadTimeout: iframeLoadTimeout,\n        onStylesheetLoad: onStylesheetLoad,\n        stylesheetLoadTimeout: stylesheetLoadTimeout,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction getDefaultExportFromCjs$1(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace$1(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser$1 = {\n    exports: {}\n};\nvar x$1 = String;\nvar create$1 = function create$1() {\n    return {\n        isColorSupported: false,\n        reset: x$1,\n        bold: x$1,\n        dim: x$1,\n        italic: x$1,\n        underline: x$1,\n        inverse: x$1,\n        hidden: x$1,\n        strikethrough: x$1,\n        black: x$1,\n        red: x$1,\n        green: x$1,\n        yellow: x$1,\n        blue: x$1,\n        magenta: x$1,\n        cyan: x$1,\n        white: x$1,\n        gray: x$1,\n        bgBlack: x$1,\n        bgRed: x$1,\n        bgGreen: x$1,\n        bgYellow: x$1,\n        bgBlue: x$1,\n        bgMagenta: x$1,\n        bgCyan: x$1,\n        bgWhite: x$1\n    };\n};\npicocolors_browser$1.exports = create$1();\npicocolors_browser$1.exports.createColors = create$1;\nvar picocolors_browserExports$1 = picocolors_browser$1.exports;\nvar __viteBrowserExternal$2 = {};\nvar __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal$2\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);\nvar pico$1 = picocolors_browserExports$1;\nvar terminalHighlight$1$1 = require$$2$1;\nvar CssSyntaxError$3$1 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError, Error1);\n    function CssSyntaxError(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico$1.isColorSupported;\n        if (terminalHighlight$1$1) {\n            if (color) css = terminalHighlight$1$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico$1_createColors = pico$1.createColors(true), bold = _pico$1_createColors.bold, gray = _pico$1_createColors.gray, red = _pico$1_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError;\n}(_wrap_native_super(Error));\nvar cssSyntaxError$1 = CssSyntaxError$3$1;\nCssSyntaxError$3$1.default = CssSyntaxError$3$1;\nvar symbols$1 = {};\nsymbols$1.isClean = Symbol(\"isClean\");\nsymbols$1.my = Symbol(\"my\");\nvar DEFAULT_RAW$1 = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize$1(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2$1 = /*#__PURE__*/ function() {\n    function Stringifier(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW$1[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize$1(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW$1[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier;\n}();\nvar stringifier$1 = Stringifier$2$1;\nStringifier$2$1.default = Stringifier$2$1;\nvar Stringifier$1$1 = stringifier$1;\nfunction stringify$4$1(node2, builder) {\n    var str = new Stringifier$1$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1$1 = stringify$4$1;\nstringify$4$1.default = stringify$4$1;\nvar isClean$2$1 = symbols$1.isClean, my$2$1 = symbols$1.my;\nvar CssSyntaxError$2$1 = cssSyntaxError$1;\nvar Stringifier2$1 = stringifier$1;\nvar stringify$3$1 = stringify_1$1;\nfunction cloneNode$1(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode$1(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode$1(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4$1 = /*#__PURE__*/ function() {\n    function Node2(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2$1] = false;\n        this[my$2$1] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node2.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode$1(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2$1(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2$1]) {\n            this[isClean$2$1] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2$1] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier2$1();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3$1;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node2, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node2;\n}();\nvar node$1 = Node$4$1;\nNode$4$1.default = Node$4$1;\nvar Node$3$1 = node$1;\nvar Declaration$4$1 = /*#__PURE__*/ function(Node$3$1) {\n    _inherits(Declaration, Node$3$1);\n    function Declaration(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3$1.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration;\n}(Node$3$1);\nvar declaration$1 = Declaration$4$1;\nDeclaration$4$1.default = Declaration$4$1;\nvar urlAlphabet$1 = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet$1[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure$1 = {\n    nanoid: nanoid$1$1};\nvar SourceMapConsumer$2$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$2$1 = require$$2$1.SourceMapGenerator;\nvar existsSync$1 = require$$2$1.existsSync, readFileSync$1 = require$$2$1.readFileSync;\nvar dirname$1$1 = require$$2$1.dirname, join$1 = require$$2$1.join;\nfunction fromBase64$1(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2$1 = /*#__PURE__*/ function() {\n    function PreviousMap(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2$1(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64$1(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1$1(path);\n        if (existsSync$1(path)) {\n            this.mapFile = path;\n            return readFileSync$1(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2$1)) {\n                return SourceMapGenerator$2$1.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2$1)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join$1(dirname$1$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap;\n}();\nvar previousMap$1 = PreviousMap$2$1;\nPreviousMap$2$1.default = PreviousMap$2$1;\nvar SourceMapConsumer$1$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$1$1 = require$$2$1.SourceMapGenerator;\nvar fileURLToPath$1 = require$$2$1.fileURLToPath, pathToFileURL$1$1 = require$$2$1.pathToFileURL;\nvar isAbsolute$1 = require$$2$1.isAbsolute, resolve$1$1 = require$$2$1.resolve;\nvar nanoid$2 = nonSecure$1.nanoid;\nvar terminalHighlight$2 = require$$2$1;\nvar CssSyntaxError$1$1 = cssSyntaxError$1;\nvar PreviousMap$1$1 = previousMap$1;\nvar fromOffsetCache$1 = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);\nvar pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);\nvar Input$4$1 = /*#__PURE__*/ function() {\n    function Input(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"￾\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute$1(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1$1(opts.from);\n            }\n        }\n        if (pathAvailable$1$1 && sourceMapAvailable$1$1) {\n            var map = new PreviousMap$1$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid$2(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1$1) {\n                result2.input.url = pathToFileURL$1$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache$1]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache$1] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache$1];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute$1(from.source)) {\n            fromUrl = pathToFileURL$1$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath$1) {\n                result2.file = fileURLToPath$1(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input;\n}();\nvar input$1 = Input$4$1;\nInput$4$1.default = Input$4$1;\nif (terminalHighlight$2 && terminalHighlight$2.registerInput) {\n    terminalHighlight$2.registerInput(Input$4$1);\n}\nvar SourceMapConsumer$3 = require$$2$1.SourceMapConsumer, SourceMapGenerator$3 = require$$2$1.SourceMapGenerator;\nvar dirname$2 = require$$2$1.dirname, relative$1 = require$$2$1.relative, resolve$2 = require$$2$1.resolve, sep$1 = require$$2$1.sep;\nvar pathToFileURL$2 = require$$2$1.pathToFileURL;\nvar Input$3$1 = input$1;\nvar sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);\nvar pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);\nvar MapGenerator$2$1 = /*#__PURE__*/ function() {\n    function MapGenerator(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname$2(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer$3(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator$3.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator$3({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator$3({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname$2(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname$2(resolve$2(from, this.mapOpts.annotation));\n        }\n        var path = relative$1(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3$1(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL$2) {\n            var fileURL = pathToFileURL$2(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep$1 === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator;\n}();\nvar mapGenerator$1 = MapGenerator$2$1;\nvar Node$2$1 = node$1;\nvar Comment$4$1 = /*#__PURE__*/ function(Node$2$1) {\n    _inherits(Comment, Node$2$1);\n    function Comment(defaults) {\n        var _this;\n        _this = Node$2$1.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment;\n}(Node$2$1);\nvar comment$1 = Comment$4$1;\nComment$4$1.default = Comment$4$1;\nvar isClean$1$1 = symbols$1.isClean, my$1$1 = symbols$1.my;\nvar Declaration$3$1 = declaration$1;\nvar Comment$3$1 = comment$1;\nvar Node$1$1 = node$1;\nvar parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;\nfunction cleanSource$1(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp$1(node2) {\n    node2[isClean$1$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp$1(i2);\n        }\n    }\n}\nvar Container$7$1 = /*#__PURE__*/ function(Node$1$1) {\n    _inherits(Container, Node$1$1);\n    function Container() {\n        return Node$1$1.apply(this, arguments) || this;\n    }\n    var _proto = Container.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource$1(parse$4$1(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3$1(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4$1(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4$1(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3$1(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1$1]) Container.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1$1]) markDirtyUp$1(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container;\n}(Node$1$1);\nContainer$7$1.registerParse = function(dependant) {\n    parse$4$1 = dependant;\n};\nContainer$7$1.registerRule = function(dependant) {\n    Rule$4$1 = dependant;\n};\nContainer$7$1.registerAtRule = function(dependant) {\n    AtRule$4$1 = dependant;\n};\nContainer$7$1.registerRoot = function(dependant) {\n    Root$6$1 = dependant;\n};\nvar container$1 = Container$7$1;\nContainer$7$1.default = Container$7$1;\nContainer$7$1.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4$1.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4$1.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3$1.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3$1.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6$1.prototype);\n    }\n    node2[my$1$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7$1.rebuild(child);\n        });\n    }\n};\nvar Container$6$1 = container$1;\nvar LazyResult$4$1, Processor$3$1;\nvar Document$3$1 = /*#__PURE__*/ function(Container$6$1) {\n    _inherits(Document2, Container$6$1);\n    function Document2(defaults) {\n        var _this;\n        _this = Container$6$1.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document2.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Document2;\n}(Container$6$1);\nDocument$3$1.registerLazyResult = function(dependant) {\n    LazyResult$4$1 = dependant;\n};\nDocument$3$1.registerProcessor = function(dependant) {\n    Processor$3$1 = dependant;\n};\nvar document$1$1 = Document$3$1;\nDocument$3$1.default = Document$3$1;\nvar printed$1 = {};\nvar warnOnce$2$1 = function warnOnce(message) {\n    if (printed$1[message]) return;\n    printed$1[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2$1 = /*#__PURE__*/ function() {\n    function Warning(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning;\n}();\nvar warning$1 = Warning$2$1;\nWarning$2$1.default = Warning$2$1;\nvar Warning$1$1 = warning$1;\nvar Result$3$1 = /*#__PURE__*/ function() {\n    function Result(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result;\n}();\nvar result$1 = Result$3$1;\nResult$3$1.default = Result$3$1;\nvar SINGLE_QUOTE$1 = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE$1 = '\"'.charCodeAt(0);\nvar BACKSLASH$1 = \"\\\\\".charCodeAt(0);\nvar SLASH$1 = \"/\".charCodeAt(0);\nvar NEWLINE$1 = \"\\n\".charCodeAt(0);\nvar SPACE$1 = \" \".charCodeAt(0);\nvar FEED$1 = \"\\f\".charCodeAt(0);\nvar TAB$1 = \"\t\".charCodeAt(0);\nvar CR$1 = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE$1 = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE$1 = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES$1 = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES$1 = \")\".charCodeAt(0);\nvar OPEN_CURLY$1 = \"{\".charCodeAt(0);\nvar CLOSE_CURLY$1 = \"}\".charCodeAt(0);\nvar SEMICOLON$1 = \";\".charCodeAt(0);\nvar ASTERISK$1 = \"*\".charCodeAt(0);\nvar COLON$1 = \":\".charCodeAt(0);\nvar AT$1 = \"@\".charCodeAt(0);\nvar RE_AT_END$1 = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END$1 = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET$1 = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE$1 = /[\\da-f]/i;\nvar tokenize$1 = function tokenizer(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE$1:\n            case SPACE$1:\n            case TAB$1:\n            case CR$1:\n            case FEED$1:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE$1:\n            case CLOSE_SQUARE$1:\n            case OPEN_CURLY$1:\n            case CLOSE_CURLY$1:\n            case COLON$1:\n            case SEMICOLON$1:\n            case CLOSE_PARENTHESES$1:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES$1:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET$1.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE$1:\n            case DOUBLE_QUOTE$1:\n                {\n                    quote = code === SINGLE_QUOTE$1 ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT$1:\n                {\n                    RE_AT_END$1.lastIndex = pos + 1;\n                    RE_AT_END$1.test(css);\n                    if (RE_AT_END$1.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END$1.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH$1:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH$1){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE$1.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE$1) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END$1.lastIndex = pos + 1;\n                        RE_WORD_END$1.test(css);\n                        if (RE_WORD_END$1.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END$1.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5$1 = container$1;\nvar AtRule$3$1 = /*#__PURE__*/ function(Container$5$1) {\n    _inherits(AtRule, Container$5$1);\n    function AtRule(defaults) {\n        var _this;\n        _this = Container$5$1.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_append = Container$5$1.prototype.append).call.apply(_Container$5$1_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_prepend = Container$5$1.prototype.prepend).call.apply(_Container$5$1_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule;\n}(Container$5$1);\nvar atRule$1 = AtRule$3$1;\nAtRule$3$1.default = AtRule$3$1;\nContainer$5$1.registerAtRule(AtRule$3$1);\nvar Container$4$1 = container$1;\nvar LazyResult$3$1, Processor$2$1;\nvar Root$5$1 = /*#__PURE__*/ function(Container$4$1) {\n    _inherits(Root, Container$4$1);\n    function Root(defaults) {\n        var _this;\n        _this = Container$4$1.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4$1.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4$1.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Root;\n}(Container$4$1);\nRoot$5$1.registerLazyResult = function(dependant) {\n    LazyResult$3$1 = dependant;\n};\nRoot$5$1.registerProcessor = function(dependant) {\n    Processor$2$1 = dependant;\n};\nvar root$1 = Root$5$1;\nRoot$5$1.default = Root$5$1;\nContainer$4$1.registerRoot(Root$5$1);\nvar list$2$1 = {\n    comma: function comma(string) {\n        return list$2$1.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2$1.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1$1 = list$2$1;\nlist$2$1.default = list$2$1;\nvar Container$3$1 = container$1;\nvar list$1$1 = list_1$1;\nvar Rule$3$1 = /*#__PURE__*/ function(Container$3$1) {\n    _inherits(Rule, Container$3$1);\n    function Rule(defaults) {\n        var _this;\n        _this = Container$3$1.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule;\n}(Container$3$1);\nvar rule$1 = Rule$3$1;\nRule$3$1.default = Rule$3$1;\nContainer$3$1.registerRule(Rule$3$1);\nvar Declaration$2$1 = declaration$1;\nvar tokenizer2$1 = tokenize$1;\nvar Comment$2$1 = comment$1;\nvar AtRule$2$1 = atRule$1;\nvar Root$4$1 = root$1;\nvar Rule$2$1 = rule$1;\nvar SAFE_COMMENT_NEIGHBOR$1 = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition$1(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1$1 = /*#__PURE__*/ function() {\n    function Parser(input2) {\n        this.input = input2;\n        this.root = new Root$4$1();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2$1();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2$1();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer2$1(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2$1();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition$1(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2$1();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2$1();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser;\n}();\nvar parser$1 = Parser$1$1;\nvar Container$2$1 = container$1;\nvar Parser2$1 = parser$1;\nvar Input$2$1 = input$1;\nfunction parse$3$1(css, opts) {\n    var input2 = new Input$2$1(css, opts);\n    var parser2 = new Parser2$1(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1$1 = parse$3$1;\nparse$3$1.default = parse$3$1;\nContainer$2$1.registerParse(parse$3$1);\nvar isClean$3 = symbols$1.isClean, my$3 = symbols$1.my;\nvar MapGenerator$1$1 = mapGenerator$1;\nvar stringify$2$1 = stringify_1$1;\nvar Container$1$1 = container$1;\nvar Document$2$1 = document$1$1;\nvar warnOnce$1$1 = warnOnce$2$1;\nvar Result$2$1 = result$1;\nvar parse$2$1 = parse_1$1;\nvar Root$3$1 = root$1;\nvar TYPE_TO_CLASS_NAME$1 = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS$1 = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS$1 = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN$1 = 0;\nfunction isPromise$1(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents$1(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME$1[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN$1,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN$1,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack$1(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN$1,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN$1,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents$1(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks$1(node2) {\n    node2[isClean$3] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks$1(i2);\n    });\n    return node2;\n}\nvar postcss$2$1 = {};\nvar LazyResult$2$1 = /*#__PURE__*/ function() {\n    function LazyResult(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks$1(css);\n        } else if (_instanceof(css, LazyResult) || _instanceof(css, Result$2$1)) {\n            root2 = cleanMarks$1(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2$1;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my$3]) {\n                Container$1$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2$1(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2$1, {\n            postcss: postcss$2$1,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS$1[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise$1(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean$3]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean$3] = true;\n                        stack = [\n                            toStack$1(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise$1(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise$1(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2$1;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean$3]){\n                root2[isClean$3] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean$3]) {\n                    child[isClean$3] = true;\n                    stack.push(toStack$1(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN$1) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean$3] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean$3] = true;\n        var events = getEvents$1(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN$1) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean$3]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult;\n}();\nLazyResult$2$1.registerPostcss = function(dependant) {\n    postcss$2$1 = dependant;\n};\nvar lazyResult$1 = LazyResult$2$1;\nLazyResult$2$1.default = LazyResult$2$1;\nRoot$3$1.registerLazyResult(LazyResult$2$1);\nDocument$2$1.registerLazyResult(LazyResult$2$1);\nvar MapGenerator2$1 = mapGenerator$1;\nvar stringify$1$1 = stringify_1$1;\nvar warnOnce2$1 = warnOnce$2$1;\nvar parse$1$1 = parse_1$1;\nvar Result$1$1 = result$1;\nvar NoWorkResult$1$1 = /*#__PURE__*/ function() {\n    function NoWorkResult(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1$1;\n        this.result = new Result$1$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator2$1(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce2$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult;\n}();\nvar noWorkResult$1 = NoWorkResult$1$1;\nNoWorkResult$1$1.default = NoWorkResult$1$1;\nvar NoWorkResult2$1 = noWorkResult$1;\nvar LazyResult$1$1 = lazyResult$1;\nvar Document$1$1 = document$1$1;\nvar Root$2$1 = root$1;\nvar Processor$1$1 = /*#__PURE__*/ function() {\n    function Processor(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult2$1(this, css, opts);\n        } else {\n            return new LazyResult$1$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor;\n}();\nvar processor$1 = Processor$1$1;\nProcessor$1$1.default = Processor$1$1;\nRoot$2$1.registerProcessor(Processor$1$1);\nDocument$1$1.registerProcessor(Processor$1$1);\nvar Declaration$1$1 = declaration$1;\nvar PreviousMap2$1 = previousMap$1;\nvar Comment$1$1 = comment$1;\nvar AtRule$1$1 = atRule$1;\nvar Input$1$1 = input$1;\nvar Root$1$1 = root$1;\nvar Rule$1$1 = rule$1;\nfunction fromJSON$1$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap2$1.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1$1 = fromJSON$1$1;\nfromJSON$1$1.default = fromJSON$1$1;\nvar CssSyntaxError2$1 = cssSyntaxError$1;\nvar Declaration2$1 = declaration$1;\nvar LazyResult2$1 = lazyResult$1;\nvar Container2$1 = container$1;\nvar Processor2$1 = processor$1;\nvar stringify$5 = stringify_1$1;\nvar fromJSON$2 = fromJSON_1$1;\nvar Document22 = document$1$1;\nvar Warning2$1 = warning$1;\nvar Comment2$1 = comment$1;\nvar AtRule2$1 = atRule$1;\nvar Result2$1 = result$1;\nvar Input2$1 = input$1;\nvar parse$5 = parse_1$1;\nvar list$3 = list_1$1;\nvar Rule2$1 = rule$1;\nvar Root2$1 = root$1;\nvar Node2$1 = node$1;\nfunction postcss$3() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor2$1(plugins);\n}\npostcss$3.plugin = function plugin(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \": 里面 postcss.plugin 被弃用. 迁移指南:\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor2$1().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss$3([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss$3.stringify = stringify$5;\npostcss$3.parse = parse$5;\npostcss$3.fromJSON = fromJSON$2;\npostcss$3.list = list$3;\npostcss$3.comment = function(defaults) {\n    return new Comment2$1(defaults);\n};\npostcss$3.atRule = function(defaults) {\n    return new AtRule2$1(defaults);\n};\npostcss$3.decl = function(defaults) {\n    return new Declaration2$1(defaults);\n};\npostcss$3.rule = function(defaults) {\n    return new Rule2$1(defaults);\n};\npostcss$3.root = function(defaults) {\n    return new Root2$1(defaults);\n};\npostcss$3.document = function(defaults) {\n    return new Document22(defaults);\n};\npostcss$3.CssSyntaxError = CssSyntaxError2$1;\npostcss$3.Declaration = Declaration2$1;\npostcss$3.Container = Container2$1;\npostcss$3.Processor = Processor2$1;\npostcss$3.Document = Document22;\npostcss$3.Comment = Comment2$1;\npostcss$3.Warning = Warning2$1;\npostcss$3.AtRule = AtRule2$1;\npostcss$3.Result = Result2$1;\npostcss$3.Input = Input2$1;\npostcss$3.Rule = Rule2$1;\npostcss$3.Root = Root2$1;\npostcss$3.Node = Node2$1;\nLazyResult2$1.registerPostcss(postcss$3);\nvar postcss_1$1 = postcss$3;\npostcss$3.default = postcss$3;\nvar postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);\npostcss$1$1.stringify;\npostcss$1$1.fromJSON;\npostcss$1$1.plugin;\npostcss$1$1.parse;\npostcss$1$1.list;\npostcss$1$1.document;\npostcss$1$1.comment;\npostcss$1$1.atRule;\npostcss$1$1.rule;\npostcss$1$1.decl;\npostcss$1$1.root;\npostcss$1$1.CssSyntaxError;\npostcss$1$1.Declaration;\npostcss$1$1.Container;\npostcss$1$1.Processor;\npostcss$1$1.Document;\npostcss$1$1.Comment;\npostcss$1$1.Warning;\npostcss$1$1.AtRule;\npostcss$1$1.Result;\npostcss$1$1.Input;\npostcss$1$1.Rule;\npostcss$1$1.Root;\npostcss$1$1.Node;\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = function(obj, key, value) {\n    return key in obj ? __defProp2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField2 = function(obj, key, value) {\n    return __defNormalProp2(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction getDefaultExportFromCjs(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser = {\n    exports: {}\n};\nvar x = String;\nvar create = function create() {\n    return {\n        isColorSupported: false,\n        reset: x,\n        bold: x,\n        dim: x,\n        italic: x,\n        underline: x,\n        inverse: x,\n        hidden: x,\n        strikethrough: x,\n        black: x,\n        red: x,\n        green: x,\n        yellow: x,\n        blue: x,\n        magenta: x,\n        cyan: x,\n        white: x,\n        gray: x,\n        bgBlack: x,\n        bgRed: x,\n        bgGreen: x,\n        bgYellow: x,\n        bgBlue: x,\n        bgMagenta: x,\n        bgCyan: x,\n        bgWhite: x\n    };\n};\npicocolors_browser.exports = create();\npicocolors_browser.exports.createColors = create;\nvar picocolors_browserExports = picocolors_browser.exports;\nvar __viteBrowserExternal = {};\nvar __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\nvar pico = picocolors_browserExports;\nvar terminalHighlight$1 = require$$2;\nvar CssSyntaxError$3 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError2, Error1);\n    function CssSyntaxError2(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError2);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError2.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico.isColorSupported;\n        if (terminalHighlight$1) {\n            if (color) css = terminalHighlight$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico_createColors = pico.createColors(true), bold = _pico_createColors.bold, gray = _pico_createColors.gray, red = _pico_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError2;\n}(_wrap_native_super(Error));\nvar cssSyntaxError = CssSyntaxError$3;\nCssSyntaxError$3.default = CssSyntaxError$3;\nvar symbols = {};\nsymbols.isClean = Symbol(\"isClean\");\nsymbols.my = Symbol(\"my\");\nvar DEFAULT_RAW = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2 = /*#__PURE__*/ function() {\n    function Stringifier2(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier2.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier2;\n}();\nvar stringifier = Stringifier$2;\nStringifier$2.default = Stringifier$2;\nvar Stringifier$1 = stringifier;\nfunction stringify$4(node2, builder) {\n    var str = new Stringifier$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1 = stringify$4;\nstringify$4.default = stringify$4;\nvar isClean$2 = symbols.isClean, my$2 = symbols.my;\nvar CssSyntaxError$2 = cssSyntaxError;\nvar Stringifier22 = stringifier;\nvar stringify$3 = stringify_1;\nfunction cloneNode(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4 = /*#__PURE__*/ function() {\n    function Node3(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2] = false;\n        this[my$2] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node3.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2]) {\n            this[isClean$2] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier22();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node3, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node3;\n}();\nvar node = Node$4;\nNode$4.default = Node$4;\nvar Node$3 = node;\nvar Declaration$4 = /*#__PURE__*/ function(Node$3) {\n    _inherits(Declaration2, Node$3);\n    function Declaration2(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration2, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration2;\n}(Node$3);\nvar declaration = Declaration$4;\nDeclaration$4.default = Declaration$4;\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure = {\n    nanoid: nanoid$1};\nvar SourceMapConsumer$2 = require$$2.SourceMapConsumer, SourceMapGenerator$2 = require$$2.SourceMapGenerator;\nvar existsSync = require$$2.existsSync, readFileSync = require$$2.readFileSync;\nvar dirname$1 = require$$2.dirname, join = require$$2.join;\nfunction fromBase64(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2 = /*#__PURE__*/ function() {\n    function PreviousMap2(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap2.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1(path);\n        if (existsSync(path)) {\n            this.mapFile = path;\n            return readFileSync(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2)) {\n                return SourceMapGenerator$2.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join(dirname$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap2;\n}();\nvar previousMap = PreviousMap$2;\nPreviousMap$2.default = PreviousMap$2;\nvar SourceMapConsumer$1 = require$$2.SourceMapConsumer, SourceMapGenerator$1 = require$$2.SourceMapGenerator;\nvar fileURLToPath = require$$2.fileURLToPath, pathToFileURL$1 = require$$2.pathToFileURL;\nvar isAbsolute = require$$2.isAbsolute, resolve$1 = require$$2.resolve;\nvar nanoid = nonSecure.nanoid;\nvar terminalHighlight = require$$2;\nvar CssSyntaxError$1 = cssSyntaxError;\nvar PreviousMap$1 = previousMap;\nvar fromOffsetCache = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);\nvar pathAvailable$1 = Boolean(resolve$1 && isAbsolute);\nvar Input$4 = /*#__PURE__*/ function() {\n    function Input2(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"￾\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1(opts.from);\n            }\n        }\n        if (pathAvailable$1 && sourceMapAvailable$1) {\n            var map = new PreviousMap$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input2.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1) {\n                result2.input.url = pathToFileURL$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute(from.source)) {\n            fromUrl = pathToFileURL$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath) {\n                result2.file = fileURLToPath(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input2, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input2;\n}();\nvar input = Input$4;\nInput$4.default = Input$4;\nif (terminalHighlight && terminalHighlight.registerInput) {\n    terminalHighlight.registerInput(Input$4);\n}\nvar SourceMapConsumer = require$$2.SourceMapConsumer, SourceMapGenerator = require$$2.SourceMapGenerator;\nvar dirname = require$$2.dirname, relative = require$$2.relative, resolve$3 = require$$2.resolve, sep = require$$2.sep;\nvar pathToFileURL = require$$2.pathToFileURL;\nvar Input$3 = input;\nvar sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nvar pathAvailable = Boolean(dirname && resolve$3 && relative && sep);\nvar MapGenerator$2 = /*#__PURE__*/ function() {\n    function MapGenerator2(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator2.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable && sourceMapAvailable && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname(resolve$3(from, this.mapOpts.annotation));\n        }\n        var path = relative(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL) {\n            var fileURL = pathToFileURL(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator2;\n}();\nvar mapGenerator = MapGenerator$2;\nvar Node$2 = node;\nvar Comment$4 = /*#__PURE__*/ function(Node$2) {\n    _inherits(Comment2, Node$2);\n    function Comment2(defaults) {\n        var _this;\n        _this = Node$2.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment2;\n}(Node$2);\nvar comment = Comment$4;\nComment$4.default = Comment$4;\nvar isClean$1 = symbols.isClean, my$1 = symbols.my;\nvar Declaration$3 = declaration;\nvar Comment$3 = comment;\nvar Node$1 = node;\nvar parse$4, Rule$4, AtRule$4, Root$6;\nfunction cleanSource(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp(node2) {\n    node2[isClean$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp(i2);\n        }\n    }\n}\nvar Container$7 = /*#__PURE__*/ function(Node$1) {\n    _inherits(Container2, Node$1);\n    function Container2() {\n        return Node$1.apply(this, arguments) || this;\n    }\n    var _proto = Container2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource(parse$4(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1]) Container2.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1]) markDirtyUp(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container2, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container2;\n}(Node$1);\nContainer$7.registerParse = function(dependant) {\n    parse$4 = dependant;\n};\nContainer$7.registerRule = function(dependant) {\n    Rule$4 = dependant;\n};\nContainer$7.registerAtRule = function(dependant) {\n    AtRule$4 = dependant;\n};\nContainer$7.registerRoot = function(dependant) {\n    Root$6 = dependant;\n};\nvar container = Container$7;\nContainer$7.default = Container$7;\nContainer$7.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6.prototype);\n    }\n    node2[my$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7.rebuild(child);\n        });\n    }\n};\nvar Container$6 = container;\nvar LazyResult$4, Processor$3;\nvar Document$3 = /*#__PURE__*/ function(Container$6) {\n    _inherits(Document23, Container$6);\n    function Document23(defaults) {\n        var _this;\n        _this = Container$6.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document23.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4(new Processor$3(), this, opts);\n        return lazy.stringify();\n    };\n    return Document23;\n}(Container$6);\nDocument$3.registerLazyResult = function(dependant) {\n    LazyResult$4 = dependant;\n};\nDocument$3.registerProcessor = function(dependant) {\n    Processor$3 = dependant;\n};\nvar document$1$2 = Document$3;\nDocument$3.default = Document$3;\nvar printed = {};\nvar warnOnce$2 = function warnOnce2(message) {\n    if (printed[message]) return;\n    printed[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2 = /*#__PURE__*/ function() {\n    function Warning2(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning2.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning2;\n}();\nvar warning = Warning$2;\nWarning$2.default = Warning$2;\nvar Warning$1 = warning;\nvar Result$3 = /*#__PURE__*/ function() {\n    function Result2(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result2.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result2;\n}();\nvar result = Result$3;\nResult$3.default = Result$3;\nvar SINGLE_QUOTE = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = \"\\\\\".charCodeAt(0);\nvar SLASH = \"/\".charCodeAt(0);\nvar NEWLINE = \"\\n\".charCodeAt(0);\nvar SPACE = \" \".charCodeAt(0);\nvar FEED = \"\\f\".charCodeAt(0);\nvar TAB = \"\t\".charCodeAt(0);\nvar CR = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES = \")\".charCodeAt(0);\nvar OPEN_CURLY = \"{\".charCodeAt(0);\nvar CLOSE_CURLY = \"}\".charCodeAt(0);\nvar SEMICOLON = \";\".charCodeAt(0);\nvar ASTERISK = \"*\".charCodeAt(0);\nvar COLON = \":\".charCodeAt(0);\nvar AT = \"@\".charCodeAt(0);\nvar RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE = /[\\da-f]/i;\nvar tokenize = function tokenizer2(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n                {\n                    quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT:\n                {\n                    RE_AT_END.lastIndex = pos + 1;\n                    RE_AT_END.test(css);\n                    if (RE_AT_END.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END.lastIndex = pos + 1;\n                        RE_WORD_END.test(css);\n                        if (RE_WORD_END.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5 = container;\nvar AtRule$3 = /*#__PURE__*/ function(Container$5) {\n    _inherits(AtRule2, Container$5);\n    function AtRule2(defaults) {\n        var _this;\n        _this = Container$5.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_append = Container$5.prototype.append).call.apply(_Container$5_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_prepend = Container$5.prototype.prepend).call.apply(_Container$5_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule2;\n}(Container$5);\nvar atRule = AtRule$3;\nAtRule$3.default = AtRule$3;\nContainer$5.registerAtRule(AtRule$3);\nvar Container$4 = container;\nvar LazyResult$3, Processor$2;\nvar Root$5 = /*#__PURE__*/ function(Container$4) {\n    _inherits(Root2, Container$4);\n    function Root2(defaults) {\n        var _this;\n        _this = Container$4.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root2.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3(new Processor$2(), this, opts);\n        return lazy.stringify();\n    };\n    return Root2;\n}(Container$4);\nRoot$5.registerLazyResult = function(dependant) {\n    LazyResult$3 = dependant;\n};\nRoot$5.registerProcessor = function(dependant) {\n    Processor$2 = dependant;\n};\nvar root = Root$5;\nRoot$5.default = Root$5;\nContainer$4.registerRoot(Root$5);\nvar list$2 = {\n    comma: function comma(string) {\n        return list$2.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1 = list$2;\nlist$2.default = list$2;\nvar Container$3 = container;\nvar list$1 = list_1;\nvar Rule$3 = /*#__PURE__*/ function(Container$3) {\n    _inherits(Rule2, Container$3);\n    function Rule2(defaults) {\n        var _this;\n        _this = Container$3.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule2, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule2;\n}(Container$3);\nvar rule = Rule$3;\nRule$3.default = Rule$3;\nContainer$3.registerRule(Rule$3);\nvar Declaration$2 = declaration;\nvar tokenizer22 = tokenize;\nvar Comment$2 = comment;\nvar AtRule$2 = atRule;\nvar Root$4 = root;\nvar Rule$2 = rule;\nvar SAFE_COMMENT_NEIGHBOR = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1 = /*#__PURE__*/ function() {\n    function Parser2(input2) {\n        this.input = input2;\n        this.root = new Root$4();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser2.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer22(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser2;\n}();\nvar parser = Parser$1;\nvar Container$2 = container;\nvar Parser22 = parser;\nvar Input$2 = input;\nfunction parse$3(css, opts) {\n    var input2 = new Input$2(css, opts);\n    var parser2 = new Parser22(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1 = parse$3;\nparse$3.default = parse$3;\nContainer$2.registerParse(parse$3);\nvar isClean = symbols.isClean, my = symbols.my;\nvar MapGenerator$1 = mapGenerator;\nvar stringify$2 = stringify_1;\nvar Container$1 = container;\nvar Document$2 = document$1$2;\nvar warnOnce$1 = warnOnce$2;\nvar Result$2 = result;\nvar parse$2 = parse_1;\nvar Root$3 = root;\nvar TYPE_TO_CLASS_NAME = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN = 0;\nfunction isPromise(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks(node2) {\n    node2[isClean] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks(i2);\n    });\n    return node2;\n}\nvar postcss$2 = {};\nvar LazyResult$2 = /*#__PURE__*/ function() {\n    function LazyResult2(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks(css);\n        } else if (_instanceof(css, LazyResult2) || _instanceof(css, Result$2)) {\n            root2 = cleanMarks(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my]) {\n                Container$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2, {\n            postcss: postcss$2,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean] = true;\n                        stack = [\n                            toStack(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean]){\n                root2[isClean] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean]) {\n                    child[isClean] = true;\n                    stack.push(toStack(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean] = true;\n        var events = getEvents(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult2;\n}();\nLazyResult$2.registerPostcss = function(dependant) {\n    postcss$2 = dependant;\n};\nvar lazyResult = LazyResult$2;\nLazyResult$2.default = LazyResult$2;\nRoot$3.registerLazyResult(LazyResult$2);\nDocument$2.registerLazyResult(LazyResult$2);\nvar MapGenerator22 = mapGenerator;\nvar stringify$1 = stringify_1;\nvar warnOnce22 = warnOnce$2;\nvar parse$1 = parse_1;\nvar Result$1 = result;\nvar NoWorkResult$1 = /*#__PURE__*/ function() {\n    function NoWorkResult2(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1;\n        this.result = new Result$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator22(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce22(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult2;\n}();\nvar noWorkResult = NoWorkResult$1;\nNoWorkResult$1.default = NoWorkResult$1;\nvar NoWorkResult22 = noWorkResult;\nvar LazyResult$1 = lazyResult;\nvar Document$1 = document$1$2;\nvar Root$2 = root;\nvar Processor$1 = /*#__PURE__*/ function() {\n    function Processor2(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor2.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult22(this, css, opts);\n        } else {\n            return new LazyResult$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor2;\n}();\nvar processor = Processor$1;\nProcessor$1.default = Processor$1;\nRoot$2.registerProcessor(Processor$1);\nDocument$1.registerProcessor(Processor$1);\nvar Declaration$1 = declaration;\nvar PreviousMap22 = previousMap;\nvar Comment$1 = comment;\nvar AtRule$1 = atRule;\nvar Input$1 = input;\nvar Root$1 = root;\nvar Rule$1 = rule;\nfunction fromJSON$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap22.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1 = fromJSON$1;\nfromJSON$1.default = fromJSON$1;\nvar CssSyntaxError22 = cssSyntaxError;\nvar Declaration22 = declaration;\nvar LazyResult22 = lazyResult;\nvar Container22 = container;\nvar Processor22 = processor;\nvar stringify = stringify_1;\nvar fromJSON = fromJSON_1;\nvar Document222 = document$1$2;\nvar Warning22 = warning;\nvar Comment22 = comment;\nvar AtRule22 = atRule;\nvar Result22 = result;\nvar Input22 = input;\nvar parse = parse_1;\nvar list = list_1;\nvar Rule22 = rule;\nvar Root22 = root;\nvar Node22 = node;\nfunction postcss() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor22(plugins);\n}\npostcss.plugin = function plugin2(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \": 里面 postcss.plugin 被弃用. 迁移指南:\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor22().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss.stringify = stringify;\npostcss.parse = parse;\npostcss.fromJSON = fromJSON;\npostcss.list = list;\npostcss.comment = function(defaults) {\n    return new Comment22(defaults);\n};\npostcss.atRule = function(defaults) {\n    return new AtRule22(defaults);\n};\npostcss.decl = function(defaults) {\n    return new Declaration22(defaults);\n};\npostcss.rule = function(defaults) {\n    return new Rule22(defaults);\n};\npostcss.root = function(defaults) {\n    return new Root22(defaults);\n};\npostcss.document = function(defaults) {\n    return new Document222(defaults);\n};\npostcss.CssSyntaxError = CssSyntaxError22;\npostcss.Declaration = Declaration22;\npostcss.Container = Container22;\npostcss.Processor = Processor22;\npostcss.Document = Document222;\npostcss.Comment = Comment22;\npostcss.Warning = Warning22;\npostcss.AtRule = AtRule22;\npostcss.Result = Result22;\npostcss.Input = Input22;\npostcss.Rule = Rule22;\npostcss.Root = Root22;\npostcss.Node = Node22;\nLazyResult22.registerPostcss(postcss);\nvar postcss_1 = postcss;\npostcss.default = postcss;\nvar postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);\npostcss$1.stringify;\npostcss$1.fromJSON;\npostcss$1.plugin;\npostcss$1.parse;\npostcss$1.list;\npostcss$1.document;\npostcss$1.comment;\npostcss$1.atRule;\npostcss$1.rule;\npostcss$1.decl;\npostcss$1.root;\npostcss$1.CssSyntaxError;\npostcss$1.Declaration;\npostcss$1.Container;\npostcss$1.Processor;\npostcss$1.Document;\npostcss$1.Comment;\npostcss$1.Warning;\npostcss$1.AtRule;\npostcss$1.Result;\npostcss$1.Input;\npostcss$1.Rule;\npostcss$1.Root;\npostcss$1.Node;\nvar BaseRRNode = /*#__PURE__*/ function() {\n    function BaseRRNode() {\n        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n            _args[_key] = arguments[_key];\n        }\n        __publicField2(this, \"parentElement\", null);\n        __publicField2(this, \"parentNode\", null);\n        __publicField2(this, \"ownerDocument\");\n        __publicField2(this, \"firstChild\", null);\n        __publicField2(this, \"lastChild\", null);\n        __publicField2(this, \"previousSibling\", null);\n        __publicField2(this, \"nextSibling\", null);\n        __publicField2(this, \"ELEMENT_NODE\", 1);\n        __publicField2(this, \"TEXT_NODE\", 3);\n        __publicField2(this, \"nodeType\");\n        __publicField2(this, \"nodeName\");\n        __publicField2(this, \"RRNodeType\");\n    }\n    var _proto = BaseRRNode.prototype;\n    _proto.contains = function contains(node2) {\n        if (!_instanceof(node2, BaseRRNode)) return false;\n        else if (node2.ownerDocument !== this.ownerDocument) return false;\n        else if (node2 === this) return true;\n        while(node2.parentNode){\n            if (node2.parentNode === this) return true;\n            node2 = node2.parentNode;\n        }\n        return false;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.appendChild = function appendChild(_newChild) {\n        throw new Error(\"RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.insertBefore = function insertBefore(_newChild, _refChild) {\n        throw new Error(\"RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.removeChild = function removeChild(_node) {\n        throw new Error(\"RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    _proto.toString = function toString() {\n        return \"RRNode\";\n    };\n    _create_class(BaseRRNode, [\n        {\n            key: \"childNodes\",\n            get: function get() {\n                var childNodes2 = [];\n                var childIterator = this.firstChild;\n                while(childIterator){\n                    childNodes2.push(childIterator);\n                    childIterator = childIterator.nextSibling;\n                }\n                return childNodes2;\n            }\n        }\n    ]);\n    return BaseRRNode;\n}();\nvar testableAccessors = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype = {};\nvar isAngularZonePresent = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n    if (untaintedBasePrototype[key]) return untaintedBasePrototype[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods ? testableMethods[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n        untaintedBasePrototype[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache[cacheKey]) return untaintedAccessorCache[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache[cacheKey]) return untaintedMethodCache[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentElement\");\n}\nfunction textContent(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"textContent\");\n}\nfunction contains(n2, other) {\n    return getUntaintedMethod(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode(n2) {\n    return getUntaintedMethod(\"Node\", n2, \"getRootNode\")();\n}\nfunction host(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n    return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nvar index = {\n    childNodes: childNodes,\n    parentNode: parentNode,\n    parentElement: parentElement,\n    textContent: textContent,\n    contains: contains,\n    getRootNode: getRootNode,\n    host: host,\n    styleSheets: styleSheets,\n    shadowRoot: shadowRoot,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    mutationObserver: mutationObserverCtor\n};\nfunction on(type, fn, target) {\n    if (target === void 0) target = document;\n    var options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return function() {\n        return target.removeEventListener(type, fn, options);\n    };\n}\nvar DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nvar _mirror = {\n    map: {},\n    getId: function getId() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode: function getNode() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap: function removeNodeFromMap() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has: function has() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset: function reset() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n        get: function get(target, prop, receiver) {\n            if (prop === \"map\") {\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\nfunction throttle(func, wait, options) {\n    if (options === void 0) options = {};\n    var timeout = null;\n    var previous = 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        var remaining = wait - (now - previous);\n        var context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(function() {\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked, win) {\n    if (win === void 0) win = window;\n    var original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set: function set(value) {\n            var _this = this;\n            setTimeout(function() {\n                d.set.call(_this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return function() {\n        return hookSetter(target, key, original || {}, true);\n    };\n}\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = function() {\n        return /* @__PURE__ */ new Date().getTime();\n    };\n}\nfunction getWindowScroll(win) {\n    var _a2, _b, _c, _d;\n    var doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node2) {\n    if (!node2) {\n        return null;\n    }\n    var el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);\n    return el;\n}\nfunction isBlocked(node2, blockClass, blockSelector, checkAncestors) {\n    if (!node2) {\n        return false;\n    }\n    var el = closestElementOfNode(node2);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e2) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n2, mirror2) {\n    return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2, slimDOMOptions) {\n    if (n2.tagName === \"TITLE\" && slimDOMOptions.headTitleMutations) {\n        return true;\n    }\n    return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    var id = mirror2.getId(target);\n    if (!mirror2.has(id)) {\n        return true;\n    }\n    var parent = index.parentNode(target);\n    if (parent && parent.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!parent) {\n        return true;\n    }\n    return isAncestorRemoved(parent, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win) {\n    if (win === void 0) win = window;\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n}\nfunction isSerializedIframe(n2, mirror2) {\n    return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n    return Boolean(n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2));\n}\nfunction hasShadowRoot(n2) {\n    if (!n2) return false;\n    if (_instanceof(n2, BaseRRNode) && \"shadowRoot\" in n2) {\n        return Boolean(n2.shadowRoot);\n    }\n    return Boolean(index.shadowRoot(n2));\n}\nvar StyleSheetMirror = /*#__PURE__*/ function() {\n    function StyleSheetMirror() {\n        __publicField(this, \"id\", 1);\n        __publicField(this, \"styleIDMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"idStyleMap\", /* @__PURE__ */ new Map());\n    }\n    var _proto = StyleSheetMirror.prototype;\n    _proto.getId = function getId(stylesheet) {\n        var _this_styleIDMap_get;\n        return (_this_styleIDMap_get = this.styleIDMap.get(stylesheet)) != null ? _this_styleIDMap_get : -1;\n    };\n    _proto.has = function has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    };\n    /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */ _proto.add = function add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        var newId;\n        if (id === void 0) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    };\n    _proto.getStyle = function getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    };\n    _proto.reset = function reset() {\n        this.styleIDMap = /* @__PURE__ */ new WeakMap();\n        this.idStyleMap = /* @__PURE__ */ new Map();\n        this.id = 1;\n    };\n    _proto.generateId = function generateId() {\n        return this.id++;\n    };\n    return StyleSheetMirror;\n}();\nfunction getShadowHost(n2) {\n    var _a2;\n    var shadowHost = null;\n    if (\"getRootNode\" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2))) shadowHost = index.host(index.getRootNode(n2));\n    return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n    var rootShadowHost = n2;\n    var shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    var shadowHost = getRootShadowHost(n2);\n    return index.contains(doc, shadowHost);\n}\nfunction inDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    return index.contains(doc, n2) || shadowHostInDom(n2);\n}\nvar EventType = /* @__PURE__ */ function(EventType2) {\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n}(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ function(IncrementalSource2) {\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n}(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ function(MouseInteractions2) {\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n}(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ function(PointerTypes2) {\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n}(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ function(CanvasContext2) {\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n}(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ function(MediaInteractions2) {\n    MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n    MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n    MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n    MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n    MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n    return MediaInteractions2;\n}(MediaInteractions || {});\nvar NodeType = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType || {});\nfunction isNodeInLinkedList(n2) {\n    return \"__ln\" in n2;\n}\nvar DoubleLinkedList = /*#__PURE__*/ function() {\n    function DoubleLinkedList() {\n        __publicField(this, \"length\", 0);\n        __publicField(this, \"head\", null);\n        __publicField(this, \"tail\", null);\n    }\n    var _proto = DoubleLinkedList.prototype;\n    _proto.get = function get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        var current = this.head;\n        for(var index2 = 0; index2 < position; index2++){\n            current = (current == null ? void 0 : current.next) || null;\n        }\n        return current;\n    };\n    _proto.addNode = function addNode(n2) {\n        var node2 = {\n            value: n2,\n            previous: null,\n            next: null\n        };\n        n2.__ln = node2;\n        if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n            var current = n2.previousSibling.__ln.next;\n            node2.next = current;\n            node2.previous = n2.previousSibling.__ln;\n            n2.previousSibling.__ln.next = node2;\n            if (current) {\n                current.previous = node2;\n            }\n        } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n            var current1 = n2.nextSibling.__ln.previous;\n            node2.previous = current1;\n            node2.next = n2.nextSibling.__ln;\n            n2.nextSibling.__ln.previous = node2;\n            if (current1) {\n                current1.next = node2;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node2;\n            }\n            node2.next = this.head;\n            this.head = node2;\n        }\n        if (node2.next === null) {\n            this.tail = node2;\n        }\n        this.length++;\n    };\n    _proto.removeNode = function removeNode(n2) {\n        var current = n2.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n2.__ln) {\n            delete n2.__ln;\n        }\n        this.length--;\n    };\n    return DoubleLinkedList;\n}();\nvar moveKey = function(id, parentId) {\n    return id + \"@\" + parentId;\n};\nvar MutationBuffer = /*#__PURE__*/ function() {\n    function MutationBuffer() {\n        var _this = this;\n        __publicField(this, \"frozen\", false);\n        __publicField(this, \"locked\", false);\n        __publicField(this, \"texts\", []);\n        __publicField(this, \"attributes\", []);\n        __publicField(this, \"attributeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"removes\", []);\n        __publicField(this, \"mapRemoves\", []);\n        __publicField(this, \"movedMap\", {});\n        /**\n     * the browser MutationObserver emits multiple mutations after\n     * a delay for performance reasons, making tracing added nodes hard\n     * in our `processMutations` callback function.\n     * For example, if we append an element el_1 into body, and then append\n     * another element el_2 into el_1, these two mutations may be passed to the\n     * callback function together when the two operations were done.\n     * Generally we need to trace child nodes of newly added nodes, but in this\n     * case if we count el_2 as el_1's child node in the first mutation record,\n     * then we will count el_2 again in the second mutation record which was\n     * duplicated.\n     * To avoid of duplicate counting added nodes, we use a Set to store\n     * added nodes and its child nodes during iterate mutation records. Then\n     * collect added nodes from the Set which have no duplicate copy. But\n     * this also causes newly added nodes will not be serialized with id ASAP,\n     * which means all the id related calculation should be lazy too.\n     */ __publicField(this, \"addedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"movedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"droppedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"removesSubTreeCache\", /* @__PURE__ */ new Set());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"blockClass\");\n        __publicField(this, \"blockSelector\");\n        __publicField(this, \"maskTextClass\");\n        __publicField(this, \"maskTextSelector\");\n        __publicField(this, \"inlineStylesheet\");\n        __publicField(this, \"maskInputOptions\");\n        __publicField(this, \"maskTextFn\");\n        __publicField(this, \"maskInputFn\");\n        __publicField(this, \"keepIframeSrcFn\");\n        __publicField(this, \"recordCanvas\");\n        __publicField(this, \"inlineImages\");\n        __publicField(this, \"slimDOMOptions\");\n        __publicField(this, \"dataURLOptions\");\n        __publicField(this, \"doc\");\n        __publicField(this, \"mirror\");\n        __publicField(this, \"iframeManager\");\n        __publicField(this, \"stylesheetManager\");\n        __publicField(this, \"shadowDomManager\");\n        __publicField(this, \"canvasManager\");\n        __publicField(this, \"processedNodeManager\");\n        __publicField(this, \"unattachedDoc\");\n        __publicField(this, \"processMutations\", function(mutations) {\n            mutations.forEach(_this.processMutation);\n            _this.emit();\n        });\n        __publicField(this, \"emit\", function() {\n            if (_this.frozen || _this.locked) {\n                return;\n            }\n            var adds = [];\n            var addedIds = /* @__PURE__ */ new Set();\n            var addList = new DoubleLinkedList();\n            var getNextId = function(n2) {\n                var ns = n2;\n                var nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && _this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            var pushAdd = function(n2) {\n                var parent = index.parentNode(n2);\n                if (!parent || !inDom(n2)) {\n                    return;\n                }\n                var cssCaptured = false;\n                if (n2.nodeType === Node.TEXT_NODE) {\n                    var parentTag = parent.tagName;\n                    if (parentTag === \"TEXTAREA\") {\n                        return;\n                    } else if (parentTag === \"STYLE\" && _this.addedSet.has(parent)) {\n                        cssCaptured = true;\n                    }\n                }\n                var parentId = isShadowRoot(parent) ? _this.mirror.getId(getShadowHost(n2)) : _this.mirror.getId(parent);\n                var nextId = getNextId(n2);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n2);\n                }\n                var sn = serializeNodeWithId(n2, {\n                    doc: _this.doc,\n                    mirror: _this.mirror,\n                    blockClass: _this.blockClass,\n                    blockSelector: _this.blockSelector,\n                    maskTextClass: _this.maskTextClass,\n                    maskTextSelector: _this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: _this.inlineStylesheet,\n                    maskInputOptions: _this.maskInputOptions,\n                    maskTextFn: _this.maskTextFn,\n                    maskInputFn: _this.maskInputFn,\n                    slimDOMOptions: _this.slimDOMOptions,\n                    dataURLOptions: _this.dataURLOptions,\n                    recordCanvas: _this.recordCanvas,\n                    inlineImages: _this.inlineImages,\n                    onSerialize: function(currentN) {\n                        if (isSerializedIframe(currentN, _this.mirror)) {\n                            _this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, _this.mirror)) {\n                            _this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n2)) {\n                            _this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), _this.doc);\n                        }\n                    },\n                    onIframeLoad: function(iframe, childSn) {\n                        _this.iframeManager.attachIframe(iframe, childSn);\n                        _this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: function(link, childSn) {\n                        _this.stylesheetManager.attachLinkElement(link, childSn);\n                    },\n                    cssCaptured: cssCaptured\n                });\n                if (sn) {\n                    adds.push({\n                        parentId: parentId,\n                        nextId: nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(_this.mapRemoves.length){\n                _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(_this.movedSet), _step; !(_step = _iterator()).done;){\n                var n2 = _step.value;\n                if (isParentRemoved(_this.removesSubTreeCache, n2, _this.mirror) && !_this.movedSet.has(index.parentNode(n2))) {\n                    continue;\n                }\n                pushAdd(n2);\n            }\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(_this.addedSet), _step1; !(_step1 = _iterator1()).done;){\n                var n21 = _step1.value;\n                if (!isAncestorInSet(_this.droppedSet, n21) && !isParentRemoved(_this.removesSubTreeCache, n21, _this.mirror)) {\n                    pushAdd(n21);\n                } else if (isAncestorInSet(_this.movedSet, n21)) {\n                    pushAdd(n21);\n                } else {\n                    _this.droppedSet.add(n21);\n                }\n            }\n            var candidate = null;\n            while(addList.length){\n                var node2 = null;\n                if (candidate) {\n                    var parentId = _this.mirror.getId(index.parentNode(candidate.value));\n                    var nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node2 = candidate;\n                    }\n                }\n                if (!node2) {\n                    var tailNode = addList.tail;\n                    while(tailNode){\n                        var _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            var parentId1 = _this.mirror.getId(index.parentNode(_node.value));\n                            var nextId1 = getNextId(_node.value);\n                            if (nextId1 === -1) continue;\n                            else if (parentId1 !== -1) {\n                                node2 = _node;\n                                break;\n                            } else {\n                                var unhandledNode = _node.value;\n                                var parent = index.parentNode(unhandledNode);\n                                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    var shadowHost = index.host(parent);\n                                    var parentId2 = _this.mirror.getId(shadowHost);\n                                    if (parentId2 !== -1) {\n                                        node2 = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node2) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node2.previous;\n                addList.removeNode(node2.value);\n                pushAdd(node2.value);\n            }\n            var payload = {\n                texts: _this.texts.map(function(text) {\n                    var n2 = text.node;\n                    var parent = index.parentNode(n2);\n                    if (parent && parent.tagName === \"TEXTAREA\") {\n                        _this.genTextAreaValueMutation(parent);\n                    }\n                    return {\n                        id: _this.mirror.getId(n2),\n                        value: text.value\n                    };\n                }).filter(function(text) {\n                    return !addedIds.has(text.id);\n                }).filter(function(text) {\n                    return _this.mirror.has(text.id);\n                }),\n                attributes: _this.attributes.map(function(attribute) {\n                    var attributes = attribute.attributes;\n                    if (typeof attributes.style === \"string\") {\n                        var diffAsStr = JSON.stringify(attribute.styleDiff);\n                        var unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: _this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter(function(attribute) {\n                    return !addedIds.has(attribute.id);\n                }).filter(function(attribute) {\n                    return _this.mirror.has(attribute.id);\n                }),\n                removes: _this.removes,\n                adds: adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            _this.texts = [];\n            _this.attributes = [];\n            _this.attributeMap = /* @__PURE__ */ new WeakMap();\n            _this.removes = [];\n            _this.addedSet = /* @__PURE__ */ new Set();\n            _this.movedSet = /* @__PURE__ */ new Set();\n            _this.droppedSet = /* @__PURE__ */ new Set();\n            _this.removesSubTreeCache = /* @__PURE__ */ new Set();\n            _this.movedMap = {};\n            _this.mutationCb(payload);\n        });\n        __publicField(this, \"genTextAreaValueMutation\", function(textarea) {\n            var item = _this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                _this.attributes.push(item);\n                _this.attributeMap.set(textarea, item);\n            }\n            item.attributes.value = Array.from(index.childNodes(textarea), function(cn) {\n                return index.textContent(cn) || \"\";\n            }).join(\"\");\n        });\n        __publicField(this, \"processMutation\", function(m) {\n            if (isIgnored(m.target, _this.mirror, _this.slimDOMOptions)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        var value = index.textContent(m.target);\n                        if (!isBlocked(m.target, _this.blockClass, _this.blockSelector, false) && value !== m.oldValue) {\n                            _this.texts.push({\n                                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector, true) && value ? _this.maskTextFn ? _this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        var target = m.target;\n                        var attributeName = m.attributeName;\n                        var value1 = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            var type = getInputType(target);\n                            value1 = maskInputValue({\n                                element: target,\n                                maskInputOptions: _this.maskInputOptions,\n                                tagName: target.tagName,\n                                type: type,\n                                value: value1,\n                                maskInputFn: _this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || value1 === m.oldValue) {\n                            return;\n                        }\n                        var item = _this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !_this.keepIframeSrcFn(value1)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            _this.attributes.push(item);\n                            _this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(_this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value1);\n                            if (attributeName === \"style\") {\n                                if (!_this.unattachedDoc) {\n                                    try {\n                                        _this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e2) {\n                                        _this.unattachedDoc = _this.doc;\n                                    }\n                                }\n                                var old = _this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(target.style)), _step; !(_step = _iterator()).done;){\n                                    var pname = _step.value;\n                                    var newValue = target.style.getPropertyValue(pname);\n                                    var newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(old.style)), _step1; !(_step1 = _iterator1()).done;){\n                                    var pname1 = _step1.value;\n                                    if (target.style.getPropertyValue(pname1) === \"\") {\n                                        item.styleDiff[pname1] = false;\n                                    }\n                                }\n                            } else if (attributeName === \"open\" && target.tagName === \"DIALOG\") {\n                                if (target.matches(\"dialog:modal\")) {\n                                    item.attributes[\"rr_open_mode\"] = \"modal\";\n                                } else {\n                                    item.attributes[\"rr_open_mode\"] = \"non-modal\";\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            _this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach(function(n2) {\n                            return _this.genAdds(n2, m.target);\n                        });\n                        m.removedNodes.forEach(function(n2) {\n                            var nodeId = _this.mirror.getId(n2);\n                            var parentId = isShadowRoot(m.target) ? _this.mirror.getId(index.host(m.target)) : _this.mirror.getId(m.target);\n                            if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || isIgnored(n2, _this.mirror, _this.slimDOMOptions) || !isSerialized(n2, _this.mirror)) {\n                                return;\n                            }\n                            if (_this.addedSet.has(n2)) {\n                                deepDelete(_this.addedSet, n2);\n                                _this.droppedSet.add(n2);\n                            } else if (_this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, _this.mirror)) ;\n                            else if (_this.movedSet.has(n2) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(_this.movedSet, n2);\n                            } else {\n                                _this.removes.push({\n                                    parentId: parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                                });\n                                processRemoves(n2, _this.removesSubTreeCache);\n                            }\n                            _this.mapRemoves.push(n2);\n                        });\n                        break;\n                    }\n            }\n        });\n        /**\n     * Make sure you check if `n`'s parent is blocked before calling this function\n     * */ __publicField(this, \"genAdds\", function(n2, target) {\n            if (_this.processedNodeManager.inOtherBuffer(n2, _this)) return;\n            if (_this.addedSet.has(n2) || _this.movedSet.has(n2)) return;\n            if (_this.mirror.hasNode(n2)) {\n                if (isIgnored(n2, _this.mirror, _this.slimDOMOptions)) {\n                    return;\n                }\n                _this.movedSet.add(n2);\n                var targetId = null;\n                if (target && _this.mirror.hasNode(target)) {\n                    targetId = _this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    _this.movedMap[moveKey(_this.mirror.getId(n2), targetId)] = true;\n                }\n            } else {\n                _this.addedSet.add(n2);\n                _this.droppedSet.delete(n2);\n            }\n            if (!isBlocked(n2, _this.blockClass, _this.blockSelector, false)) {\n                index.childNodes(n2).forEach(function(childN) {\n                    return _this.genAdds(childN);\n                });\n                if (hasShadowRoot(n2)) {\n                    index.childNodes(index.shadowRoot(n2)).forEach(function(childN) {\n                        _this.processedNodeManager.add(childN, _this);\n                        _this.genAdds(childN, n2);\n                    });\n                }\n            }\n        });\n    }\n    var _proto = MutationBuffer.prototype;\n    _proto.init = function init(options) {\n        var _this = this;\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach(function(key) {\n            _this[key] = options[key];\n        });\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    };\n    _proto.isFrozen = function isFrozen() {\n        return this.frozen;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    };\n    _proto.reset = function reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    };\n    return MutationBuffer;\n}();\nfunction deepDelete(addsSet, n2) {\n    addsSet.delete(n2);\n    index.childNodes(n2).forEach(function(childN) {\n        return deepDelete(addsSet, childN);\n    });\n}\nfunction processRemoves(n2, cache) {\n    var queue = [\n        n2\n    ];\n    while(queue.length){\n        var next = queue.pop();\n        if (cache.has(next)) continue;\n        cache.add(next);\n        index.childNodes(next).forEach(function(n22) {\n            return queue.push(n22);\n        });\n    }\n    return;\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n    if (removes.size === 0) return false;\n    return _isParentRemoved(removes, n2);\n}\nfunction _isParentRemoved(removes, n2, _mirror2) {\n    var node2 = index.parentNode(n2);\n    if (!node2) return false;\n    return removes.has(node2);\n}\nfunction isAncestorInSet(set, n2) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n    var parent = index.parentNode(n2);\n    if (!parent) {\n        return false;\n    }\n    if (set.has(parent)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parent);\n}\nvar errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = void 0;\n}\nvar callbackWrapper = function(cb) {\n    if (!errorHandler) {\n        return cb;\n    }\n    var rrwebWrapped = function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        try {\n            return cb.apply(void 0, [].concat(rest));\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nvar mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            var path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (e) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    var observer = new (mutationObserverCtor())(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver(param) {\n    var mousemoveCb = param.mousemoveCb, sampling = param.sampling, doc = param.doc, mirror2 = param.mirror;\n    if (sampling.mousemove === false) {\n        return function() {};\n    }\n    var threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    var callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    var positions = [];\n    var timeBaseline;\n    var wrappedCb = throttle(callbackWrapper(function(source) {\n        var totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map(function(p) {\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        var _ref = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt, clientX = _ref.clientX, clientY = _ref.clientY;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror2.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && _instanceof(evt, DragEvent) ? IncrementalSource.Drag : _instanceof(evt, MouseEvent) ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    var handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initMouseInteractionObserver(param) {\n    var mouseInteractionCb = param.mouseInteractionCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    if (sampling.mouseInteraction === false) {\n        return function() {};\n    }\n    var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n    var handlers = [];\n    var currentPointerType = null;\n    var getHandler = function(eventKey) {\n        return function(event) {\n            var target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var pointerType = null;\n            var thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            var e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e2) {\n                return;\n            }\n            var id = mirror2.getId(target);\n            var clientX = e2.clientX, clientY = e2.clientY;\n            callbackWrapper(mouseInteractionCb)(_extends({\n                type: MouseInteractions[thisEventKey],\n                id: id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType: pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter(function(key) {\n        return Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false;\n    }).forEach(function(eventKey) {\n        var eventName = toLowerCase(eventKey);\n        var handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initScrollObserver(param) {\n    var scrollCb = param.scrollCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        var id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n            var scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id: id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id: id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver(param, param1) {\n    var viewportResizeCb = param.viewportResizeCb;\n    var win = param1.win;\n    var lastH = -1;\n    var lastW = -1;\n    var updateDimension = callbackWrapper(throttle(callbackWrapper(function() {\n        var height = getWindowHeight();\n        var width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nvar INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nvar lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver(param) {\n    var inputCb = param.inputCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, ignoreClass = param.ignoreClass, ignoreSelector = param.ignoreSelector, maskInputOptions = param.maskInputOptions, maskInputFn = param.maskInputFn, sampling = param.sampling, userTriggeredOnInput = param.userTriggeredOnInput;\n    function eventHandler(event) {\n        var target = getEventTarget(event);\n        var userTriggered = event.isTrusted;\n        var tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = index.parentElement(target);\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        var text = target.value;\n        var isChecked = false;\n        var type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions: maskInputOptions,\n                tagName: tagName,\n                type: type,\n                value: text,\n                maskInputFn: maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text: text,\n            isChecked: isChecked,\n            userTriggered: userTriggered\n        } : {\n            text: text,\n            isChecked: isChecked\n        });\n        var name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]').forEach(function(el) {\n                if (el !== target) {\n                    var text2 = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text: text2,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text: text2,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v2) {\n        var lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n            lastInputValueMap.set(target, v2);\n            var id = mirror2.getId(target);\n            callbackWrapper(inputCb)(_extends({}, v2, {\n                id: id\n            }));\n        }\n    }\n    var events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    var handlers = events.map(function(eventName) {\n        return on(eventName, callbackWrapper(eventHandler), doc);\n    });\n    var currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n        };\n    }\n    var propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    var hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        // Some UI library use selectedIndex to set select value\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        var _handlers;\n        (_handlers = handlers).push.apply(_handlers, [].concat(hookProperties.map(function(p) {\n            return hookSetter(p[0], p[1], {\n                set: function set() {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow);\n        })));\n    }\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction getNestedCSSRulePositions(rule2) {\n    var positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && _instanceof(childRule.parentRule, CSSGroupingRule) || hasNestedCSSRule(\"CSSMediaRule\") && _instanceof(childRule.parentRule, CSSMediaRule) || hasNestedCSSRule(\"CSSSupportsRule\") && _instanceof(childRule.parentRule, CSSSupportsRule) || hasNestedCSSRule(\"CSSConditionRule\") && _instanceof(childRule.parentRule, CSSConditionRule)) {\n            var rules2 = Array.from(childRule.parentRule.cssRules);\n            var index2 = rules2.indexOf(childRule);\n            pos.unshift(index2);\n        } else if (childRule.parentStyleSheet) {\n            var rules21 = Array.from(childRule.parentStyleSheet.cssRules);\n            var index21 = rules21.indexOf(childRule);\n            pos.unshift(index21);\n        }\n        return pos;\n    }\n    return recurse(rule2, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n    var id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId: styleId,\n        id: id\n    };\n}\nfunction initStyleSheetObserver(param, param1) {\n    var styleSheetRuleCb = param.styleSheetRuleCb, mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return function() {};\n    }\n    var insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var rule2 = argumentsList[0], index2 = argumentsList[1];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    adds: [\n                        {\n                            rule: rule2,\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2) {\n        if (index2 === void 0) index2 = this.cssRules.length;\n        var rule2 = selector + \" { \" + styleBlock + \" }\";\n        return win.CSSStyleSheet.prototype.insertRule.apply(this, [\n            rule2,\n            index2\n        ]);\n    };\n    var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var index2 = argumentsList[0];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    removes: [\n                        {\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.removeRule = function(index2) {\n        return win.CSSStyleSheet.prototype.deleteRule.apply(this, [\n            index2\n        ]);\n    };\n    var replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    var unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n        var typeKey = param[0], type = param[1];\n        unmodifiedFunctions[typeKey] = {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            insertRule: type.prototype.insertRule,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var rule2 = argumentsList[0], index2 = argumentsList[1];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        adds: [\n                            {\n                                rule: rule2,\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2 || 0\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var index2 = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        removes: [\n                            {\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n            var typeKey = param[0], type = param[1];\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver(param, host2) {\n    var mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var _a2, _b, _c;\n    var hostId = null;\n    if (host2.nodeName === \"#document\") hostId = mirror2.getId(host2);\n    else hostId = mirror2.getId(index.host(host2));\n    var patchTarget = host2.nodeName === \"#document\" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;\n    var originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget == null ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : void 0;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return function() {};\n    Object.defineProperty(host2, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get: function get() {\n            var _a3;\n            return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);\n        },\n        set: function set(sheets) {\n            var _a3;\n            var result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e2) {}\n            }\n            return result2;\n        }\n    });\n    return callbackWrapper(function() {\n        Object.defineProperty(host2, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            get: originalPropertyDescriptor.get,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver(param, param1) {\n    var styleDeclarationCb = param.styleDeclarationCb, mirror2 = param.mirror, ignoreCSSAttributes = param.ignoreCSSAttributes, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0], value = argumentsList[1], priority = argumentsList[2];\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    set: {\n                        property: property,\n                        value: value,\n                        priority: priority\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0];\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    remove: {\n                        property: property\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver(param) {\n    var mediaInteractionCb = param.mediaInteractionCb, blockClass = param.blockClass, blockSelector = param.blockSelector, mirror2 = param.mirror, sampling = param.sampling, doc = param.doc;\n    var handler = callbackWrapper(function(type) {\n        return throttle(callbackWrapper(function(event) {\n            var target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var currentTime = target.currentTime, volume = target.volume, muted = target.muted, playbackRate = target.playbackRate, loop = target.loop;\n            mediaInteractionCb({\n                type: type,\n                id: mirror2.getId(target),\n                currentTime: currentTime,\n                volume: volume,\n                muted: muted,\n                playbackRate: playbackRate,\n                loop: loop\n            });\n        }), sampling.media || 500);\n    });\n    var handlers = [\n        on(\"play\", handler(MediaInteractions.Play), doc),\n        on(\"pause\", handler(MediaInteractions.Pause), doc),\n        on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n        on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n        on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initFontObserver(param) {\n    var fontCb = param.fontCb, doc = param.doc;\n    var win = doc.defaultView;\n    if (!win) {\n        return function() {};\n    }\n    var handlers = [];\n    var fontMap = /* @__PURE__ */ new WeakMap();\n    var originalFontFace = win.FontFace;\n    win.FontFace = function FontFace2(family, source, descriptors) {\n        var fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family: family,\n            buffer: typeof source !== \"string\",\n            descriptors: descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    var restoreHandler = patch(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(function() {\n                var p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(function() {\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initSelectionObserver(param) {\n    var doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, selectionCb = param.selectionCb;\n    var collapsed = true;\n    var updateSelection = callbackWrapper(function() {\n        var selection = doc.getSelection();\n        if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        var ranges = [];\n        var count = selection.rangeCount || 0;\n        for(var i2 = 0; i2 < count; i2++){\n            var range = selection.getRangeAt(i2);\n            var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;\n            var blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror2.getId(startContainer),\n                startOffset: startOffset,\n                end: mirror2.getId(endContainer),\n                endOffset: endOffset\n            });\n        }\n        selectionCb({\n            ranges: ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver(param) {\n    var doc = param.doc, customElementCb = param.customElementCb;\n    var win = doc.defaultView;\n    if (!win || !win.customElements) return function() {};\n    var restoreHandler = patch(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name: name\n                    }\n                });\n            } catch (e2) {\n                console.warn(\"Custom element callback failed for \" + name);\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o2, hooks) {\n    var mutationCb = o2.mutationCb, mousemoveCb = o2.mousemoveCb, mouseInteractionCb = o2.mouseInteractionCb, scrollCb = o2.scrollCb, viewportResizeCb = o2.viewportResizeCb, inputCb = o2.inputCb, mediaInteractionCb = o2.mediaInteractionCb, styleSheetRuleCb = o2.styleSheetRuleCb, styleDeclarationCb = o2.styleDeclarationCb, canvasMutationCb = o2.canvasMutationCb, fontCb = o2.fontCb, selectionCb = o2.selectionCb, customElementCb = o2.customElementCb;\n    o2.mutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mutation) {\n            var _hooks;\n            (_hooks = hooks).mutation.apply(_hooks, [].concat(p));\n        }\n        mutationCb.apply(void 0, [].concat(p));\n    };\n    o2.mousemoveCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mousemove) {\n            var _hooks;\n            (_hooks = hooks).mousemove.apply(_hooks, [].concat(p));\n        }\n        mousemoveCb.apply(void 0, [].concat(p));\n    };\n    o2.mouseInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mouseInteraction) {\n            var _hooks;\n            (_hooks = hooks).mouseInteraction.apply(_hooks, [].concat(p));\n        }\n        mouseInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.scrollCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.scroll) {\n            var _hooks;\n            (_hooks = hooks).scroll.apply(_hooks, [].concat(p));\n        }\n        scrollCb.apply(void 0, [].concat(p));\n    };\n    o2.viewportResizeCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.viewportResize) {\n            var _hooks;\n            (_hooks = hooks).viewportResize.apply(_hooks, [].concat(p));\n        }\n        viewportResizeCb.apply(void 0, [].concat(p));\n    };\n    o2.inputCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.input) {\n            var _hooks;\n            (_hooks = hooks).input.apply(_hooks, [].concat(p));\n        }\n        inputCb.apply(void 0, [].concat(p));\n    };\n    o2.mediaInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mediaInteaction) {\n            var _hooks;\n            (_hooks = hooks).mediaInteaction.apply(_hooks, [].concat(p));\n        }\n        mediaInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.styleSheetRuleCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleSheetRule) {\n            var _hooks;\n            (_hooks = hooks).styleSheetRule.apply(_hooks, [].concat(p));\n        }\n        styleSheetRuleCb.apply(void 0, [].concat(p));\n    };\n    o2.styleDeclarationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleDeclaration) {\n            var _hooks;\n            (_hooks = hooks).styleDeclaration.apply(_hooks, [].concat(p));\n        }\n        styleDeclarationCb.apply(void 0, [].concat(p));\n    };\n    o2.canvasMutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.canvasMutation) {\n            var _hooks;\n            (_hooks = hooks).canvasMutation.apply(_hooks, [].concat(p));\n        }\n        canvasMutationCb.apply(void 0, [].concat(p));\n    };\n    o2.fontCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.font) {\n            var _hooks;\n            (_hooks = hooks).font.apply(_hooks, [].concat(p));\n        }\n        fontCb.apply(void 0, [].concat(p));\n    };\n    o2.selectionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.selection) {\n            var _hooks;\n            (_hooks = hooks).selection.apply(_hooks, [].concat(p));\n        }\n        selectionCb.apply(void 0, [].concat(p));\n    };\n    o2.customElementCb = function() {\n        for(var _len = arguments.length, c2 = new Array(_len), _key = 0; _key < _len; _key++){\n            c2[_key] = arguments[_key];\n        }\n        if (hooks.customElement) {\n            var _hooks;\n            (_hooks = hooks).customElement.apply(_hooks, [].concat(c2));\n        }\n        customElementCb.apply(void 0, [].concat(c2));\n    };\n}\nfunction initObservers(o2, hooks) {\n    if (hooks === void 0) hooks = {};\n    var currentWindow = o2.doc.defaultView;\n    if (!currentWindow) {\n        return function() {};\n    }\n    mergeHooks(o2, hooks);\n    var mutationObserver;\n    if (o2.recordDOM) {\n        mutationObserver = initMutationObserver(o2, o2.doc);\n    }\n    var mousemoveHandler = initMoveObserver(o2);\n    var mouseInteractionHandler = initMouseInteractionObserver(o2);\n    var scrollHandler = initScrollObserver(o2);\n    var viewportResizeHandler = initViewportResizeObserver(o2, {\n        win: currentWindow\n    });\n    var inputHandler = initInputObserver(o2);\n    var mediaInteractionHandler = initMediaInteractionObserver(o2);\n    var styleSheetObserver = function() {};\n    var adoptedStyleSheetObserver = function() {};\n    var styleDeclarationObserver = function() {};\n    var fontObserver = function() {};\n    if (o2.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o2, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n            win: currentWindow\n        });\n        if (o2.collectFonts) {\n            fontObserver = initFontObserver(o2);\n        }\n    }\n    var selectionObserver = initSelectionObserver(o2);\n    var customElementObserver = initCustomElementObserver(o2);\n    var pluginHandlers = [];\n    for(var _iterator = _create_for_of_iterator_helper_loose(o2.plugins), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        pluginHandlers.push(plugin3.observer(plugin3.callback, currentWindow, plugin3.options));\n    }\n    return callbackWrapper(function() {\n        mutationBuffers.forEach(function(b) {\n            return b.reset();\n        });\n        mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nvar CrossOriginIframeMirror = /*#__PURE__*/ function() {\n    function CrossOriginIframeMirror(generateIdFn) {\n        __publicField(this, \"iframeIdToRemoteIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"iframeRemoteIdToIdMap\", /* @__PURE__ */ new WeakMap());\n        this.generateIdFn = generateIdFn;\n    }\n    var _proto = CrossOriginIframeMirror.prototype;\n    _proto.getId = function getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        var idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        var id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    };\n    _proto.getIds = function getIds(iframe, remoteId) {\n        var _this = this;\n        var idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map(function(id) {\n            return _this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap);\n        });\n    };\n    _proto.getRemoteId = function getRemoteId(iframe, id, map) {\n        var remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        var remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    };\n    _proto.getRemoteIds = function getRemoteIds(iframe, ids) {\n        var _this = this;\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map(function(id) {\n            return _this.getRemoteId(iframe, id, remoteIdToIdMap);\n        });\n    };\n    _proto.reset = function reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n            this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    };\n    _proto.getIdToRemoteIdMap = function getIdToRemoteIdMap(iframe) {\n        var idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = /* @__PURE__ */ new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    };\n    _proto.getRemoteIdToIdMap = function getRemoteIdToIdMap(iframe) {\n        var remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = /* @__PURE__ */ new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    };\n    return CrossOriginIframeMirror;\n}();\nvar IframeManager = /*#__PURE__*/ function() {\n    function IframeManager(options) {\n        __publicField(this, \"iframes\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"crossOriginIframeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"crossOriginIframeMirror\", new CrossOriginIframeMirror(genId));\n        __publicField(this, \"crossOriginIframeStyleMirror\");\n        __publicField(this, \"crossOriginIframeRootIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"mirror\");\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"wrappedEmit\");\n        __publicField(this, \"loadListener\");\n        __publicField(this, \"stylesheetManager\");\n        __publicField(this, \"recordCrossOriginIframes\");\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n    var _proto = IframeManager.prototype;\n    _proto.addIframe = function addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    };\n    _proto.addLoadListener = function addLoadListener(cb) {\n        this.loadListener = cb;\n    };\n    _proto.attachIframe = function attachIframe(iframeEl, childSn) {\n        var _a2, _b;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        if (this.recordCrossOriginIframes) (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(\"message\", this.handleMessage.bind(this));\n        (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    };\n    _proto.handleMessage = function handleMessage(message) {\n        var crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n        crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        var iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        var iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        var transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    };\n    _proto.transformCrossOriginEvent = function transformCrossOriginEvent(iframeEl, e2) {\n        var _this = this;\n        var _a2;\n        switch(e2.type){\n            case EventType.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e2.data.node, iframeEl);\n                    var rootId = e2.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e2.data.node, rootId);\n                    return {\n                        timestamp: e2.timestamp,\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e2.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType.Meta:\n            case EventType.Load:\n            case EventType.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType.Plugin:\n                {\n                    return e2;\n                }\n            case EventType.Custom:\n                {\n                    this.replaceIds(e2.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e2;\n                }\n            case EventType.IncrementalSnapshot:\n                {\n                    switch(e2.data.source){\n                        case IncrementalSource.Mutation:\n                            {\n                                e2.data.adds.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    _this.replaceIdOnNode(n2.node, iframeEl);\n                                    var rootId = _this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && _this.patchRootIdOnNode(n2.node, rootId);\n                                });\n                                e2.data.removes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.attributes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.texts.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.Drag:\n                        case IncrementalSource.TouchMove:\n                        case IncrementalSource.MouseMove:\n                            {\n                                e2.data.positions.forEach(function(p) {\n                                    _this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource.MediaInteraction:\n                        case IncrementalSource.MouseInteraction:\n                        case IncrementalSource.Scroll:\n                        case IncrementalSource.CanvasMutation:\n                        case IncrementalSource.Input:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.StyleSheetRule:\n                        case IncrementalSource.StyleDeclaration:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.Font:\n                            {\n                                return e2;\n                            }\n                        case IncrementalSource.Selection:\n                            {\n                                e2.data.ranges.forEach(function(range) {\n                                    _this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach(function(style) {\n                                    _this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                    }\n                }\n        }\n        return false;\n    };\n    _proto.replace = function replace(iframeMirror, obj, iframeEl, keys) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n            var key = _step.value;\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    };\n    _proto.replaceIds = function replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceStyleIds = function replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceIdOnNode = function replaceIdOnNode(node2, iframeEl) {\n        var _this = this;\n        this.replaceIds(node2, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    };\n    _proto.patchRootIdOnNode = function patchRootIdOnNode(node2, rootId) {\n        var _this = this;\n        if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    };\n    return IframeManager;\n}();\nvar ShadowDomManager = /*#__PURE__*/ function() {\n    function ShadowDomManager(options) {\n        __publicField(this, \"shadowDoms\", /* @__PURE__ */ new WeakSet());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"scrollCb\");\n        __publicField(this, \"bypassOptions\");\n        __publicField(this, \"mirror\");\n        __publicField(this, \"restoreHandlers\", []);\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n    var _proto = ShadowDomManager.prototype;\n    _proto.init = function init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    };\n    _proto.addShadowRoot = function addShadowRoot(shadowRoot2, doc) {\n        var _this = this;\n        if (!isNativeShadowDom(shadowRoot2)) return;\n        if (this.shadowDoms.has(shadowRoot2)) return;\n        this.shadowDoms.add(shadowRoot2);\n        var observer = initMutationObserver(_extends({}, this.bypassOptions, {\n            doc: doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot2);\n        this.restoreHandlers.push(function() {\n            return observer.disconnect();\n        });\n        this.restoreHandlers.push(initScrollObserver(_extends({}, this.bypassOptions, {\n            scrollCb: this.scrollCb,\n            // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n            // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n            doc: shadowRoot2,\n            mirror: this.mirror\n        })));\n        setTimeout(function() {\n            if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0) _this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot2.adoptedStyleSheets, _this.mirror.getId(index.host(shadowRoot2)));\n            _this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: _this.mirror,\n                stylesheetManager: _this.bypassOptions.stylesheetManager\n            }, shadowRoot2));\n        }, 0);\n    };\n    /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */ _proto.observeAttachShadow = function observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    };\n    /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */ _proto.patchAttachShadow = function patchAttachShadow(element, doc) {\n        var manager = this;\n        this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                var sRoot = original.call(this, option);\n                var shadowRootEl = index.shadowRoot(this);\n                if (shadowRootEl && inDom(this)) manager.addShadowRoot(shadowRootEl, doc);\n                return sRoot;\n            };\n        }));\n    };\n    _proto.reset = function reset() {\n        this.restoreHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e2) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    };\n    return ShadowDomManager;\n}();\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i$1 = 0; i$1 < chars.length; i$1++){\n    lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function encode(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n    for(i2 = 0; i2 < len; i2 += 3){\n        base64 += chars[bytes[i2] >> 2];\n        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n        base64 += chars[bytes[i2 + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nvar canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n    var contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = /* @__PURE__ */ new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nvar saveWebGLVar = function(value, win, ctx) {\n    if (!value || !(isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\")) return;\n    var name = value.constructor.name;\n    var list2 = variableListFor$1(ctx, name);\n    var index2 = list2.indexOf(value);\n    if (index2 === -1) {\n        index2 = list2.length;\n        list2.push(value);\n    }\n    return index2;\n};\nfunction serializeArg(value, win, ctx) {\n    if (_instanceof(value, Array)) {\n        return value.map(function(arg) {\n            return serializeArg(arg, win, ctx);\n        });\n    } else if (value === null) {\n        return value;\n    } else if (_instanceof(value, Float32Array) || _instanceof(value, Float64Array) || _instanceof(value, Int32Array) || _instanceof(value, Uint32Array) || _instanceof(value, Uint8Array) || _instanceof(value, Uint16Array) || _instanceof(value, Int16Array) || _instanceof(value, Int8Array) || _instanceof(value, Uint8ClampedArray)) {\n        var name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (// SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    _instanceof(value, ArrayBuffer)) {\n        var name1 = value.constructor.name;\n        var base64 = encode(value);\n        return {\n            rr_type: name1,\n            base64: base64\n        };\n    } else if (_instanceof(value, DataView)) {\n        var name2 = value.constructor.name;\n        return {\n            rr_type: name2,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (_instanceof(value, HTMLImageElement)) {\n        var name3 = value.constructor.name;\n        var src = value.src;\n        return {\n            rr_type: name3,\n            src: src\n        };\n    } else if (_instanceof(value, HTMLCanvasElement)) {\n        var name4 = \"HTMLImageElement\";\n        var src1 = value.toDataURL();\n        return {\n            rr_type: name4,\n            src: src1\n        };\n    } else if (_instanceof(value, ImageData)) {\n        var name5 = value.constructor.name;\n        return {\n            rr_type: name5,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\") {\n        var name6 = value.constructor.name;\n        var index2 = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name6,\n            index: index2\n        };\n    }\n    return value;\n}\nvar serializeArgs = function(args, win, ctx) {\n    return args.map(function(arg) {\n        return serializeArg(arg, win, ctx);\n    });\n};\nvar isInstanceOfWebGLObject = function(value, win) {\n    var webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    var supportedWebGLConstructorNames = webGLConstructorNames.filter(function(name) {\n        return typeof win[name] === \"function\";\n    });\n    return Boolean(supportedWebGLConstructorNames.find(function(name) {\n        return _instanceof(value, win[name]);\n    }));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    var _loop = function() {\n        var prop = _step.value;\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function() {\n                    var _this = this;\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(function() {\n                            var recordArgs = serializeArgs(args, win, _this);\n                            cb(_this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props2D), _step; !(_step = _iterator()).done;)_loop();\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    var handlers = [];\n    try {\n        var restoreHandler = patch(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    var ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && _type_of(args[0]) === \"object\") {\n                            var contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [].concat([\n                    contextType\n                ], args));\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (e) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {\n    var _loop = function() {\n        var prop = _step.value;\n        if (//prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n        [\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            return \"continue\";\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch(prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    var result2 = original.apply(this, args);\n                    saveWebGLVar(result2, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        var recordArgs = serializeArgs(args, win, this);\n                        var mutation = {\n                            type: type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result2;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: type,\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props = Object.getOwnPropertyNames(prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props), _step; !(_step = _iterator()).done;)_loop();\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {\n    var _handlers;\n    var handlers = [];\n    (_handlers = handlers).push.apply(_handlers, [].concat(patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, win)));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        var _handlers1;\n        (_handlers1 = handlers).push.apply(_handlers1, [].concat(patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, win)));\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nvar encodedJs = \"KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=\";\nvar decodeBase64 = function(base64) {\n    return Uint8Array.from(atob(base64), function(c2) {\n        return c2.charCodeAt(0);\n    });\n};\nvar blob = typeof window !== \"undefined\" && window.Blob && new Blob([\n    decodeBase64(encodedJs)\n], {\n    type: \"text/javascript;charset=utf-8\"\n});\nfunction WorkerWrapper(options) {\n    var objURL;\n    try {\n        objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);\n        if (!objURL) throw \"\";\n        var worker = new Worker(objURL, {\n            name: options == null ? void 0 : options.name\n        });\n        worker.addEventListener(\"error\", function() {\n            (window.URL || window.webkitURL).revokeObjectURL(objURL);\n        });\n        return worker;\n    } catch (e2) {\n        return new Worker(\"data:text/javascript;base64,\" + encodedJs, {\n            name: options == null ? void 0 : options.name\n        });\n    } finally{\n        objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);\n    }\n}\nvar CanvasManager = /*#__PURE__*/ function() {\n    function CanvasManager(options) {\n        var _this = this;\n        __publicField(this, \"pendingCanvasMutations\", /* @__PURE__ */ new Map());\n        __publicField(this, \"rafStamps\", {\n            latestId: 0,\n            invokeId: null\n        });\n        __publicField(this, \"mirror\");\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"resetObservers\");\n        __publicField(this, \"frozen\", false);\n        __publicField(this, \"locked\", false);\n        __publicField(this, \"processMutation\", function(target, mutation) {\n            var newFrame = _this.rafStamps.invokeId && _this.rafStamps.latestId !== _this.rafStamps.invokeId;\n            if (newFrame || !_this.rafStamps.invokeId) _this.rafStamps.invokeId = _this.rafStamps.latestId;\n            if (!_this.pendingCanvasMutations.has(target)) {\n                _this.pendingCanvasMutations.set(target, []);\n            }\n            _this.pendingCanvasMutations.get(target).push(mutation);\n        });\n        var _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? \"all\" : _options_sampling, win = options.win, blockClass = options.blockClass, blockSelector = options.blockSelector, recordCanvas = options.recordCanvas, dataURLOptions = options.dataURLOptions;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions: dataURLOptions\n        });\n    }\n    var _proto = CanvasManager.prototype;\n    _proto.reset = function reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n    };\n    _proto.initCanvasFPSObserver = function initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        var _this = this;\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        var snapshotInProgressMap = /* @__PURE__ */ new Map();\n        var worker = new WorkerWrapper();\n        worker.onmessage = function(e2) {\n            var id = e2.data.id;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e2.data)) return;\n            var _e2_data = e2.data, base64 = _e2_data.base64, type = _e2_data.type, width = _e2_data.width, height = _e2_data.height;\n            _this.mutationCb({\n                id: id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        // wipe canvas\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        // draws (semi-transparent) image\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64: base64\n                                            }\n                                        ],\n                                        type: type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        var timeBetweenSnapshots = 1e3 / fps;\n        var lastSnapshotTime = 0;\n        var rafId;\n        var getCanvas = function() {\n            var matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach(function(canvas) {\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        var takeCanvasSnapshots = function(timestamp) {\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            var _this1 = _this;\n            getCanvas().forEach(/*#__PURE__*/ _async_to_generator(function(canvas) {\n                var _a2, id, context, bitmap;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            id = _this1.mirror.getId(canvas);\n                            if (snapshotInProgressMap.get(id)) return [\n                                2\n                            ];\n                            if (canvas.width === 0 || canvas.height === 0) return [\n                                2\n                            ];\n                            snapshotInProgressMap.set(id, true);\n                            if ([\n                                \"webgl\",\n                                \"webgl2\"\n                            ].includes(canvas.__context)) {\n                                context = canvas.getContext(canvas.__context);\n                                if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {\n                                    context.clear(context.COLOR_BUFFER_BIT);\n                                }\n                            }\n                            return [\n                                4,\n                                createImageBitmap(canvas)\n                            ];\n                        case 1:\n                            bitmap = _state.sent();\n                            worker.postMessage({\n                                id: id,\n                                bitmap: bitmap,\n                                width: canvas.width,\n                                height: canvas.height,\n                                dataURLOptions: options.dataURLOptions\n                            }, [\n                                bitmap\n                            ]);\n                            return [\n                                2\n                            ];\n                    }\n                });\n            }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = function() {\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    };\n    _proto.initCanvasMutationObserver = function initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        this.resetObservers = function() {\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    };\n    _proto.startPendingCanvasMutationFlusher = function startPendingCanvasMutationFlusher() {\n        var _this = this;\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.startRAFTimestamping = function startRAFTimestamping() {\n        var _this = this;\n        var setLatestRAFTimestamp = function(timestamp) {\n            _this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    _proto.flushPendingCanvasMutations = function flushPendingCanvasMutations() {\n        var _this = this;\n        this.pendingCanvasMutations.forEach(function(_values, canvas) {\n            var id = _this.mirror.getId(canvas);\n            _this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.flushPendingCanvasMutationFor = function flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        var valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        var values = valuesWithType.map(function(value) {\n            value.type; var rest = _object_without_properties_loose(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        var type = valuesWithType[0].type;\n        this.mutationCb({\n            id: id,\n            type: type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    };\n    return CanvasManager;\n}();\nvar StylesheetManager = /*#__PURE__*/ function() {\n    function StylesheetManager(options) {\n        __publicField(this, \"trackedLinkElements\", /* @__PURE__ */ new WeakSet());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"adoptedStyleSheetCb\");\n        __publicField(this, \"styleMirror\", new StyleSheetMirror());\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    var _proto = StylesheetManager.prototype;\n    _proto.attachLinkElement = function attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    };\n    _proto.trackLinkElement = function trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    };\n    _proto.adoptStyleSheets = function adoptStyleSheets(sheets, hostId) {\n        var _this, _loop = function() {\n            var sheet = _step.value;\n            var styleId = void 0;\n            if (!_this.styleMirror.has(sheet)) {\n                styleId = _this.styleMirror.add(sheet);\n                styles.push({\n                    styleId: styleId,\n                    rules: Array.from(sheet.rules || CSSRule, function(r2, index2) {\n                        return {\n                            rule: stringifyRule(r2, sheet.href),\n                            index: index2\n                        };\n                    })\n                });\n            } else styleId = _this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        };\n        if (sheets.length === 0) return;\n        var adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        var styles = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(sheets), _step; !(_step = _iterator()).done;)_this = this, _loop();\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    };\n    _proto.reset = function reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    };\n    // TODO: take snapshot on stylesheet reload by applying event listener\n    _proto.trackStylesheetInLinkElement = function trackStylesheetInLinkElement(_linkEl) {};\n    return StylesheetManager;\n}();\nvar ProcessedNodeManager = /*#__PURE__*/ function() {\n    function ProcessedNodeManager() {\n        __publicField(this, \"nodeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"active\", false);\n    }\n    var _proto = ProcessedNodeManager.prototype;\n    _proto.inOtherBuffer = function inOtherBuffer(node2, thisBuffer) {\n        var buffers = this.nodeMap.get(node2);\n        return buffers && Array.from(buffers).some(function(buffer) {\n            return buffer !== thisBuffer;\n        });\n    };\n    _proto.add = function add(node2, buffer) {\n        var _this = this;\n        if (!this.active) {\n            this.active = true;\n            requestAnimationFrame(function() {\n                _this.nodeMap = /* @__PURE__ */ new WeakMap();\n                _this.active = false;\n            });\n        }\n        this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));\n    };\n    _proto.destroy = function destroy() {};\n    return ProcessedNodeManager;\n}();\nvar wrappedEmit;\nvar takeFullSnapshot$1;\nvar canvasManager;\nvar recording = false;\ntry {\n    if (Array.from([\n        1\n    ], function(x2) {\n        return x2 * 2;\n    })[0] !== 2) {\n        var cleanFrame = document.createElement(\"iframe\");\n        document.body.appendChild(cleanFrame);\n        Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;\n        document.body.removeChild(cleanFrame);\n    }\n} catch (err) {\n    console.debug(\"Unable to override Array.from\", err);\n}\nvar mirror = createMirror$2();\nfunction record(options) {\n    if (options === void 0) options = {};\n    var emit = options.emit, checkoutEveryNms = options.checkoutEveryNms, checkoutEveryNth = options.checkoutEveryNth, _options_blockClass = options.blockClass, blockClass = _options_blockClass === void 0 ? \"rr-block\" : _options_blockClass, _options_blockSelector = options.blockSelector, blockSelector = _options_blockSelector === void 0 ? null : _options_blockSelector, _options_ignoreClass = options.ignoreClass, ignoreClass = _options_ignoreClass === void 0 ? \"rr-ignore\" : _options_ignoreClass, _options_ignoreSelector = options.ignoreSelector, ignoreSelector = _options_ignoreSelector === void 0 ? null : _options_ignoreSelector, _options_maskTextClass = options.maskTextClass, maskTextClass = _options_maskTextClass === void 0 ? \"rr-mask\" : _options_maskTextClass, _options_maskTextSelector = options.maskTextSelector, maskTextSelector = _options_maskTextSelector === void 0 ? null : _options_maskTextSelector, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, maskAllInputs = options.maskAllInputs, _maskInputOptions = options.maskInputOptions, _slimDOMOptions = options.slimDOMOptions, maskInputFn = options.maskInputFn, maskTextFn = options.maskTextFn, hooks = options.hooks, packFn = options.packFn, _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? {} : _options_sampling, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, mousemoveWait = options.mousemoveWait, _options_recordDOM = options.recordDOM, recordDOM = _options_recordDOM === void 0 ? true : _options_recordDOM, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, _options_recordCrossOriginIframes = options.recordCrossOriginIframes, recordCrossOriginIframes = _options_recordCrossOriginIframes === void 0 ? false : _options_recordCrossOriginIframes, _options_recordAfter = options.recordAfter, recordAfter = _options_recordAfter === void 0 ? options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\" : _options_recordAfter, _options_userTriggeredOnInput = options.userTriggeredOnInput, userTriggeredOnInput = _options_userTriggeredOnInput === void 0 ? false : _options_userTriggeredOnInput, _options_collectFonts = options.collectFonts, collectFonts = _options_collectFonts === void 0 ? false : _options_collectFonts, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, plugins = options.plugins, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_ignoreCSSAttributes = options.ignoreCSSAttributes, ignoreCSSAttributes = _options_ignoreCSSAttributes === void 0 ? /* @__PURE__ */ new Set([]) : _options_ignoreCSSAttributes, errorHandler2 = options.errorHandler;\n    registerErrorHandler(errorHandler2);\n    var inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    var passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e2) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (!inEmittingFrame && !passEmitsToParent) {\n        return function() {};\n    }\n    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : _maskInputOptions !== void 0 ? _maskInputOptions : {\n        password: true\n    };\n    var slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        // the following are off for slimDOMOptions === true,\n        // as they destroy some (hidden) info:\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\",\n        headTitleMutations: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill$1();\n    var lastFullSnapshotEvent;\n    var incrementalSnapshotCount = 0;\n    var eventProcessor = function(e2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n            var plugin3 = _step.value;\n            if (plugin3.eventProcessor) {\n                e2 = plugin3.eventProcessor(e2);\n            }\n        }\n        if (packFn && // Disable packing events which will be emitted to parent frames.\n        !passEmitsToParent) {\n            e2 = packFn(e2);\n        }\n        return e2;\n    };\n    wrappedEmit = function(r2, isCheckout) {\n        var _a2;\n        var e2 = r2;\n        e2.timestamp = nowTimestamp();\n        if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n            mutationBuffers.forEach(function(buf) {\n                return buf.unfreeze();\n            });\n        }\n        if (inEmittingFrame) {\n            emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);\n        } else if (passEmitsToParent) {\n            var message = {\n                type: \"rrweb\",\n                event: eventProcessor(e2),\n                origin: window.location.origin,\n                isCheckout: isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e2.type === EventType.FullSnapshot) {\n            lastFullSnapshotEvent = e2;\n            incrementalSnapshotCount = 0;\n        } else if (e2.type === EventType.IncrementalSnapshot) {\n            if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            var exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot$1(true);\n            }\n        }\n    };\n    var wrappedMutationEmit = function(m) {\n        wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Mutation\n            }, m)\n        });\n    };\n    var wrappedScrollEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Scroll\n            }, p)\n        });\n    };\n    var wrappedCanvasMutationEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.CanvasMutation\n            }, p)\n        });\n    };\n    var wrappedAdoptedStyleSheetEmit = function(a2) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.AdoptedStyleSheet\n            }, a2)\n        });\n    };\n    var stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    var iframeManager = new IframeManager({\n        mirror: mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes: recordCrossOriginIframes,\n        wrappedEmit: wrappedEmit\n    });\n    for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        if (plugin3.getMirror) plugin3.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    var processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas: recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        mirror: mirror,\n        sampling: sampling.canvas,\n        dataURLOptions: dataURLOptions\n    });\n    var shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            dataURLOptions: dataURLOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            sampling: sampling,\n            slimDOMOptions: slimDOMOptions,\n            iframeManager: iframeManager,\n            stylesheetManager: stylesheetManager,\n            canvasManager: canvasManager,\n            keepIframeSrcFn: keepIframeSrcFn,\n            processedNodeManager: processedNodeManager\n        },\n        mirror: mirror\n    });\n    takeFullSnapshot$1 = function(isCheckout) {\n        if (isCheckout === void 0) isCheckout = false;\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit({\n            type: EventType.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }, isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach(function(buf) {\n            return buf.lock();\n        });\n        var node2 = snapshot(document, {\n            mirror: mirror,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            onSerialize: function(n2) {\n                if (isSerializedIframe(n2, mirror)) {\n                    iframeManager.addIframe(n2);\n                }\n                if (isSerializedStylesheet(n2, mirror)) {\n                    stylesheetManager.trackLinkElement(n2);\n                }\n                if (hasShadowRoot(n2)) {\n                    shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);\n                }\n            },\n            onIframeLoad: function(iframe, childSn) {\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: function(linkEl, childSn) {\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn: keepIframeSrcFn\n        });\n        if (!node2) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit({\n            type: EventType.FullSnapshot,\n            data: {\n                node: node2,\n                initialOffset: getWindowScroll(window)\n            }\n        }, isCheckout);\n        mutationBuffers.forEach(function(buf) {\n            return buf.unlock();\n        });\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        var handlers = [];\n        var observe = function(doc) {\n            var _a2;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: function(positions, source) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: source,\n                            positions: positions\n                        }\n                    });\n                },\n                mouseInteractionCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MouseInteraction\n                        }, d)\n                    });\n                },\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.ViewportResize\n                        }, d)\n                    });\n                },\n                inputCb: function(v2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Input\n                        }, v2)\n                    });\n                },\n                mediaInteractionCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MediaInteraction\n                        }, p)\n                    });\n                },\n                styleSheetRuleCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleSheetRule\n                        }, r2)\n                    });\n                },\n                styleDeclarationCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleDeclaration\n                        }, r2)\n                    });\n                },\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Font\n                        }, p)\n                    });\n                },\n                selectionCb: function(p) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Selection\n                        }, p)\n                    });\n                },\n                customElementCb: function(c2) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.CustomElement\n                        }, c2)\n                    });\n                },\n                blockClass: blockClass,\n                ignoreClass: ignoreClass,\n                ignoreSelector: ignoreSelector,\n                maskTextClass: maskTextClass,\n                maskTextSelector: maskTextSelector,\n                maskInputOptions: maskInputOptions,\n                inlineStylesheet: inlineStylesheet,\n                sampling: sampling,\n                recordDOM: recordDOM,\n                recordCanvas: recordCanvas,\n                inlineImages: inlineImages,\n                userTriggeredOnInput: userTriggeredOnInput,\n                collectFonts: collectFonts,\n                doc: doc,\n                maskInputFn: maskInputFn,\n                maskTextFn: maskTextFn,\n                keepIframeSrcFn: keepIframeSrcFn,\n                blockSelector: blockSelector,\n                slimDOMOptions: slimDOMOptions,\n                dataURLOptions: dataURLOptions,\n                mirror: mirror,\n                iframeManager: iframeManager,\n                stylesheetManager: stylesheetManager,\n                shadowDomManager: shadowDomManager,\n                processedNodeManager: processedNodeManager,\n                canvasManager: canvasManager,\n                ignoreCSSAttributes: ignoreCSSAttributes,\n                plugins: ((_a2 = plugins == null ? void 0 : plugins.filter(function(p) {\n                    return p.observer;\n                })) == null ? void 0 : _a2.map(function(p) {\n                    return {\n                        observer: p.observer,\n                        options: p.options,\n                        callback: function(payload) {\n                            return wrappedEmit({\n                                type: EventType.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload: payload\n                                }\n                            });\n                        }\n                    };\n                })) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener(function(iframeEl) {\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        var init = function() {\n            takeFullSnapshot$1();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", function() {\n                wrappedEmit({\n                    type: EventType.DomContentLoaded,\n                    data: {}\n                });\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", function() {\n                wrappedEmit({\n                    type: EventType.Load,\n                    data: {}\n                });\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = function(tag, payload) {\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit({\n        type: EventType.Custom,\n        data: {\n            tag: tag,\n            payload: payload\n        }\n    });\n};\nrecord.freezePage = function() {\n    mutationBuffers.forEach(function(buf) {\n        return buf.freeze();\n    });\n};\nrecord.takeFullSnapshot = function(isCheckout) {\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot$1(isCheckout);\n};\nrecord.mirror = mirror;\nvar n;\n!function(t2) {\n    t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nrecord.addCustomEvent;\nrecord.freezePage;\nrecord.takeFullSnapshot;\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.63.0'\n};\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical('Implementation error. Please turn on debug and contact support@mixpanel.com.');\n            if (Config.DEBUG){\n                console$1.critical(e);\n            }\n        }\n    };\n};\n\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for (var func in proto) {\n        if (typeof(proto[func]) === 'function') {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = function() {\n    try {\n        // use native Crypto API when available\n        return win['crypto']['randomUUID']();\n    } catch (err) {\n        // fall back to generating our own UUID\n        // based on https://gist.github.com/scwood/3bff42cc005cc20ab7ec98f0d8e1d59d\n        var uuid = new Array(36);\n        for (var i = 0; i < 36; i++) {\n            uuid[i] = Math.floor(Math.random() * 16);\n        }\n        uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100\n        uuid[19] = uuid[19] &= -5; // set bit 6 of clock-seq-and-reserved to zero\n        uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\n        return _.map(uuid, function(x) {\n            return x.toString(16);\n        }).join('');\n    }\n};\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'amazonbot',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandex',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _testStorageSupported = function (storage) {\n    var supported = true;\n    try {\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    return supported;\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    return _localStorageSupported = _testStorageSupported(storage || win.localStorage);\n};\n\nvar _sessionStorageSupported = null;\nvar sessionStorageSupported = function(storage, forceCheck) {\n    if (_sessionStorageSupported !== null && !forceCheck) {\n        return _sessionStorageSupported;\n    }\n    return _sessionStorageSupported = _testStorageSupported(storage || win.sessionStorage);\n};\n\nfunction _storageWrapper(storage, name, is_supported_fn) {\n    var log_error = function(msg) {\n        console$1.error(name + ' error: ' + msg);\n    };\n\n    return {\n        is_supported: function(forceCheck) {\n            var supported = is_supported_fn(storage, forceCheck);\n            if (!supported) {\n                console$1.error(name + ' unsupported');\n            }\n            return supported;\n        },\n        error: log_error,\n        get: function(key) {\n            try {\n                return storage.getItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n            return null;\n        },\n        parse: function(key) {\n            try {\n                return _.JSONDecode(storage.getItem(key)) || {};\n            } catch (err) {\n                // noop\n            }\n            return null;\n        },\n        set: function(key, value) {\n            try {\n                storage.setItem(key, value);\n            } catch (err) {\n                log_error(err);\n            }\n        },\n        remove: function(key) {\n            try {\n                storage.removeItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n        }\n    };\n}\n\n_.localStorage = _storageWrapper(win.localStorage, 'localStorage', localStorageSupported);\n_.sessionStorage = _storageWrapper(win.sessionStorage, 'sessionStorage', sessionStorageSupported);\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\n/**\n * Returns a throttled function that will only run at most every `waitMs` and returns a promise that resolves with the next invocation.\n * Throttled calls will build up a batch of args and invoke the callback with all args since the last invocation.\n */\nvar batchedThrottle = function (fn, waitMs) {\n    var timeoutPromise = null;\n    var throttledItems = [];\n    return function (item) {\n        var self = this;\n        throttledItems.push(item);\n\n        if (!timeoutPromise) {\n            timeoutPromise = new PromisePolyfill(function (resolve) {\n                setTimeout(function () {\n                    var returnValue = fn.apply(self, [throttledItems]);\n                    timeoutPromise = null;\n                    throttledItems = [];\n                    resolve(returnValue);\n                }, waitMs);\n            });\n        }\n        return timeoutPromise;\n    };\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar NOOP_FUNC = function () {};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n// UNMINIFIED EXPORTS (for closure compiler)\n_['info']                   = _.info;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['device']         = _.info.device;\n_['info']['properties']     = _.info.properties;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['isObject']               = _.isObject;\n_['JSONDecode']             = _.JSONDecode;\n_['JSONEncode']             = _.JSONEncode;\n_['toArray']                = _.toArray;\n_['NPO']                    = NpoPromise;\n\nvar MIXPANEL_DB_NAME = 'mixpanelBrowserDb';\n\nvar RECORDING_EVENTS_STORE_NAME = 'mixpanelRecordingEvents';\nvar RECORDING_REGISTRY_STORE_NAME = 'mixpanelRecordingRegistry';\n\n// note: increment the version number when adding new object stores\nvar DB_VERSION = 1;\nvar OBJECT_STORES = [RECORDING_EVENTS_STORE_NAME, RECORDING_REGISTRY_STORE_NAME];\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar IDBStorageWrapper = function (storeName) {\n    /**\n     * @type {Promise<IDBDatabase>|null}\n     */\n    this.dbPromise = null;\n    this.storeName = storeName;\n};\n\nIDBStorageWrapper.prototype._openDb = function () {\n    return new PromisePolyfill(function (resolve, reject) {\n        var openRequest = win.indexedDB.open(MIXPANEL_DB_NAME, DB_VERSION);\n        openRequest['onerror'] = function () {\n            reject(openRequest.error);\n        };\n\n        openRequest['onsuccess'] = function () {\n            resolve(openRequest.result);\n        };\n\n        openRequest['onupgradeneeded'] = function (ev) {\n            var db = ev.target.result;\n\n            OBJECT_STORES.forEach(function (storeName) {\n                db.createObjectStore(storeName);\n            });\n        };\n    });\n};\n\nIDBStorageWrapper.prototype.init = function () {\n    if (!win.indexedDB) {\n        return PromisePolyfill.reject('indexedDB is not supported in this browser');\n    }\n\n    if (!this.dbPromise) {\n        this.dbPromise = this._openDb();\n    }\n\n    return this.dbPromise\n        .then(function (dbOrError) {\n            if (dbOrError instanceof win['IDBDatabase']) {\n                return PromisePolyfill.resolve();\n            } else {\n                return PromisePolyfill.reject(dbOrError);\n            }\n        });\n};\n\n/**\n * @param {IDBTransactionMode} mode\n * @param {function(IDBObjectStore): void} storeCb\n */\nIDBStorageWrapper.prototype.makeTransaction = function (mode, storeCb) {\n    var storeName = this.storeName;\n    var doTransaction = function (db) {\n        return new PromisePolyfill(function (resolve, reject) {\n            var transaction = db.transaction(storeName, mode);\n            transaction.oncomplete = function () {\n                resolve(transaction);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                reject(transaction.error);\n            };\n\n            storeCb(transaction.objectStore(storeName));\n        });\n    };\n\n    return this.dbPromise\n        .then(doTransaction)\n        .catch(function (err) {\n            if (err && err['name'] === 'InvalidStateError') {\n                // try reopening the DB if the connection is closed\n                this.dbPromise = this._openDb();\n                return this.dbPromise.then(doTransaction);\n            } else {\n                return PromisePolyfill.reject(err);\n            }\n        }.bind(this));\n};\n\nIDBStorageWrapper.prototype.setItem = function (key, value) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.put(value, key);\n    });\n};\n\nIDBStorageWrapper.prototype.getItem = function (key) {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.get(key);\n    }).then(function () {\n        return req.result;\n    });\n};\n\nIDBStorageWrapper.prototype.removeItem = function (key) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.delete(key);\n    });\n};\n\nIDBStorageWrapper.prototype.getAll = function () {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.getAll();\n    }).then(function () {\n        return req.result;\n    });\n};\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$5 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || win.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$5.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || win.localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, JSONStringify(value));\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = JSONParse(this.storage.getItem(key));\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$4 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || win.localStorage,\n            timeoutMS: options.sharedLockTimeoutMS,\n        });\n    }\n    this.reportError = options.errorReporter || _.bind(logger$4.error, logger$4);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n\n    if (options.enqueueThrottleMs) {\n        this.enqueuePersisted = batchedThrottle(_.bind(this._enqueuePersisted, this), options.enqueueThrottleMs);\n    } else {\n        this.enqueuePersisted = _.bind(function (queueEntry) {\n            return this._enqueuePersisted([queueEntry]);\n        }, this);\n    }\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.enqueuePersisted(queueEntry);\n    }\n};\n\nRequestQueue.prototype._enqueuePersisted = function (queueEntries) {\n    var enqueueItem = _.bind(function () {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                return this.saveToStorage(storedQueue.concat(queueEntries));\n            }, this))\n            .then(_.bind(function (succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue = this.memQueue.concat(queueEntries);\n                }\n\n                return succeeded;\n            }, this))\n            .catch(_.bind(function (err) {\n                this.reportError('Error enqueueing items', err, queueEntries);\n                return false;\n            }, this));\n    }, this);\n\n    return this.lock\n        .withLock(enqueueItem, this.pid)\n        .catch(_.bind(function (err) {\n            this.reportError('Error acquiring storage lock', err);\n            return false;\n        }, this));\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                    // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.lock.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, queue);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$3 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        sharedLockTimeoutMS: options.sharedLockTimeoutMS,\n        usePersistence: options.usePersistence,\n        enqueueThrottleMs: options.enqueueThrottleMs\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n\n    this._flushPromise = null;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this._flushPromise = this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$3.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$3.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$3.error(err);\n        }\n    }\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n * @returns {boolean}\n */\nvar isRecordingExpired = function(serializedRecording) {\n    var now = Date.now();\n    return !serializedRecording || now > serializedRecording['maxExpires'] || now > serializedRecording['idleExpires'];\n};\n\nvar RECORD_ENQUEUE_THROTTLE_MS = 250;\n\nvar logger$2 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * @typedef {Object} SerializedRecording\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayId\n * @property {string} tabId\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} SessionRecordingOptions\n * @property {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @property {String} [options.replayId] - unique uuid for a single replay\n * @property {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @property {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @property {Function} [options.rrwebRecord] - rrweb's `record` function\n * @property {Function} [options.onBatchSent] - callback when a batch of events is sent to the server\n * @property {Storage} [options.sharedLockStorage] - optional storage for shared lock, used for test dependency injection\n * optional properties for deserialization:\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayStartUrl\n */\n\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {SessionRecordingOptions} options\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout || NOOP_FUNC;\n    this._onMaxLengthReached = options.onMaxLengthReached || NOOP_FUNC;\n    this._onBatchSent = options.onBatchSent || NOOP_FUNC;\n    this._rrwebRecord = options.rrwebRecord || null;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.replayId = options.replayId;\n\n    this.batchStartUrl = options.batchStartUrl || null;\n    this.replayStartUrl = options.replayStartUrl || null;\n    this.idleExpires = options.idleExpires || null;\n    this.maxExpires = options.maxExpires || null;\n    this.replayStartTime = options.replayStartTime || null;\n    this.seqNo = options.seqNo || 0;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // disable persistence if localStorage is not supported\n    // request-queue will automatically disable persistence if indexedDB fails to initialize\n    var usePersistence = localStorageSupported(options.sharedLockStorage, true);\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    this.batcherKey = '__mprec_' + this.getConfig('name') + '_' + this.getConfig('token') + '_' + this.replayId;\n    this.queueStorage = new IDBStorageWrapper(RECORDING_EVENTS_STORE_NAME);\n    this.batcher = new RequestBatcher(this.batcherKey, {\n        errorReporter: this.reportError.bind(this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: this.flushEventsWithOptOut.bind(this),\n        queueStorage: this.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: usePersistence,\n        stopAllBatchingFunc: this.stopRecording.bind(this),\n\n        // increased throttle and shared lock timeout because recording events are very high frequency.\n        // this will minimize the amount of lock contention between enqueued events.\n        // for session recordings there is a lock for each tab anyway, so there's no risk of deadlock between tabs.\n        enqueueThrottleMs: RECORD_ENQUEUE_THROTTLE_MS,\n        sharedLockTimeoutMS: 10 * 1000,\n    });\n};\n\nSessionRecording.prototype.unloadPersistedData = function () {\n    this.batcher.stop();\n    return this.batcher.flush()\n        .then(function () {\n            return this.queueStorage.removeItem(this.batcherKey);\n        }.bind(this));\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._rrwebRecord === null) {\n        this.reportError('rrweb record function not provided. ');\n        return;\n    }\n\n    if (this._stopRecording !== null) {\n        logger$2.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$2.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.maxExpires) {\n        this.maxExpires = new Date().getTime() + this.recordMaxMs;\n    }\n\n    this.recordMinMs = this.getConfig('record_min_ms');\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$2.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.replayStartTime) {\n        this.replayStartTime = new Date().getTime();\n        this.batchStartUrl = _.info.currentUrl();\n        this.replayStartUrl = _.info.currentUrl();\n    }\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = function () {\n        clearTimeout(this.idleTimeoutId);\n        var idleTimeoutMs = this.getConfig('record_idle_timeout_ms');\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, idleTimeoutMs);\n        this.idleExpires = new Date().getTime() + idleTimeoutMs;\n    }.bind(this);\n    resetIdleTimeout();\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    try {\n        this._stopRecording = this._rrwebRecord({\n            'emit': function (ev) {\n                if (this.idleExpires && this.idleExpires < ev.timestamp) {\n                    this._onIdleTimeout();\n                    return;\n                }\n                if (isUserEvent(ev)) {\n                    if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                        // start flushing again after user activity\n                        this.batcher.start();\n                    }\n                    resetIdleTimeout();\n                }\n                // promise only used to await during tests\n                this.__enqueuePromise = this.batcher.enqueue(ev);\n            }.bind(this),\n            'blockClass': this.getConfig('record_block_class'),\n            'blockSelector': blockSelector,\n            'collectFonts': this.getConfig('record_collect_fonts'),\n            'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n                'type': 'image/webp',\n                'quality': 0.6\n            },\n            'maskAllInputs': true,\n            'maskTextClass': this.getConfig('record_mask_text_class'),\n            'maskTextSelector': this.getConfig('record_mask_text_selector'),\n            'recordCanvas': this.getConfig('record_canvas'),\n            'sampling': {\n                'canvas': 15\n            }\n        });\n    } catch (err) {\n        this.reportError('Unexpected error when starting rrweb recording.', err);\n    }\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    var maxTimeoutMs = this.maxExpires - new Date().getTime();\n    this.maxTimeoutId = setTimeout(this._onMaxLengthReached.bind(this), maxTimeoutMs);\n};\n\nSessionRecording.prototype.stopRecording = function (skipFlush) {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    var flushPromise;\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        flushPromise = this.batcher.clear();\n    } else if (!skipFlush) {\n        // flush any remaining events from running batcher\n        flushPromise = this.batcher.flush();\n    }\n    this.batcher.stop();\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n    return flushPromise;\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    var onOptOut = function (code) {\n        // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n        if (code === 0) {\n            this.stopRecording();\n            cb({error: 'Tracking has been opted out, stopping recording.'});\n        }\n    }.bind(this);\n\n    this._flushEvents(data, options, cb, onOptOut);\n};\n\n/**\n * @returns {SerializedRecording}\n */\nSessionRecording.prototype.serialize = function () {\n    // don't break if mixpanel instance was destroyed at some point\n    var tabId;\n    try {\n        tabId = this._mixpanel.get_tab_id();\n    } catch (e) {\n        this.reportError('Error getting tab ID for serialization ', e);\n        tabId = null;\n    }\n\n    return {\n        'replayId': this.replayId,\n        'seqNo': this.seqNo,\n        'replayStartTime': this.replayStartTime,\n        'batchStartUrl': this.batchStartUrl,\n        'replayStartUrl': this.replayStartUrl,\n        'idleExpires': this.idleExpires,\n        'maxExpires': this.maxExpires,\n        'tabId': tabId,\n    };\n};\n\n\n/**\n * @static\n * @param {SerializedRecording} serializedRecording\n * @param {SessionRecordingOptions} options\n * @returns {SessionRecording}\n */\nSessionRecording.deserialize = function (serializedRecording, options) {\n    var recording = new SessionRecording(_.extend({}, options, {\n        replayId: serializedRecording['replayId'],\n        batchStartUrl: serializedRecording['batchStartUrl'],\n        replayStartUrl: serializedRecording['replayStartUrl'],\n        idleExpires: serializedRecording['idleExpires'],\n        maxExpires: serializedRecording['maxExpires'],\n        replayStartTime: serializedRecording['replayStartTime'],\n        seqNo: serializedRecording['seqNo'],\n        sharedLockStorage: options.sharedLockStorage,\n    }));\n\n    return recording;\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n\n        this._onBatchSent();\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }.bind(this);\n\n    win['fetch'](this.getConfig('api_host') + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    var numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = Infinity;\n        var batchEndTime = -Infinity;\n        var hasFullSnapshot = false;\n        for (var i = 0; i < numEvents; i++) {\n            batchStartTime = Math.min(batchStartTime, data[i].timestamp);\n            batchEndTime = Math.max(batchEndTime, data[i].timestamp);\n            if (data[i].type === EventType.FullSnapshot) {\n                hasFullSnapshot = true;\n            }\n        }\n\n        if (this.seqNo === 0) {\n            if (!hasFullSnapshot) {\n                callback({error: 'First batch does not contain a full snapshot. Aborting recording.'});\n                this.stopRecording(true);\n                return;\n            }\n            this.replayStartTime = batchStartTime;\n        } else if (!this.replayStartTime) {\n            this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            this.replayStartTime = batchStartTime;\n        }\n\n        var replayLengthMs = batchEndTime - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'distinct_id': String(this._mixpanel.get_distinct_id()),\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = JSON.stringify(data);\n\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property('$device_id');\n        if (deviceId) {\n            reqParams['$device_id'] = deviceId;\n        }\n        var userId = this._mixpanel.get_property('$user_id');\n        if (userId) {\n            reqParams['$user_id'] = userId;\n        }\n\n        if (CompressionStream) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }.bind(this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$2.error(err);\n    }\n};\n\n/**\n * Module for handling the storage and retrieval of recording metadata as well as any active recordings.\n * Makes sure that only one tab can be recording at a time.\n */\nvar RecordingRegistry = function (options) {\n    this.idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    this.errorReporter = options.errorReporter;\n    this.mixpanelInstance = options.mixpanelInstance;\n    this.sharedLockStorage = options.sharedLockStorage;\n};\n\nRecordingRegistry.prototype.handleError = function (err) {\n    this.errorReporter('IndexedDB error: ', err);\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n */\nRecordingRegistry.prototype.setActiveRecording = function (serializedRecording) {\n    var tabId = serializedRecording['tabId'];\n    if (!tabId) {\n        console.warn('No tab ID is set, cannot persist recording metadata.');\n        return PromisePolyfill.resolve();\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.setItem(tabId, serializedRecording);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * @returns {Promise<import('./session-recording').SerializedRecording>}\n */\nRecordingRegistry.prototype.getActiveRecording = function () {\n    return this.idb.init()\n        .then(function () {\n            return this.idb.getItem(this.mixpanelInstance.get_tab_id());\n        }.bind(this))\n        .then(function (serializedRecording) {\n            return isRecordingExpired(serializedRecording) ? null : serializedRecording;\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.clearActiveRecording = function () {\n    // mark recording as expired instead of deleting it in case the page unloads mid-flush and doesn't make it to ingestion.\n    // this will ensure the next pageload will flush the remaining events, but not try to continue the recording.\n    return this.getActiveRecording()\n        .then(function (serializedRecording) {\n            if (serializedRecording) {\n                serializedRecording['maxExpires'] = 0;\n                return this.setActiveRecording(serializedRecording);\n            }\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * Flush any inactive recordings from the registry to minimize data loss.\n * The main idea here is that we can flush remaining rrweb events on the next page load if a tab is closed mid-batch.\n */\nRecordingRegistry.prototype.flushInactiveRecordings = function () {\n    return this.idb.init()\n        .then(function() {\n            return this.idb.getAll();\n        }.bind(this))\n        .then(function (serializedRecordings) {\n            // clean up any expired recordings from the registry, non-expired ones may be active in other tabs\n            var unloadPromises = serializedRecordings\n                .filter(function (serializedRecording) {\n                    return isRecordingExpired(serializedRecording);\n                })\n                .map(function (serializedRecording) {\n                    var sessionRecording = SessionRecording.deserialize(serializedRecording, {\n                        mixpanelInstance: this.mixpanelInstance,\n                        sharedLockStorage: this.sharedLockStorage\n                    });\n                    return sessionRecording.unloadPersistedData()\n                        .then(function () {\n                            // expired recording was successfully flushed, we can clean it up from the registry\n                            return this.idb.removeItem(serializedRecording['tabId']);\n                        }.bind(this))\n                        .catch(this.handleError.bind(this));\n                }.bind(this));\n\n            return PromisePolyfill.all(unloadPromises);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nvar logger$1 = console_with_prefix('recorder');\n\n/**\n * Recorder API: bundles rrweb and and exposes methods to start and stop recordings.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n*/\nvar MixpanelRecorder = function(mixpanelInstance, rrwebRecord, sharedLockStorage) {\n    this.mixpanelInstance = mixpanelInstance;\n    this.rrwebRecord = rrwebRecord || record;\n    this.sharedLockStorage = sharedLockStorage;\n\n    /**\n     * @member {import('./registry').RecordingRegistry}\n     */\n    this.recordingRegistry = new RecordingRegistry({\n        mixpanelInstance: this.mixpanelInstance,\n        errorReporter: logger$1.error,\n        sharedLockStorage: sharedLockStorage\n    });\n    this._flushInactivePromise = this.recordingRegistry.flushInactiveRecordings();\n\n    this.activeRecording = null;\n};\n\nMixpanelRecorder.prototype.startRecording = function(options) {\n    options = options || {};\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$1.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = function () {\n        logger$1.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onMaxLengthReached = function () {\n        logger$1.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onBatchSent = function () {\n        this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n        this['__flushPromise'] = this.activeRecording.batcher._flushPromise;\n    }.bind(this);\n\n    /**\n     * @type {import('./session-recording').SessionRecordingOptions}\n     */\n    var sessionRecordingOptions = {\n        mixpanelInstance: this.mixpanelInstance,\n        onBatchSent: onBatchSent,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: this.rrwebRecord,\n        sharedLockStorage: this.sharedLockStorage\n    };\n\n    if (options.activeSerializedRecording) {\n        this.activeRecording = SessionRecording.deserialize(options.activeSerializedRecording, sessionRecordingOptions);\n    } else {\n        this.activeRecording = new SessionRecording(sessionRecordingOptions);\n    }\n\n    this.activeRecording.startRecording(options.shouldStopBatcher);\n    return this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    var stopPromise = this._stopCurrentRecording(false);\n    this.recordingRegistry.clearActiveRecording();\n    this.activeRecording = null;\n    return stopPromise;\n};\n\nMixpanelRecorder.prototype.pauseRecording = function() {\n    return this._stopCurrentRecording(false);\n};\n\nMixpanelRecorder.prototype._stopCurrentRecording = function(skipFlush) {\n    if (this.activeRecording) {\n        return this.activeRecording.stopRecording(skipFlush);\n    }\n    return PromisePolyfill.resolve();\n};\n\nMixpanelRecorder.prototype.resumeRecording = function (startNewIfInactive) {\n    if (this.activeRecording && this.activeRecording.isRrwebStopped()) {\n        this.activeRecording.startRecording(false);\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.recordingRegistry.getActiveRecording()\n        .then(function (activeSerializedRecording) {\n            if (activeSerializedRecording) {\n                return this.startRecording({activeSerializedRecording: activeSerializedRecording});\n            } else if (startNewIfInactive) {\n                return this.startRecording({shouldStopBatcher: false});\n            } else {\n                logger$1.log('No resumable recording found.');\n                return null;\n            }\n        }.bind(this));\n};\n\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording({shouldStopBatcher: true});\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n// stateless utils\n// mostly from https://github.com/mixpanel/mixpanel-js/blob/989ada50f518edab47b9c4fd9535f9fbd5ec5fc0/src/autotrack-utils.js\n\n\nvar EV_CHANGE = 'change';\nvar EV_CLICK = 'click';\nvar EV_HASHCHANGE = 'hashchange';\nvar EV_MP_LOCATION_CHANGE = 'mp_locationchange';\nvar EV_POPSTATE = 'popstate';\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = 'scrollend';\nvar EV_SUBMIT = 'submit';\n\nvar CLICK_EVENT_PROPS = [\n    'clientX', 'clientY',\n    'offsetX', 'offsetY',\n    'pageX', 'pageY',\n    'screenX', 'screenY',\n    'x', 'y'\n];\nvar OPT_IN_CLASSES = ['mp-include'];\nvar OPT_OUT_CLASSES = ['mp-no-track'];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat(['mp-sensitive']);\nvar TRACKED_ATTRS = [\n    'aria-label', 'aria-labelledby', 'aria-describedby',\n    'href', 'name', 'role', 'title', 'type'\n];\n\nvar logger = console_with_prefix('autocapture');\n\n\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(' ');\n    for (var i = 0; i < classList.length; i++) {\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */\nfunction getClassName(el) {\n    switch(typeof el.className) {\n        case 'string':\n            return el.className;\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            return el.className.baseVal || el.getAttribute('class') || '';\n        default: // future proof\n            return '';\n    }\n}\n\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        } while (el && !isElementNode(el));\n        return el;\n    }\n}\n\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        '$classes': getClassName(el).split(' '),\n        '$tag_name': el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props['$id'] = elId;\n    }\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props['$attr-' + attr] = attrVal;\n                }\n            }\n        });\n    }\n\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while (currentElem = getPreviousElementSibling(currentElem)) { // eslint-disable-line no-cond-assign\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props['$nth_child'] = nthChild;\n    props['$nth_of_type'] = nthOfType;\n\n    return props;\n}\n\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n\n    var props = null;\n\n    var target = typeof ev.target === 'undefined' ? ev.srcElement : ev.target;\n    if (isTextNode(target)) { // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)\n        target = target.parentNode;\n    }\n\n    if (\n        shouldTrackDomEvent(target, ev) &&\n        isElementAllowed(target, ev, allowElementCallback, allowSelectors) &&\n        !isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n    ) {\n        var targetElementList = [target];\n        var curEl = target;\n        while (curEl.parentNode && !isTag(curEl, 'body')) {\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet['href'] && el.tagName.toLowerCase() === 'a') {\n                href = el.getAttribute('href');\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n\n        if (!explicitNoTrack) {\n            var docElement = document$1['documentElement'];\n            props = {\n                '$event_type': ev.type,\n                '$host': win.location.host,\n                '$pathname': win.location.pathname,\n                '$elements':  elementsJson,\n                '$el_attr__href': href,\n                '$viewportHeight': Math.max(docElement['clientHeight'], win['innerHeight'] || 0),\n                '$viewportWidth': Math.max(docElement['clientWidth'], win['innerWidth'] || 0)\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props['$el_attr__' + attr] = attrVal;\n                    }\n                }\n            });\n\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props['$' + prop] = ev[prop];\n                    }\n                });\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (\n                    !isElementAllowed(target, ev, allowElementCallback, allowSelectors) ||\n                    isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n                ) {\n                    return null;\n                }\n\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props['$target'] = targetProps;\n                // pull up more props onto main event props\n                props['$el_classes'] = targetProps['$classes'];\n                _.extend(props, _.strip_empty_properties({\n                    '$el_id': targetProps['$id'],\n                    '$el_tag_name': targetProps['$tag_name']\n                }));\n            }\n        }\n    }\n\n    return props;\n}\n\n\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */\nfunction getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = '';\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)\n                    // scrub potentially sensitive values\n                    .split(/(\\s+)/).filter(shouldTrackValue).join('')\n                    // normalize whitespace\n                    .replace(/[\\r\\n]/g, ' ').replace(/[ ]+/g, ' ')\n                    // truncate\n                    .substring(0, 255);\n            }\n        });\n    }\n\n    return _.trim(elText);\n}\n\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev['composedPath']();\n    for (var i = 0; i < composedPath.length; i++) {\n        var node = composedPath[i];\n        if (\n            isTag(node, 'a') ||\n            isTag(node, 'button') ||\n            isTag(node, 'input') ||\n            isTag(node, 'select') ||\n            (node.getAttribute && node.getAttribute('role') === 'button')\n        ) {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\n\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger.critical('Error while checking element in allowElementCallback', err);\n            return false;\n        }\n    }\n\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n\n    for (var i = 0; i < allowSelectors.length; i++) {\n        var sel = allowSelectors[i];\n        try {\n            if (el['matches'](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical('Error while checking selector: ' + sel, err);\n        }\n    }\n    return false;\n}\n\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical('Error while checking element in blockElementCallback', err);\n            return true;\n        }\n    }\n\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for (i = 0; i < blockSelectors.length; i++) {\n            var sel = blockSelectors[i];\n            try {\n                if (el['matches'](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger.critical('Error while checking selector: ' + sel, err);\n            }\n        }\n    }\n\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for (i = 0; i < OPT_OUT_CLASSES.length; i++) {\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */\nfunction isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nfunction isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */\nfunction isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\n\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement('div');\n        return !!testEl['matches'];\n    } catch (err) {\n        return false;\n    }\n}\n\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */\nfunction shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, 'html') || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch (tag) {\n        case 'form':\n            return ev.type === EV_SUBMIT;\n        case 'input':\n            if (['button', 'submit'].indexOf(el.getAttribute('type')) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case 'select':\n        case 'textarea':\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n\n    for (var curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode) {\n        var classes = getClasses(curEl);\n        for (i = 0; i < SENSITIVE_DATA_CLASSES.length; i++) {\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n\n    var elClasses = getClasses(el);\n    for (i = 0; i < OPT_IN_CLASSES.length; i++) {\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (\n        isTag(el, 'input') ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return false;\n    }\n\n    // don't include hidden or password fields\n    var type = el.type || '';\n    if (typeof type === 'string') { // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch(type.toLowerCase()) {\n            case 'hidden':\n                return false;\n            case 'password':\n                return false;\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || '';\n    if (typeof name === 'string') { // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n\n    if (typeof value === 'string') {\n        value = _.trim(value);\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false;\n        }\n\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvar AUTOCAPTURE_CONFIG_KEY = 'autocapture';\nvar LEGACY_PAGEVIEW_CONFIG_KEY = 'track_pageview';\n\nvar PAGEVIEW_OPTION_FULL_URL = 'full-url';\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = 'url-with-path-and-query-string';\nvar PAGEVIEW_OPTION_URL_WITH_PATH = 'url-with-path';\n\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = 'allow_element_callback';\nvar CONFIG_ALLOW_SELECTORS = 'allow_selectors';\nvar CONFIG_ALLOW_URL_REGEXES = 'allow_url_regexes';\nvar CONFIG_BLOCK_ATTRS = 'block_attrs';\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = 'block_element_callback';\nvar CONFIG_BLOCK_SELECTORS = 'block_selectors';\nvar CONFIG_BLOCK_URL_REGEXES = 'block_url_regexes';\nvar CONFIG_CAPTURE_EXTRA_ATTRS = 'capture_extra_attrs';\nvar CONFIG_CAPTURE_TEXT_CONTENT = 'capture_text_content';\nvar CONFIG_SCROLL_CAPTURE_ALL = 'scroll_capture_all';\nvar CONFIG_SCROLL_CHECKPOINTS = 'scroll_depth_percent_checkpoints';\nvar CONFIG_TRACK_CLICK = 'click';\nvar CONFIG_TRACK_INPUT = 'input';\nvar CONFIG_TRACK_PAGEVIEW = 'pageview';\nvar CONFIG_TRACK_SCROLL = 'scroll';\nvar CONFIG_TRACK_SUBMIT = 'submit';\n\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS[CONFIG_SCROLL_CHECKPOINTS] = [25, 50, 75, 100];\nCONFIG_DEFAULTS[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS[CONFIG_TRACK_SUBMIT] = true;\n\nvar DEFAULT_PROPS = {\n    '$mp_autocapture': true\n};\n\nvar MP_EV_CLICK = '$mp_click';\nvar MP_EV_INPUT = '$mp_input_change';\nvar MP_EV_SCROLL = '$mp_scroll';\nvar MP_EV_SUBMIT = '$mp_submit';\n\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */\nvar Autocapture = function(mp) {\n    this.mp = mp;\n};\n\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger.critical('Autocapture unavailable: missing required DOM APIs');\n        return;\n    }\n\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n};\n\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\n\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for (i = 0; i < allowUrlRegexes.length; i++) {\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger.critical('Error while checking block URL regex: ' + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n\n    for (i = 0; i < blockUrlRegexes.length; i++) {\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger.critical('Error while checking block URL regex: ' + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\n\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT)\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\n\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n\n    if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n        return;\n    }\n    logger.log('Initializing click tracking');\n\n    this.listenerClick = win.addEventListener(EV_CLICK, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }.bind(this));\n};\n\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger.log('Initializing input tracking');\n\n    this.listenerChange = win.addEventListener(EV_CHANGE, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }.bind(this));\n};\n\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger.log('Initializing pageview tracking');\n\n    var previousTrackedUrl = '';\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n\n    this.listenerPopstate = win.addEventListener(EV_POPSTATE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    this.listenerHashchange = win.addEventListener(EV_HASHCHANGE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === 'function') {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === 'function') {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    this.listenerLocationchange = win.addEventListener(EV_MP_LOCATION_CHANGE, safewrap(function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split('#')[0].split('?')[0] !== previousTrackedUrl.split('#')[0].split('?')[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split('#')[0] !== previousTrackedUrl.split('#')[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger.log('Path change: re-initializing scroll depth checkpoints');\n            }\n        }\n    }.bind(this)));\n};\n\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger.log('Initializing scroll tracking');\n    this.lastScrollCheckpoint = 0;\n\n    this.listenerScroll = win.addEventListener(EV_SCROLLEND, safewrap(function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || [])\n            .slice()\n            .sort(function(a, b) { return a - b; });\n\n        var scrollTop = win.scrollY;\n        var props = _.extend({'$scroll_top': scrollTop}, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round((scrollTop / (scrollHeight - win.innerHeight)) * 100);\n            props['$scroll_height'] = scrollHeight;\n            props['$scroll_percentage'] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for (var i = 0; i < scrollCheckpoints.length; i++) {\n                    var checkpoint = scrollCheckpoints[i];\n                    if (\n                        scrollPercentage >= checkpoint &&\n                        this.lastScrollCheckpoint < checkpoint\n                    ) {\n                        props['$scroll_checkpoint'] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger.critical('Error while calculating scroll percentage', err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }.bind(this)));\n};\n\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger.log('Initializing submit tracking');\n\n    this.listenerSubmit = win.addEventListener(EV_SUBMIT, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }.bind(this));\n};\n\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n\n/* eslint camelcase: \"off\" */\n\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error('Invalid value passed to mixpanel.people.track_charge - must be a number');\n            return;\n        }\n    }\n\n    return this.append('$transactions', _.extend({\n        '$amount': amount\n    }, properties), callback);\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        JSONStringify(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track': 'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'autocapture':                       false,\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n\n    this._init_tab_id();\n    this._check_and_start_session_recording();\n};\n\n/**\n * Assigns a unique UUID to this tab / window by leveraging sessionStorage.\n * This is primarily used for session recording, where data must be isolated to the current tab.\n */\nMixpanelLib.prototype._init_tab_id = function() {\n    if (_.sessionStorage.is_supported()) {\n        try {\n            var key_suffix = this.get_config('name') + '_' + this.get_config('token');\n            var tab_id_key = 'mp_tab_id_' + key_suffix;\n\n            // A flag is used to determine if sessionStorage is copied over and we need to generate a new tab ID.\n            // This enforces a unique ID in the cases like duplicated tab, window.open(...)\n            var should_generate_new_tab_id_key = 'mp_gen_new_tab_id_' + key_suffix;\n            if (_.sessionStorage.get(should_generate_new_tab_id_key) || !_.sessionStorage.get(tab_id_key)) {\n                _.sessionStorage.set(tab_id_key, '$tab-' + _.UUID());\n            }\n\n            _.sessionStorage.set(should_generate_new_tab_id_key, '1');\n            this.tab_id = _.sessionStorage.get(tab_id_key);\n\n            // Remove the flag when the tab is unloaded to indicate the stored tab ID can be reused. This event is not reliable to detect all page unloads,\n            // but reliable in cases where the user remains in the tab e.g. a refresh or href navigation.\n            // If the flag is absent, this indicates to the next SDK instance that we can reuse the stored tab_id.\n            win.addEventListener('beforeunload', function () {\n                _.sessionStorage.remove(should_generate_new_tab_id_key);\n            });\n        } catch(err) {\n            this.report_error('Error initializing tab id', err);\n        }\n    } else {\n        this.report_error('Session storage is not supported, cannot keep track of unique tab ID.');\n    }\n};\n\nMixpanelLib.prototype.get_tab_id = function () {\n    return this.tab_id || null;\n};\n\nMixpanelLib.prototype._should_load_recorder = function () {\n    var recording_registry_idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    var tab_id = this.get_tab_id();\n    return recording_registry_idb.init()\n        .then(function () {\n            return recording_registry_idb.getAll();\n        })\n        .then(function (recordings) {\n            for (var i = 0; i < recordings.length; i++) {\n                // if there are expired recordings in the registry, we should load the recorder to flush them\n                // if there's a recording for this tab id, we should load the recorder to continue the recording\n                if (isRecordingExpired(recordings[i]) || recordings[i]['tabId'] === tab_id) {\n                    return true;\n                }\n            }\n            return false;\n        })\n        .catch(_.bind(function (err) {\n            this.report_error('Error checking recording registry', err);\n        }, this));\n};\n\nMixpanelLib.prototype._check_and_start_session_recording = addOptOutCheckMixpanelLib(function(force_start) {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var loadRecorder = _.bind(function(startNewIfInactive) {\n        var handleLoadedRecorder = _.bind(function() {\n            this._recorder = this._recorder || new win['__mp_recorder'](this);\n            this._recorder['resumeRecording'](startNewIfInactive);\n        }, this);\n\n        if (_.isUndefined(win['__mp_recorder'])) {\n            load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n        } else {\n            handleLoadedRecorder();\n        }\n    }, this);\n\n    /**\n     * If the user is sampled or start_session_recording is called, we always load the recorder since it's guaranteed a recording should start.\n     * Otherwise, if the recording registry has any records then it's likely there's a recording in progress or orphaned data that needs to be flushed.\n     */\n    var is_sampled = this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent');\n    if (force_start || is_sampled) {\n        loadRecorder(true);\n    } else {\n        this._should_load_recorder()\n            .then(function (shouldLoad) {\n                if (shouldLoad) {\n                    loadRecorder(false);\n                }\n            });\n    }\n});\n\nMixpanelLib.prototype.start_session_recording = function () {\n    this._check_and_start_session_recording(true);\n};\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['stopRecording']();\n    }\n};\n\nMixpanelLib.prototype.pause_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['pauseRecording']();\n    }\n};\n\nMixpanelLib.prototype.resume_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['resumeRecording']();\n    }\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// \"private\" public method to reach into the recorder in test cases\nMixpanelLib.prototype.__get_recorder = function () {\n    return this._recorder;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    var api_routes = this.get_config('api_routes');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', endpoint: '/' + api_routes['track'], queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', endpoint: '/' + api_routes['engage'], queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', endpoint: '/' + api_routes['groups'], queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        this._send_request(\n                            this.get_config('api_host') + attrs.endpoint,\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true,\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = JSONStringify(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_config('api_host') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n\n        if ('autocapture' in config && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n        this.stop_session_recording();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['pause_session_recording']            = MixpanelLib.prototype.pause_session_recording;\nMixpanelLib.prototype['resume_session_recording']           = MixpanelLib.prototype.resume_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['get_tab_id']                         = MixpanelLib.prototype.get_tab_id;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// Exports intended only for testing\nMixpanelLib.prototype['__get_recorder']                     = MixpanelLib.prototype.__get_recorder;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n// so that we don't load them until they are needed at runtime.\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcz8yODJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNpbmNlIGVzNiBpbXBvcnRzIGFyZSBzdGF0aWMgYW5kIHdlIHJ1biB1bml0IHRlc3RzIGZyb20gdGhlIGNvbnNvbGUsIHdpbmRvdyB3b24ndCBiZSBkZWZpbmVkIHdoZW4gaW1wb3J0aW5nIHRoaXMgZmlsZVxudmFyIHdpbjtcbmlmICh0eXBlb2Yod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbG9jID0ge1xuICAgICAgICBob3N0bmFtZTogJydcbiAgICB9O1xuICAgIHdpbiA9IHtcbiAgICAgICAgY3J5cHRvOiB7cmFuZG9tVVVJRDogZnVuY3Rpb24oKSB7dGhyb3cgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7fX0sXG4gICAgICAgIG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6ICcnLCBvbkxpbmU6IHRydWUgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICAgICAgcmVmZXJyZXI6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmVlbjogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xufSBlbHNlIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIF9hcnJheV9saWtlX3RvX2FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspYXJyMltpXSA9IGFycltpXTtcbiAgICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgIGlmIChfaXNfbmF0aXZlX3JlZmxlY3RfY29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgdmFyIGEgPSBbXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgaWYgKENsYXNzKSBfc2V0X3Byb3RvdHlwZV9vZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVfY2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9nZXRfcHJvdG90eXBlX29mKG8pIHtcbiAgICBfZ2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0X3Byb3RvdHlwZV9vZihvKTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldF9wcm90b3R5cGVfb2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2luc3RhbmNlb2YobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgIT0gbnVsbCAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0pIHtcbiAgICAgICAgcmV0dXJuICEhcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXShsZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGVmdCBpbnN0YW5jZW9mIHJpZ2h0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pc19uYXRpdmVfZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuZnVuY3Rpb24gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9zZXRfcHJvdG90eXBlX29mKG8sIHApIHtcbiAgICBfc2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldF9wcm90b3R5cGVfb2YobywgcCk7XG59XG5mdW5jdGlvbiBfdHlwZV9vZihvYmopIHtcbiAgICBcIkBzd2MvaGVscGVycyAtIHR5cGVvZlwiO1xuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX3dyYXBfbmF0aXZlX3N1cGVyKENsYXNzKSB7XG4gICAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICBfd3JhcF9uYXRpdmVfc3VwZXIgPSBmdW5jdGlvbiB3cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICAgICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNfbmF0aXZlX2Z1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuICAgICAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG4gICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldF9wcm90b3R5cGVfb2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3NldF9wcm90b3R5cGVfb2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG4gICAgcmV0dXJuIF93cmFwX25hdGl2ZV9zdXBlcihDbGFzcyk7XG59XG5mdW5jdGlvbiBfaXNfbmF0aXZlX3JlZmxlY3RfY29uc3RydWN0KCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbigpIHt9KSk7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICByZXR1cm4gKF9pc19uYXRpdmVfcmVmbGVjdF9jb25zdHJ1Y3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH0pKCk7XG59XG5mdW5jdGlvbiBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UpIHtcbiAgICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdHNfZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBfdHNfdmFsdWVzKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgICAgICAgICAgZG9uZTogIW9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9fZGVmTm9ybWFsUHJvcChvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbnZhciBfYTtcbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gX19kZWZOb3JtYWxQcm9wJDEob2JqLCAodHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihrZXkpKSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbn07XG52YXIgTm9kZVR5cGUkMyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihOb2RlVHlwZTIpIHtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xuICAgIHJldHVybiBOb2RlVHlwZTI7XG59KE5vZGVUeXBlJDMgfHwge30pO1xudmFyIHRlc3RhYmxlQWNjZXNzb3JzJDEgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNoaWxkTm9kZXNcIixcbiAgICAgICAgXCJwYXJlbnROb2RlXCIsXG4gICAgICAgIFwicGFyZW50RWxlbWVudFwiLFxuICAgICAgICBcInRleHRDb250ZW50XCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJob3N0XCIsXG4gICAgICAgIFwic3R5bGVTaGVldHNcIlxuICAgIF0sXG4gICAgRWxlbWVudDogW1xuICAgICAgICBcInNoYWRvd1Jvb3RcIixcbiAgICAgICAgXCJxdWVyeVNlbGVjdG9yXCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvckFsbFwiXG4gICAgXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbnZhciB0ZXN0YWJsZU1ldGhvZHMkMSA9IHtcbiAgICBOb2RlOiBbXG4gICAgICAgIFwiY29udGFpbnNcIixcbiAgICAgICAgXCJnZXRSb290Tm9kZVwiXG4gICAgXSxcbiAgICBTaGFkb3dSb290OiBbXG4gICAgICAgIFwiZ2V0U2VsZWN0aW9uXCJcbiAgICBdLFxuICAgIEVsZW1lbnQ6IFtdLFxuICAgIE11dGF0aW9uT2JzZXJ2ZXI6IFtcbiAgICAgICAgXCJjb25zdHJ1Y3RvclwiXG4gICAgXVxufTtcbnZhciB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDEgPSB7fTtcbnZhciBpc0FuZ3VsYXJab25lUHJlc2VudCQxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSkge1xuICAgIGlmICh1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSkgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldO1xuICAgIHZhciBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICAgIHZhciBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgdmFyIGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMkMSA/IHRlc3RhYmxlQWNjZXNzb3JzJDFba2V5XSA6IHZvaWQgMDtcbiAgICB2YXIgaXNVbnRhaW50ZWRBY2Nlc3NvcnMgPSBCb29sZWFuKGFjY2Vzc29yTmFtZXMgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgYWNjZXNzb3JOYW1lcy5ldmVyeShmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9iID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyQxID8gdGVzdGFibGVNZXRob2RzJDFba2V5XSA6IHZvaWQgMDtcbiAgICB2YXIgaXNVbnRhaW50ZWRNZXRob2RzID0gQm9vbGVhbihtZXRob2ROYW1lcyAmJiBtZXRob2ROYW1lcy5ldmVyeSgvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIiAmJiAoKF9hMiA9IGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50b1N0cmluZygpLmluY2x1ZGVzKFwiW25hdGl2ZSBjb2RlXVwiKSk7XG4gICAgfSkpO1xuICAgIGlmIChpc1VudGFpbnRlZEFjY2Vzc29ycyAmJiBpc1VudGFpbnRlZE1ldGhvZHMgJiYgIWlzQW5ndWxhclpvbmVQcmVzZW50JDEoKSkge1xuICAgICAgICB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZhciBpZnJhbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICB2YXIgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICAgICAgaWYgKCF3aW4pIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHVudGFpbnRlZE9iamVjdCA9IHdpbltrZXldLnByb3RvdHlwZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVFbCk7XG4gICAgICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGUkMVtrZXldID0gdW50YWludGVkT2JqZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgfVxufVxudmFyIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3IkMShrZXksIGluc3RhbmNlLCBhY2Nlc3Nvcikge1xuICAgIHZhciBfYTI7XG4gICAgdmFyIGNhY2hlS2V5ID0ga2V5ICsgXCIuXCIgKyBTdHJpbmcoYWNjZXNzb3IpO1xuICAgIGlmICh1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldKSByZXR1cm4gdW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XS5jYWxsKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlJDEoa2V5KTtcbiAgICB2YXIgdW50YWludGVkQWNjZXNzb3IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih1bnRhaW50ZWRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQ7XG4gICAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgICB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDFbY2FjaGVLZXldID0gdW50YWludGVkQWNjZXNzb3I7XG4gICAgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yLmNhbGwoaW5zdGFuY2UpO1xufVxudmFyIHVudGFpbnRlZE1ldGhvZENhY2hlJDEgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZCQxKGtleSwgaW5zdGFuY2UsIG1ldGhvZCkge1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKG1ldGhvZCk7XG4gICAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldKSByZXR1cm4gdW50YWludGVkTWV0aG9kQ2FjaGUkMVtjYWNoZUtleV0uYmluZChpbnN0YW5jZSk7XG4gICAgdmFyIHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZE1ldGhvZCA9IHVudGFpbnRlZFByb3RvdHlwZVttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgdW50YWludGVkTWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBpbnN0YW5jZVttZXRob2RdO1xuICAgIHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldID0gdW50YWludGVkTWV0aG9kO1xuICAgIHJldHVybiB1bnRhaW50ZWRNZXRob2QuYmluZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjaGlsZE5vZGVzJDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwiY2hpbGROb2Rlc1wiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnROb2RlXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50RWxlbWVudCQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInBhcmVudEVsZW1lbnRcIik7XG59XG5mdW5jdGlvbiB0ZXh0Q29udGVudCQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcInRleHRDb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnMkMShuMiwgb3RoZXIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kJDEoXCJOb2RlXCIsIG4yLCBcImNvbnRhaW5zXCIpKG90aGVyKTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlJDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kJDEoXCJOb2RlXCIsIG4yLCBcImdldFJvb3ROb2RlXCIpKCk7XG59XG5mdW5jdGlvbiBob3N0JDEobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJob3N0XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzJDEobjIpIHtcbiAgICByZXR1cm4gbjIuc3R5bGVTaGVldHM7XG59XG5mdW5jdGlvbiBzaGFkb3dSb290JDEobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJzaGFkb3dSb290XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IkMShuMiwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwkMShuMiwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uT2JzZXJ2ZXJDdG9yJDEoKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZFByb3RvdHlwZSQxKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbnZhciBpbmRleCQxID0ge1xuICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMkMSxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlJDEsXG4gICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudCQxLFxuICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCQxLFxuICAgIGNvbnRhaW5zOiBjb250YWlucyQxLFxuICAgIGdldFJvb3ROb2RlOiBnZXRSb290Tm9kZSQxLFxuICAgIGhvc3Q6IGhvc3QkMSxcbiAgICBzdHlsZVNoZWV0czogc3R5bGVTaGVldHMkMSxcbiAgICBzaGFkb3dSb290OiBzaGFkb3dSb290JDEsXG4gICAgcXVlcnlTZWxlY3RvcjogcXVlcnlTZWxlY3RvciQxLFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IHF1ZXJ5U2VsZWN0b3JBbGwkMSxcbiAgICBtdXRhdGlvbk9ic2VydmVyOiBtdXRhdGlvbk9ic2VydmVyQ3RvciQxXG59O1xuZnVuY3Rpb24gaXNFbGVtZW50KG4yKSB7XG4gICAgcmV0dXJuIG4yLm5vZGVUeXBlID09PSBuMi5FTEVNRU5UX05PREU7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QobjIpIHtcbiAgICB2YXIgaG9zdEVsID0gLy8gYW5jaG9yIGFuZCB0ZXh0YXJlYSBlbGVtZW50cyBhbHNvIGhhdmUgYSBgaG9zdGAgcHJvcGVydHlcbiAgICAvLyBidXQgb25seSBzaGFkb3cgcm9vdHMgaGF2ZSBhIGBtb2RlYCBwcm9wZXJ0eVxuICAgIG4yICYmIFwiaG9zdFwiIGluIG4yICYmIFwibW9kZVwiIGluIG4yICYmIGluZGV4JDEuaG9zdChuMikgfHwgbnVsbDtcbiAgICByZXR1cm4gQm9vbGVhbihob3N0RWwgJiYgXCJzaGFkb3dSb290XCIgaW4gaG9zdEVsICYmIGluZGV4JDEuc2hhZG93Um9vdChob3N0RWwpID09PSBuMik7XG59XG5mdW5jdGlvbiBpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290Mikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2hhZG93Um9vdDIpID09PSBcIltvYmplY3QgU2hhZG93Um9vdF1cIjtcbn1cbmZ1bmN0aW9uIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1MoY3NzVGV4dCkge1xuICAgIGlmIChjc3NUZXh0LmluY2x1ZGVzKFwiIGJhY2tncm91bmQtY2xpcDogdGV4dDtcIikgJiYgIWNzc1RleHQuaW5jbHVkZXMoXCIgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpKSB7XG4gICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoL1xcc2JhY2tncm91bmQtY2xpcDpcXHMqdGV4dDsvZywgXCIgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7IGJhY2tncm91bmQtY2xpcDogdGV4dDtcIik7XG4gICAgfVxuICAgIHJldHVybiBjc3NUZXh0O1xufVxuZnVuY3Rpb24gZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUyKSB7XG4gICAgdmFyIGNzc1RleHQgPSBydWxlMi5jc3NUZXh0O1xuICAgIGlmIChjc3NUZXh0LnNwbGl0KCdcIicpLmxlbmd0aCA8IDMpIHJldHVybiBjc3NUZXh0O1xuICAgIHZhciBzdGF0ZW1lbnQgPSBbXG4gICAgICAgIFwiQGltcG9ydFwiLFxuICAgICAgICBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KHJ1bGUyLmhyZWYpICsgXCIpXCJcbiAgICBdO1xuICAgIGlmIChydWxlMi5sYXllck5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgc3RhdGVtZW50LnB1c2goXCJsYXllclwiKTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUyLmxheWVyTmFtZSkge1xuICAgICAgICBzdGF0ZW1lbnQucHVzaChcImxheWVyKFwiICsgcnVsZTIubGF5ZXJOYW1lICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAocnVsZTIuc3VwcG9ydHNUZXh0KSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKFwic3VwcG9ydHMoXCIgKyBydWxlMi5zdXBwb3J0c1RleHQgKyBcIilcIik7XG4gICAgfVxuICAgIGlmIChydWxlMi5tZWRpYS5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGVtZW50LnB1c2gocnVsZTIubWVkaWEubWVkaWFUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudC5qb2luKFwiIFwiKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVzaGVldChzMikge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBydWxlczIgPSBzMi5ydWxlcyB8fCBzMi5jc3NSdWxlcztcbiAgICAgICAgaWYgKCFydWxlczIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGVldEhyZWYgPSBzMi5ocmVmO1xuICAgICAgICBpZiAoIXNoZWV0SHJlZiAmJiBzMi5vd25lck5vZGUgJiYgczIub3duZXJOb2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHNoZWV0SHJlZiA9IHMyLm93bmVyTm9kZS5vd25lckRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkUnVsZXMgPSBBcnJheS5mcm9tKHJ1bGVzMiwgZnVuY3Rpb24ocnVsZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlSdWxlKHJ1bGUyLCBzaGVldEhyZWYpO1xuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gZml4QnJvd3NlckNvbXBhdGliaWxpdHlJc3N1ZXNJbkNTUyhzdHJpbmdpZmllZFJ1bGVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSdWxlKHJ1bGUyLCBzaGVldEhyZWYpIHtcbiAgICBpZiAoaXNDU1NJbXBvcnRSdWxlKHJ1bGUyKSkge1xuICAgICAgICB2YXIgaW1wb3J0U3RyaW5naWZpZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbXBvcnRTdHJpbmdpZmllZCA9IC8vIHdlIGNhbiBhY2Nlc3MgdGhlIGltcG9ydGVkIHN0eWxlc2hlZXQgcnVsZXMgZGlyZWN0bHlcbiAgICAgICAgICAgIHN0cmluZ2lmeVN0eWxlc2hlZXQocnVsZTIuc3R5bGVTaGVldCkgfHwgLy8gd29yayBhcm91bmQgYnJvd3NlciBpc3N1ZXMgd2l0aCB0aGUgcmF3IHN0cmluZyBgQGltcG9ydCB1cmwoLi4uKWAgc3RhdGVtZW50XG4gICAgICAgICAgICBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZTIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPSBydWxlMi5jc3NUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlMi5zdHlsZVNoZWV0LmhyZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyhpbXBvcnRTdHJpbmdpZmllZCwgcnVsZTIuc3R5bGVTaGVldC5ocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0U3RyaW5naWZpZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJ1bGVTdHJpbmdpZmllZCA9IHJ1bGUyLmNzc1RleHQ7XG4gICAgICAgIGlmIChpc0NTU1N0eWxlUnVsZShydWxlMikgJiYgcnVsZTIuc2VsZWN0b3JUZXh0LmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgICAgICAgcnVsZVN0cmluZ2lmaWVkID0gZml4U2FmYXJpQ29sb25zKHJ1bGVTdHJpbmdpZmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoZWV0SHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGFic29sdXRpZnlVUkxzKHJ1bGVTdHJpbmdpZmllZCwgc2hlZXRIcmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZVN0cmluZ2lmaWVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpeFNhZmFyaUNvbG9ucyhjc3NTdHJpbmdpZmllZCkge1xuICAgIHZhciByZWdleCA9IC8oXFxbKD86W1xcdy1dKylbXlxcXFxdKSg6KD86W1xcdy1dKylcXF0pL2dtO1xuICAgIHJldHVybiBjc3NTdHJpbmdpZmllZC5yZXBsYWNlKHJlZ2V4LCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gaXNDU1NJbXBvcnRSdWxlKHJ1bGUyKSB7XG4gICAgcmV0dXJuIFwic3R5bGVTaGVldFwiIGluIHJ1bGUyO1xufVxuZnVuY3Rpb24gaXNDU1NTdHlsZVJ1bGUocnVsZTIpIHtcbiAgICByZXR1cm4gXCJzZWxlY3RvclRleHRcIiBpbiBydWxlMjtcbn1cbnZhciBNaXJyb3IgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1pcnJvcigpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiaWROb2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJub2RlTWV0YU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNaXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5nZXRJZCA9IGZ1bmN0aW9uIGdldElkKG4yKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGlmICghbjIpIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGlkID0gKF9hMiA9IHRoaXMuZ2V0TWV0YShuMikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaWQ7XG4gICAgICAgIHJldHVybiBpZCAhPSBudWxsID8gaWQgOiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5nZXROb2RlID0gZnVuY3Rpb24gZ2V0Tm9kZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZE5vZGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkcyA9IGZ1bmN0aW9uIGdldElkcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pZE5vZGVNYXAua2V5cygpKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRNZXRhID0gZnVuY3Rpb24gZ2V0TWV0YShuMikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlTWV0YU1hcC5nZXQobjIpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvLyByZW1vdmVzIHRoZSBub2RlIGZyb20gaWROb2RlTWFwXG4gICAgLy8gZG9lc24ndCByZW1vdmUgdGhlIG5vZGUgZnJvbSBub2RlTWV0YU1hcFxuICAgIF9wcm90by5yZW1vdmVOb2RlRnJvbU1hcCA9IGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tTWFwKG4yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuZ2V0SWQobjIpO1xuICAgICAgICB0aGlzLmlkTm9kZU1hcC5kZWxldGUoaWQpO1xuICAgICAgICBpZiAobjIuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgbjIuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmhhcyhpZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFzTm9kZSA9IGZ1bmN0aW9uIGhhc05vZGUobm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQobjIsIG1ldGEpIHtcbiAgICAgICAgdmFyIGlkID0gbWV0YS5pZDtcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgICAgIHRoaXMubm9kZU1ldGFNYXAuc2V0KG4yLCBtZXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShpZCwgbjIpIHtcbiAgICAgICAgdmFyIG9sZE5vZGUgPSB0aGlzLmdldE5vZGUoaWQpO1xuICAgICAgICBpZiAob2xkTm9kZSkge1xuICAgICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLm5vZGVNZXRhTWFwLmdldChvbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChtZXRhKSB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuMik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWlycm9yO1xufSgpO1xuZnVuY3Rpb24gY3JlYXRlTWlycm9yJDIoKSB7XG4gICAgcmV0dXJuIG5ldyBNaXJyb3IoKTtcbn1cbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHBhcmFtKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBwYXJhbS5lbGVtZW50LCBtYXNrSW5wdXRPcHRpb25zID0gcGFyYW0ubWFza0lucHV0T3B0aW9ucywgdGFnTmFtZSA9IHBhcmFtLnRhZ05hbWUsIHR5cGUgPSBwYXJhbS50eXBlLCB2YWx1ZSA9IHBhcmFtLnZhbHVlLCBtYXNrSW5wdXRGbiA9IHBhcmFtLm1hc2tJbnB1dEZuO1xuICAgIHZhciB0ZXh0ID0gdmFsdWUgfHwgXCJcIjtcbiAgICB2YXIgYWN0dWFsVHlwZSA9IHR5cGUgJiYgdG9Mb3dlckNhc2UodHlwZSk7XG4gICAgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBhY3R1YWxUeXBlICYmIG1hc2tJbnB1dE9wdGlvbnNbYWN0dWFsVHlwZV0pIHtcbiAgICAgICAgaWYgKG1hc2tJbnB1dEZuKSB7XG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gXCIqXCIucmVwZWF0KHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cbnZhciBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSA9IFwiX19ycndlYl9vcmlnaW5hbF9fXCI7XG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHJldHVybiB0cnVlO1xuICAgIHZhciBjaHVua1NpemUgPSA1MDtcbiAgICBmb3IodmFyIHgyID0gMDsgeDIgPCBjYW52YXMud2lkdGg7IHgyICs9IGNodW5rU2l6ZSl7XG4gICAgICAgIGZvcih2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5ICs9IGNodW5rU2l6ZSl7XG4gICAgICAgICAgICB2YXIgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEdldEltYWdlRGF0YSA9IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FIGluIGdldEltYWdlRGF0YSA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRV0gOiBnZXRJbWFnZURhdGE7XG4gICAgICAgICAgICB2YXIgcGl4ZWxCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgb3JpZ2luYWxHZXRJbWFnZURhdGEuY2FsbChjdHgsIHgyLCB5LCBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgyKSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChwaXhlbEJ1ZmZlci5zb21lKGZ1bmN0aW9uKHBpeGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpeGVsICE9PSAwO1xuICAgICAgICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldElucHV0VHlwZShlbGVtZW50KSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiKSA/IFwicGFzc3dvcmRcIiA6IHR5cGUgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgdG9Mb3dlckNhc2UodHlwZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVFeHRlbnNpb24ocGF0aCwgYmFzZVVSTCkge1xuICAgIHZhciB1cmw7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVVJMICE9IG51bGwgPyBiYXNlVVJMIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlZ2V4ID0gL1xcLihbMC05YS16XSspKD86JCkvaTtcbiAgICB2YXIgbWF0Y2ggPSB1cmwucGF0aG5hbWUubWF0Y2gocmVnZXgpO1xuICAgIHZhciBfcmVmO1xuICAgIHJldHVybiAoX3JlZiA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFsxXSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xufVxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcbiAgICB2YXIgb3JpZ2luID0gXCJcIjtcbiAgICBpZiAodXJsLmluZGV4T2YoXCIvL1wiKSA+IC0xKSB7XG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIikuc2xpY2UoMCwgMykuam9pbihcIi9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KFwiL1wiKVswXTtcbiAgICB9XG4gICAgb3JpZ2luID0gb3JpZ2luLnNwbGl0KFwiP1wiKVswXTtcbiAgICByZXR1cm4gb3JpZ2luO1xufVxudmFyIFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xudmFyIFVSTF9QUk9UT0NPTF9NQVRDSCA9IC9eKD86W2EteitdKzopP1xcL1xcLy9pO1xudmFyIFVSTF9XV1dfTUFUQ0ggPSAvXnd3d1xcLi4qL2k7XG52YXIgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcbmZ1bmN0aW9uIGFic29sdXRpZnlVUkxzKGNzc1RleHQsIGhyZWYpIHtcbiAgICByZXR1cm4gKGNzc1RleHQgfHwgXCJcIikucmVwbGFjZShVUkxfSU5fQ1NTX1JFRiwgZnVuY3Rpb24ob3JpZ2luLCBxdW90ZTEsIHBhdGgxLCBxdW90ZTIsIHBhdGgyLCBwYXRoMykge1xuICAgICAgICB2YXIgZmlsZVBhdGggPSBwYXRoMSB8fCBwYXRoMiB8fCBwYXRoMztcbiAgICAgICAgdmFyIG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8IFwiXCI7XG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVSTF9QUk9UT0NPTF9NQVRDSC50ZXN0KGZpbGVQYXRoKSB8fCBVUkxfV1dXX01BVENILnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgZmlsZVBhdGggKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgZmlsZVBhdGggKyBtYXliZVF1b3RlICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSBcIi9cIikge1xuICAgICAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIChleHRyYWN0T3JpZ2luKGhyZWYpICsgZmlsZVBhdGgpICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFjayA9IGhyZWYuc3BsaXQoXCIvXCIpO1xuICAgICAgICB2YXIgcGFydHMgPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwYXJ0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIHN0YWNrLmpvaW4oXCIvXCIpICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQpIHtcbiAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKC8oXFwvXFwqW14qXSpcXCpcXC8pfFtcXHM7XS9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSkge1xuICAgIHZhciBjaGlsZE5vZGVzMiA9IEFycmF5LmZyb20oc3R5bGUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHNwbGl0cyA9IFtdO1xuICAgIGlmIChjaGlsZE5vZGVzMi5sZW5ndGggPiAxICYmIGNzc1RleHQgJiYgdHlwZW9mIGNzc1RleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGNzc1RleHROb3JtID0gbm9ybWFsaXplQ3NzU3RyaW5nKGNzc1RleHQpO1xuICAgICAgICBmb3IodmFyIGkyID0gMTsgaTIgPCBjaGlsZE5vZGVzMi5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCAmJiB0eXBlb2YgY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50Tm9ybSA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDM7IGogPCB0ZXh0Q29udGVudE5vcm0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gdGV4dENvbnRlbnROb3JtLnN1YnN0cmluZygwLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc1RleHROb3JtLnNwbGl0KGJpdCkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXROb3JtID0gY3NzVGV4dE5vcm0uaW5kZXhPZihiaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrID0gc3BsaXROb3JtOyBrIDwgY3NzVGV4dC5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0LnN1YnN0cmluZygwLCBrKSkubGVuZ3RoID09PSBzcGxpdE5vcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRzLnB1c2goY3NzVGV4dC5zdWJzdHJpbmcoMCwgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5zdWJzdHJpbmcoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNwbGl0cy5wdXNoKGNzc1RleHQpO1xuICAgIHJldHVybiBzcGxpdHM7XG59XG5mdW5jdGlvbiBtYXJrQ3NzU3BsaXRzKGNzc1RleHQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHNwbGl0Q3NzVGV4dChjc3NUZXh0LCBzdHlsZSkuam9pbihcIi8qIHJyX3NwbGl0ICovXCIpO1xufVxudmFyIF9pZCA9IDE7XG52YXIgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteYS16MC05LV86XVwiKTtcbnZhciBJR05PUkVEX05PREUgPSAtMjtcbmZ1bmN0aW9uIGdlbklkKCkge1xuICAgIHJldHVybiBfaWQrKztcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVGFnTmFtZSQxKGVsZW1lbnQpIHtcbiAgICBpZiAoX2luc3RhbmNlb2YoZWxlbWVudCwgSFRNTEZvcm1FbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gXCJmb3JtXCI7XG4gICAgfVxuICAgIHZhciBwcm9jZXNzZWRUYWdOYW1lID0gdG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICBpZiAodGFnTmFtZVJlZ2V4LnRlc3QocHJvY2Vzc2VkVGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZGl2XCI7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWRUYWdOYW1lO1xufVxudmFyIGNhbnZhc1NlcnZpY2U7XG52YXIgY2FudmFzQ3R4O1xudmFyIFNSQ1NFVF9OT1RfU1BBQ0VTID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvO1xudmFyIFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvO1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgIH1cbiAgICB2YXIgcG9zID0gMDtcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuICAgICAgICB2YXIgY2hhcnMyO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZWdFeC5leGVjKGF0dHJpYnV0ZVZhbHVlLnN1YnN0cmluZyhwb3MpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjaGFyczIgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHBvcyArPSBjaGFyczIubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJzMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlKHRydWUpe1xuICAgICAgICBjb2xsZWN0Q2hhcmFjdGVycyhTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyk7XG4gICAgICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX05PVF9TUEFDRVMpO1xuICAgICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh1cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzU3RyID0gXCJcIjtcbiAgICAgICAgICAgIHVybCA9IGFic29sdXRlVG9Eb2MoZG9jLCB1cmwpO1xuICAgICAgICAgICAgdmFyIGluUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoYzIgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpblBhcmVucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMyID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1N0ciArPSBjMjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCIsIFwiKTtcbn1cbnZhciBjYWNoZWREb2N1bWVudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYWJzb2x1dGVUb0RvYyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SHJlZihkb2MsIGF0dHJpYnV0ZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xuICAgIHJldHVybiBCb29sZWFuKGVsLnRhZ05hbWUgPT09IFwic3ZnXCIgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhyZWYoZG9jLCBjdXN0b21IcmVmKSB7XG4gICAgdmFyIGEyID0gY2FjaGVkRG9jdW1lbnQuZ2V0KGRvYyk7XG4gICAgaWYgKCFhMikge1xuICAgICAgICBhMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgY2FjaGVkRG9jdW1lbnQuc2V0KGRvYywgYTIpO1xuICAgIH1cbiAgICBpZiAoIWN1c3RvbUhyZWYpIHtcbiAgICAgICAgY3VzdG9tSHJlZiA9IFwiXCI7XG4gICAgfSBlbHNlIGlmIChjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCBjdXN0b21IcmVmLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICByZXR1cm4gY3VzdG9tSHJlZjtcbiAgICB9XG4gICAgYTIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBjdXN0b21IcmVmKTtcbiAgICByZXR1cm4gYTIuaHJlZjtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInNyY1wiIHx8IG5hbWUgPT09IFwiaHJlZlwiICYmICEodGFnTmFtZSA9PT0gXCJ1c2VcIiAmJiB2YWx1ZVswXSA9PT0gXCIjXCIpKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ4bGluazpocmVmXCIgJiYgdmFsdWVbMF0gIT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIgJiYgKHRhZ05hbWUgPT09IFwidGFibGVcIiB8fCB0YWdOYW1lID09PSBcInRkXCIgfHwgdGFnTmFtZSA9PT0gXCJ0aFwiKSkge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3Jjc2V0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyh2YWx1ZSwgZ2V0SHJlZihkb2MpKTtcbiAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IFwib2JqZWN0XCIgJiYgbmFtZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUF0dHJpYnV0ZSh0YWdOYW1lLCBuYW1lLCBfdmFsdWUpIHtcbiAgICByZXR1cm4gKHRhZ05hbWUgPT09IFwidmlkZW9cIiB8fCB0YWdOYW1lID09PSBcImF1ZGlvXCIpICYmIG5hbWUgPT09IFwiYXV0b3BsYXlcIjtcbn1cbmZ1bmN0aW9uIF9pc0Jsb2NrZWRFbGVtZW50KGVsZW1lbnQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yKHZhciBlSW5kZXggPSBlbGVtZW50LmNsYXNzTGlzdC5sZW5ndGg7IGVJbmRleC0tOyl7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrQ2xhc3MudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhibG9ja1NlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUyLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUyLm5vZGVUeXBlICE9PSBub2RlMi5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgaWYgKCFjaGVja0FuY2VzdG9ycykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbiAgICB9XG4gICAgZm9yKHZhciBlSW5kZXggPSBub2RlMi5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTspe1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gbm9kZTIuY2xhc3NMaXN0W2VJbmRleF07XG4gICAgICAgIGlmIChyZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hlY2tBbmNlc3RvcnMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgoaW5kZXgkMS5wYXJlbnROb2RlKG5vZGUyKSwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKTtcbn1cbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlMiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgICB2YXIgZWw7XG4gICAgaWYgKGlzRWxlbWVudChub2RlMikpIHtcbiAgICAgICAgZWwgPSBub2RlMjtcbiAgICAgICAgaWYgKCFpbmRleCQxLmNoaWxkTm9kZXMoZWwpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleCQxLnBhcmVudEVsZW1lbnQobm9kZTIpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGluZGV4JDEucGFyZW50RWxlbWVudChub2RlMik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWFza1RleHRDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsb3Nlc3QoXCIuXCIgKyBtYXNrVGV4dENsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMobWFza1RleHRDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsYXNzTWF0Y2hlc1JlZ2V4KGVsLCBtYXNrVGV4dENsYXNzLCBjaGVja0FuY2VzdG9ycykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXNrVGV4dFNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xvc2VzdChtYXNrVGV4dFNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbC5tYXRjaGVzKG1hc2tUZXh0U2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xuICAgIHZhciB3aW4gPSBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG4gICAgdmFyIHJlYWR5U3RhdGU7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHdpbi5kb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XG4gICAgICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBibGFua1VybCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgICBpZiAod2luLmxvY2F0aW9uLmhyZWYgIT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHwgaWZyYW1lRWwuc3JjID09PSBcIlwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGlzdGVuZXIsIDApO1xuICAgICAgICByZXR1cm4gaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBvbmNlU3R5bGVzaGVldExvYWRlZChsaW5rLCBsaXN0ZW5lciwgc3R5bGVTaGVldExvYWRUaW1lb3V0KSB7XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlU2hlZXRMb2FkZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgc3R5bGVTaGVldExvYWRlZCA9IGxpbmsuc2hlZXQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3R5bGVTaGVldExvYWRlZCkgcmV0dXJuO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBzdHlsZVNoZWV0TG9hZFRpbWVvdXQpO1xuICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIG1pcnJvcjIgPSBvcHRpb25zLm1pcnJvciwgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgbmVlZHNNYXNrID0gb3B0aW9ucy5uZWVkc01hc2ssIGlubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBpbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9IG9wdGlvbnMubmV3bHlBZGRlZEVsZW1lbnQsIG5ld2x5QWRkZWRFbGVtZW50ID0gX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQsIF9vcHRpb25zX2Nzc0NhcHR1cmVkID0gb3B0aW9ucy5jc3NDYXB0dXJlZCwgY3NzQ2FwdHVyZWQgPSBfb3B0aW9uc19jc3NDYXB0dXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19jc3NDYXB0dXJlZDtcbiAgICB2YXIgcm9vdElkID0gZ2V0Um9vdElkKGRvYywgbWlycm9yMik7XG4gICAgc3dpdGNoKG4yLm5vZGVUeXBlKXtcbiAgICAgICAgY2FzZSBuMi5ET0NVTUVOVF9OT0RFOlxuICAgICAgICAgICAgaWYgKG4yLmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdE1vZGU6IG4yLmNvbXBhdE1vZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgbjIuRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkRvY3VtZW50VHlwZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuMi5uYW1lLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiBuMi5wdWJsaWNJZCxcbiAgICAgICAgICAgICAgICBzeXN0ZW1JZDogbjIuc3lzdGVtSWQsXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgbjIuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCB7XG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBuZXdseUFkZGVkRWxlbWVudCxcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgbjIuVEVYVF9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRleHROb2RlKG4yLCB7XG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZCxcbiAgICAgICAgICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIG4yLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5DREFUQSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBuMi5DT01NRU5UX05PREU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuQ29tbWVudCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogaW5kZXgkMS50ZXh0Q29udGVudChuMikgfHwgXCJcIixcbiAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSb290SWQoZG9jLCBtaXJyb3IyKSB7XG4gICAgaWYgKCFtaXJyb3IyLmhhc05vZGUoZG9jKSkgcmV0dXJuIHZvaWQgMDtcbiAgICB2YXIgZG9jSWQgPSBtaXJyb3IyLmdldElkKGRvYyk7XG4gICAgcmV0dXJuIGRvY0lkID09PSAxID8gdm9pZCAwIDogZG9jSWQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZShuMiwgb3B0aW9ucykge1xuICAgIHZhciBuZWVkc01hc2sgPSBvcHRpb25zLm5lZWRzTWFzaywgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgcm9vdElkID0gb3B0aW9ucy5yb290SWQsIGNzc0NhcHR1cmVkID0gb3B0aW9ucy5jc3NDYXB0dXJlZDtcbiAgICB2YXIgcGFyZW50ID0gaW5kZXgkMS5wYXJlbnROb2RlKG4yKTtcbiAgICB2YXIgcGFyZW50VGFnTmFtZSA9IHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZTtcbiAgICB2YXIgdGV4dENvbnRlbnQyID0gXCJcIjtcbiAgICB2YXIgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09IFwiU1RZTEVcIiA/IHRydWUgOiB2b2lkIDA7XG4gICAgdmFyIGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gXCJTQ1JJUFRcIiA/IHRydWUgOiB2b2lkIDA7XG4gICAgaWYgKGlzU2NyaXB0KSB7XG4gICAgICAgIHRleHRDb250ZW50MiA9IFwiU0NSSVBUX1BMQUNFSE9MREVSXCI7XG4gICAgfSBlbHNlIGlmICghY3NzQ2FwdHVyZWQpIHtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gaW5kZXgkMS50ZXh0Q29udGVudChuMik7XG4gICAgICAgIGlmIChpc1N0eWxlICYmIHRleHRDb250ZW50Mikge1xuICAgICAgICAgICAgdGV4dENvbnRlbnQyID0gYWJzb2x1dGlmeVVSTHModGV4dENvbnRlbnQyLCBnZXRIcmVmKG9wdGlvbnMuZG9jKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1N0eWxlICYmICFpc1NjcmlwdCAmJiB0ZXh0Q29udGVudDIgJiYgbmVlZHNNYXNrKSB7XG4gICAgICAgIHRleHRDb250ZW50MiA9IG1hc2tUZXh0Rm4gPyBtYXNrVGV4dEZuKHRleHRDb250ZW50MiwgaW5kZXgkMS5wYXJlbnRFbGVtZW50KG4yKSkgOiB0ZXh0Q29udGVudDIucmVwbGFjZSgvW1xcU10vZywgXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLlRleHQsXG4gICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudDIgfHwgXCJcIixcbiAgICAgICAgcm9vdElkOiByb290SWRcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRWxlbWVudE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIGlubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBpbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9IG9wdGlvbnMubmV3bHlBZGRlZEVsZW1lbnQsIG5ld2x5QWRkZWRFbGVtZW50ID0gX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQsIHJvb3RJZCA9IG9wdGlvbnMucm9vdElkO1xuICAgIHZhciBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XG4gICAgdmFyIHRhZ05hbWUgPSBnZXRWYWxpZFRhZ05hbWUkMShuMik7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgbGVuID0gbjIuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbGVuOyBpMisrKXtcbiAgICAgICAgdmFyIGF0dHIgPSBuMi5hdHRyaWJ1dGVzW2kyXTtcbiAgICAgICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5hbWVdID0gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgdG9Mb3dlckNhc2UoYXR0ci5uYW1lKSwgYXR0ci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwibGlua1wiICYmIGlubGluZVN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmluZChmdW5jdGlvbihzMikge1xuICAgICAgICAgICAgcmV0dXJuIHMyLmhyZWYgPT09IG4yLmhyZWY7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3NzVGV4dCA9IG51bGw7XG4gICAgICAgIGlmIChzdHlsZXNoZWV0KSB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChzdHlsZXNoZWV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMucmVsO1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuaHJlZjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcInN0eWxlXCIgJiYgbjIuc2hlZXQpIHtcbiAgICAgICAgdmFyIGNzc1RleHQxID0gc3RyaW5naWZ5U3R5bGVzaGVldChuMi5zaGVldCk7XG4gICAgICAgIGlmIChjc3NUZXh0MSkge1xuICAgICAgICAgICAgaWYgKG4yLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQxID0gbWFya0Nzc1NwbGl0cyhjc3NUZXh0MSwgbjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlcy5fY3NzVGV4dCA9IGNzc1RleHQxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZ05hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbjIudmFsdWU7XG4gICAgICAgIHZhciBjaGVja2VkID0gbjIuY2hlY2tlZDtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJyYWRpb1wiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJjaGVja2JveFwiICYmIGF0dHJpYnV0ZXMudHlwZSAhPT0gXCJzdWJtaXRcIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwiYnV0dG9uXCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogbjIsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKG4yKSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICBpZiAobjIuc2VsZWN0ZWQgJiYgIW1hc2tJbnB1dE9wdGlvbnNbXCJzZWxlY3RcIl0pIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiZGlhbG9nXCIgJiYgbjIub3Blbikge1xuICAgICAgICBhdHRyaWJ1dGVzLnJyX29wZW5fbW9kZSA9IG4yLm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikgPyBcIm1vZGFsXCIgOiBcIm5vbi1tb2RhbFwiO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJjYW52YXNcIiAmJiByZWNvcmRDYW52YXMpIHtcbiAgICAgICAgaWYgKG4yLl9fY29udGV4dCA9PT0gXCIyZFwiKSB7XG4gICAgICAgICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayhuMikpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBuMi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcIl9fY29udGV4dFwiIGluIG4yKSkge1xuICAgICAgICAgICAgdmFyIGNhbnZhc0RhdGFVUkwgPSBuMi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB2YXIgYmxhbmtDYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIGJsYW5rQ2FudmFzLndpZHRoID0gbjIud2lkdGg7XG4gICAgICAgICAgICBibGFua0NhbnZhcy5oZWlnaHQgPSBuMi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgYmxhbmtDYW52YXNEYXRhVVJMID0gYmxhbmtDYW52YXMudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGFVUkwgIT09IGJsYW5rQ2FudmFzRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiaW1nXCIgJiYgaW5saW5lSW1hZ2VzKSB7XG4gICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xuICAgICAgICAgICAgY2FudmFzU2VydmljZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltYWdlID0gbjI7XG4gICAgICAgIHZhciBpbWFnZVNyYyA9IGltYWdlLmN1cnJlbnRTcmMgfHwgaW1hZ2UuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiPHVua25vd24tc3JjPlwiO1xuICAgICAgICB2YXIgcHJpb3JDcm9zc09yaWdpbiA9IGltYWdlLmNyb3NzT3JpZ2luO1xuICAgICAgICB2YXIgcmVjb3JkSW5saW5lSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY2FudmFzQ3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuY3Jvc3NPcmlnaW4gIT09IFwiYW5vbnltb3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKSByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBpbmxpbmUgaW1nIHNyYz1cIiArIGltYWdlU3JjICsgXCIhIEVycm9yOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luID09PSBcImFub255bW91c1wiKSB7XG4gICAgICAgICAgICAgICAgcHJpb3JDcm9zc09yaWdpbiA/IGF0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4gPSBwcmlvckNyb3NzT3JpZ2luIDogaW1hZ2UucmVtb3ZlQXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHJlY29yZElubGluZUltYWdlKCk7XG4gICAgICAgIGVsc2UgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVjb3JkSW5saW5lSW1hZ2UpO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJhdWRpb1wiIHx8IHRhZ05hbWUgPT09IFwidmlkZW9cIikge1xuICAgICAgICB2YXIgbWVkaWFBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhU3RhdGUgPSBuMi5wYXVzZWQgPyBcInBhdXNlZFwiIDogXCJwbGF5ZWRcIjtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhQ3VycmVudFRpbWUgPSBuMi5jdXJyZW50VGltZTtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhUGxheWJhY2tSYXRlID0gbjIucGxheWJhY2tSYXRlO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFNdXRlZCA9IG4yLm11dGVkO1xuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFMb29wID0gbjIubG9vcDtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhVm9sdW1lID0gbjIudm9sdW1lO1xuICAgIH1cbiAgICBpZiAoIW5ld2x5QWRkZWRFbGVtZW50KSB7XG4gICAgICAgIGlmIChuMi5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbExlZnQgPSBuMi5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMi5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsVG9wID0gbjIuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkQmxvY2spIHtcbiAgICAgICAgdmFyIF9uMl9nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBuMi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfbjJfZ2V0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoLCBoZWlnaHQgPSBfbjJfZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgICAgICAgcnJfd2lkdGg6IFwiXCIgKyB3aWR0aCArIFwicHhcIixcbiAgICAgICAgICAgIHJyX2hlaWdodDogXCJcIiArIGhlaWdodCArIFwicHhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJpZnJhbWVcIiAmJiAha2VlcElmcmFtZVNyY0ZuKGF0dHJpYnV0ZXMuc3JjKSkge1xuICAgICAgICBpZiAoIW4yLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zcmMgPSBhdHRyaWJ1dGVzLnNyYztcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5zcmM7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkgaXNDdXN0b21FbGVtZW50ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlMikge31cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkVsZW1lbnQsXG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICBpc1NWRzogaXNTVkdFbGVtZW50KG4yKSB8fCB2b2lkIDAsXG4gICAgICAgIG5lZWRCbG9jazogbmVlZEJsb2NrLFxuICAgICAgICByb290SWQ6IHJvb3RJZCxcbiAgICAgICAgaXNDdXN0b206IGlzQ3VzdG9tRWxlbWVudFxuICAgIH07XG59XG5mdW5jdGlvbiBsb3dlcklmRXhpc3RzKG1heWJlQXR0cikge1xuICAgIGlmIChtYXliZUF0dHIgPT09IHZvaWQgMCB8fCBtYXliZUF0dHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1heWJlQXR0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNsaW1ET01FeGNsdWRlZChzbiwgc2xpbURPTU9wdGlvbnMpIHtcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZSQzLkNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJiAvLyBzY3JpcHQgdGFnXG4gICAgICAgIChzbi50YWdOYW1lID09PSBcInNjcmlwdFwiIHx8IC8vIChtb2R1bGUpcHJlbG9hZCBsaW5rXG4gICAgICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIChzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgfHwgc24uYXR0cmlidXRlcy5yZWwgPT09IFwibW9kdWxlcHJlbG9hZFwiKSAmJiBzbi5hdHRyaWJ1dGVzLmFzID09PSBcInNjcmlwdFwiIHx8IC8vIHByZWZldGNoIGxpbmtcbiAgICAgICAgc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlZmV0Y2hcIiAmJiB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSBcInN0cmluZ1wiICYmIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNuLmF0dHJpYnV0ZXMuaHJlZikgPT09IFwianNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRGYXZpY29uICYmIChzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzaG9ydGN1dCBpY29uXCIgfHwgc24udGFnTmFtZSA9PT0gXCJtZXRhXCIgJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXm1zYXBwbGljYXRpb24tdGlsZShpbWFnZXxjb2xvcikkLykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImFwcGxpY2F0aW9uLW5hbWVcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJpY29uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiYXBwbGUtdG91Y2gtaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcInNob3J0Y3V0IGljb25cIikpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzbi50YWdOYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhRGVzY0tleXdvcmRzICYmIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXmRlc2NyaXB0aW9ufGtleXdvcmRzJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eKG9nfHR3aXR0ZXJ8ZmIpOi8pIHx8IC8vIG9nID0gb3BlbmdyYXBoIChmYWNlYm9vaylcbiAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicGludGVyZXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhUm9ib3RzICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicm9ib3RzXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZWJvdFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJiaW5nYm90XCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhSHR0cEVxdWl2ICYmIHNuLmF0dHJpYnV0ZXNbXCJodHRwLWVxdWl2XCJdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFBdXRob3JzaGlwICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYXV0aG9yXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdlbmVyYXRvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJmcmFtZXdvcmtcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicHVibGlzaGVyXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInByb2dpZFwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15hcnRpY2xlOi8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5wcm9wZXJ0eSkubWF0Y2goL15wcm9kdWN0Oi8pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVZlcmlmaWNhdGlvbiAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImdvb2dsZS1zaXRlLXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ5YW5kZXgtdmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImNzcmYtdG9rZW5cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwicDpkb21haW5fdmVyaWZ5XCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInZlcmlmeS12MVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwic2hvcGlmeS1jaGVja291dC1hcGktdG9rZW5cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvYyA9IG9wdGlvbnMuZG9jLCBtaXJyb3IyID0gb3B0aW9ucy5taXJyb3IsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIG1hc2tUZXh0Q2xhc3MgPSBvcHRpb25zLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIF9vcHRpb25zX3NraXBDaGlsZCA9IG9wdGlvbnMuc2tpcENoaWxkLCBza2lwQ2hpbGQgPSBfb3B0aW9uc19za2lwQ2hpbGQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfc2tpcENoaWxkLCBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0ID0gb3B0aW9ucy5pbmxpbmVTdHlsZXNoZWV0LCBpbmxpbmVTdHlsZXNoZWV0ID0gX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQsIF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX21hc2tJbnB1dE9wdGlvbnMsIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgc2xpbURPTU9wdGlvbnMgPSBvcHRpb25zLnNsaW1ET01PcHRpb25zLCBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMsIF9vcHRpb25zX2lubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCBpbmxpbmVJbWFnZXMgPSBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfaW5saW5lSW1hZ2VzLCBfb3B0aW9uc19yZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX29wdGlvbnNfcmVjb3JkQ2FudmFzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3JlY29yZENhbnZhcywgb25TZXJpYWxpemUgPSBvcHRpb25zLm9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQgPSBvcHRpb25zLm9uSWZyYW1lTG9hZCwgX29wdGlvbnNfaWZyYW1lTG9hZFRpbWVvdXQgPSBvcHRpb25zLmlmcmFtZUxvYWRUaW1lb3V0LCBpZnJhbWVMb2FkVGltZW91dCA9IF9vcHRpb25zX2lmcmFtZUxvYWRUaW1lb3V0ID09PSB2b2lkIDAgPyA1ZTMgOiBfb3B0aW9uc19pZnJhbWVMb2FkVGltZW91dCwgb25TdHlsZXNoZWV0TG9hZCA9IG9wdGlvbnMub25TdHlsZXNoZWV0TG9hZCwgX29wdGlvbnNfc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gb3B0aW9ucy5zdHlsZXNoZWV0TG9hZFRpbWVvdXQsIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IF9vcHRpb25zX3N0eWxlc2hlZXRMb2FkVGltZW91dCA9PT0gdm9pZCAwID8gNWUzIDogX29wdGlvbnNfc3R5bGVzaGVldExvYWRUaW1lb3V0LCBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID0gb3B0aW9ucy5uZXdseUFkZGVkRWxlbWVudCwgbmV3bHlBZGRlZEVsZW1lbnQgPSBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCwgX29wdGlvbnNfY3NzQ2FwdHVyZWQgPSBvcHRpb25zLmNzc0NhcHR1cmVkLCBjc3NDYXB0dXJlZCA9IF9vcHRpb25zX2Nzc0NhcHR1cmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2Nzc0NhcHR1cmVkO1xuICAgIHZhciBuZWVkc01hc2sgPSBvcHRpb25zLm5lZWRzTWFzaztcbiAgICB2YXIgX29wdGlvbnNfcHJlc2VydmVXaGl0ZVNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlU3BhY2UsIHByZXNlcnZlV2hpdGVTcGFjZSA9IF9vcHRpb25zX3ByZXNlcnZlV2hpdGVTcGFjZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX3ByZXNlcnZlV2hpdGVTcGFjZTtcbiAgICBpZiAoIW5lZWRzTWFzaykge1xuICAgICAgICB2YXIgY2hlY2tBbmNlc3RvcnMgPSBuZWVkc01hc2sgPT09IHZvaWQgMDtcbiAgICAgICAgbmVlZHNNYXNrID0gbmVlZE1hc2tpbmdUZXh0KG4yLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycyk7XG4gICAgfVxuICAgIHZhciBfc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVOb2RlKG4yLCB7XG4gICAgICAgIGRvYzogZG9jLFxuICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IG5ld2x5QWRkZWRFbGVtZW50LFxuICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICB9KTtcbiAgICBpZiAoIV9zZXJpYWxpemVkTm9kZSkge1xuICAgICAgICBjb25zb2xlLndhcm4objIsIFwibm90IHNlcmlhbGl6ZWRcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaWQ7XG4gICAgaWYgKG1pcnJvcjIuaGFzTm9kZShuMikpIHtcbiAgICAgICAgaWQgPSBtaXJyb3IyLmdldElkKG4yKTtcbiAgICB9IGVsc2UgaWYgKHNsaW1ET01FeGNsdWRlZChfc2VyaWFsaXplZE5vZGUsIHNsaW1ET01PcHRpb25zKSB8fCAhcHJlc2VydmVXaGl0ZVNwYWNlICYmIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLlRleHQgJiYgIV9zZXJpYWxpemVkTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwgXCJcIikubGVuZ3RoKSB7XG4gICAgICAgIGlkID0gSUdOT1JFRF9OT0RFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gZ2VuSWQoKTtcbiAgICB9XG4gICAgdmFyIHNlcmlhbGl6ZWROb2RlID0gT2JqZWN0LmFzc2lnbihfc2VyaWFsaXplZE5vZGUsIHtcbiAgICAgICAgaWQ6IGlkXG4gICAgfSk7XG4gICAgbWlycm9yMi5hZGQobjIsIHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoaWQgPT09IElHTk9SRURfTk9ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9uU2VyaWFsaXplKSB7XG4gICAgICAgIG9uU2VyaWFsaXplKG4yKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSB7XG4gICAgICAgIHJlY29yZENoaWxkID0gcmVjb3JkQ2hpbGQgJiYgIXNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcbiAgICAgICAgdmFyIHNoYWRvd1Jvb3RFbCA9IGluZGV4JDEuc2hhZG93Um9vdChuMik7XG4gICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsKSkgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3dIb3N0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkRvY3VtZW50IHx8IHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkgJiYgcmVjb3JkQ2hpbGQpIHtcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRXaGl0ZXNwYWNlICYmIHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImhlYWRcIikge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5cGFzc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbmVlZHNNYXNrOiBuZWVkc01hc2ssXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIHNraXBDaGlsZDogc2tpcENoaWxkLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBvbklmcmFtZUxvYWQsXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0OiBzdHlsZXNoZWV0TG9hZFRpbWVvdXQsXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgIGNzc0NhcHR1cmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnZhbHVlICE9PSB2b2lkIDApIDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuX2Nzc1RleHQgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5fY3NzVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJ5cGFzc09wdGlvbnMuY3NzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoQXJyYXkuZnJvbShpbmRleCQxLmNoaWxkTm9kZXMobjIpKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuY2hpbGROb2Rlcy5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZG93Um9vdEVsMSA9IG51bGw7XG4gICAgICAgIGlmIChpc0VsZW1lbnQobjIpICYmIChzaGFkb3dSb290RWwxID0gaW5kZXgkMS5zaGFkb3dSb290KG4yKSkpIHtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKGluZGV4JDEuY2hpbGROb2RlcyhzaGFkb3dSb290RWwxKSkpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTjEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDaGlsZE5vZGUxID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4xLCBieXBhc3NPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdEVsMSkgJiYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUxLmlzU2hhZG93ID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBpbmRleCQxLnBhcmVudE5vZGUobjIpO1xuICAgIGlmIChwYXJlbnQgJiYgaXNTaGFkb3dSb290KHBhcmVudCkgJiYgaXNOYXRpdmVTaGFkb3dEb20ocGFyZW50KSkge1xuICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvdyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJpZnJhbWVcIikge1xuICAgICAgICBvbmNlSWZyYW1lTG9hZGVkKG4yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWVEb2MgPSBuMi5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAoaWZyYW1lRG9jICYmIG9uSWZyYW1lTG9hZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogaWZyYW1lRG9jLFxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkSWZyYW1lTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobjIsIHNlcmlhbGl6ZWRJZnJhbWVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcImxpbmtcIiAmJiB0eXBlb2Ygc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwic3RyaW5nXCIgJiYgKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYpID09PSBcImNzc1wiKSkge1xuICAgICAgICBvbmNlU3R5bGVzaGVldExvYWRlZChuMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob25TdHlsZXNoZWV0TG9hZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkTGlua05vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkTGlua05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZChuMiwgc2VyaWFsaXplZExpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0eWxlc2hlZXRMb2FkVGltZW91dCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90KG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LCB0bXAgPSBfcmVmLm1pcnJvciwgbWlycm9yMiA9IHRtcCA9PT0gdm9pZCAwID8gbmV3IE1pcnJvcigpIDogdG1wLCBfcmVmX2Jsb2NrQ2xhc3MgPSBfcmVmLmJsb2NrQ2xhc3MsIGJsb2NrQ2xhc3MgPSBfcmVmX2Jsb2NrQ2xhc3MgPT09IHZvaWQgMCA/IFwicnItYmxvY2tcIiA6IF9yZWZfYmxvY2tDbGFzcywgX3JlZl9ibG9ja1NlbGVjdG9yID0gX3JlZi5ibG9ja1NlbGVjdG9yLCBibG9ja1NlbGVjdG9yID0gX3JlZl9ibG9ja1NlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX3JlZl9ibG9ja1NlbGVjdG9yLCBfcmVmX21hc2tUZXh0Q2xhc3MgPSBfcmVmLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0Q2xhc3MgPSBfcmVmX21hc2tUZXh0Q2xhc3MgPT09IHZvaWQgMCA/IFwicnItbWFza1wiIDogX3JlZl9tYXNrVGV4dENsYXNzLCBfcmVmX21hc2tUZXh0U2VsZWN0b3IgPSBfcmVmLm1hc2tUZXh0U2VsZWN0b3IsIG1hc2tUZXh0U2VsZWN0b3IgPSBfcmVmX21hc2tUZXh0U2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmX21hc2tUZXh0U2VsZWN0b3IsIF9yZWZfaW5saW5lU3R5bGVzaGVldCA9IF9yZWYuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9yZWZfaW5saW5lU3R5bGVzaGVldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWZfaW5saW5lU3R5bGVzaGVldCwgX3JlZl9pbmxpbmVJbWFnZXMgPSBfcmVmLmlubGluZUltYWdlcywgaW5saW5lSW1hZ2VzID0gX3JlZl9pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9pbmxpbmVJbWFnZXMsIF9yZWZfcmVjb3JkQ2FudmFzID0gX3JlZi5yZWNvcmRDYW52YXMsIHJlY29yZENhbnZhcyA9IF9yZWZfcmVjb3JkQ2FudmFzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWZfcmVjb3JkQ2FudmFzLCBfcmVmX21hc2tBbGxJbnB1dHMgPSBfcmVmLm1hc2tBbGxJbnB1dHMsIG1hc2tBbGxJbnB1dHMgPSBfcmVmX21hc2tBbGxJbnB1dHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9tYXNrQWxsSW5wdXRzLCBtYXNrVGV4dEZuID0gX3JlZi5tYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiA9IF9yZWYubWFza0lucHV0Rm4sIF9yZWZfc2xpbURPTSA9IF9yZWYuc2xpbURPTSwgc2xpbURPTSA9IF9yZWZfc2xpbURPTSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmX3NsaW1ET00sIGRhdGFVUkxPcHRpb25zID0gX3JlZi5kYXRhVVJMT3B0aW9ucywgcHJlc2VydmVXaGl0ZVNwYWNlID0gX3JlZi5wcmVzZXJ2ZVdoaXRlU3BhY2UsIG9uU2VyaWFsaXplID0gX3JlZi5vblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkID0gX3JlZi5vbklmcmFtZUxvYWQsIGlmcmFtZUxvYWRUaW1lb3V0ID0gX3JlZi5pZnJhbWVMb2FkVGltZW91dCwgb25TdHlsZXNoZWV0TG9hZCA9IF9yZWYub25TdHlsZXNoZWV0TG9hZCwgc3R5bGVzaGVldExvYWRUaW1lb3V0ID0gX3JlZi5zdHlsZXNoZWV0TG9hZFRpbWVvdXQsIF9yZWZfa2VlcElmcmFtZVNyY0ZuID0gX3JlZi5rZWVwSWZyYW1lU3JjRm4sIGtlZXBJZnJhbWVTcmNGbiA9IF9yZWZfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfcmVmX2tlZXBJZnJhbWVTcmNGbjtcbiAgICB2YXIgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICBkYXRlOiB0cnVlLFxuICAgICAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICBtb250aDogdHJ1ZSxcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICByYW5nZTogdHJ1ZSxcbiAgICAgICAgc2VhcmNoOiB0cnVlLFxuICAgICAgICB0ZWw6IHRydWUsXG4gICAgICAgIHRleHQ6IHRydWUsXG4gICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgIHVybDogdHJ1ZSxcbiAgICAgICAgd2VlazogdHJ1ZSxcbiAgICAgICAgdGV4dGFyZWE6IHRydWUsXG4gICAgICAgIHNlbGVjdDogdHJ1ZSxcbiAgICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICB9IDogbWFza0FsbElucHV0cyA9PT0gZmFsc2UgPyB7XG4gICAgICAgIHBhc3N3b3JkOiB0cnVlXG4gICAgfSA6IG1hc2tBbGxJbnB1dHM7XG4gICAgdmFyIHNsaW1ET01PcHRpb25zID0gc2xpbURPTSA9PT0gdHJ1ZSB8fCBzbGltRE9NID09PSBcImFsbFwiID8gLy8gaWYgdHJ1ZTogc2V0IG9mIHNlbnNpYmxlIG9wdGlvbnMgdGhhdCBzaG91bGQgbm90IHRocm93IGF3YXkgYW55IGluZm9ybWF0aW9uXG4gICAge1xuICAgICAgICBzY3JpcHQ6IHRydWUsXG4gICAgICAgIGNvbW1lbnQ6IHRydWUsXG4gICAgICAgIGhlYWRGYXZpY29uOiB0cnVlLFxuICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHNsaW1ET00gPT09IFwiYWxsXCIsXG4gICAgICAgIC8vIGRlc3RydWN0aXZlXG4gICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWVcbiAgICB9IDogc2xpbURPTSA9PT0gZmFsc2UgPyB7fSA6IHNsaW1ET007XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgZG9jOiBuMixcbiAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxuICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXG4gICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXG4gICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IG9uU3R5bGVzaGVldExvYWQsXG4gICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IGZhbHNlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHgyKSB7XG4gICAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZSQxKG4yKSB7XG4gICAgaWYgKG4yLl9fZXNNb2R1bGUpIHJldHVybiBuMjtcbiAgICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2YgZjIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZih0aGlzLCBhMjIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYyLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGEyLnByb3RvdHlwZSA9IGYyLnByb3RvdHlwZTtcbiAgICB9IGVsc2UgYTIgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobjIsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjJba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhMjtcbn1cbnZhciBwaWNvY29sb3JzX2Jyb3dzZXIkMSA9IHtcbiAgICBleHBvcnRzOiB7fVxufTtcbnZhciB4JDEgPSBTdHJpbmc7XG52YXIgY3JlYXRlJDEgPSBmdW5jdGlvbiBjcmVhdGUkMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0NvbG9yU3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgcmVzZXQ6IHgkMSxcbiAgICAgICAgYm9sZDogeCQxLFxuICAgICAgICBkaW06IHgkMSxcbiAgICAgICAgaXRhbGljOiB4JDEsXG4gICAgICAgIHVuZGVybGluZTogeCQxLFxuICAgICAgICBpbnZlcnNlOiB4JDEsXG4gICAgICAgIGhpZGRlbjogeCQxLFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiB4JDEsXG4gICAgICAgIGJsYWNrOiB4JDEsXG4gICAgICAgIHJlZDogeCQxLFxuICAgICAgICBncmVlbjogeCQxLFxuICAgICAgICB5ZWxsb3c6IHgkMSxcbiAgICAgICAgYmx1ZTogeCQxLFxuICAgICAgICBtYWdlbnRhOiB4JDEsXG4gICAgICAgIGN5YW46IHgkMSxcbiAgICAgICAgd2hpdGU6IHgkMSxcbiAgICAgICAgZ3JheTogeCQxLFxuICAgICAgICBiZ0JsYWNrOiB4JDEsXG4gICAgICAgIGJnUmVkOiB4JDEsXG4gICAgICAgIGJnR3JlZW46IHgkMSxcbiAgICAgICAgYmdZZWxsb3c6IHgkMSxcbiAgICAgICAgYmdCbHVlOiB4JDEsXG4gICAgICAgIGJnTWFnZW50YTogeCQxLFxuICAgICAgICBiZ0N5YW46IHgkMSxcbiAgICAgICAgYmdXaGl0ZTogeCQxXG4gICAgfTtcbn07XG5waWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzID0gY3JlYXRlJDEoKTtcbnBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHMuY3JlYXRlQ29sb3JzID0gY3JlYXRlJDE7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyQxID0gcGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cztcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMiA9IHt9O1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdDogX192aXRlQnJvd3NlckV4dGVybmFsJDJcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiBcIk1vZHVsZVwiXG59KSk7XG52YXIgcmVxdWlyZSQkMiQxID0gLyogQF9fUFVSRV9fICovIGdldEF1Z21lbnRlZE5hbWVzcGFjZSQxKF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxJDEpO1xudmFyIHBpY28kMSA9IHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMkMTtcbnZhciB0ZXJtaW5hbEhpZ2hsaWdodCQxJDEgPSByZXF1aXJlJCQyJDE7XG52YXIgQ3NzU3ludGF4RXJyb3IkMyQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihFcnJvcjEpIHtcbiAgICBfaW5oZXJpdHMoQ3NzU3ludGF4RXJyb3IsIEVycm9yMSk7XG4gICAgZnVuY3Rpb24gQ3NzU3ludGF4RXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBFcnJvcjEuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gXCJDc3NTeW50YXhFcnJvclwiO1xuICAgICAgICBfdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgX3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW4yMikge1xuICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb2x1bW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmRMaW5lID0gY29sdW1uLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kQ29sdW1uID0gY29sdW1uLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zZXRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIENzc1N5bnRheEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDc3NTeW50YXhFcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgXCI6IFwiIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBcIjpcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3dTb3VyY2VDb2RlID0gZnVuY3Rpb24gc2hvd1NvdXJjZUNvZGUoY29sb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljbyQxLmlzQ29sb3JTdXBwb3J0ZWQ7XG4gICAgICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCQxJDEpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcikgY3NzID0gdGVybWluYWxIaWdobGlnaHQkMSQxKGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4odGhpcy5saW5lICsgMiwgbGluZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgICAgICB2YXIgbWFyaywgYXNpZGU7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgdmFyIF9waWNvJDFfY3JlYXRlQ29sb3JzID0gcGljbyQxLmNyZWF0ZUNvbG9ycyh0cnVlKSwgYm9sZCA9IF9waWNvJDFfY3JlYXRlQ29sb3JzLmJvbGQsIGdyYXkgPSBfcGljbyQxX2NyZWF0ZUNvbG9ycy5ncmF5LCByZWQgPSBfcGljbyQxX2NyZWF0ZUNvbG9ycy5yZWQ7XG4gICAgICAgICAgICBtYXJrID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBib2xkKHJlZCh0ZXh0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXNpZGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXkodGV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFyayA9IGFzaWRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcChmdW5jdGlvbihsaW5lLCBpbmRleDIpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDI7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyID0gXCIgXCIgKyAoXCIgXCIgKyBudW1iZXIpLnNsaWNlKC1tYXhXaWR0aCkgKyBcIiB8IFwiO1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gX3RoaXMubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjaW5nID0gYXNpZGUoZ3V0dGVyLnJlcGxhY2UoL1xcZC9nLCBcIiBcIikpICsgbGluZS5zbGljZSgwLCBfdGhpcy5jb2x1bW4gLSAxKS5yZXBsYWNlKC9bXlxcdF0vZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrKFwiPlwiKSArIGFzaWRlKGd1dHRlcikgKyBsaW5lICsgXCJcXG4gXCIgKyBzcGFjaW5nICsgbWFyayhcIl5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCIgXCIgKyBhc2lkZShndXR0ZXIpICsgbGluZTtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuc2hvd1NvdXJjZUNvZGUoKTtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSBcIlxcblxcblwiICsgY29kZSArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIGNvZGU7XG4gICAgfTtcbiAgICByZXR1cm4gQ3NzU3ludGF4RXJyb3I7XG59KF93cmFwX25hdGl2ZV9zdXBlcihFcnJvcikpO1xudmFyIGNzc1N5bnRheEVycm9yJDEgPSBDc3NTeW50YXhFcnJvciQzJDE7XG5Dc3NTeW50YXhFcnJvciQzJDEuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDMkMTtcbnZhciBzeW1ib2xzJDEgPSB7fTtcbnN5bWJvbHMkMS5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMkMS5teSA9IFN5bWJvbChcIm15XCIpO1xudmFyIERFRkFVTFRfUkFXJDEgPSB7XG4gICAgYWZ0ZXI6IFwiXFxuXCIsXG4gICAgYmVmb3JlQ2xvc2U6IFwiXFxuXCIsXG4gICAgYmVmb3JlQ29tbWVudDogXCJcXG5cIixcbiAgICBiZWZvcmVEZWNsOiBcIlxcblwiLFxuICAgIGJlZm9yZU9wZW46IFwiIFwiLFxuICAgIGJlZm9yZVJ1bGU6IFwiXFxuXCIsXG4gICAgY29sb246IFwiOiBcIixcbiAgICBjb21tZW50TGVmdDogXCIgXCIsXG4gICAgY29tbWVudFJpZ2h0OiBcIiBcIixcbiAgICBlbXB0eUJvZHk6IFwiXCIsXG4gICAgaW5kZW50OiBcIiAgICBcIixcbiAgICBzZW1pY29sb246IGZhbHNlXG59O1xuZnVuY3Rpb24gY2FwaXRhbGl6ZSQxKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbnZhciBTdHJpbmdpZmllciQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ2lmaWVyKGJ1aWxkZXIpIHtcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0cmluZ2lmaWVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkBcIiArIG5vZGUyLm5hbWU7XG4gICAgICAgIHZhciBwYXJhbXMgPSBub2RlMi5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInBhcmFtc1wiKSA6IFwiXCI7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBuYW1lICs9IFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gKG5vZGUyLnJhd3MuYmV0d2VlbiB8fCBcIlwiKSArIChzZW1pY29sb24gPyBcIjtcIiA6IFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZUFmdGVyID0gZnVuY3Rpb24gYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNvbW1lbnRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgIHdoaWxlKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpe1xuICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiaW5kZW50XCIpO1xuICAgICAgICAgICAgaWYgKGluZGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKyl2YWx1ZSArPSBpbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLmJsb2NrID0gZnVuY3Rpb24gYmxvY2sobm9kZTIsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyBcIntcIiwgbm9kZTIsIFwic3RhcnRcIik7XG4gICAgICAgIHZhciBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIsIFwiZW1wdHlCb2R5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwifVwiLCBub2RlMiwgXCJlbmRcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uYm9keSA9IGZ1bmN0aW9uIGJvZHkobm9kZTIpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShsYXN0ID4gMCl7XG4gICAgICAgICAgICBpZiAobm9kZTIubm9kZXNbbGFzdF0udHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgbGFzdCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW1pY29sb24gPSB0aGlzLnJhdyhub2RlMiwgXCJzZW1pY29sb25cIik7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IG5vZGUyLm5vZGVzLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG5vZGUyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJhdyhub2RlMiwgXCJyaWdodFwiLCBcImNvbW1lbnRSaWdodFwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwiLypcIiArIGxlZnQgKyBub2RlMi50ZXh0ICsgcmlnaHQgKyBcIiovXCIsIG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImNvbG9uXCIpO1xuICAgICAgICB2YXIgc3RyaW5nID0gbm9kZTIucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInZhbHVlXCIpO1xuICAgICAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSBcIjtcIjtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvY3VtZW50ID0gZnVuY3Rpb24gZG9jdW1lbnQxKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBvd24sIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgICAgIGlmIChvd24pIHtcbiAgICAgICAgICAgIHZhbHVlID0gbm9kZTIucmF3c1tvd25dO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50eXBlID09PSBcInJvb3RcIiAmJiBwYXJlbnQuZmlyc3QgPT09IG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIERFRkFVTFRfUkFXJDFbZGV0ZWN0XTtcbiAgICAgICAgdmFyIHJvb3QyID0gbm9kZTIucm9vdCgpO1xuICAgICAgICBpZiAoIXJvb3QyLnJhd0NhY2hlKSByb290Mi5yYXdDYWNoZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIgfHwgZGV0ZWN0ID09PSBcImFmdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplJDEoZGV0ZWN0KTtcbiAgICAgICAgICAgIGlmICh0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNbbWV0aG9kXShyb290Miwgbm9kZTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3c1tvd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgdmFsdWUgPSBERUZBVUxUX1JBVyQxW2RldGVjdF07XG4gICAgICAgIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZUNsb3NlID0gZnVuY3Rpb24gcmF3QmVmb3JlQ2xvc2Uocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5hZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0NvbW1lbnRzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVEZWNsID0gZnVuY3Rpb24gcmF3QmVmb3JlRGVjbChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrRGVjbHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZU9wZW4gPSBmdW5jdGlvbiByYXdCZWZvcmVPcGVuKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZVJ1bGUgPSBmdW5jdGlvbiByYXdCZWZvcmVSdWxlKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIChpMi5wYXJlbnQgIT09IHJvb3QyIHx8IHJvb3QyLmZpcnN0ICE9PSBpMikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3Q29sb24gPSBmdW5jdGlvbiByYXdDb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJldHdlZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdFbXB0eUJvZHkgPSBmdW5jdGlvbiByYXdFbXB0eUJvZHkocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdJbmRlbnQgPSBmdW5jdGlvbiByYXdJbmRlbnQocm9vdDIpIHtcbiAgICAgICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgdmFyIHAgPSBpMi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocCAmJiBwICE9PSByb290MiAmJiBwLnBhcmVudCAmJiBwLnBhcmVudCA9PT0gcm9vdDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGkyLnJhd3MuYmVmb3JlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdTZW1pY29sb24gPSBmdW5jdGlvbiByYXdTZW1pY29sb24ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Muc2VtaWNvbG9uO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlKG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgICAgICB2YXIgcmF3ID0gbm9kZTIucmF3c1twcm9wXTtcbiAgICAgICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3LnJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3Qobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3MuYWZ0ZXIpIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLmFmdGVyKTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZShub2RlMikge1xuICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5vd25TZW1pY29sb24sIG5vZGUyLCBcImVuZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBBU1Qgbm9kZSB0eXBlIFwiICsgbm9kZTIudHlwZSArIFwiLiBNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tub2RlMi50eXBlXShub2RlMiwgc2VtaWNvbG9uKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdpZmllcjtcbn0oKTtcbnZhciBzdHJpbmdpZmllciQxID0gU3RyaW5naWZpZXIkMiQxO1xuU3RyaW5naWZpZXIkMiQxLmRlZmF1bHQgPSBTdHJpbmdpZmllciQyJDE7XG52YXIgU3RyaW5naWZpZXIkMSQxID0gc3RyaW5naWZpZXIkMTtcbmZ1bmN0aW9uIHN0cmluZ2lmeSQ0JDEobm9kZTIsIGJ1aWxkZXIpIHtcbiAgICB2YXIgc3RyID0gbmV3IFN0cmluZ2lmaWVyJDEkMShidWlsZGVyKTtcbiAgICBzdHIuc3RyaW5naWZ5KG5vZGUyKTtcbn1cbnZhciBzdHJpbmdpZnlfMSQxID0gc3RyaW5naWZ5JDQkMTtcbnN0cmluZ2lmeSQ0JDEuZGVmYXVsdCA9IHN0cmluZ2lmeSQ0JDE7XG52YXIgaXNDbGVhbiQyJDEgPSBzeW1ib2xzJDEuaXNDbGVhbiwgbXkkMiQxID0gc3ltYm9scyQxLm15O1xudmFyIENzc1N5bnRheEVycm9yJDIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG52YXIgU3RyaW5naWZpZXIyJDEgPSBzdHJpbmdpZmllciQxO1xudmFyIHN0cmluZ2lmeSQzJDEgPSBzdHJpbmdpZnlfMSQxO1xuZnVuY3Rpb24gY2xvbmVOb2RlJDEob2JqLCBwYXJlbnQpIHtcbiAgICB2YXIgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICAgIGZvcih2YXIgaTIgaW4gb2JqKXtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbaTJdO1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSk7XG4gICAgICAgIGlmIChpMiA9PT0gXCJwYXJlbnRcIiAmJiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50KSBjbG9uZWRbaTJdID0gcGFyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGkyID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZU5vZGUkMShqLCBjbG9uZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkgdmFsdWUgPSBjbG9uZU5vZGUkMSh2YWx1ZSk7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbnZhciBOb2RlJDQkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9kZTIoZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzID09PSB2b2lkIDApIGRlZmF1bHRzID0ge307XG4gICAgICAgIHRoaXMucmF3cyA9IHt9O1xuICAgICAgICB0aGlzW2lzQ2xlYW4kMiQxXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW215JDIkMV0gPSB0cnVlO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gZGVmYXVsdHMpe1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShkZWZhdWx0c1tuYW1lXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZTIuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9kZTIucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRUb0Vycm9yID0gZnVuY3Rpb24gYWRkVG9FcnJvcihlcnJvcikge1xuICAgICAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgICAgIGlmIChlcnJvci5zdGFjayAmJiB0aGlzLnNvdXJjZSAmJiAvXFxuXFxzezR9YXQgLy50ZXN0KGVycm9yLnN0YWNrKSkge1xuICAgICAgICAgICAgdmFyIHMyID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xcblxcc3s0fWF0IC8sIFwiJCZcIiArIHMyLmlucHV0LmZyb20gKyBcIjpcIiArIHMyLnN0YXJ0LmxpbmUgKyBcIjpcIiArIHMyLnN0YXJ0LmNvbHVtbiArIFwiJCZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLmFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoYWRkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICAgICAgaWYgKCFrZWVwQmV0d2VlbikgZGVsZXRlIHRoaXMucmF3cy5iZXR3ZWVuO1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUkMSh0aGlzKTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUFmdGVyID0gZnVuY3Rpb24gY2xvbmVBZnRlcihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUJlZm9yZSA9IGZ1bmN0aW9uIGNsb25lQmVmb3JlKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpc19yYW5nZUJ5ID0gdGhpcy5yYW5nZUJ5KG9wdHMpLCBlbmQgPSBfdGhpc19yYW5nZUJ5LmVuZCwgc3RhcnQgPSBfdGhpc19yYW5nZUJ5LnN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZC5saW5lXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIkMShtZXNzYWdlKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRQcm94eVByb2Nlc3NvciA9IGZ1bmN0aW9uIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTJbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3BcIiB8fCBwcm9wID09PSBcInZhbHVlXCIgfHwgcHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcImltcG9ydGFudFwiIHx8IC8qIGM4IGlnbm9yZSBuZXh0ICovIHByb3AgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5tYXJrRGlydHkgPSBmdW5jdGlvbiBtYXJrRGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzW2lzQ2xlYW4kMiQxXSkge1xuICAgICAgICAgICAgdGhpc1tpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlKG5leHQgPSBuZXh0LnBhcmVudCl7XG4gICAgICAgICAgICAgICAgbmV4dFtpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgKyAxXTtcbiAgICB9O1xuICAgIF9wcm90by5wb3NpdGlvbkJ5ID0gZnVuY3Rpb24gcG9zaXRpb25CeShvcHRzLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zb3VyY2Uuc3RhcnQ7XG4gICAgICAgIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSBwb3MgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBfcHJvdG8ucG9zaXRpb25JbnNpZGUgPSBmdW5jdGlvbiBwb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBzdHJpbmdSZXByZXNlbnRhdGlvbiB8fCB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgaW5kZXgyOyBpMisrKXtcbiAgICAgICAgICAgIGlmIChzdHJpbmdbaTJdID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyIC0gMV07XG4gICAgfTtcbiAgICBfcHJvdG8ucmFuZ2VCeSA9IGZ1bmN0aW9uIHJhbmdlQnkob3B0cykge1xuICAgICAgICB2YXIgc3RhcnQgPSB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuc291cmNlLnN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuc291cmNlLmVuZCA/IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDEsXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnNvdXJjZS5lbmQubGluZVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy53b3JkKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIgKyBvcHRzLndvcmQubGVuZ3RoLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG9wdHMuc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBvcHRzLnN0YXJ0LmxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZW5kKSB7XG4gICAgICAgICAgICAgICAgZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG9wdHMuZW5kLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogb3B0cy5lbmQubGluZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmVuZEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHwgZW5kLmxpbmUgPT09IHN0YXJ0LmxpbmUgJiYgZW5kLmNvbHVtbiA8PSBzdGFydC5jb2x1bW4pIHtcbiAgICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcocHJvcCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgdmFyIHN0ciA9IG5ldyBTdHJpbmdpZmllcjIkMSgpO1xuICAgICAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBub2RlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgYm9va21hcmsgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgYm9va21hcmsgPSBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kU2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gdGhpcztcbiAgICAgICAgd2hpbGUocmVzdWx0Mi5wYXJlbnQgJiYgcmVzdWx0Mi5wYXJlbnQudHlwZSAhPT0gXCJkb2N1bWVudFwiKXtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgICAgIHZhciBmaXhlZCA9IHt9O1xuICAgICAgICB2YXIgZW1pdElucHV0cyA9IGlucHV0cyA9PSBudWxsO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzKXtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJwYXJlbnRcIiB8fCBuYW1lID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNOZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dElkOiBpbnB1dElkLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICAgICAgICBmaXhlZC5pbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzLmtleXMoKSkubWFwKGZ1bmN0aW9uKGlucHV0Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDIudG9KU09OKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8udG9Qcm94eSA9IGZ1bmN0aW9uIHRvUHJveHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZpZXIyKSB7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIgPT09IHZvaWQgMCkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDMkMTtcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVyMi5zdHJpbmdpZnkpIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmaWVyMi5zdHJpbmdpZnk7XG4gICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgc3RyaW5naWZpZXIyKHRoaXMsIGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybiA9IGZ1bmN0aW9uIHdhcm4ocmVzdWx0MiwgdGV4dCwgb3B0cykge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBpMiBpbiBvcHRzKWRhdGFbaTJdID0gb3B0c1tpMl07XG4gICAgICAgIHJldHVybiByZXN1bHQyLndhcm4odGV4dCwgZGF0YSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKE5vZGUyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm94eU9mXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBOb2RlMjtcbn0oKTtcbnZhciBub2RlJDEgPSBOb2RlJDQkMTtcbk5vZGUkNCQxLmRlZmF1bHQgPSBOb2RlJDQkMTtcbnZhciBOb2RlJDMkMSA9IG5vZGUkMTtcbnZhciBEZWNsYXJhdGlvbiQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMyQxKSB7XG4gICAgX2luaGVyaXRzKERlY2xhcmF0aW9uLCBOb2RlJDMkMSk7XG4gICAgZnVuY3Rpb24gRGVjbGFyYXRpb24oZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBOb2RlJDMkMS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJkZWNsXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhEZWNsYXJhdGlvbiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRGVjbGFyYXRpb247XG59KE5vZGUkMyQxKTtcbnZhciBkZWNsYXJhdGlvbiQxID0gRGVjbGFyYXRpb24kNCQxO1xuRGVjbGFyYXRpb24kNCQxLmRlZmF1bHQgPSBEZWNsYXJhdGlvbiQ0JDE7XG52YXIgdXJsQWxwaGFiZXQkMSA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xudmFyIG5hbm9pZCQxJDEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgc2l6ZSA9IDIxO1xuICAgIHZhciBpZCA9IFwiXCI7XG4gICAgdmFyIGkyID0gc2l6ZTtcbiAgICB3aGlsZShpMi0tKXtcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXQkMVtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUkMSA9IHtcbiAgICBuYW5vaWQ6IG5hbm9pZCQxJDF9O1xudmFyIFNvdXJjZU1hcENvbnN1bWVyJDIkMSA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDIkMSA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZXhpc3RzU3luYyQxID0gcmVxdWlyZSQkMiQxLmV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyQxID0gcmVxdWlyZSQkMiQxLnJlYWRGaWxlU3luYztcbnZhciBkaXJuYW1lJDEkMSA9IHJlcXVpcmUkJDIkMS5kaXJuYW1lLCBqb2luJDEgPSByZXF1aXJlJCQyJDEuam9pbjtcbmZ1bmN0aW9uIGZyb21CYXNlNjQkMShzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cik7XG4gICAgfVxufVxudmFyIFByZXZpb3VzTWFwJDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJldmlvdXNNYXAoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1hcCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2FkQW5ub3RhdGlvbihjc3MpO1xuICAgICAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgXCJkYXRhOlwiKTtcbiAgICAgICAgdmFyIHByZXYgPSBvcHRzLm1hcCA/IG9wdHMubWFwLnByZXYgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5sb2FkTWFwKG9wdHMuZnJvbSwgcHJldik7XG4gICAgICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcEZpbGUpIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHRoaXMubWFwRmlsZSk7XG4gICAgICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJldmlvdXNNYXAucHJvdG90eXBlO1xuICAgIF9wcm90by5jb25zdW1lciA9IGZ1bmN0aW9uIGNvbnN1bWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIkMSh0aGlzLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVyQ2FjaGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjb2RlSW5saW5lID0gZnVuY3Rpb24gZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICAgICAgdmFyIGJhc2VDaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/ODtiYXNlNjQsLztcbiAgICAgICAgdmFyIGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvO1xuICAgICAgICB2YXIgY2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzgsLztcbiAgICAgICAgdmFyIHVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb24sLztcbiAgICAgICAgaWYgKGNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCB1cmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IGJhc2VVcmkudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21CYXNlNjQkMSh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QW5ub3RhdGlvblVSTCA9IGZ1bmN0aW9uIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgXCJcIikudHJpbSgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAobWFwKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG1hcCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihtYXApKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFwLl9tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KG1hcC5zZWN0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEFubm90YXRpb24gPSBmdW5jdGlvbiBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gY3NzLm1hdGNoKC9cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS9nbSk7XG4gICAgICAgIGlmICghY29tbWVudHMpIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICAgICAgdmFyIGVuZCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uVVJMKGNzcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEZpbGUgPSBmdW5jdGlvbiBsb2FkRmlsZShwYXRoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMSQxKHBhdGgpO1xuICAgICAgICBpZiAoZXhpc3RzU3luYyQxKHBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyQxKHBhdGgsIFwidXRmLThcIikudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkTWFwID0gZnVuY3Rpb24gbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBDb25zdW1lciQyJDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEuZnJvbVNvdXJjZU1hcChwcmV2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiBcIiArIHByZXYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG1hcDEgPSB0aGlzLmFubm90YXRpb247XG4gICAgICAgICAgICBpZiAoZmlsZSkgbWFwMSA9IGpvaW4kMShkaXJuYW1lJDEkMShmaWxlKSwgbWFwMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uIHN0YXJ0V2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gICAgICAgIGlmICghc3RyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT09IHN0YXJ0O1xuICAgIH07XG4gICAgX3Byb3RvLndpdGhDb250ZW50ID0gZnVuY3Rpb24gd2l0aENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQgJiYgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXZpb3VzTWFwO1xufSgpO1xudmFyIHByZXZpb3VzTWFwJDEgPSBQcmV2aW91c01hcCQyJDE7XG5QcmV2aW91c01hcCQyJDEuZGVmYXVsdCA9IFByZXZpb3VzTWFwJDIkMTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQxJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQxJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGZpbGVVUkxUb1BhdGgkMSA9IHJlcXVpcmUkJDIkMS5maWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMJDEkMSA9IHJlcXVpcmUkJDIkMS5wYXRoVG9GaWxlVVJMO1xudmFyIGlzQWJzb2x1dGUkMSA9IHJlcXVpcmUkJDIkMS5pc0Fic29sdXRlLCByZXNvbHZlJDEkMSA9IHJlcXVpcmUkJDIkMS5yZXNvbHZlO1xudmFyIG5hbm9pZCQyID0gbm9uU2VjdXJlJDEubmFub2lkO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0JDIgPSByZXF1aXJlJCQyJDE7XG52YXIgQ3NzU3ludGF4RXJyb3IkMSQxID0gY3NzU3ludGF4RXJyb3IkMTtcbnZhciBQcmV2aW91c01hcCQxJDEgPSBwcmV2aW91c01hcCQxO1xudmFyIGZyb21PZmZzZXRDYWNoZSQxID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyJDEkMSAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxKTtcbnZhciBwYXRoQXZhaWxhYmxlJDEkMSA9IEJvb2xlYW4ocmVzb2x2ZSQxJDEgJiYgaXNBYnNvbHV0ZSQxKTtcbnZhciBJbnB1dCQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElucHV0KGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmIChjc3MgPT09IG51bGwgfHwgdHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0Q1NTIHJlY2VpdmVkIFwiICsgY3NzICsgXCIgaW5zdGVhZCBvZiBDU1Mgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUkMShvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gb3B0cy5mcm9tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSByZXNvbHZlJDEkMShvcHRzLmZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlJDEkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSQxKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IFByZXZpb3VzTWFwJDEkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICAgICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCI8aW5wdXQgY3NzIFwiICsgbmFub2lkJDIoNikgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJbnB1dC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIHJlc3VsdDIsIGVuZExpbmUsIGVuZENvbHVtbjtcbiAgICAgICAgaWYgKGxpbmUgJiYgKHR5cGVvZiBsaW5lID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGxpbmUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGluZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjb2x1bW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5lID0gcG9zLmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gcG9zLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvczEgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IHBvczEubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBwb3MxLmNvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lO1xuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdmFyIHBvczIgPSB0aGlzLmZyb21PZmZzZXQobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gcG9zMi5saW5lO1xuICAgICAgICAgICAgY29sdW1uID0gcG9zMi5jb2w7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luKGxpbmUsIGNvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEobWVzc2FnZSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5saW5lIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4ubGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5jb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbi5lbmRMaW5lXG4gICAgICAgICAgICB9LCBvcmlnaW4uc291cmNlLCBvcmlnaW4uZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxJDEobWVzc2FnZSwgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICB9LCBlbmRMaW5lID09PSB2b2lkIDAgPyBjb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSwgdGhpcy5jc3MsIHRoaXMuZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdDIuaW5wdXQgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZSxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuY3NzXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDEkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQudXJsID0gcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5maWxlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dC5maWxlID0gdGhpcy5maWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmZyb21PZmZzZXQgPSBmdW5jdGlvbiBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2YXIgbGFzdExpbmUsIGxpbmVUb0luZGV4O1xuICAgICAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlJDFdKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSAwLCBsMiA9IGxpbmVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKyl7XG4gICAgICAgICAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCArPSBsaW5lc1tpMl0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbZnJvbU9mZnNldENhY2hlJDFdID0gbGluZVRvSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlJDFdO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMaW5lID0gbGluZVRvSW5kZXhbbGluZVRvSW5kZXgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICBpZiAob2Zmc2V0ID49IGxhc3RMaW5lKSB7XG4gICAgICAgICAgICBtaW4gPSBsaW5lVG9JbmRleC5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgICB2YXIgbWlkO1xuICAgICAgICAgICAgd2hpbGUobWluIDwgbWF4KXtcbiAgICAgICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPj0gbGluZVRvSW5kZXhbbWlkICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sOiBvZmZzZXQgLSBsaW5lVG9JbmRleFttaW5dICsgMSxcbiAgICAgICAgICAgIGxpbmU6IG1pbiArIDFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5tYXBSZXNvbHZlID0gZnVuY3Rpb24gbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSQxJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9yaWdpbiA9IGZ1bmN0aW9uIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHRoaXMubWFwLmNvbnN1bWVyKCk7XG4gICAgICAgIHZhciBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZnJvbS5zb3VyY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHRvO1xuICAgICAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21Vcmw7XG4gICAgICAgIGlmIChpc0Fic29sdXRlJDEoZnJvbS5zb3VyY2UpKSB7XG4gICAgICAgICAgICBmcm9tVXJsID0gcGF0aFRvRmlsZVVSTCQxJDEoZnJvbS5zb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVVybCA9IG5ldyBVUkwoZnJvbS5zb3VyY2UsIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEkMSh0aGlzLm1hcC5tYXBGaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDIgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICAgICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIikge1xuICAgICAgICAgICAgaWYgKGZpbGVVUkxUb1BhdGgkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIuZmlsZSA9IGZpbGVVUkxUb1BhdGgkMShmcm9tVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsZTogcHJvdG9jb2wgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IGNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlKSByZXN1bHQyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICBmb3IodmFyIF9pID0gMCwgX2l0ZXIgPSBbXG4gICAgICAgICAgICBcImhhc0JPTVwiLFxuICAgICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICAgIFwiZmlsZVwiLFxuICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgIF07IF9pIDwgX2l0ZXIubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2l0ZXJbX2ldO1xuICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGpzb25bbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAganNvbi5tYXAgPSBfZXh0ZW5kcyh7fSwgdGhpcy5tYXApO1xuICAgICAgICAgICAgaWYgKGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhJbnB1dCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSB8fCB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIElucHV0O1xufSgpO1xudmFyIGlucHV0JDEgPSBJbnB1dCQ0JDE7XG5JbnB1dCQ0JDEuZGVmYXVsdCA9IElucHV0JDQkMTtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCQyICYmIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dCkge1xuICAgIHRlcm1pbmFsSGlnaGxpZ2h0JDIucmVnaXN0ZXJJbnB1dChJbnB1dCQ0JDEpO1xufVxudmFyIFNvdXJjZU1hcENvbnN1bWVyJDMgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQzID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBkaXJuYW1lJDIgPSByZXF1aXJlJCQyJDEuZGlybmFtZSwgcmVsYXRpdmUkMSA9IHJlcXVpcmUkJDIkMS5yZWxhdGl2ZSwgcmVzb2x2ZSQyID0gcmVxdWlyZSQkMiQxLnJlc29sdmUsIHNlcCQxID0gcmVxdWlyZSQkMiQxLnNlcDtcbnZhciBwYXRoVG9GaWxlVVJMJDIgPSByZXF1aXJlJCQyJDEucGF0aFRvRmlsZVVSTDtcbnZhciBJbnB1dCQzJDEgPSBpbnB1dCQxO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQyID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQzICYmIFNvdXJjZU1hcEdlbmVyYXRvciQzKTtcbnZhciBwYXRoQXZhaWxhYmxlJDIgPSBCb29sZWFuKGRpcm5hbWUkMiAmJiByZXNvbHZlJDIgJiYgcmVsYXRpdmUkMSAmJiBzZXAkMSk7XG52YXIgTWFwR2VuZXJhdG9yJDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFwR2VuZXJhdG9yKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgICAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1hcEdlbmVyYXRvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZEFubm90YXRpb24gPSBmdW5jdGlvbiBhZGRBbm5vdGF0aW9uKCkge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgY29udGVudCA9IFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbih0aGlzLm9wdHMudG8sIHRoaXMucm9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5vdXRwdXRGaWxlKCkgKyBcIi5tYXBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW9sID0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHRoaXMuY3NzLmluY2x1ZGVzKFwiXFxyXFxuXCIpKSBlb2wgPSBcIlxcclxcblwiO1xuICAgICAgICB0aGlzLmNzcyArPSBlb2wgKyBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY29udGVudCArIFwiICovXCI7XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwbHlQcmV2TWFwcyA9IGZ1bmN0aW9uIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJldmlvdXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMudG9VcmwodGhpcy5wYXRoKHByZXYuZmlsZSkpO1xuICAgICAgICAgICAgdmFyIHJvb3QyID0gcHJldi5yb290IHx8IGRpcm5hbWUkMihwcmV2LmZpbGUpO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDMocHJldi50ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJBbm5vdGF0aW9uID0gZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHZhciBub2RlMjtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnRleHQuaW5kZXhPZihcIiMgc291cmNlTWFwcGluZ1VSTD1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUkMiAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMiAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByZXN1bHQyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGVNYXAgPSBmdW5jdGlvbiBnZW5lcmF0ZU1hcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVN0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKCk7XG4gICAgICAgICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwID0gU291cmNlTWFwR2VuZXJhdG9yJDMuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU291cmNlc0NvbnRlbnQoKSkgdGhpcy5zZXRTb3VyY2VzQ29udGVudCgpO1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwKSB0aGlzLmFwcGx5UHJldk1hcHMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNBbm5vdGF0aW9uKCkpIHRoaXMuYWRkQW5ub3RhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gZ2VuZXJhdGVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3NzID0gXCJcIjtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yJDMoe1xuICAgICAgICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgdmFyIG5vU291cmNlID0gXCI8bm8gc291cmNlPlwiO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgbGluZXMsIGxhc3Q7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgZnVuY3Rpb24oc3RyLCBub2RlMiwgdHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuY3NzICs9IHN0cjtcbiAgICAgICAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2Uuc3RhcnQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHN0ci5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBub2RlMi5wYXJlbnQgfHwge1xuICAgICAgICAgICAgICAgICAgICByYXdzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkbGVzcyA9IG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgIW5vZGUyLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRsZXNzIHx8IG5vZGUyICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gX3RoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNBbm5vdGF0aW9uID0gZnVuY3Rpb24gaXNBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNJbmxpbmUgPSBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgYW5ub3RhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuaW5saW5lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNNYXAgPSBmdW5jdGlvbiBpc01hcCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIF9wcm90by5pc1NvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gaXNTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi53aXRoQ29udGVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8ub3V0cHV0RmlsZSA9IGZ1bmN0aW9uIG91dHB1dEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudG8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLnRvKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhdGggPSBmdW5jdGlvbiBwYXRoKGZpbGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmIChmaWxlLmNoYXJDb2RlQXQoMCkgPT09IDYwKSByZXR1cm4gZmlsZTtcbiAgICAgICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlO1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lJDIodGhpcy5vcHRzLnRvKSA6IFwiLlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcm9tID0gZGlybmFtZSQyKHJlc29sdmUkMihmcm9tLCB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gcmVsYXRpdmUkMShmcm9tLCBmaWxlKTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Qud2FsayhmdW5jdGlvbihub2RlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBub2RlMi5zb3VyY2UuaW5wdXQubWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQzJDEodGhpcy5vcmlnaW5hbENTUywgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFscmVhZHkgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tVXJsID0gX3RoaXMudXNlc0ZpbGVVcmxzID8gX3RoaXMudG9GaWxlVXJsKGZyb20pIDogX3RoaXMudG9VcmwoX3RoaXMucGF0aChmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc291cmNlUGF0aCA9IGZ1bmN0aW9uIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvQmFzZTY0ID0gZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0ZpbGVVcmwgPSBmdW5jdGlvbiB0b0ZpbGVVcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwkMikge1xuICAgICAgICAgICAgdmFyIGZpbGVVUkwgPSBwYXRoVG9GaWxlVVJMJDIocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvVXJsID0gZnVuY3Rpb24gdG9VcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFVSTHMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBpZiAoc2VwJDEgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwR2VuZXJhdG9yO1xufSgpO1xudmFyIG1hcEdlbmVyYXRvciQxID0gTWFwR2VuZXJhdG9yJDIkMTtcbnZhciBOb2RlJDIkMSA9IG5vZGUkMTtcbnZhciBDb21tZW50JDQkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQyJDEpIHtcbiAgICBfaW5oZXJpdHMoQ29tbWVudCwgTm9kZSQyJDEpO1xuICAgIGZ1bmN0aW9uIENvbW1lbnQoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IE5vZGUkMiQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tbWVudDtcbn0oTm9kZSQyJDEpO1xudmFyIGNvbW1lbnQkMSA9IENvbW1lbnQkNCQxO1xuQ29tbWVudCQ0JDEuZGVmYXVsdCA9IENvbW1lbnQkNCQxO1xudmFyIGlzQ2xlYW4kMSQxID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDEkMSA9IHN5bWJvbHMkMS5teTtcbnZhciBEZWNsYXJhdGlvbiQzJDEgPSBkZWNsYXJhdGlvbiQxO1xudmFyIENvbW1lbnQkMyQxID0gY29tbWVudCQxO1xudmFyIE5vZGUkMSQxID0gbm9kZSQxO1xudmFyIHBhcnNlJDQkMSwgUnVsZSQ0JDEsIEF0UnVsZSQ0JDEsIFJvb3QkNiQxO1xuZnVuY3Rpb24gY2xlYW5Tb3VyY2UkMShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlJDEoaTIubm9kZXMpO1xuICAgICAgICBkZWxldGUgaTIuc291cmNlO1xuICAgICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcCQxKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbiQxJDFdID0gZmFsc2U7XG4gICAgaWYgKG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZTIucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbWFya0RpcnR5VXAkMShpMik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgQ29udGFpbmVyJDckMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQxJDEpIHtcbiAgICBfaW5oZXJpdHMoQ29udGFpbmVyLCBOb2RlJDEkMSk7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gTm9kZSQxJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ29udGFpbmVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIE5vZGUkMSQxLnByb3RvdHlwZS5jbGVhblJhd3MuY2FsbCh0aGlzLCBrZWVwQmV0d2Vlbik7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIG5vZGUyLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB2YXIgaW5kZXgyLCByZXN1bHQyO1xuICAgICAgICB3aGlsZSh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleDJdLCBpbmRleDIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiBldmVyeShjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHRoaXMubGFzdEVhY2ggPSAwO1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgICAgIHRoaXMubGFzdEVhY2ggKz0gMTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaDtcbiAgICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRQcm94eVByb2Nlc3NvciA9IGZ1bmN0aW9uIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUyW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZWFjaFwiIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiICYmIHByb3Auc3RhcnRzV2l0aChcIndhbGtcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfbm9kZTIgPSBub2RlMilbcHJvcF0uYXBwbHkoX25vZGUyLCBbXS5jb25jYXQoYXJncy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImV2ZXJ5XCIgfHwgcHJvcCA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvdGhlciA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC50b1Byb3h5KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBvdGhlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIubm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZmlyc3RcIiB8fCBwcm9wID09PSBcImxhc3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0udG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluZGV4ID0gZnVuY3Rpb24gaW5kZXgoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGQucHJveHlPZikgY2hpbGQgPSBjaGlsZC5wcm94eU9mO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXggKyAxLCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyBcInByZXBlbmRcIiA6IGZhbHNlO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0SW5kZXggPD0gaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBub2RlcyA9IGNsZWFuU291cmNlJDEocGFyc2UkNCQxKG5vZGVzKS5ub2Rlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyLCBcImlnbm9yZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy50eXBlID09PSBcInJvb3RcIiAmJiB0aGlzLnR5cGUgIT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgaTIxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMjEucGFyZW50KSBpMjEucGFyZW50LnJlbW92ZUNoaWxkKGkyMSwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMucHJvcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy52YWx1ZSA9IFN0cmluZyhub2Rlcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24kMyQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFJ1bGUkNCQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQXRSdWxlJDQkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IENvbW1lbnQkMyQxKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IG5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKCFpMltteSQxJDFdKSBDb250YWluZXIucmVidWlsZChpMik7XG4gICAgICAgICAgICBpMiA9IGkyLnByb3h5T2Y7XG4gICAgICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIpO1xuICAgICAgICAgICAgaWYgKGkyW2lzQ2xlYW4kMSQxXSkgbWFya0RpcnR5VXAkMShpMik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpMi5wYXJlbnQgPSBfdGhpcy5wcm94eU9mO1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShjaGlsZHJlbiksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsIFwicHJlcGVuZFwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChjaGlsZCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBub2RlMi5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VWYWx1ZXMgPSBmdW5jdGlvbiByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm47XG4gICAgICAgICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVybjtcbiAgICAgICAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrID0gZnVuY3Rpb24gd2FsayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtBdFJ1bGVzID0gZnVuY3Rpb24gd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YobmFtZSwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0NvbW1lbnRzID0gZnVuY3Rpb24gd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0RlY2xzID0gZnVuY3Rpb24gd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihwcm9wLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtSdWxlcyA9IGZ1bmN0aW9uIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihzZWxlY3RvciwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKENvbnRhaW5lciwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZmlyc3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsYXN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzW3RoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBDb250YWluZXI7XG59KE5vZGUkMSQxKTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJQYXJzZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBhcnNlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJBdFJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBBdFJ1bGUkNCQxID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3JDEucmVnaXN0ZXJSb290ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUm9vdCQ2JDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGNvbnRhaW5lciQxID0gQ29udGFpbmVyJDckMTtcbkNvbnRhaW5lciQ3JDEuZGVmYXVsdCA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLnJlYnVpbGQgPSBmdW5jdGlvbihub2RlMikge1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQXRSdWxlJDQkMS5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSdWxlJDQkMS5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzJDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgQ29tbWVudCQzJDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUm9vdCQ2JDEucHJvdG90eXBlKTtcbiAgICB9XG4gICAgbm9kZTJbbXkkMSQxXSA9IHRydWU7XG4gICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIENvbnRhaW5lciQ3JDEucmVidWlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgQ29udGFpbmVyJDYkMSA9IGNvbnRhaW5lciQxO1xudmFyIExhenlSZXN1bHQkNCQxLCBQcm9jZXNzb3IkMyQxO1xudmFyIERvY3VtZW50JDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDYkMSkge1xuICAgIF9pbmhlcml0cyhEb2N1bWVudDIsIENvbnRhaW5lciQ2JDEpO1xuICAgIGZ1bmN0aW9uIERvY3VtZW50MihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDYkMS5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9jdW1lbnRcIlxuICAgICAgICB9LCBkZWZhdWx0cykpIHx8IHRoaXM7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG9jdW1lbnQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQ0JDEobmV3IFByb2Nlc3NvciQzJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50Mjtcbn0oQ29udGFpbmVyJDYkMSk7XG5Eb2N1bWVudCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyUHJvY2Vzc29yID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUHJvY2Vzc29yJDMkMSA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSQxID0gRG9jdW1lbnQkMyQxO1xuRG9jdW1lbnQkMyQxLmRlZmF1bHQgPSBEb2N1bWVudCQzJDE7XG52YXIgcHJpbnRlZCQxID0ge307XG52YXIgd2Fybk9uY2UkMiQxID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmIChwcmludGVkJDFbbWVzc2FnZV0pIHJldHVybjtcbiAgICBwcmludGVkJDFbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbn07XG52YXIgV2FybmluZyQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdhcm5pbmcodGV4dCwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHRoaXMudHlwZSA9IFwid2FybmluZ1wiO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5saW5lID0gcmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmU7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBvcHQgaW4gb3B0cyl0aGlzW29wdF0gPSBvcHRzW29wdF07XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBXYXJuaW5nLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICAgICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgICAgICAgfSkubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArIFwiOiBcIiArIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFdhcm5pbmc7XG59KCk7XG52YXIgd2FybmluZyQxID0gV2FybmluZyQyJDE7XG5XYXJuaW5nJDIkMS5kZWZhdWx0ID0gV2FybmluZyQyJDE7XG52YXIgV2FybmluZyQxJDEgPSB3YXJuaW5nJDE7XG52YXIgUmVzdWx0JDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVzdWx0KHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbHVnaW4gPSB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmluZzIgPSBuZXcgV2FybmluZyQxJDEodGV4dCwgb3B0cyk7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaCh3YXJuaW5nMik7XG4gICAgICAgIHJldHVybiB3YXJuaW5nMjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMi50eXBlID09PSBcIndhcm5pbmdcIjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKFJlc3VsdCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcbnZhciByZXN1bHQkMSA9IFJlc3VsdCQzJDE7XG5SZXN1bHQkMyQxLmRlZmF1bHQgPSBSZXN1bHQkMyQxO1xudmFyIFNJTkdMRV9RVU9URSQxID0gXCInXCIuY2hhckNvZGVBdCgwKTtcbnZhciBET1VCTEVfUVVPVEUkMSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbnZhciBCQUNLU0xBU0gkMSA9IFwiXFxcXFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0xBU0gkMSA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgTkVXTElORSQxID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xudmFyIFNQQUNFJDEgPSBcIiBcIi5jaGFyQ29kZUF0KDApO1xudmFyIEZFRUQkMSA9IFwiXFxmXCIuY2hhckNvZGVBdCgwKTtcbnZhciBUQUIkMSA9IFwiXHRcIi5jaGFyQ29kZUF0KDApO1xudmFyIENSJDEgPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9TUVVBUkUkMSA9IFwiW1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfU1FVQVJFJDEgPSBcIl1cIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fUEFSRU5USEVTRVMkMSA9IFwiKFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfUEFSRU5USEVTRVMkMSA9IFwiKVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9DVVJMWSQxID0gXCJ7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9DVVJMWSQxID0gXCJ9XCIuY2hhckNvZGVBdCgwKTtcbnZhciBTRU1JQ09MT04kMSA9IFwiO1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVNURVJJU0skMSA9IFwiKlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ09MT04kMSA9IFwiOlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVQkMSA9IFwiQFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgUkVfQVRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2c7XG52YXIgUkVfV09SRF9FTkQkMSA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2c7XG52YXIgUkVfQkFEX0JSQUNLRVQkMSA9IC8uW1xcclxcblwiJygvXFxcXF0vO1xudmFyIFJFX0hFWF9FU0NBUEUkMSA9IC9bXFxkYS1mXS9pO1xudmFyIHRva2VuaXplJDEgPSBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgICB2YXIgaWdub3JlID0gb3B0aW9ucy5pZ25vcmVFcnJvcnM7XG4gICAgdmFyIGNvZGUsIG5leHQsIHF1b3RlLCBjb250ZW50LCBlc2NhcGU7XG4gICAgdmFyIGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgICB2YXIgbGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIHJldHVybmVkID0gW107XG4gICAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICAgICAgdGhyb3cgaW5wdXQyLmVycm9yKFwiVW5jbG9zZWQgXCIgKyB3aGF0LCBwb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRPZkZpbGUoKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpIHtcbiAgICAgICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpO1xuICAgICAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB2YXIgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlO1xuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgICAgY2FzZSBORVdMSU5FJDE6XG4gICAgICAgICAgICBjYXNlIFNQQUNFJDE6XG4gICAgICAgICAgICBjYXNlIFRBQiQxOlxuICAgICAgICAgICAgY2FzZSBDUiQxOlxuICAgICAgICAgICAgY2FzZSBGRUVEJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoY29kZSA9PT0gU1BBQ0UkMSB8fCBjb2RlID09PSBORVdMSU5FJDEgfHwgY29kZSA9PT0gVEFCJDEgfHwgY29kZSA9PT0gQ1IkMSB8fCBjb2RlID09PSBGRUVEJDEpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRSQxOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9TUVVBUkUkMTpcbiAgICAgICAgICAgIGNhc2UgT1BFTl9DVVJMWSQxOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWSQxOlxuICAgICAgICAgICAgY2FzZSBDT0xPTiQxOlxuICAgICAgICAgICAgY2FzZSBTRU1JQ09MT04kMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVMkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbENoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1BBUkVOVEhFU0VTJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUkMSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFJDEgJiYgbjIgIT09IFNQQUNFJDEgJiYgbjIgIT09IE5FV0xJTkUkMSAmJiBuMiAhPT0gVEFCJDEgJiYgbjIgIT09IEZFRUQkMSAmJiBuMiAhPT0gQ1IkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfXdoaWxlIChlc2NhcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xIHx8IFJFX0JBRF9CUkFDS0VUJDEudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhY2tldHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU0lOR0xFX1FVT1RFJDE6XG4gICAgICAgICAgICBjYXNlIERPVUJMRV9RVU9URSQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBjb2RlID09PSBTSU5HTEVfUVVPVEUkMSA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCQxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQVQkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORCQxLmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORCQxLnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0FUX0VORCQxLmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IFJFX0FUX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdC13b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQkFDS1NMQVNIJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCQxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZSAmJiBjb2RlICE9PSBTTEFTSCQxICYmIGNvZGUgIT09IFNQQUNFJDEgJiYgY29kZSAhPT0gTkVXTElORSQxICYmIGNvZGUgIT09IFRBQiQxICYmIGNvZGUgIT09IENSJDEgJiYgY29kZSAhPT0gRkVFRCQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShSRV9IRVhfRVNDQVBFJDEudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBTTEFTSCQxICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBBU1RFUklTSyQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORCQxLmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWNrKHRva2VuKSB7XG4gICAgICAgIHJldHVybmVkLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrOiBiYWNrLFxuICAgICAgICBlbmRPZkZpbGU6IGVuZE9mRmlsZSxcbiAgICAgICAgbmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH07XG59O1xudmFyIENvbnRhaW5lciQ1JDEgPSBjb250YWluZXIkMTtcbnZhciBBdFJ1bGUkMyQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNSQxKSB7XG4gICAgX2luaGVyaXRzKEF0UnVsZSwgQ29udGFpbmVyJDUkMSk7XG4gICAgZnVuY3Rpb24gQXRSdWxlKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNSQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBdFJ1bGUucHJvdG90eXBlO1xuICAgIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX2FwcGVuZDtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIChfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfYXBwZW5kID0gQ29udGFpbmVyJDUkMS5wcm90b3R5cGUuYXBwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9hcHBlbmQsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX3ByZXBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX3ByZXBlbmQgPSBDb250YWluZXIkNSQxLnByb3RvdHlwZS5wcmVwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0UnVsZTtcbn0oQ29udGFpbmVyJDUkMSk7XG52YXIgYXRSdWxlJDEgPSBBdFJ1bGUkMyQxO1xuQXRSdWxlJDMkMS5kZWZhdWx0ID0gQXRSdWxlJDMkMTtcbkNvbnRhaW5lciQ1JDEucmVnaXN0ZXJBdFJ1bGUoQXRSdWxlJDMkMSk7XG52YXIgQ29udGFpbmVyJDQkMSA9IGNvbnRhaW5lciQxO1xudmFyIExhenlSZXN1bHQkMyQxLCBQcm9jZXNzb3IkMiQxO1xudmFyIFJvb3QkNSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNCQxKSB7XG4gICAgX2luaGVyaXRzKFJvb3QsIENvbnRhaW5lciQ0JDEpO1xuICAgIGZ1bmN0aW9uIFJvb3QoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ0JDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSb290LnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gQ29udGFpbmVyJDQkMS5wcm90b3R5cGUubm9ybWFsaXplLmNhbGwodGhpcywgY2hpbGQpO1xuICAgICAgICBpZiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkLCBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250YWluZXIkNCQxLnByb3RvdHlwZS5yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1Jlc3VsdCA9IGZ1bmN0aW9uIHRvUmVzdWx0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDMkMShuZXcgUHJvY2Vzc29yJDIkMSgpLCB0aGlzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vdDtcbn0oQ29udGFpbmVyJDQkMSk7XG5Sb290JDUkMS5yZWdpc3RlckxhenlSZXN1bHQgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBMYXp5UmVzdWx0JDMkMSA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUkMS5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIHJvb3QkMSA9IFJvb3QkNSQxO1xuUm9vdCQ1JDEuZGVmYXVsdCA9IFJvb3QkNSQxO1xuQ29udGFpbmVyJDQkMS5yZWdpc3RlclJvb3QoUm9vdCQ1JDEpO1xudmFyIGxpc3QkMiQxID0ge1xuICAgIGNvbW1hOiBmdW5jdGlvbiBjb21tYShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgW1xuICAgICAgICAgICAgXCIsXCJcbiAgICAgICAgXSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBzcGFjZTogZnVuY3Rpb24gc3BhY2Uoc3RyaW5nKSB7XG4gICAgICAgIHZhciBzcGFjZXMgPSBbXG4gICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICBcIlx0XCJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGxpc3QkMiQxLnNwbGl0KHN0cmluZywgc3BhY2VzKTtcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvcnMsIGxhc3QpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgIHZhciBmdW5jID0gMDtcbiAgICAgICAgdmFyIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByZXZRdW90ZSA9IFwiXCI7XG4gICAgICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoc3RyaW5nKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGxldHRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZRdW90ZSA9IGxldHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbnZhciBsaXN0XzEkMSA9IGxpc3QkMiQxO1xubGlzdCQyJDEuZGVmYXVsdCA9IGxpc3QkMiQxO1xudmFyIENvbnRhaW5lciQzJDEgPSBjb250YWluZXIkMTtcbnZhciBsaXN0JDEkMSA9IGxpc3RfMSQxO1xudmFyIFJ1bGUkMyQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkMyQxKSB7XG4gICAgX2luaGVyaXRzKFJ1bGUsIENvbnRhaW5lciQzJDEpO1xuICAgIGZ1bmN0aW9uIFJ1bGUoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQzJDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicnVsZVwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoUnVsZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdCQxJDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IubWF0Y2goLyxcXHMqLykgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzZXAyID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiLFwiICsgdGhpcy5yYXcoXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmFsdWVzLmpvaW4oc2VwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZTtcbn0oQ29udGFpbmVyJDMkMSk7XG52YXIgcnVsZSQxID0gUnVsZSQzJDE7XG5SdWxlJDMkMS5kZWZhdWx0ID0gUnVsZSQzJDE7XG5Db250YWluZXIkMyQxLnJlZ2lzdGVyUnVsZShSdWxlJDMkMSk7XG52YXIgRGVjbGFyYXRpb24kMiQxID0gZGVjbGFyYXRpb24kMTtcbnZhciB0b2tlbml6ZXIyJDEgPSB0b2tlbml6ZSQxO1xudmFyIENvbW1lbnQkMiQxID0gY29tbWVudCQxO1xudmFyIEF0UnVsZSQyJDEgPSBhdFJ1bGUkMTtcbnZhciBSb290JDQkMSA9IHJvb3QkMTtcbnZhciBSdWxlJDIkMSA9IHJ1bGUkMTtcbnZhciBTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMSA9IHtcbiAgICBlbXB0eTogdHJ1ZSxcbiAgICBzcGFjZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGZpbmRMYXN0V2l0aFBvc2l0aW9uJDEodG9rZW5zKSB7XG4gICAgZm9yKHZhciBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKXtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgICAgdmFyIHBvcyA9IHRva2VuWzNdIHx8IHRva2VuWzJdO1xuICAgICAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICAgIH1cbn1cbnZhciBQYXJzZXIkMSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoaW5wdXQyKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDI7XG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBSb290JDQkMSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dDIsXG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBBdFJ1bGUkMiQxKCk7XG4gICAgICAgIG5vZGUyLm5hbWUgPSB0b2tlblsxXS5zbGljZSgxKTtcbiAgICAgICAgaWYgKG5vZGUyLm5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMudW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIHZhciBzaGlmdDtcbiAgICAgICAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiICYmIGJyYWNrZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IHBhcmFtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1tzaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwcmV2ICYmIHByZXZbMF0gPT09IFwic3BhY2VcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBhcmFtc1stLXNoaWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwicGFyYW1zXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucGFyYW1zID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgbm9kZTIubm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGNvbG9uID0gdGhpcy5jb2xvbih0b2tlbnMpO1xuICAgICAgICBpZiAoY29sb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHZhciBmb3VuZGVkID0gMDtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBmb3IodmFyIGogPSBjb2xvbiAtIDE7IGogPj0gMDsgai0tKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzBdICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZGVkICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kZWQgPT09IDIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJNaXNzZWQgc2VtaWNvbG9uXCIsIHRva2VuWzBdID09PSBcIndvcmRcIiA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdKTtcbiAgICB9O1xuICAgIF9wcm90by5jb2xvbiA9IGZ1bmN0aW9uIGNvbG9uKHRva2Vucykge1xuICAgICAgICB2YXIgYnJhY2tldHMgPSAwO1xuICAgICAgICB2YXIgdG9rZW4sIHR5cGUsIHByZXY7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRva2Vucy5lbnRyaWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgaTIgPSBfc3RlcF92YWx1ZVswXSwgZWxlbWVudCA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgdG9rZW4gPSBlbGVtZW50O1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMgPT09IDAgJiYgdHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDb2xvbih0b2tlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2WzBdID09PSBcIndvcmRcIiAmJiBwcmV2WzFdID09PSBcInByb2dpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBDb21tZW50JDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB2YXIgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKTtcbiAgICAgICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXihcXHMqKShbXl0qXFxTKShcXHMqKSQvKTtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5yaWdodCA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlVG9rZW5pemVyID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5pemVyKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIkMSh0aGlzLmlucHV0KTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBEZWNsYXJhdGlvbiQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICB2YXIgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0WzBdID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2VucykpO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB3aGlsZSh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKXtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnByb3AgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCJ3b3JkXCIgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duV29yZChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgICAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gXCIgIWltcG9ydGFudFwiKSBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBpMjsgaiA+IDA7IGotLSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlMSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCAmJiB0eXBlMSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjYWNoZS5wb3AoKVsxXSArIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiICYmIHRva2VuWzBdICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNXb3JkID0gdG9rZW5zLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyWzFdO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwidmFsdWVcIiwgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRvdWJsZUNvbG9uID0gZnVuY3Rpb24gZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkRvdWJsZSBjb2xvblwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZW1wdHlSdWxlID0gZnVuY3Rpb24gZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc2VsZWN0b3IgPSBcIlwiO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5lbmQgPSBmdW5jdGlvbiBlbmQodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bMl0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kRmlsZSA9IGZ1bmN0aW9uIGVuZEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQucGFyZW50KSB0aGlzLnVuY2xvc2VkQmxvY2soKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCBcIlwiKSArIHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnJvb3Quc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy50b2tlbml6ZXIucG9zaXRpb24oKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJlZVNlbWljb2xvbiA9IGZ1bmN0aW9uIGZyZWVTZW1pY29sb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50Lm5vZGVzW3RoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gXCJydWxlXCIgJiYgIXByZXYucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBIZWxwZXJzXG4gICAgX3Byb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmlucHV0LmZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgICAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChub2RlMiwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUyKTtcbiAgICAgICAgbm9kZTIuc291cmNlID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5nZXRQb3NpdGlvbihvZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwiY29tbWVudFwiKSB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm90aGVyID0gZnVuY3Rpb24gb3RoZXIoc3RhcnQpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciBjb2xvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgYnJhY2tldCA9IG51bGw7XG4gICAgICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgICAgICB2YXIgY3VzdG9tUHJvcGVydHkgPSBzdGFydFsxXS5zdGFydHNXaXRoKFwiLS1cIik7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlKHRva2VuKXtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tUHJvcGVydHkgJiYgY29sb24gJiYgdHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZSh0b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSBicmFja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKSBlbmQgPSB0cnVlO1xuICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldCk7XG4gICAgICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgICAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IFwic3BhY2VcIiAmJiB0b2tlbiAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCh0b2tlblswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNwYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWVudCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhdC13b3JkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRydWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eVJ1bGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm90aGVyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRGaWxlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlY2hlY2tNaXNzZWRTZW1pY29sb24gPSBmdW5jdGlvbiBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpIHt9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIHByb3AsIHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICAgICAgdmFyIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgdmFyIG5leHQsIHByZXY7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGxlbmd0aDsgaTIgKz0gMSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzcGFjZVwiICYmIGkyID09PSBsZW5ndGggLSAxICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHRva2Vuc1tpMiAtIDFdID8gdG9rZW5zW2kyIC0gMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1tpMiArIDFdID8gdG9rZW5zW2kyICsgMV1bMF0gOiBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgaWYgKCFTQUZFX0NPTU1FTlRfTkVJR0hCT1IkMVtwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbbmV4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsZWFuKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbihhbGwsIGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbCArIGkyWzFdO1xuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgICAgICBub2RlMi5yYXdzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKHRva2Vucykge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIkMSgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInNlbGVjdG9yXCIsIHRva2Vucyk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlblR5cGU7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIiAmJiBsYXN0VG9rZW5UeXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9O1xuICAgIC8vIEVycm9yc1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCA9IGZ1bmN0aW9uIHNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHRva2Vucykge1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3BhY2VzRnJvbUVuZCA9IGZ1bmN0aW9uIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5nRnJvbSA9IGZ1bmN0aW9uIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpMiA9IGZyb207IGkyIDwgdG9rZW5zLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICByZXN1bHQyICs9IHRva2Vuc1tpMl1bMV07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnVuY2xvc2VkQmxvY2sgPSBmdW5jdGlvbiB1bmNsb3NlZEJsb2NrKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5jdXJyZW50LnNvdXJjZS5zdGFydDtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJsb2NrXCIsIHBvcy5saW5lLCBwb3MuY29sdW1uKTtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJyYWNrZXQgPSBmdW5jdGlvbiB1bmNsb3NlZEJyYWNrZXQoYnJhY2tldCkge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYnJhY2tldFwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IGJyYWNrZXRbMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmV4cGVjdGVkQ2xvc2UgPSBmdW5jdGlvbiB1bmV4cGVjdGVkQ2xvc2UodG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuZXhwZWN0ZWQgfVwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyAxXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVua25vd25Xb3JkID0gZnVuY3Rpb24gdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmtub3duIHdvcmRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbnNbMF1bMl0gKyB0b2tlbnNbMF1bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVubmFtZWRBdHJ1bGUgPSBmdW5jdGlvbiB1bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbikge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiQXQtcnVsZSB3aXRob3V0IG5hbWVcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcbnZhciBwYXJzZXIkMSA9IFBhcnNlciQxJDE7XG52YXIgQ29udGFpbmVyJDIkMSA9IGNvbnRhaW5lciQxO1xudmFyIFBhcnNlcjIkMSA9IHBhcnNlciQxO1xudmFyIElucHV0JDIkMSA9IGlucHV0JDE7XG5mdW5jdGlvbiBwYXJzZSQzJDEoY3NzLCBvcHRzKSB7XG4gICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQyJDEoY3NzLCBvcHRzKTtcbiAgICB2YXIgcGFyc2VyMiA9IG5ldyBQYXJzZXIyJDEoaW5wdXQyKTtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZXIyLnBhcnNlKCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGUyLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiBvcHRzICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTI7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSQxID0gcGFyc2UkMyQxO1xucGFyc2UkMyQxLmRlZmF1bHQgPSBwYXJzZSQzJDE7XG5Db250YWluZXIkMiQxLnJlZ2lzdGVyUGFyc2UocGFyc2UkMyQxKTtcbnZhciBpc0NsZWFuJDMgPSBzeW1ib2xzJDEuaXNDbGVhbiwgbXkkMyA9IHN5bWJvbHMkMS5teTtcbnZhciBNYXBHZW5lcmF0b3IkMSQxID0gbWFwR2VuZXJhdG9yJDE7XG52YXIgc3RyaW5naWZ5JDIkMSA9IHN0cmluZ2lmeV8xJDE7XG52YXIgQ29udGFpbmVyJDEkMSA9IGNvbnRhaW5lciQxO1xudmFyIERvY3VtZW50JDIkMSA9IGRvY3VtZW50JDEkMTtcbnZhciB3YXJuT25jZSQxJDEgPSB3YXJuT25jZSQyJDE7XG52YXIgUmVzdWx0JDIkMSA9IHJlc3VsdCQxO1xudmFyIHBhcnNlJDIkMSA9IHBhcnNlXzEkMTtcbnZhciBSb290JDMkMSA9IHJvb3QkMTtcbnZhciBUWVBFX1RPX0NMQVNTX05BTUUkMSA9IHtcbiAgICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gICAgY29tbWVudDogXCJDb21tZW50XCIsXG4gICAgZGVjbDogXCJEZWNsYXJhdGlvblwiLFxuICAgIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gICAgcm9vdDogXCJSb290XCIsXG4gICAgcnVsZTogXCJSdWxlXCJcbn07XG52YXIgUExVR0lOX1BST1BTJDEgPSB7XG4gICAgQXRSdWxlOiB0cnVlLFxuICAgIEF0UnVsZUV4aXQ6IHRydWUsXG4gICAgQ29tbWVudDogdHJ1ZSxcbiAgICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gICAgRG9jdW1lbnQ6IHRydWUsXG4gICAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICAgIE9uY2U6IHRydWUsXG4gICAgT25jZUV4aXQ6IHRydWUsXG4gICAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgICBwcmVwYXJlOiB0cnVlLFxuICAgIFJvb3Q6IHRydWUsXG4gICAgUm9vdEV4aXQ6IHRydWUsXG4gICAgUnVsZTogdHJ1ZSxcbiAgICBSdWxlRXhpdDogdHJ1ZVxufTtcbnZhciBOT1RfVklTSVRPUlMkMSA9IHtcbiAgICBPbmNlOiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZVxufTtcbnZhciBDSElMRFJFTiQxID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSQxKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvYmopKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyQxKG5vZGUyKSB7XG4gICAgdmFyIGtleSA9IGZhbHNlO1xuICAgIHZhciB0eXBlID0gVFlQRV9UT19DTEFTU19OQU1FJDFbbm9kZTIudHlwZV07XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAga2V5ID0gbm9kZTIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoa2V5ICYmIG5vZGUyLmFwcGVuZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBDSElMRFJFTiQxLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1N0YWNrJDEobm9kZTIpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgZXZlbnRzID0gW1xuICAgICAgICAgICAgXCJEb2N1bWVudFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIFwiRG9jdW1lbnRFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiUm9vdFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIFwiUm9vdEV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRJbmRleDogMCxcbiAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgIGl0ZXJhdG9yOiAwLFxuICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgdmlzaXRvckluZGV4OiAwLFxuICAgICAgICB2aXNpdG9yczogW11cbiAgICB9O1xufVxuZnVuY3Rpb24gY2xlYW5NYXJrcyQxKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbiQzXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5ub2Rlcykgbm9kZTIubm9kZXMuZm9yRWFjaChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gY2xlYW5NYXJrcyQxKGkyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZTI7XG59XG52YXIgcG9zdGNzcyQyJDEgPSB7fTtcbnZhciBMYXp5UmVzdWx0JDIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTGF6eVJlc3VsdChwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIGlmICgodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiBjc3MgIT09IG51bGwgJiYgKGNzcy50eXBlID09PSBcInJvb3RcIiB8fCBjc3MudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkge1xuICAgICAgICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzJDEoY3NzKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihjc3MsIExhenlSZXN1bHQpIHx8IF9pbnN0YW5jZW9mKGNzcywgUmVzdWx0JDIkMSkpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcy5yb290KTtcbiAgICAgICAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0cy5tYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDIkMTtcbiAgICAgICAgICAgIGlmIChvcHRzLnN5bnRheCkgcGFyc2VyMiA9IG9wdHMuc3ludGF4LnBhcnNlO1xuICAgICAgICAgICAgaWYgKG9wdHMucGFyc2VyKSBwYXJzZXIyID0gb3B0cy5wYXJzZXI7XG4gICAgICAgICAgICBpZiAocGFyc2VyMi5wYXJzZSkgcGFyc2VyMiA9IHBhcnNlcjIucGFyc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMihjc3MsIG9wdHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QyICYmICFyb290MltteSQzXSkge1xuICAgICAgICAgICAgICAgIENvbnRhaW5lciQxJDEucmVidWlsZChyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDIkMShwcm9jZXNzb3IyLCByb290Miwgb3B0cyk7XG4gICAgICAgIHRoaXMuaGVscGVycyA9IF9leHRlbmRzKHt9LCBwb3N0Y3NzJDIkMSwge1xuICAgICAgICAgICAgcG9zdGNzczogcG9zdGNzcyQyJDEsXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMucmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcChmdW5jdGlvbihwbHVnaW4yMikge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwbHVnaW4yMiwgcGx1Z2luMjIucHJlcGFyZShfdGhpcy5yZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExhenlSZXN1bHQucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gdGhpcy5ydW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBc3luY0Vycm9yID0gZnVuY3Rpb24gZ2V0QXN5bmNFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2luc1wiKTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBub2RlMikge1xuICAgICAgICB2YXIgcGx1Z2luMjIgPSB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vZGUyKSBub2RlMi5hZGRUb0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgIWVycm9yLnBsdWdpbikge1xuICAgICAgICAgICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luVmVyID0gcGx1Z2luMjIucG9zdGNzc1ZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHBsdWdpblZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gcnVudGltZVZlci5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhMlswXSAhPT0gYlswXSB8fCBwYXJzZUludChhMlsxXSkgPiBwYXJzZUludChiWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgdmVyc2lvbiBpcyBcIiArIHJ1bnRpbWVWZXIgKyBcIiwgYnV0IFwiICsgcGx1Z2luTmFtZSArIFwiIHVzZXMgXCIgKyBwbHVnaW5WZXIgKyBcIi4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBhcmVWaXNpdG9ycyA9IGZ1bmN0aW9uIHByZXBhcmVWaXNpdG9ycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uKHBsdWdpbjIyLCB0eXBlLCBjYikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnNbdHlwZV0pIF90aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgX3RoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goW1xuICAgICAgICAgICAgICAgIHBsdWdpbjIyLFxuICAgICAgICAgICAgICAgIGNiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBldmVudCBpbiBwbHVnaW4yMil7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUExVR0lOX1BST1BTJDFbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50IFwiICsgZXZlbnQgKyBcIiBpbiBcIiArIHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW4gKyBcIi4gVHJ5IHRvIHVwZGF0ZSBQb3N0Q1NTIChcIiArIHRoaXMucHJvY2Vzc29yLnZlcnNpb24gKyBcIiBub3cpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SUyQxW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlX29mKHBsdWdpbjIyW2V2ZW50XSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGZpbHRlciBpbiBwbHVnaW4yMltldmVudF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCArIFwiLVwiICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuQXN5bmMgPSBmdW5jdGlvbiBydW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaTIsIHBsdWdpbjIyLCBwcm9taXNlLCBlcnJvciwgcm9vdDIsIHN0YWNrLCBwcm9taXNlMSwgZTIsIG5vZGUyLCBfbG9vcCwgX2l0ZXJhdG9yLCBfc3RlcDtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbHVnaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaTIgPCBfdGhpcy5wbHVnaW5zLmxlbmd0aCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIgPSBfdGhpcy5wbHVnaW5zW2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBfdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UkMShwcm9taXNlKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXBhcmVWaXNpdG9ycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNMaXN0ZW5lcikgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDIgPSBfdGhpcy5yZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJvb3QyW2lzQ2xlYW4kM10pIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdGFjayQxKHJvb3QyKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YWNrLmxlbmd0aCA+IDApKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMSA9IF90aGlzLnZpc2l0VGljayhzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZSQxKHByb21pc2UxKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlLCBwbHVnaW4yMiwgdmlzaXRvciwgcm9vdHMsIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290cyA9IHJvb3QyLm5vZGVzLm1hcChmdW5jdGlvbihzdWJSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKHN1YlJvb3QsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHJvb3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdG9yKHJvb3QyLCBfdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHNfdmFsdWVzKF9sb29wKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHJpbmdpZnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIF9wcm90by5ydW5PblJvb3QgPSBmdW5jdGlvbiBydW5PblJvb3QocGx1Z2luMjIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5PbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKGZ1bmN0aW9uKHJvb3QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZShyb290MiwgX3RoaXMuaGVscGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQyJDE7XG4gICAgICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5O1xuICAgICAgICBpZiAob3B0cy5zdHJpbmdpZmllcikgc3RyID0gb3B0cy5zdHJpbmdpZmllcjtcbiAgICAgICAgaWYgKHN0ci5zdHJpbmdpZnkpIHN0ciA9IHN0ci5zdHJpbmdpZnk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yJDEkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBkYXRhWzBdO1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnBsdWdpbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMjIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSQxKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSghcm9vdDJbaXNDbGVhbiQzXSl7XG4gICAgICAgICAgICAgICAgcm9vdDJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShyb290Mi5ub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJSb290ID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHN1YlJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZSQxJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by52aXNpdFN5bmMgPSBmdW5jdGlvbiB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHZpc2l0b3JzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIucHJveHlPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRUaWNrID0gZnVuY3Rpb24gdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgICAgIHZhciB2aXNpdDIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5vZGUyID0gdmlzaXQyLm5vZGUsIHZpc2l0b3JzID0gdmlzaXQyLnZpc2l0b3JzO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdG9ycy5sZW5ndGggPiAwICYmIHZpc2l0Mi52aXNpdG9ySW5kZXggPCB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleCA9IHZpc2l0b3JzW3Zpc2l0Mi52aXNpdG9ySW5kZXhdLCBwbHVnaW4yMiA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzBdLCB2aXNpdG9yID0gX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXhbMV07XG4gICAgICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAodmlzaXQyLnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gW107XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKG5vZGUyLnRvUHJveHkoKSwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpdDIuaXRlcmF0b3IgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZpc2l0Mi5pdGVyYXRvcjtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGNoaWxkID0gbm9kZTIubm9kZXNbbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl1dKXtcbiAgICAgICAgICAgICAgICBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbiQzXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFtpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrJDEoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IDA7XG4gICAgICAgICAgICBkZWxldGUgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50cyA9IHZpc2l0Mi5ldmVudHM7XG4gICAgICAgIHdoaWxlKHZpc2l0Mi5ldmVudEluZGV4IDwgZXZlbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbdmlzaXQyLmV2ZW50SW5kZXhdO1xuICAgICAgICAgICAgdmlzaXQyLmV2ZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4kMSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTJbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IG5vZGUyLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrU3luYyA9IGZ1bmN0aW9uIHdhbGtTeW5jKG5vZGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICB2YXIgZXZlbnRzID0gZ2V0RXZlbnRzJDEobm9kZTIpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShldmVudHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4kMSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW4kM10pIF90aGlzLndhbGtTeW5jKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZTIudG9Qcm94eSgpKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhMYXp5UmVzdWx0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvcHRzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb2Nlc3NvclwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJvb3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkxhenlSZXN1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBMYXp5UmVzdWx0O1xufSgpO1xuTGF6eVJlc3VsdCQyJDEucmVnaXN0ZXJQb3N0Y3NzID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgcG9zdGNzcyQyJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQkMSA9IExhenlSZXN1bHQkMiQxO1xuTGF6eVJlc3VsdCQyJDEuZGVmYXVsdCA9IExhenlSZXN1bHQkMiQxO1xuUm9vdCQzJDEucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMiQxKTtcbkRvY3VtZW50JDIkMS5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyJDEpO1xudmFyIE1hcEdlbmVyYXRvcjIkMSA9IG1hcEdlbmVyYXRvciQxO1xudmFyIHN0cmluZ2lmeSQxJDEgPSBzdHJpbmdpZnlfMSQxO1xudmFyIHdhcm5PbmNlMiQxID0gd2Fybk9uY2UkMiQxO1xudmFyIHBhcnNlJDEkMSA9IHBhcnNlXzEkMTtcbnZhciBSZXN1bHQkMSQxID0gcmVzdWx0JDE7XG52YXIgTm9Xb3JrUmVzdWx0JDEkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9Xb3JrUmVzdWx0KHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLl9jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQxJDE7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQxJDEodGhpcy5fcHJvY2Vzc29yLCByb290MiwgdGhpcy5fb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXN1bHQsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IyJDEoc3RyLCByb290MiwgdGhpcy5fb3B0cywgY3NzKTtcbiAgICAgICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICAgICAgICB2YXIgX21hcF9nZW5lcmF0ZSA9IG1hcC5nZW5lcmF0ZSgpLCBnZW5lcmF0ZWRDU1MgPSBfbWFwX2dlbmVyYXRlWzBdLCBnZW5lcmF0ZWRNYXAgPSBfbWFwX2dlbmVyYXRlWzFdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZENTUykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXAuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb1dvcmtSZXN1bHQucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICB9O1xuICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMuX29wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UyJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb1dvcmtSZXN1bHQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjc3NcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXIyID0gcGFyc2UkMSQxO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMih0aGlzLl9jc3MsIHRoaXMuX29wdHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9Xb3JrUmVzdWx0O1xufSgpO1xudmFyIG5vV29ya1Jlc3VsdCQxID0gTm9Xb3JrUmVzdWx0JDEkMTtcbk5vV29ya1Jlc3VsdCQxJDEuZGVmYXVsdCA9IE5vV29ya1Jlc3VsdCQxJDE7XG52YXIgTm9Xb3JrUmVzdWx0MiQxID0gbm9Xb3JrUmVzdWx0JDE7XG52YXIgTGF6eVJlc3VsdCQxJDEgPSBsYXp5UmVzdWx0JDE7XG52YXIgRG9jdW1lbnQkMSQxID0gZG9jdW1lbnQkMSQxO1xudmFyIFJvb3QkMiQxID0gcm9vdCQxO1xudmFyIFByb2Nlc3NvciQxJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NvcihwbHVnaW5zKSB7XG4gICAgICAgIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI4LjQuMzhcIjtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcm9jZXNzb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUocGx1Z2lucykge1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoaTIucG9zdGNzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGkyID0gaTIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaTIucG9zdGNzcykge1xuICAgICAgICAgICAgICAgIGkyID0gaTIucG9zdGNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShpMi5wbHVnaW5zKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLmNvbmNhdChpMi5wbHVnaW5zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIGkyLnBvc3Rjc3NQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiAoaTIucGFyc2UgfHwgaTIuc3RyaW5naWZ5KSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyBzeW50YXhlcyBjYW5ub3QgYmUgdXNlZCBhcyBwbHVnaW5zLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIG9uZSBvZiB0aGUgc3ludGF4L3BhcnNlci9zdHJpbmdpZmllciBvcHRpb25zIGFzIG91dGxpbmVkIGluIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaTIgKyBcIiBpcyBub3QgYSBQb3N0Q1NTIHBsdWdpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9O1xuICAgIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzczEoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnBsdWdpbnMubGVuZ3RoICYmICFvcHRzLnBhcnNlciAmJiAhb3B0cy5zdHJpbmdpZmllciAmJiAhb3B0cy5zeW50YXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0MiQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQkMSQxKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UocGx1Z2luMjIpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbXG4gICAgICAgICAgICBwbHVnaW4yMlxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFByb2Nlc3Nvcjtcbn0oKTtcbnZhciBwcm9jZXNzb3IkMSA9IFByb2Nlc3NvciQxJDE7XG5Qcm9jZXNzb3IkMSQxLmRlZmF1bHQgPSBQcm9jZXNzb3IkMSQxO1xuUm9vdCQyJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG5Eb2N1bWVudCQxJDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEkMSk7XG52YXIgRGVjbGFyYXRpb24kMSQxID0gZGVjbGFyYXRpb24kMTtcbnZhciBQcmV2aW91c01hcDIkMSA9IHByZXZpb3VzTWFwJDE7XG52YXIgQ29tbWVudCQxJDEgPSBjb21tZW50JDE7XG52YXIgQXRSdWxlJDEkMSA9IGF0UnVsZSQxO1xudmFyIElucHV0JDEkMSA9IGlucHV0JDE7XG52YXIgUm9vdCQxJDEgPSByb290JDE7XG52YXIgUnVsZSQxJDEgPSBydWxlJDE7XG5mdW5jdGlvbiBmcm9tSlNPTiQxJDEoanNvbiwgaW5wdXRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICByZXR1cm4gZnJvbUpTT04kMSQxKG4yKTtcbiAgICB9KTtcbiAgICB2YXIgb3duSW5wdXRzID0ganNvbi5pbnB1dHMsIGRlZmF1bHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoanNvbiwgW1xuICAgICAgICBcImlucHV0c1wiXG4gICAgXSk7XG4gICAgaWYgKG93bklucHV0cykge1xuICAgICAgICBpbnB1dHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uob3duSW5wdXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGlucHV0MiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlucHV0SHlkcmF0ZWQgPSBfZXh0ZW5kcyh7fSwgaW5wdXQyLCB7XG4gICAgICAgICAgICAgICAgX19wcm90b19fOiBJbnB1dCQxJDEucHJvdG90eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dEh5ZHJhdGVkLm1hcCkge1xuICAgICAgICAgICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0gX2V4dGVuZHMoe30sIGlucHV0SHlkcmF0ZWQubWFwLCB7XG4gICAgICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAyJDEucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dEh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICAgICAgZGVmYXVsdHMubm9kZXMgPSBqc29uLm5vZGVzLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KU09OJDEkMShuMiwgaW5wdXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICAgICAgdmFyIF9kZWZhdWx0c19zb3VyY2UgPSBkZWZhdWx0cy5zb3VyY2UsIGlucHV0SWQgPSBfZGVmYXVsdHNfc291cmNlLmlucHV0SWQsIHNvdXJjZSA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKF9kZWZhdWx0c19zb3VyY2UsIFtcbiAgICAgICAgICAgIFwiaW5wdXRJZFwiXG4gICAgICAgIF0pO1xuICAgICAgICBkZWZhdWx0cy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb290JDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWVudCQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IEF0UnVsZSQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gICAgfVxufVxudmFyIGZyb21KU09OXzEkMSA9IGZyb21KU09OJDEkMTtcbmZyb21KU09OJDEkMS5kZWZhdWx0ID0gZnJvbUpTT04kMSQxO1xudmFyIENzc1N5bnRheEVycm9yMiQxID0gY3NzU3ludGF4RXJyb3IkMTtcbnZhciBEZWNsYXJhdGlvbjIkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgTGF6eVJlc3VsdDIkMSA9IGxhenlSZXN1bHQkMTtcbnZhciBDb250YWluZXIyJDEgPSBjb250YWluZXIkMTtcbnZhciBQcm9jZXNzb3IyJDEgPSBwcm9jZXNzb3IkMTtcbnZhciBzdHJpbmdpZnkkNSA9IHN0cmluZ2lmeV8xJDE7XG52YXIgZnJvbUpTT04kMiA9IGZyb21KU09OXzEkMTtcbnZhciBEb2N1bWVudDIyID0gZG9jdW1lbnQkMSQxO1xudmFyIFdhcm5pbmcyJDEgPSB3YXJuaW5nJDE7XG52YXIgQ29tbWVudDIkMSA9IGNvbW1lbnQkMTtcbnZhciBBdFJ1bGUyJDEgPSBhdFJ1bGUkMTtcbnZhciBSZXN1bHQyJDEgPSByZXN1bHQkMTtcbnZhciBJbnB1dDIkMSA9IGlucHV0JDE7XG52YXIgcGFyc2UkNSA9IHBhcnNlXzEkMTtcbnZhciBsaXN0JDMgPSBsaXN0XzEkMTtcbnZhciBSdWxlMiQxID0gcnVsZSQxO1xudmFyIFJvb3QyJDEgPSByb290JDE7XG52YXIgTm9kZTIkMSA9IG5vZGUkMTtcbmZ1bmN0aW9uIHBvc3Rjc3MkMygpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb2Nlc3NvcjIkMShwbHVnaW5zKTtcbn1cbnBvc3Rjc3MkMy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4obmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgICB2YXIgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjcmVhdG9yKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiAhd2FybmluZ1ByaW50ZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdQcmludGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTEFORyAmJiBwcm9jZXNzLmVudi5MQU5HLnN0YXJ0c1dpdGgoXCJjblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IGluaXRpYWxpemVyLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcjIkMSgpLnZlcnNpb247XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFyIGNhY2hlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY3JlYXRvci5wcm9jZXNzID0gZnVuY3Rpb24oY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgICAgICByZXR1cm4gcG9zdGNzcyQzKFtcbiAgICAgICAgICAgIGNyZWF0b3IocGx1Z2luT3B0cylcbiAgICAgICAgXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3MkMy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkkNTtcbnBvc3Rjc3MkMy5wYXJzZSA9IHBhcnNlJDU7XG5wb3N0Y3NzJDMuZnJvbUpTT04gPSBmcm9tSlNPTiQyO1xucG9zdGNzcyQzLmxpc3QgPSBsaXN0JDM7XG5wb3N0Y3NzJDMuY29tbWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50MiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuYXRSdWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZTIkMShkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLmRlY2wgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24yJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5ydWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5yb290ID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5kb2N1bWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudDIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIkMTtcbnBvc3Rjc3MkMy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMiQxO1xucG9zdGNzcyQzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIkMTtcbnBvc3Rjc3MkMy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyJDE7XG5wb3N0Y3NzJDMuRG9jdW1lbnQgPSBEb2N1bWVudDIyO1xucG9zdGNzcyQzLkNvbW1lbnQgPSBDb21tZW50MiQxO1xucG9zdGNzcyQzLldhcm5pbmcgPSBXYXJuaW5nMiQxO1xucG9zdGNzcyQzLkF0UnVsZSA9IEF0UnVsZTIkMTtcbnBvc3Rjc3MkMy5SZXN1bHQgPSBSZXN1bHQyJDE7XG5wb3N0Y3NzJDMuSW5wdXQgPSBJbnB1dDIkMTtcbnBvc3Rjc3MkMy5SdWxlID0gUnVsZTIkMTtcbnBvc3Rjc3MkMy5Sb290ID0gUm9vdDIkMTtcbnBvc3Rjc3MkMy5Ob2RlID0gTm9kZTIkMTtcbkxhenlSZXN1bHQyJDEucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MkMyk7XG52YXIgcG9zdGNzc18xJDEgPSBwb3N0Y3NzJDM7XG5wb3N0Y3NzJDMuZGVmYXVsdCA9IHBvc3Rjc3MkMztcbnZhciBwb3N0Y3NzJDEkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHBvc3Rjc3NfMSQxKTtcbnBvc3Rjc3MkMSQxLnN0cmluZ2lmeTtcbnBvc3Rjc3MkMSQxLmZyb21KU09OO1xucG9zdGNzcyQxJDEucGx1Z2luO1xucG9zdGNzcyQxJDEucGFyc2U7XG5wb3N0Y3NzJDEkMS5saXN0O1xucG9zdGNzcyQxJDEuZG9jdW1lbnQ7XG5wb3N0Y3NzJDEkMS5jb21tZW50O1xucG9zdGNzcyQxJDEuYXRSdWxlO1xucG9zdGNzcyQxJDEucnVsZTtcbnBvc3Rjc3MkMSQxLmRlY2w7XG5wb3N0Y3NzJDEkMS5yb290O1xucG9zdGNzcyQxJDEuQ3NzU3ludGF4RXJyb3I7XG5wb3N0Y3NzJDEkMS5EZWNsYXJhdGlvbjtcbnBvc3Rjc3MkMSQxLkNvbnRhaW5lcjtcbnBvc3Rjc3MkMSQxLlByb2Nlc3NvcjtcbnBvc3Rjc3MkMSQxLkRvY3VtZW50O1xucG9zdGNzcyQxJDEuQ29tbWVudDtcbnBvc3Rjc3MkMSQxLldhcm5pbmc7XG5wb3N0Y3NzJDEkMS5BdFJ1bGU7XG5wb3N0Y3NzJDEkMS5SZXN1bHQ7XG5wb3N0Y3NzJDEkMS5JbnB1dDtcbnBvc3Rjc3MkMSQxLlJ1bGU7XG5wb3N0Y3NzJDEkMS5Sb290O1xucG9zdGNzcyQxJDEuTm9kZTtcbnZhciBfX2RlZlByb3AyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcDIgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcDIob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkMiA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3AyKG9iaiwgKHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yoa2V5KSkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeDIpIHtcbiAgICByZXR1cm4geDIgJiYgeDIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeDIsIFwiZGVmYXVsdFwiKSA/IHgyW1wiZGVmYXVsdFwiXSA6IHgyO1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4yKSB7XG4gICAgaWYgKG4yLl9fZXNNb2R1bGUpIHJldHVybiBuMjtcbiAgICB2YXIgZjIgPSBuMi5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2YgZjIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhMiA9IGZ1bmN0aW9uIGEyMigpIHtcbiAgICAgICAgICAgIGlmIChfaW5zdGFuY2VvZih0aGlzLCBhMjIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYyLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGEyLnByb3RvdHlwZSA9IGYyLnByb3RvdHlwZTtcbiAgICB9IGVsc2UgYTIgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMobjIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobjIsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYTIsIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjJba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhMjtcbn1cbnZhciBwaWNvY29sb3JzX2Jyb3dzZXIgPSB7XG4gICAgZXhwb3J0czoge31cbn07XG52YXIgeCA9IFN0cmluZztcbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDb2xvclN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHJlc2V0OiB4LFxuICAgICAgICBib2xkOiB4LFxuICAgICAgICBkaW06IHgsXG4gICAgICAgIGl0YWxpYzogeCxcbiAgICAgICAgdW5kZXJsaW5lOiB4LFxuICAgICAgICBpbnZlcnNlOiB4LFxuICAgICAgICBoaWRkZW46IHgsXG4gICAgICAgIHN0cmlrZXRocm91Z2g6IHgsXG4gICAgICAgIGJsYWNrOiB4LFxuICAgICAgICByZWQ6IHgsXG4gICAgICAgIGdyZWVuOiB4LFxuICAgICAgICB5ZWxsb3c6IHgsXG4gICAgICAgIGJsdWU6IHgsXG4gICAgICAgIG1hZ2VudGE6IHgsXG4gICAgICAgIGN5YW46IHgsXG4gICAgICAgIHdoaXRlOiB4LFxuICAgICAgICBncmF5OiB4LFxuICAgICAgICBiZ0JsYWNrOiB4LFxuICAgICAgICBiZ1JlZDogeCxcbiAgICAgICAgYmdHcmVlbjogeCxcbiAgICAgICAgYmdZZWxsb3c6IHgsXG4gICAgICAgIGJnQmx1ZTogeCxcbiAgICAgICAgYmdNYWdlbnRhOiB4LFxuICAgICAgICBiZ0N5YW46IHgsXG4gICAgICAgIGJnV2hpdGU6IHhcbiAgICB9O1xufTtcbnBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzID0gY3JlYXRlKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGU7XG52YXIgcGljb2NvbG9yc19icm93c2VyRXhwb3J0cyA9IHBpY29jb2xvcnNfYnJvd3Nlci5leHBvcnRzO1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCA9IHt9O1xudmFyIF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6IFwiTW9kdWxlXCJcbn0pKTtcbnZhciByZXF1aXJlJCQyID0gLyogQF9fUFVSRV9fICovIGdldEF1Z21lbnRlZE5hbWVzcGFjZShfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSk7XG52YXIgcGljbyA9IHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHM7XG52YXIgdGVybWluYWxIaWdobGlnaHQkMSA9IHJlcXVpcmUkJDI7XG52YXIgQ3NzU3ludGF4RXJyb3IkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRXJyb3IxKSB7XG4gICAgX2luaGVyaXRzKENzc1N5bnRheEVycm9yMiwgRXJyb3IxKTtcbiAgICBmdW5jdGlvbiBDc3NTeW50YXhFcnJvcjIobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBFcnJvcjEuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gXCJDc3NTeW50YXhFcnJvclwiO1xuICAgICAgICBfdGhpcy5yZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgX3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW4yMikge1xuICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb2x1bW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGluZSA9IGxpbmUubGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmRMaW5lID0gY29sdW1uLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kQ29sdW1uID0gY29sdW1uLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zZXRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIENzc1N5bnRheEVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ3NzU3ludGF4RXJyb3IyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIHNldE1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyBcIjogXCIgOiBcIlwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogXCI8Y3NzIGlucHV0PlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOlwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6IFwiICsgdGhpcy5yZWFzb247XG4gICAgfTtcbiAgICBfcHJvdG8uc2hvd1NvdXJjZUNvZGUgPSBmdW5jdGlvbiBzaG93U291cmNlQ29kZShjb2xvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvLmlzQ29sb3JTdXBwb3J0ZWQ7XG4gICAgICAgIGlmICh0ZXJtaW5hbEhpZ2hsaWdodCQxKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEoY3NzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgodGhpcy5saW5lIC0gMywgMCk7XG4gICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih0aGlzLmxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgICAgICB2YXIgbWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGg7XG4gICAgICAgIHZhciBtYXJrLCBhc2lkZTtcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgX3BpY29fY3JlYXRlQ29sb3JzID0gcGljby5jcmVhdGVDb2xvcnModHJ1ZSksIGJvbGQgPSBfcGljb19jcmVhdGVDb2xvcnMuYm9sZCwgZ3JheSA9IF9waWNvX2NyZWF0ZUNvbG9ycy5ncmF5LCByZWQgPSBfcGljb19jcmVhdGVDb2xvcnMucmVkO1xuICAgICAgICAgICAgbWFyayA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9sZChyZWQodGV4dCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzaWRlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncmF5KHRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmsgPSBhc2lkZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaW5kZXgyKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgICAgICAgdmFyIGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IF90aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgX3RoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gXCJcXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1N5bnRheEVycm9yMjtcbn0oX3dyYXBfbmF0aXZlX3N1cGVyKEVycm9yKSk7XG52YXIgY3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvciQzO1xuQ3NzU3ludGF4RXJyb3IkMy5kZWZhdWx0ID0gQ3NzU3ludGF4RXJyb3IkMztcbnZhciBzeW1ib2xzID0ge307XG5zeW1ib2xzLmlzQ2xlYW4gPSBTeW1ib2woXCJpc0NsZWFuXCIpO1xuc3ltYm9scy5teSA9IFN5bWJvbChcIm15XCIpO1xudmFyIERFRkFVTFRfUkFXID0ge1xuICAgIGFmdGVyOiBcIlxcblwiLFxuICAgIGJlZm9yZUNsb3NlOiBcIlxcblwiLFxuICAgIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gICAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgICBiZWZvcmVPcGVuOiBcIiBcIixcbiAgICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICAgIGNvbG9uOiBcIjogXCIsXG4gICAgY29tbWVudExlZnQ6IFwiIFwiLFxuICAgIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gICAgZW1wdHlCb2R5OiBcIlwiLFxuICAgIGluZGVudDogXCIgICAgXCIsXG4gICAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxudmFyIFN0cmluZ2lmaWVyJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ2lmaWVyMihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHJpbmdpZmllcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hdHJ1bGUgPSBmdW5jdGlvbiBhdHJ1bGUobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICB2YXIgbmFtZSA9IFwiQFwiICsgbm9kZTIubmFtZTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5vZGUyLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZTIsIFwicGFyYW1zXCIpIDogXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5yYXdzLmFmdGVyTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbmFtZSArPSBub2RlMi5yYXdzLmFmdGVyTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCBuYW1lICsgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSAobm9kZTIucmF3cy5iZXR3ZWVuIHx8IFwiXCIpICsgKHNlbWljb2xvbiA/IFwiO1wiIDogXCJcIik7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobmFtZSArIHBhcmFtcyArIGVuZCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlQWZ0ZXIgPSBmdW5jdGlvbiBiZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ29tbWVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlQ2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgd2hpbGUoYnVmICYmIGJ1Zi50eXBlICE9PSBcInJvb3RcIil7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICAgICAgYnVmID0gYnVmLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJpbmRlbnRcIik7XG4gICAgICAgICAgICBpZiAoaW5kZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgc3RlcCA9IDA7IHN0ZXAgPCBkZXB0aDsgc3RlcCsrKXZhbHVlICs9IGluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uYmxvY2sgPSBmdW5jdGlvbiBibG9jayhub2RlMiwgc3RhcnQpIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArIFwie1wiLCBub2RlMiwgXCJzdGFydFwiKTtcbiAgICAgICAgdmFyIGFmdGVyO1xuICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIiwgXCJlbXB0eUJvZHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyKSB0aGlzLmJ1aWxkZXIoYWZ0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCJ9XCIsIG5vZGUyLCBcImVuZFwiKTtcbiAgICB9O1xuICAgIF9wcm90by5ib2R5ID0gZnVuY3Rpb24gYm9keShub2RlMikge1xuICAgICAgICB2YXIgbGFzdCA9IG5vZGUyLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlKGxhc3QgPiAwKXtcbiAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlc1tsYXN0XS50eXBlICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBsYXN0IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbWljb2xvbiA9IHRoaXMucmF3KG5vZGUyLCBcInNlbWljb2xvblwiKTtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbm9kZTIubm9kZXMubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUyLm5vZGVzW2kyXTtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSB0aGlzLnJhdyhjaGlsZCwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB0aGlzLmJ1aWxkZXIoYmVmb3JlKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpMiB8fCBzZW1pY29sb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQobm9kZTIpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJhdyhub2RlMiwgXCJsZWZ0XCIsIFwiY29tbWVudExlZnRcIik7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmF3KG5vZGUyLCBcInJpZ2h0XCIsIFwiY29tbWVudFJpZ2h0XCIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoXCIvKlwiICsgbGVmdCArIG5vZGUyLnRleHQgKyByaWdodCArIFwiKi9cIiwgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY2wgPSBmdW5jdGlvbiBkZWNsKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIGJldHdlZW4gPSB0aGlzLnJhdyhub2RlMiwgXCJiZXR3ZWVuXCIsIFwiY29sb25cIik7XG4gICAgICAgIHZhciBzdHJpbmcgPSBub2RlMi5wcm9wICsgYmV0d2VlbiArIHRoaXMucmF3VmFsdWUobm9kZTIsIFwidmFsdWVcIik7XG4gICAgICAgIGlmIChub2RlMi5pbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBub2RlMi5yYXdzLmltcG9ydGFudCB8fCBcIiAhaW1wb3J0YW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9IFwiO1wiO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoc3RyaW5nLCBub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZG9jdW1lbnQgPSBmdW5jdGlvbiBkb2N1bWVudDEobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcobm9kZTIsIG93biwgZGV0ZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKCFkZXRlY3QpIGRldGVjdCA9IG93bjtcbiAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlMi5yYXdzW293bl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUyLnBhcmVudDtcbiAgICAgICAgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5maXJzdCA9PT0gbm9kZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSByZXR1cm4gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICAgICAgdmFyIHJvb3QyID0gbm9kZTIucm9vdCgpO1xuICAgICAgICBpZiAoIXJvb3QyLnJhd0NhY2hlKSByb290Mi5yYXdDYWNoZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByb290Mi5yYXdDYWNoZVtkZXRlY3RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIgfHwgZGV0ZWN0ID09PSBcImFmdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwicmF3XCIgKyBjYXBpdGFsaXplKGRldGVjdCk7XG4gICAgICAgICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVdbZGV0ZWN0XTtcbiAgICAgICAgcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ2xvc2UgPSBmdW5jdGlvbiByYXdCZWZvcmVDbG9zZShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVDb21tZW50ID0gZnVuY3Rpb24gcmF3QmVmb3JlQ29tbWVudChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrQ29tbWVudHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZURlY2wgPSBmdW5jdGlvbiByYXdCZWZvcmVEZWNsKHJvb3QyLCBub2RlMikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlT3BlbiA9IGZ1bmN0aW9uIHJhd0JlZm9yZU9wZW4ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIudHlwZSAhPT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2VlbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlUnVsZSA9IGZ1bmN0aW9uIHJhd0JlZm9yZVJ1bGUocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgKGkyLnBhcmVudCAhPT0gcm9vdDIgfHwgcm9vdDIuZmlyc3QgIT09IGkyKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdDb2xvbiA9IGZ1bmN0aW9uIHJhd0NvbG9uKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0RlY2xzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmV0d2VlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0VtcHR5Qm9keSA9IGZ1bmN0aW9uIHJhd0VtcHR5Qm9keShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0luZGVudCA9IGZ1bmN0aW9uIHJhd0luZGVudChyb290Mikge1xuICAgICAgICBpZiAocm9vdDIucmF3cy5pbmRlbnQpIHJldHVybiByb290Mi5yYXdzLmluZGVudDtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGkyLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwICYmIHAgIT09IHJvb3QyICYmIHAucGFyZW50ICYmIHAucGFyZW50ID09PSByb290Mikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gaTIucmF3cy5iZWZvcmUuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1NlbWljb2xvbiA9IGZ1bmN0aW9uIHJhd1NlbWljb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiBpMi5ub2Rlcy5sZW5ndGggJiYgaTIubGFzdC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5zZW1pY29sb247XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd1ZhbHVlID0gZnVuY3Rpb24gcmF3VmFsdWUobm9kZTIsIHByb3ApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZTJbcHJvcF07XG4gICAgICAgIHZhciByYXcgPSBub2RlMi5yYXdzW3Byb3BdO1xuICAgICAgICBpZiAocmF3ICYmIHJhdy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByYXcucmF3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yb290ID0gZnVuY3Rpb24gcm9vdChub2RlMikge1xuICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5hZnRlcikgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3MuYWZ0ZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYmxvY2sobm9kZTIsIHRoaXMucmF3VmFsdWUobm9kZTIsIFwic2VsZWN0b3JcIikpO1xuICAgICAgICBpZiAobm9kZTIucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLm93blNlbWljb2xvbiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgaWYgKCF0aGlzW25vZGUyLnR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEFTVCBub2RlIHR5cGUgXCIgKyBub2RlMi50eXBlICsgXCIuIE1heWJlIHlvdSBuZWVkIHRvIGNoYW5nZSBQb3N0Q1NTIHN0cmluZ2lmaWVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW25vZGUyLnR5cGVdKG5vZGUyLCBzZW1pY29sb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmluZ2lmaWVyMjtcbn0oKTtcbnZhciBzdHJpbmdpZmllciA9IFN0cmluZ2lmaWVyJDI7XG5TdHJpbmdpZmllciQyLmRlZmF1bHQgPSBTdHJpbmdpZmllciQyO1xudmFyIFN0cmluZ2lmaWVyJDEgPSBzdHJpbmdpZmllcjtcbmZ1bmN0aW9uIHN0cmluZ2lmeSQ0KG5vZGUyLCBidWlsZGVyKSB7XG4gICAgdmFyIHN0ciA9IG5ldyBTdHJpbmdpZmllciQxKGJ1aWxkZXIpO1xuICAgIHN0ci5zdHJpbmdpZnkobm9kZTIpO1xufVxudmFyIHN0cmluZ2lmeV8xID0gc3RyaW5naWZ5JDQ7XG5zdHJpbmdpZnkkNC5kZWZhdWx0ID0gc3RyaW5naWZ5JDQ7XG52YXIgaXNDbGVhbiQyID0gc3ltYm9scy5pc0NsZWFuLCBteSQyID0gc3ltYm9scy5teTtcbnZhciBDc3NTeW50YXhFcnJvciQyID0gY3NzU3ludGF4RXJyb3I7XG52YXIgU3RyaW5naWZpZXIyMiA9IHN0cmluZ2lmaWVyO1xudmFyIHN0cmluZ2lmeSQzID0gc3RyaW5naWZ5XzE7XG5mdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcbiAgICB2YXIgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuICAgIGZvcih2YXIgaTIgaW4gb2JqKXtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMiA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbaTJdO1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSk7XG4gICAgICAgIGlmIChpMiA9PT0gXCJwYXJlbnRcIiAmJiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50KSBjbG9uZWRbaTJdID0gcGFyZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGkyID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZU5vZGUoaiwgY2xvbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNsb25lZFtpMl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xufVxudmFyIE5vZGUkNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9kZTMoZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzID09PSB2b2lkIDApIGRlZmF1bHRzID0ge307XG4gICAgICAgIHRoaXMucmF3cyA9IHt9O1xuICAgICAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tteSQyXSA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBkZWZhdWx0cyl7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGRlZmF1bHRzW25hbWVdKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlMi5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMi5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBOb2RlMy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZFRvRXJyb3IgPSBmdW5jdGlvbiBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnBvc3Rjc3NOb2RlID0gdGhpcztcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICAgICAgICB2YXIgczIgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxuXFxzezR9YXQgLywgXCIkJlwiICsgczIuaW5wdXQuZnJvbSArIFwiOlwiICsgczIuc3RhcnQubGluZSArIFwiOlwiICsgczIuc3RhcnQuY29sdW1uICsgXCIkJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBfcHJvdG8uYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gb3ZlcnJpZGVzKXtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGFkZCkge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgYWRkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYW5SYXdzID0gZnVuY3Rpb24gY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlO1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmFmdGVyO1xuICAgICAgICBpZiAoIWtlZXBCZXR3ZWVuKSBkZWxldGUgdGhpcy5yYXdzLmJldHdlZW47XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IGNsb25lTm9kZSh0aGlzKTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUFmdGVyID0gZnVuY3Rpb24gY2xvbmVBZnRlcihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZUJlZm9yZSA9IGZ1bmN0aW9uIGNsb25lQmVmb3JlKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gdGhpcy5jbG9uZShvdmVycmlkZXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKTtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpc19yYW5nZUJ5ID0gdGhpcy5yYW5nZUJ5KG9wdHMpLCBlbmQgPSBfdGhpc19yYW5nZUJ5LmVuZCwgc3RhcnQgPSBfdGhpc19yYW5nZUJ5LnN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZC5saW5lXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENzc1N5bnRheEVycm9yJDIobWVzc2FnZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqLyBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5KCkge1xuICAgICAgICBpZiAodGhpc1tpc0NsZWFuJDJdKSB7XG4gICAgICAgICAgICB0aGlzW2lzQ2xlYW4kMl0gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlKG5leHQgPSBuZXh0LnBhcmVudCl7XG4gICAgICAgICAgICAgICAgbmV4dFtpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gICAgfTtcbiAgICBfcHJvdG8ucG9zaXRpb25CeSA9IGZ1bmN0aW9uIHBvc2l0aW9uQnkob3B0cywgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgICAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uSW5zaWRlID0gZnVuY3Rpb24gcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKyl7XG4gICAgICAgICAgICBpZiAoc3RyaW5nW2kyXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnJhbmdlQnkgPSBmdW5jdGlvbiByYW5nZUJ5KG9wdHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyICsgb3B0cy53b3JkLmxlbmd0aCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5lbmRJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8IGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGVuZC5jb2x1bW4gPD0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIyMigpO1xuICAgICAgICByZXR1cm4gc3RyLnJhdyh0aGlzLCBwcm9wLCBkZWZhdWx0VHlwZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBub2RlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgYm9va21hcmsgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZvdW5kU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgYm9va21hcmsgPSBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kU2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3QoKSB7XG4gICAgICAgIHZhciByZXN1bHQyID0gdGhpcztcbiAgICAgICAgd2hpbGUocmVzdWx0Mi5wYXJlbnQgJiYgcmVzdWx0Mi5wYXJlbnQudHlwZSAhPT0gXCJkb2N1bWVudFwiKXtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oXywgaW5wdXRzKSB7XG4gICAgICAgIHZhciBmaXhlZCA9IHt9O1xuICAgICAgICB2YXIgZW1pdElucHV0cyA9IGlucHV0cyA9PSBudWxsO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGlucHV0c05leHRJbmRleCA9IDA7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzKXtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJwYXJlbnRcIiB8fCBuYW1lID09PSBcInByb3h5Q2FjaGVcIikgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi50b0pTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMi50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZS50b0pTT04obnVsbCwgaW5wdXRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dElkID0gaW5wdXRzTmV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNOZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZDogdmFsdWUuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dElkOiBpbnB1dElkLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdmFsdWUuc3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbWl0SW5wdXRzKSB7XG4gICAgICAgICAgICBmaXhlZC5pbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzLmtleXMoKSkubWFwKGZ1bmN0aW9uKGlucHV0Mikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDIudG9KU09OKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8udG9Qcm94eSA9IGZ1bmN0aW9uIHRvUHJveHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZpZXIyKSB7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIgPT09IHZvaWQgMCkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZ5JDM7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIHN0cmluZ2lmaWVyMih0aGlzLCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgaTIgaW4gb3B0cylkYXRhW2kyXSA9IG9wdHNbaTJdO1xuICAgICAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb2RlMywgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJveHlPZlwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9kZTM7XG59KCk7XG52YXIgbm9kZSA9IE5vZGUkNDtcbk5vZGUkNC5kZWZhdWx0ID0gTm9kZSQ0O1xudmFyIE5vZGUkMyA9IG5vZGU7XG52YXIgRGVjbGFyYXRpb24kNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQzKSB7XG4gICAgX2luaGVyaXRzKERlY2xhcmF0aW9uMiwgTm9kZSQzKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGlvbjIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBpZiAoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBOb2RlJDMuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiZGVjbFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoRGVjbGFyYXRpb24yLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5zdGFydHNXaXRoKFwiLS1cIikgfHwgdGhpcy5wcm9wWzBdID09PSBcIiRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjI7XG59KE5vZGUkMyk7XG52YXIgZGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbiQ0O1xuRGVjbGFyYXRpb24kNC5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNDtcbnZhciB1cmxBbHBoYWJldCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xudmFyIG5hbm9pZCQxID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHNpemUgPSAyMTtcbiAgICB2YXIgaWQgPSBcIlwiO1xuICAgIHZhciBpMiA9IHNpemU7XG4gICAgd2hpbGUoaTItLSl7XG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG59O1xudmFyIG5vblNlY3VyZSA9IHtcbiAgICBuYW5vaWQ6IG5hbm9pZCQxfTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQyID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDIgPSByZXF1aXJlJCQyLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBleGlzdHNTeW5jID0gcmVxdWlyZSQkMi5leGlzdHNTeW5jLCByZWFkRmlsZVN5bmMgPSByZXF1aXJlJCQyLnJlYWRGaWxlU3luYztcbnZhciBkaXJuYW1lJDEgPSByZXF1aXJlJCQyLmRpcm5hbWUsIGpvaW4gPSByZXF1aXJlJCQyLmpvaW47XG5mdW5jdGlvbiBmcm9tQmFzZTY0KHN0cikge1xuICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2luZG93LmF0b2Ioc3RyKTtcbiAgICB9XG59XG52YXIgUHJldmlvdXNNYXAkMiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJldmlvdXNNYXAyKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgICAgIHZhciBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgICAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEodGhpcy5tYXBGaWxlKTtcbiAgICAgICAgaWYgKHRleHQpIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcmV2aW91c01hcDIucHJvdG90eXBlO1xuICAgIF9wcm90by5jb25zdW1lciA9IGZ1bmN0aW9uIGNvbnN1bWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyJDIodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY29kZUlubGluZSA9IGZ1bmN0aW9uIGRlY29kZUlubGluZSh0ZXh0KSB7XG4gICAgICAgIHZhciBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgICAgIHZhciBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICAgICAgdmFyIGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC87XG4gICAgICAgIHZhciB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQmFzZTY0KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuY29kaW5nID0gdGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyBcIiArIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBbm5vdGF0aW9uVVJMID0gZnVuY3Rpb24gZ2V0QW5ub3RhdGlvblVSTChzb3VyY2VNYXBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZU1hcFN0cmluZy5yZXBsYWNlKC9eXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vLCBcIlwiKS50cmltKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNNYXAgPSBmdW5jdGlvbiBpc01hcChtYXApIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbWFwID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKG1hcCkpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWFwLm1hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobWFwLnNlY3Rpb25zKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGxvYWRBbm5vdGF0aW9uKGNzcykge1xuICAgICAgICB2YXIgY29tbWVudHMgPSBjc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9L2dtKTtcbiAgICAgICAgaWYgKCFjb21tZW50cykgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhcnQgPSBjc3MubGFzdEluZGV4T2YoY29tbWVudHMucG9wKCkpO1xuICAgICAgICB2YXIgZW5kID0gY3NzLmluZGV4T2YoXCIqL1wiLCBzdGFydCk7XG4gICAgICAgIGlmIChzdGFydCA+IC0xICYmIGVuZCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb24gPSB0aGlzLmdldEFubm90YXRpb25VUkwoY3NzLnN1YnN0cmluZyhzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkRmlsZSA9IGZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgpIHtcbiAgICAgICAgdGhpcy5yb290ID0gZGlybmFtZSQxKHBhdGgpO1xuICAgICAgICBpZiAoZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMocGF0aCwgXCJ1dGYtOFwiKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRNYXAgPSBmdW5jdGlvbiBsb2FkTWFwKGZpbGUsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UGF0aCA9IHByZXYoZmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmxvYWRGaWxlKHByZXZQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6IFwiICsgcHJldlBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHByZXYsIFNvdXJjZU1hcENvbnN1bWVyJDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvciQyLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwR2VuZXJhdG9yJDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcChwcmV2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcmV2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcHJldmlvdXMgc291cmNlIG1hcCBmb3JtYXQ6IFwiICsgcHJldi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlSW5saW5lKHRoaXMuYW5ub3RhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWFwMSA9IHRoaXMuYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGlmIChmaWxlKSBtYXAxID0gam9pbihkaXJuYW1lJDEoZmlsZSksIG1hcDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdGFydFdpdGggPSBmdW5jdGlvbiBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgICAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgICB9O1xuICAgIF9wcm90by53aXRoQ29udGVudCA9IGZ1bmN0aW9uIHdpdGhDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmV2aW91c01hcDI7XG59KCk7XG52YXIgcHJldmlvdXNNYXAgPSBQcmV2aW91c01hcCQyO1xuUHJldmlvdXNNYXAkMi5kZWZhdWx0ID0gUHJldmlvdXNNYXAkMjtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQxID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yJDEgPSByZXF1aXJlJCQyLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBmaWxlVVJMVG9QYXRoID0gcmVxdWlyZSQkMi5maWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMJDEgPSByZXF1aXJlJCQyLnBhdGhUb0ZpbGVVUkw7XG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUkJDIuaXNBYnNvbHV0ZSwgcmVzb2x2ZSQxID0gcmVxdWlyZSQkMi5yZXNvbHZlO1xudmFyIG5hbm9pZCA9IG5vblNlY3VyZS5uYW5vaWQ7XG52YXIgdGVybWluYWxIaWdobGlnaHQgPSByZXF1aXJlJCQyO1xudmFyIENzc1N5bnRheEVycm9yJDEgPSBjc3NTeW50YXhFcnJvcjtcbnZhciBQcmV2aW91c01hcCQxID0gcHJldmlvdXNNYXA7XG52YXIgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKFwiZnJvbU9mZnNldENhY2hlXCIpO1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxICYmIFNvdXJjZU1hcEdlbmVyYXRvciQxKTtcbnZhciBwYXRoQXZhaWxhYmxlJDEgPSBCb29sZWFuKHJlc29sdmUkMSAmJiBpc0Fic29sdXRlKTtcbnZhciBJbnB1dCQ0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbnB1dDIoY3NzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKGNzcyA9PT0gbnVsbCB8fCB0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiIHx8ICh0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGNzcykpID09PSBcIm9iamVjdFwiICYmICFjc3MudG9TdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1MgcmVjZWl2ZWQgXCIgKyBjc3MgKyBcIiBpbnN0ZWFkIG9mIENTUyBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuY3NzWzBdID09PSBcIlxcdUZFRkZcIiB8fCB0aGlzLmNzc1swXSA9PT0gXCLvv75cIikge1xuICAgICAgICAgICAgdGhpcy5oYXNCT00gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB0aGlzLmNzcy5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFwYXRoQXZhaWxhYmxlJDEgfHwgL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pIHx8IGlzQWJzb2x1dGUob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxKG9wdHMuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUkMSAmJiBzb3VyY2VNYXBBdmFpbGFibGUkMSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBQcmV2aW91c01hcCQxKHRoaXMuY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbWFwLmNvbnN1bWVyKCkuZmlsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiBmaWxlKSB0aGlzLmZpbGUgPSB0aGlzLm1hcFJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBcIjxpbnB1dCBjc3MgXCIgKyBuYW5vaWQoNikgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHRoaXMubWFwLmZpbGUgPSB0aGlzLmZyb207XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJbnB1dDIucHJvdG90eXBlO1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgICAgIGlmIChsaW5lICYmICh0eXBlb2YgbGluZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihsaW5lKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29sdW1uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBzdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBwb3MxLmxpbmU7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gcG9zMS5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBwb3MyID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgICAgICAgbGluZSA9IHBvczIubGluZTtcbiAgICAgICAgICAgIGNvbHVtbiA9IHBvczIuY29sO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMShtZXNzYWdlLCBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmxpbmUgOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW4uY29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbi5saW5lXG4gICAgICAgICAgICB9LCBvcmlnaW4uZW5kTGluZSA9PT0gdm9pZCAwID8gb3JpZ2luLmNvbHVtbiA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbi5lbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luLmVuZExpbmVcbiAgICAgICAgICAgIH0sIG9yaWdpbi5zb3VyY2UsIG9yaWdpbi5maWxlLCBvcHRzLnBsdWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEobWVzc2FnZSwgZW5kTGluZSA9PT0gdm9pZCAwID8gbGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICB9LCBlbmRMaW5lID09PSB2b2lkIDAgPyBjb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSwgdGhpcy5jc3MsIHRoaXMuZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdDIuaW5wdXQgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZSxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuY3NzXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLmZpbGUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQyLmlucHV0LmZpbGUgPSB0aGlzLmZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJvbU9mZnNldCA9IGZ1bmN0aW9uIGZyb21PZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBsYXN0TGluZSwgbGluZVRvSW5kZXg7XG4gICAgICAgIGlmICghdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmNzcy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIGxpbmVUb0luZGV4ID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSAwLCBsMiA9IGxpbmVzLmxlbmd0aDsgaTIgPCBsMjsgaTIrKyl7XG4gICAgICAgICAgICAgICAgbGluZVRvSW5kZXhbaTJdID0gcHJldkluZGV4O1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCArPSBsaW5lc1tpMl0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbZnJvbU9mZnNldENhY2hlXSA9IGxpbmVUb0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExpbmUgPSBsaW5lVG9JbmRleFtsaW5lVG9JbmRleC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIHZhciBtaWQ7XG4gICAgICAgICAgICB3aGlsZShtaW4gPCBtYXgpe1xuICAgICAgICAgICAgICAgIG1pZCA9IG1pbiArIChtYXggLSBtaW4gPj4gMSk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxpbmVUb0luZGV4W21pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgICAgICAgbGluZTogbWluICsgMVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLm1hcFJlc29sdmUgPSBmdW5jdGlvbiBtYXBSZXNvbHZlKGZpbGUpIHtcbiAgICAgICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlJDEodGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHRoaXMubWFwLnJvb3QgfHwgXCIuXCIsIGZpbGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9yaWdpbiA9IGZ1bmN0aW9uIG9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHRoaXMubWFwLmNvbnN1bWVyKCk7XG4gICAgICAgIHZhciBmcm9tID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZnJvbS5zb3VyY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHRvO1xuICAgICAgICBpZiAodHlwZW9mIGVuZExpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21Vcmw7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKGZyb20uc291cmNlKSkge1xuICAgICAgICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMShmcm9tLnNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9tVXJsID0gbmV3IFVSTChmcm9tLnNvdXJjZSwgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwkMSh0aGlzLm1hcC5tYXBGaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDIgPSB7XG4gICAgICAgICAgICBjb2x1bW46IGZyb20uY29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiB0byAmJiB0by5jb2x1bW4sXG4gICAgICAgICAgICBlbmRMaW5lOiB0byAmJiB0by5saW5lLFxuICAgICAgICAgICAgbGluZTogZnJvbS5saW5lLFxuICAgICAgICAgICAgdXJsOiBmcm9tVXJsLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIikge1xuICAgICAgICAgICAgaWYgKGZpbGVVUkxUb1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoKGZyb21VcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWxlOiBwcm90b2NvbCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UpIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHZhciBqc29uID0ge307XG4gICAgICAgIGZvcih2YXIgX2kgPSAwLCBfaXRlciA9IFtcbiAgICAgICAgICAgIFwiaGFzQk9NXCIsXG4gICAgICAgICAgICBcImNzc1wiLFxuICAgICAgICAgICAgXCJmaWxlXCIsXG4gICAgICAgICAgICBcImlkXCJcbiAgICAgICAgXTsgX2kgPCBfaXRlci5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfaXRlcltfaV07XG4gICAgICAgICAgICBpZiAodGhpc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAganNvbltuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBqc29uLm1hcCA9IF9leHRlbmRzKHt9LCB0aGlzLm1hcCk7XG4gICAgICAgICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICAgICAgICAgIGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKElucHV0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZnJvbVwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZSB8fCB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIElucHV0Mjtcbn0oKTtcbnZhciBpbnB1dCA9IElucHV0JDQ7XG5JbnB1dCQ0LmRlZmF1bHQgPSBJbnB1dCQ0O1xuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0ICYmIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQpIHtcbiAgICB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KElucHV0JDQpO1xufVxudmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZGlybmFtZSA9IHJlcXVpcmUkJDIuZGlybmFtZSwgcmVsYXRpdmUgPSByZXF1aXJlJCQyLnJlbGF0aXZlLCByZXNvbHZlJDMgPSByZXF1aXJlJCQyLnJlc29sdmUsIHNlcCA9IHJlcXVpcmUkJDIuc2VwO1xudmFyIHBhdGhUb0ZpbGVVUkwgPSByZXF1aXJlJCQyLnBhdGhUb0ZpbGVVUkw7XG52YXIgSW5wdXQkMyA9IGlucHV0O1xudmFyIHNvdXJjZU1hcEF2YWlsYWJsZSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIgJiYgU291cmNlTWFwR2VuZXJhdG9yKTtcbnZhciBwYXRoQXZhaWxhYmxlID0gQm9vbGVhbihkaXJuYW1lICYmIHJlc29sdmUkMyAmJiByZWxhdGl2ZSAmJiBzZXApO1xudmFyIE1hcEdlbmVyYXRvciQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNYXBHZW5lcmF0b3IyKHN0cmluZ2lmeTIsIHJvb3QyLCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnkyO1xuICAgICAgICB0aGlzLm1hcE9wdHMgPSBvcHRzLm1hcCB8fCB7fTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ1NTID0gY3NzU3RyaW5nO1xuICAgICAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGU7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1hcEdlbmVyYXRvcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRBbm5vdGF0aW9uID0gZnVuY3Rpb24gYWRkQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVvbCA9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICAgICAgdGhpcy5jc3MgKz0gZW9sICsgXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNvbnRlbnQgKyBcIiAqL1wiO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGx5UHJldk1hcHMgPSBmdW5jdGlvbiBhcHBseVByZXZNYXBzKCkge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnByZXZpb3VzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcHJldiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgICAgICAgIHZhciByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lKHByZXYuZmlsZSk7XG4gICAgICAgICAgICB2YXIgbWFwID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocHJldi50ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZyb20sIHRoaXMudG9VcmwodGhpcy5wYXRoKHJvb3QyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJBbm5vdGF0aW9uID0gZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHZhciBub2RlMjtcbiAgICAgICAgICAgIGZvcih2YXIgaTIgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICAgICAgbm9kZTIgPSB0aGlzLnJvb3Qubm9kZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnRleHQuaW5kZXhPZihcIiMgc291cmNlTWFwcGluZ1VSTD1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3MucmVwbGFjZSgvXFxuKj9cXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sIFwiXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHBhdGhBdmFpbGFibGUgJiYgc291cmNlTWFwQXZhaWxhYmxlICYmIHRoaXMuaXNNYXAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNYXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyICs9IGkyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJlc3VsdDJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZU1hcCA9IGZ1bmN0aW9uIGdlbmVyYXRlTWFwKCkge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZpb3VzKClbMF0uY29uc3VtZXIoKTtcbiAgICAgICAgICAgIHByZXYuZmlsZSA9IHRoaXMub3V0cHV0RmlsZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChwcmV2LCB7XG4gICAgICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQW5ub3RhdGlvbigpKSB0aGlzLmFkZEFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGluZSA9IDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICB2YXIgbm9Tb3VyY2UgPSBcIjxubyBzb3VyY2U+XCI7XG4gICAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsaW5lcywgbGFzdDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBmdW5jdGlvbihzdHIsIG5vZGUyLCB0eXBlKSB7XG4gICAgICAgICAgICBfdGhpcy5jc3MgKz0gc3RyO1xuICAgICAgICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gX3RoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5zdGFydC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0ci5sZW5ndGggLSBsYXN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5vZGUyLnBhcmVudCB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHJhd3M6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRsZXNzID0gbm9kZTIudHlwZSA9PT0gXCJkZWNsXCIgfHwgbm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiAhbm9kZTIubm9kZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZGxlc3MgfHwgbm9kZTIgIT09IHAubGFzdCB8fCBwLnJhd3Muc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBfdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUyLnNvdXJjZS5lbmQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLmVuZC5jb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG5vU291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5pc0Fubm90YXRpb24gPSBmdW5jdGlvbiBpc0Fubm90YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLmFubm90YXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5pc0lubGluZSA9IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5pbmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi5pbmxpbmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5pc01hcCA9IGZ1bmN0aW9uIGlzTWFwKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMub3B0cy5tYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLmlzU291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBpc1NvdXJjZXNDb250ZW50KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLndpdGhDb250ZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5vdXRwdXRGaWxlID0gZnVuY3Rpb24gb3V0cHV0RmlsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInRvLmNzc1wiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGF0aCA9IGZ1bmN0aW9uIHBhdGgoZmlsZSkge1xuICAgICAgICBpZiAodGhpcy5tYXBPcHRzLmFic29sdXRlKSByZXR1cm4gZmlsZTtcbiAgICAgICAgaWYgKGZpbGUuY2hhckNvZGVBdCgwKSA9PT0gNjApIHJldHVybiBmaWxlO1xuICAgICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkgcmV0dXJuIGZpbGU7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLm1lbW9pemVkUGF0aHMuZ2V0KGZpbGUpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy50byA/IGRpcm5hbWUodGhpcy5vcHRzLnRvKSA6IFwiLlwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcm9tID0gZGlybmFtZShyZXNvbHZlJDMoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IHJlbGF0aXZlKGZyb20sIGZpbGUpO1xuICAgICAgICB0aGlzLm1lbW9pemVkUGF0aHMuc2V0KGZpbGUsIHBhdGgpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIF9wcm90by5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzTWFwcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlMi5zb3VyY2UgJiYgbm9kZTIuc291cmNlLmlucHV0Lm1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG5vZGUyLnNvdXJjZS5pbnB1dC5tYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByZXZpb3VzTWFwcy5pbmNsdWRlcyhtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJldmlvdXNNYXBzLnB1c2gobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQyID0gbmV3IElucHV0JDModGhpcy5vcmlnaW5hbENTUywgdGhpcy5vcHRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQyLm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dDIubWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c01hcHM7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U291cmNlc0NvbnRlbnQgPSBmdW5jdGlvbiBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFscmVhZHkgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbm9kZTIuc291cmNlLmlucHV0LmZyb207XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tVXJsID0gX3RoaXMudXNlc0ZpbGVVcmxzID8gX3RoaXMudG9GaWxlVXJsKGZyb20pIDogX3RoaXMudG9VcmwoX3RoaXMucGF0aChmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuc2V0U291cmNlQ29udGVudChmcm9tVXJsLCBub2RlMi5zb3VyY2UuaW5wdXQuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbSwgdGhpcy5jc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc291cmNlUGF0aCA9IGZ1bmN0aW9uIHNvdXJjZVBhdGgobm9kZTIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLm1hcE9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VzRmlsZVVybHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRmlsZVVybChub2RlMi5zb3VyY2UuaW5wdXQuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1VybCh0aGlzLnBhdGgobm9kZTIuc291cmNlLmlucHV0LmZyb20pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvQmFzZTY0ID0gZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgICAgIGlmIChCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0ZpbGVVcmwgPSBmdW5jdGlvbiB0b0ZpbGVVcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZEZpbGVVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHBhdGhUb0ZpbGVVUkwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTChwYXRoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5tZW1vaXplZEZpbGVVUkxzLnNldChwYXRoLCBmaWxlVVJMKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlVVJMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG1hcC5hYnNvbHV0ZWAgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9VcmwgPSBmdW5jdGlvbiB0b1VybChwYXRoKSB7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLm1lbW9pemVkVVJMcy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGlmIChzZXAgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoL1sjP10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFVSTHMuc2V0KHBhdGgsIHVybCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwR2VuZXJhdG9yMjtcbn0oKTtcbnZhciBtYXBHZW5lcmF0b3IgPSBNYXBHZW5lcmF0b3IkMjtcbnZhciBOb2RlJDIgPSBub2RlO1xudmFyIENvbW1lbnQkNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oTm9kZSQyKSB7XG4gICAgX2luaGVyaXRzKENvbW1lbnQyLCBOb2RlJDIpO1xuICAgIGZ1bmN0aW9uIENvbW1lbnQyKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBOb2RlJDIuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiY29tbWVudFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21tZW50Mjtcbn0oTm9kZSQyKTtcbnZhciBjb21tZW50ID0gQ29tbWVudCQ0O1xuQ29tbWVudCQ0LmRlZmF1bHQgPSBDb21tZW50JDQ7XG52YXIgaXNDbGVhbiQxID0gc3ltYm9scy5pc0NsZWFuLCBteSQxID0gc3ltYm9scy5teTtcbnZhciBEZWNsYXJhdGlvbiQzID0gZGVjbGFyYXRpb247XG52YXIgQ29tbWVudCQzID0gY29tbWVudDtcbnZhciBOb2RlJDEgPSBub2RlO1xudmFyIHBhcnNlJDQsIFJ1bGUkNCwgQXRSdWxlJDQsIFJvb3QkNjtcbmZ1bmN0aW9uIGNsZWFuU291cmNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICBpZiAoaTIubm9kZXMpIGkyLm5vZGVzID0gY2xlYW5Tb3VyY2UoaTIubm9kZXMpO1xuICAgICAgICBkZWxldGUgaTIuc291cmNlO1xuICAgICAgICByZXR1cm4gaTI7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXJrRGlydHlVcChub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kMV0gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIucHJveHlPZi5ub2Rlcykge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlMi5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGkyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBtYXJrRGlydHlVcChpMik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgQ29udGFpbmVyJDcgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMSkge1xuICAgIF9pbmhlcml0cyhDb250YWluZXIyLCBOb2RlJDEpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcjIoKSB7XG4gICAgICAgIHJldHVybiBOb2RlJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ29udGFpbmVyMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGNoaWxkcmVuKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2gobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBOb2RlJDEucHJvdG90eXBlLmNsZWFuUmF3cy5jYWxsKHRoaXMsIGtlZXBCZXR3ZWVuKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgbm9kZTIuY2xlYW5SYXdzKGtlZXBCZXR3ZWVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHZhciBpbmRleDIsIHJlc3VsdDI7XG4gICAgICAgIHdoaWxlKHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPCB0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgICAgICByZXN1bHQyID0gY2FsbGJhY2sodGhpcy5wcm94eU9mLm5vZGVzW2luZGV4Ml0sIGluZGV4Mik7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by5ldmVyeSA9IGZ1bmN0aW9uIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDA7XG4gICAgICAgIGlmICghdGhpcy5pbmRleGVzKSB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sYXN0RWFjaCArPSAxO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmxhc3RFYWNoO1xuICAgICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByb3h5UHJvY2Vzc29yID0gZnVuY3Rpb24gZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghbm9kZTJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJlYWNoXCIgfHwgdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgJiYgcHJvcC5zdGFydHNXaXRoKFwid2Fsa1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbm9kZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9ub2RlMiA9IG5vZGUyKVtwcm9wXS5hcHBseShfbm9kZTIsIFtdLmNvbmNhdChhcmdzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2hpbGQsIGluZGV4Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyKGNoaWxkLnRvUHJveHkoKSwgaW5kZXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZXZlcnlcIiB8fCBwcm9wID09PSBcInNvbWVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXShmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG90aGVyID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcltfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnRvUHJveHkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIG90aGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5ub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMi50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJmaXJzdFwiIHx8IHByb3AgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChub2RlMiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTJbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwic2VsZWN0b3JcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5kZXggPSBmdW5jdGlvbiBpbmRleChjaGlsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiKSByZXR1cm4gY2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZC5wcm94eU9mKSBjaGlsZCA9IGNoaWxkLnByb3h5T2Y7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihleGlzdCwgYWRkKSB7XG4gICAgICAgIHZhciBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdKS5yZXZlcnNlKCk7XG4gICAgICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCArIDEsIDAsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShleGlzdCwgYWRkKSB7XG4gICAgICAgIHZhciBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIHZhciB0eXBlID0gZXhpc3RJbmRleCA9PT0gMCA/IFwicHJlcGVuZFwiIDogZmFsc2U7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGFkZCwgdGhpcy5wcm94eU9mLm5vZGVzW2V4aXN0SW5kZXhdLCB0eXBlKS5yZXZlcnNlKCk7XG4gICAgICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCwgMCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyICsgbm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShub2Rlcywgc2FtcGxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gY2xlYW5Tb3VyY2UocGFyc2UkNChub2Rlcykubm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaTIxLnBhcmVudCkgaTIxLnBhcmVudC5yZW1vdmVDaGlsZChpMjEsIFwiaWdub3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uJDMobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgUnVsZSQ0KG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5uYW1lKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQXRSdWxlJDQobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBDb21tZW50JDMobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvY2Vzc2VkID0gbm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoIWkyW215JDFdKSBDb250YWluZXIyLnJlYnVpbGQoaTIpO1xuICAgICAgICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgIGlmIChpMltpc0NsZWFuJDFdKSBtYXJrRGlydHlVcChpMik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZSAmJiB0eXBlb2Ygc2FtcGxlLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGkyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpMi5wYXJlbnQgPSBfdGhpcy5wcm94eU9mO1xuICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShjaGlsZHJlbiksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsIFwicHJlcGVuZFwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy51bnNoaWZ0KG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gdGhpcy5pbmRleGVzW2lkXSArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChjaGlsZCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wcm94eU9mLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBub2RlMi5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzW2NoaWxkXS5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA+PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VWYWx1ZXMgPSBmdW5jdGlvbiByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm9wcyAmJiAhb3B0cy5wcm9wcy5pbmNsdWRlcyhkZWNsLnByb3ApKSByZXR1cm47XG4gICAgICAgICAgICBpZiAob3B0cy5mYXN0ICYmICFkZWNsLnZhbHVlLmluY2x1ZGVzKG9wdHMuZmFzdCkpIHJldHVybjtcbiAgICAgICAgICAgIGRlY2wudmFsdWUgPSBkZWNsLnZhbHVlLnJlcGxhY2UocGF0dGVybiwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrID0gZnVuY3Rpb24gd2FsayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtBdFJ1bGVzID0gZnVuY3Rpb24gd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YobmFtZSwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImF0cnVsZVwiICYmIGNoaWxkLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0NvbW1lbnRzID0gZnVuY3Rpb24gd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa0RlY2xzID0gZnVuY3Rpb24gd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihwcm9wLCBSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIiAmJiBjaGlsZC5wcm9wID09PSBwcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtSdWxlcyA9IGZ1bmN0aW9uIHdhbGtSdWxlcyhzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaW5zdGFuY2VvZihzZWxlY3RvciwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIiAmJiBjaGlsZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKENvbnRhaW5lcjIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZpcnN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibGFzdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ29udGFpbmVyMjtcbn0oTm9kZSQxKTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUGFyc2UgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBwYXJzZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJ1bGUkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlckF0UnVsZSA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIEF0UnVsZSQ0ID0gZGVwZW5kYW50O1xufTtcbkNvbnRhaW5lciQ3LnJlZ2lzdGVyUm9vdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJvb3QkNiA9IGRlcGVuZGFudDtcbn07XG52YXIgY29udGFpbmVyID0gQ29udGFpbmVyJDc7XG5Db250YWluZXIkNy5kZWZhdWx0ID0gQ29udGFpbmVyJDc7XG5Db250YWluZXIkNy5yZWJ1aWxkID0gZnVuY3Rpb24obm9kZTIpIHtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0LnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJ1bGUkNC5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBEZWNsYXJhdGlvbiQzLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMy5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSb290JDYucHJvdG90eXBlKTtcbiAgICB9XG4gICAgbm9kZTJbbXkkMV0gPSB0cnVlO1xuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICBub2RlMi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBDb250YWluZXIkNy5yZWJ1aWxkKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBDb250YWluZXIkNiA9IGNvbnRhaW5lcjtcbnZhciBMYXp5UmVzdWx0JDQsIFByb2Nlc3NvciQzO1xudmFyIERvY3VtZW50JDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ2KSB7XG4gICAgX2luaGVyaXRzKERvY3VtZW50MjMsIENvbnRhaW5lciQ2KTtcbiAgICBmdW5jdGlvbiBEb2N1bWVudDIzKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNi5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9jdW1lbnRcIlxuICAgICAgICB9LCBkZWZhdWx0cykpIHx8IHRoaXM7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG9jdW1lbnQyMy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvUmVzdWx0ID0gZnVuY3Rpb24gdG9SZXN1bHQob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciBsYXp5ID0gbmV3IExhenlSZXN1bHQkNChuZXcgUHJvY2Vzc29yJDMoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERvY3VtZW50MjM7XG59KENvbnRhaW5lciQ2KTtcbkRvY3VtZW50JDMucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQ0ID0gZGVwZW5kYW50O1xufTtcbkRvY3VtZW50JDMucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMyA9IGRlcGVuZGFudDtcbn07XG52YXIgZG9jdW1lbnQkMSQyID0gRG9jdW1lbnQkMztcbkRvY3VtZW50JDMuZGVmYXVsdCA9IERvY3VtZW50JDM7XG52YXIgcHJpbnRlZCA9IHt9O1xudmFyIHdhcm5PbmNlJDIgPSBmdW5jdGlvbiB3YXJuT25jZTIobWVzc2FnZSkge1xuICAgIGlmIChwcmludGVkW21lc3NhZ2VdKSByZXR1cm47XG4gICAgcHJpbnRlZFttZXNzYWdlXSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxufTtcbnZhciBXYXJuaW5nJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdhcm5pbmcyKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBvcHRzLm5vZGUucmFuZ2VCeShvcHRzKTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZSA9IHJhbmdlLmVuZC5saW5lO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgb3B0IGluIG9wdHMpdGhpc1tvcHRdID0gb3B0c1tvcHRdO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gV2FybmluZzIucHJvdG90eXBlO1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmVycm9yKHRoaXMudGV4dCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIHBsdWdpbjogdGhpcy5wbHVnaW4sXG4gICAgICAgICAgICAgICAgd29yZDogdGhpcy53b3JkXG4gICAgICAgICAgICB9KS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBsdWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luICsgXCI6IFwiICsgdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gV2FybmluZzI7XG59KCk7XG52YXIgd2FybmluZyA9IFdhcm5pbmckMjtcbldhcm5pbmckMi5kZWZhdWx0ID0gV2FybmluZyQyO1xudmFyIFdhcm5pbmckMSA9IHdhcm5pbmc7XG52YXIgUmVzdWx0JDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJlc3VsdDIocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNzcyA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSZXN1bHQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbHVnaW4gPSB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmluZzIgPSBuZXcgV2FybmluZyQxKHRleHQsIG9wdHMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2god2FybmluZzIpO1xuICAgICAgICByZXR1cm4gd2FybmluZzI7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhSZXN1bHQyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUmVzdWx0Mjtcbn0oKTtcbnZhciByZXN1bHQgPSBSZXN1bHQkMztcblJlc3VsdCQzLmRlZmF1bHQgPSBSZXN1bHQkMztcbnZhciBTSU5HTEVfUVVPVEUgPSBcIidcIi5jaGFyQ29kZUF0KDApO1xudmFyIERPVUJMRV9RVU9URSA9ICdcIicuY2hhckNvZGVBdCgwKTtcbnZhciBCQUNLU0xBU0ggPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xudmFyIFNMQVNIID0gXCIvXCIuY2hhckNvZGVBdCgwKTtcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xudmFyIFNQQUNFID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbnZhciBGRUVEID0gXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xudmFyIFRBQiA9IFwiXHRcIi5jaGFyQ29kZUF0KDApO1xudmFyIENSID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fU1FVQVJFID0gXCJbXCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9TUVVBUkUgPSBcIl1cIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fUEFSRU5USEVTRVMgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1BBUkVOVEhFU0VTID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX0NVUkxZID0gXCJ7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9DVVJMWSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0VNSUNPTE9OID0gXCI7XCIuY2hhckNvZGVBdCgwKTtcbnZhciBBU1RFUklTSyA9IFwiKlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ09MT04gPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFUID0gXCJAXCIuY2hhckNvZGVBdCgwKTtcbnZhciBSRV9BVF9FTkQgPSAvW1xcdFxcblxcZlxcciBcIiMnKCkvO1tcXFxcXFxde31dL2c7XG52YXIgUkVfV09SRF9FTkQgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xudmFyIFJFX0JBRF9CUkFDS0VUID0gLy5bXFxyXFxuXCInKC9cXFxcXS87XG52YXIgUkVfSEVYX0VTQ0FQRSA9IC9bXFxkYS1mXS9pO1xudmFyIHRva2VuaXplID0gZnVuY3Rpb24gdG9rZW5pemVyMihpbnB1dDIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgdmFyIGNzcyA9IGlucHV0Mi5jc3MudmFsdWVPZigpO1xuICAgIHZhciBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9ycztcbiAgICB2YXIgY29kZSwgbmV4dCwgcXVvdGUsIGNvbnRlbnQsIGVzY2FwZTtcbiAgICB2YXIgZXNjYXBlZCwgZXNjYXBlUG9zLCBwcmV2LCBuMiwgY3VycmVudFRva2VuO1xuICAgIHZhciBsZW5ndGggPSBjc3MubGVuZ3RoO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgcmV0dXJuZWQgPSBbXTtcbiAgICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCkge1xuICAgICAgICB0aHJvdyBpbnB1dDIuZXJyb3IoXCJVbmNsb3NlZCBcIiArIHdoYXQsIHBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZE9mRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHJldHVybmVkLmxlbmd0aCA9PT0gMCAmJiBwb3MgPj0gbGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0VG9rZW4ob3B0cykge1xuICAgICAgICBpZiAocmV0dXJuZWQubGVuZ3RoKSByZXR1cm4gcmV0dXJuZWQucG9wKCk7XG4gICAgICAgIGlmIChwb3MgPj0gbGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHZhciBpZ25vcmVVbmNsb3NlZCA9IG9wdHMgPyBvcHRzLmlnbm9yZVVuY2xvc2VkIDogZmFsc2U7XG4gICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgICBjYXNlIE5FV0xJTkU6XG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgY2FzZSBUQUI6XG4gICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgY2FzZSBGRUVEOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGNvZGUgPT09IFNQQUNFIHx8IGNvZGUgPT09IE5FV0xJTkUgfHwgY29kZSA9PT0gVEFCIHx8IGNvZGUgPT09IENSIHx8IGNvZGUgPT09IEZFRUQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFOlxuICAgICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWTpcbiAgICAgICAgICAgIGNhc2UgQ09MT046XG4gICAgICAgICAgICBjYXNlIFNFTUlDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfUEFSRU5USEVTRVM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBidWZmZXIubGVuZ3RoID8gYnVmZmVyLnBvcCgpWzFdIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBjc3MuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IFwidXJsXCIgJiYgbjIgIT09IFNJTkdMRV9RVU9URSAmJiBuMiAhPT0gRE9VQkxFX1FVT1RFICYmIG4yICE9PSBTUEFDRSAmJiBuMiAhPT0gTkVXTElORSAmJiBuMiAhPT0gVEFCICYmIG4yICE9PSBGRUVEICYmIG4yICE9PSBDUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTSU5HTEVfUVVPVEU6XG4gICAgICAgICAgICBjYXNlIERPVUJMRV9RVU9URTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFID8gXCInXCIgOiAnXCInO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQVQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgUkVfQVRfRU5ELnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0FUX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQubGFzdEluZGV4IC0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImF0LXdvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCQUNLU0xBU0g6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IEJBQ0tTTEFTSCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGUgJiYgY29kZSAhPT0gU0xBU0ggJiYgY29kZSAhPT0gU1BBQ0UgJiYgY29kZSAhPT0gTkVXTElORSAmJiBjb2RlICE9PSBUQUIgJiYgY29kZSAhPT0gQ1IgJiYgY29kZSAhPT0gRkVFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKFJFX0hFWF9FU0NBUEUudGVzdChjc3MuY2hhckF0KG5leHQgKyAxKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3MuY2hhckNvZGVBdChuZXh0ICsgMSkgPT09IFNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0ggJiYgY3NzLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIqL1wiLCBwb3MgKyAyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgUkVfV09SRF9FTkQubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5ELnRlc3QoY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9XT1JEX0VORC5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgICAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogYmFjayxcbiAgICAgICAgZW5kT2ZGaWxlOiBlbmRPZkZpbGUsXG4gICAgICAgIG5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICB9O1xufTtcbnZhciBDb250YWluZXIkNSA9IGNvbnRhaW5lcjtcbnZhciBBdFJ1bGUkMyA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDUpIHtcbiAgICBfaW5oZXJpdHMoQXRSdWxlMiwgQ29udGFpbmVyJDUpO1xuICAgIGZ1bmN0aW9uIEF0UnVsZTIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ1LmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImF0cnVsZVwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBdFJ1bGUyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNV9wcm90b3R5cGVfYXBwZW5kO1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKF9Db250YWluZXIkNV9wcm90b3R5cGVfYXBwZW5kID0gQ29udGFpbmVyJDUucHJvdG90eXBlLmFwcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDVfcHJvdG90eXBlX2FwcGVuZCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfQ29udGFpbmVyJDVfcHJvdG90eXBlX3ByZXBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9wcmVwZW5kID0gQ29udGFpbmVyJDUucHJvdG90eXBlLnByZXBlbmQpLmNhbGwuYXBwbHkoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9wcmVwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0UnVsZTI7XG59KENvbnRhaW5lciQ1KTtcbnZhciBhdFJ1bGUgPSBBdFJ1bGUkMztcbkF0UnVsZSQzLmRlZmF1bHQgPSBBdFJ1bGUkMztcbkNvbnRhaW5lciQ1LnJlZ2lzdGVyQXRSdWxlKEF0UnVsZSQzKTtcbnZhciBDb250YWluZXIkNCA9IGNvbnRhaW5lcjtcbnZhciBMYXp5UmVzdWx0JDMsIFByb2Nlc3NvciQyO1xudmFyIFJvb3QkNSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDQpIHtcbiAgICBfaW5oZXJpdHMoUm9vdDIsIENvbnRhaW5lciQ0KTtcbiAgICBmdW5jdGlvbiBSb290MihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDQuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwicm9vdFwiO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBSb290Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgICAgIHZhciBub2RlcyA9IENvbnRhaW5lciQ0LnByb3RvdHlwZS5ub3JtYWxpemUuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICAgIGlmIChzYW1wbGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInByZXBlbmRcIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdCAhPT0gc2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQsIGlnbm9yZSkge1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgICAgIGlmICghaWdub3JlICYmIGluZGV4MiA9PT0gMCAmJiB0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzW2luZGV4Ml0ucmF3cy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnRhaW5lciQ0LnByb3RvdHlwZS5yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1Jlc3VsdCA9IGZ1bmN0aW9uIHRvUmVzdWx0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDMobmV3IFByb2Nlc3NvciQyKCksIHRoaXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgICB9O1xuICAgIHJldHVybiBSb290Mjtcbn0oQ29udGFpbmVyJDQpO1xuUm9vdCQ1LnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIExhenlSZXN1bHQkMyA9IGRlcGVuZGFudDtcbn07XG5Sb290JDUucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgcm9vdCA9IFJvb3QkNTtcblJvb3QkNS5kZWZhdWx0ID0gUm9vdCQ1O1xuQ29udGFpbmVyJDQucmVnaXN0ZXJSb290KFJvb3QkNSk7XG52YXIgbGlzdCQyID0ge1xuICAgIGNvbW1hOiBmdW5jdGlvbiBjb21tYShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QkMi5zcGxpdChzdHJpbmcsIFtcbiAgICAgICAgICAgIFwiLFwiXG4gICAgICAgIF0sIHRydWUpO1xuICAgIH0sXG4gICAgc3BhY2U6IGZ1bmN0aW9uIHNwYWNlKHN0cmluZykge1xuICAgICAgICB2YXIgc3BhY2VzID0gW1xuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgXCJcdFwiXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBsaXN0JDIuc3BsaXQoc3RyaW5nLCBzcGFjZXMpO1xuICAgIH0sXG4gICAgc3BsaXQ6IGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZ1bmMgPSAwO1xuICAgICAgICB2YXIgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJldlF1b3RlID0gXCJcIjtcbiAgICAgICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShzdHJpbmcpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpblF1b3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldHRlciA9PT0gcHJldlF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1wiJyB8fCBsZXR0ZXIgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldlF1b3RlID0gbGV0dGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgZnVuYyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMgPiAwKSBmdW5jIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9ycy5pbmNsdWRlcyhsZXR0ZXIpKSBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBsZXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3QgfHwgY3VycmVudCAhPT0gXCJcIikgYXJyYXkucHVzaChjdXJyZW50LnRyaW0oKSk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG59O1xudmFyIGxpc3RfMSA9IGxpc3QkMjtcbmxpc3QkMi5kZWZhdWx0ID0gbGlzdCQyO1xudmFyIENvbnRhaW5lciQzID0gY29udGFpbmVyO1xudmFyIGxpc3QkMSA9IGxpc3RfMTtcbnZhciBSdWxlJDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQzKSB7XG4gICAgX2luaGVyaXRzKFJ1bGUyLCBDb250YWluZXIkMyk7XG4gICAgZnVuY3Rpb24gUnVsZTIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQzLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKFJ1bGUyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0JDEuY29tbWEodGhpcy5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IubWF0Y2goLyxcXHMqLykgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzZXAyID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiLFwiICsgdGhpcy5yYXcoXCJiZXR3ZWVuXCIsIFwiYmVmb3JlT3BlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdmFsdWVzLmpvaW4oc2VwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gUnVsZTI7XG59KENvbnRhaW5lciQzKTtcbnZhciBydWxlID0gUnVsZSQzO1xuUnVsZSQzLmRlZmF1bHQgPSBSdWxlJDM7XG5Db250YWluZXIkMy5yZWdpc3RlclJ1bGUoUnVsZSQzKTtcbnZhciBEZWNsYXJhdGlvbiQyID0gZGVjbGFyYXRpb247XG52YXIgdG9rZW5pemVyMjIgPSB0b2tlbml6ZTtcbnZhciBDb21tZW50JDIgPSBjb21tZW50O1xudmFyIEF0UnVsZSQyID0gYXRSdWxlO1xudmFyIFJvb3QkNCA9IHJvb3Q7XG52YXIgUnVsZSQyID0gcnVsZTtcbnZhciBTQUZFX0NPTU1FTlRfTkVJR0hCT1IgPSB7XG4gICAgZW1wdHk6IHRydWUsXG4gICAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpIHtcbiAgICBmb3IodmFyIGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICB2YXIgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl07XG4gICAgICAgIGlmIChwb3MpIHJldHVybiBwb3M7XG4gICAgfVxufVxudmFyIFBhcnNlciQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIyKGlucHV0Mikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnNlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuaXplcigpO1xuICAgICAgICB0aGlzLnJvb3Quc291cmNlID0ge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0MixcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQYXJzZXIyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBBdFJ1bGUkMigpO1xuICAgICAgICBub2RlMi5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSk7XG4gICAgICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgc2hpZnQ7XG4gICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgICAgIHdoaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocHJldiAmJiBwcmV2WzBdID09PSBcInNwYWNlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHByZXZbM10gfHwgcHJldlsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcyk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnBhcmFtcyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgICAgIHZhciBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICAgICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZm91bmRlZCA9IDA7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgZm9yKHZhciBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiTWlzc2VkIHNlbWljb2xvblwiLCB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY29sb24gPSBmdW5jdGlvbiBjb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gMDtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlLCBwcmV2O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0b2tlbnMuZW50cmllcygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIGkyID0gX3N0ZXBfdmFsdWVbMF0sIGVsZW1lbnQgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQ29tbWVudCQyKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblszXSB8fCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgIHZhciB0ZXh0ID0gdG9rZW5bMV0uc2xpY2UoMiwgLTIpO1xuICAgICAgICBpZiAoL15cXHMqJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgbm9kZTIudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmxlZnQgPSB0ZXh0O1xuICAgICAgICAgICAgbm9kZTIucmF3cy5yaWdodCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pO1xuICAgICAgICAgICAgbm9kZTIudGV4dCA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gbWF0Y2hbM107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVUb2tlbml6ZXIgPSBmdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyMjIodGhpcy5pbnB1dCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgRGVjbGFyYXRpb24kMigpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2Vuc1swXVsyXSk7XG4gICAgICAgIHZhciBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RbMF0gPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWU7XG4gICAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24obGFzdFszXSB8fCBsYXN0WzJdIHx8IGZpbmRMYXN0V2l0aFBvc2l0aW9uKHRva2VucykpO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB3aGlsZSh0b2tlbnNbMF1bMF0gIT09IFwid29yZFwiKXtcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSk7XG4gICAgICAgIG5vZGUyLnByb3AgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiOlwiIHx8IHR5cGUgPT09IFwic3BhY2VcIiB8fCB0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIucHJvcCArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSBcIlwiO1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblswXSA9PT0gXCJ3b3JkXCIgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duV29yZChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5wcm9wWzBdID09PSBcIl9cIiB8fCBub2RlMi5wcm9wWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gbm9kZTIucHJvcFswXTtcbiAgICAgICAgICAgIG5vZGUyLnByb3AgPSBub2RlMi5wcm9wLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcy5wdXNoKHRva2Vucy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgICAgICBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCIhaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlMi5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZ0Zyb20odG9rZW5zLCBpMik7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gdGhpcy5zcGFjZXNGcm9tRW5kKHRva2VucykgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gXCIgIWltcG9ydGFudFwiKSBub2RlMi5yYXdzLmltcG9ydGFudCA9IHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJpbXBvcnRhbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHRva2Vucy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBpMjsgaiA+IDA7IGotLSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlMSA9IGNhY2hlW2pdWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKFwiIVwiKSA9PT0gMCAmJiB0eXBlMSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBjYWNoZS5wb3AoKVsxXSArIHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IGNhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiICYmIHRva2VuWzBdICE9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNXb3JkID0gdG9rZW5zLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJldHVybiBpMlswXSAhPT0gXCJzcGFjZVwiICYmIGkyWzBdICE9PSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gKz0gZmlyc3RTcGFjZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyWzFdO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGZpcnN0U3BhY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwidmFsdWVcIiwgZmlyc3RTcGFjZXMuY29uY2F0KHRva2VucyksIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgaWYgKG5vZGUyLnZhbHVlLmluY2x1ZGVzKFwiOlwiKSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRvdWJsZUNvbG9uID0gZnVuY3Rpb24gZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkRvdWJsZSBjb2xvblwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZW1wdHlSdWxlID0gZnVuY3Rpb24gZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVuZEZpbGUgPSBmdW5jdGlvbiBlbmRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWVTZW1pY29sb24gPSBmdW5jdGlvbiBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgcHJldi5yYXdzLm93blNlbWljb2xvbiA9IHRoaXMuc3BhY2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGVscGVyc1xuICAgIF9wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IHBvcy5jb2wsXG4gICAgICAgICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgICAgIG5vZGUyLnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zaXRpb24ob2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vdGhlciA9IGZ1bmN0aW9uIG90aGVyKHN0YXJ0KSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgY29sb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGJyYWNrZXQgPSBudWxsO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgdmFyIGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSh0b2tlbil7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgICAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICBzd2l0Y2godG9rZW5bMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kRmlsZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7fTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0b2tlbiwgdHlwZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBjbGVhbiA9IHRydWU7XG4gICAgICAgIHZhciBuZXh0LCBwcmV2O1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SW3ByZXZdICYmICFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbbmV4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsZWFuKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbihhbGwsIGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbCArIGkyWzFdO1xuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgICAgICBub2RlMi5yYXdzW3Byb3BdID0ge1xuICAgICAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMltwcm9wXSA9IHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bGUgPSBmdW5jdGlvbiBydWxlKHRva2Vucykge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHZhciBub2RlMiA9IG5ldyBSdWxlJDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJzZWxlY3RvclwiLCB0b2tlbnMpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICAvLyBFcnJvcnNcbiAgICBfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgICAgICB2YXIgbGFzdFRva2VuVHlwZTtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ0Zyb20gPSBmdW5jdGlvbiBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJsb2NrID0gZnVuY3Rpb24gdW5jbG9zZWRCbG9jaygpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICBfcHJvdG8udW5jbG9zZWRCcmFja2V0ID0gZnVuY3Rpb24gdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJyYWNrZXRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogYnJhY2tldFsyXSArIDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5leHBlY3RlZENsb3NlID0gZnVuY3Rpb24gdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmV4cGVjdGVkIH1cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmtub3duV29yZCA9IGZ1bmN0aW9uIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5rbm93biB3b3JkXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bm5hbWVkQXRydWxlID0gZnVuY3Rpb24gdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkF0LXJ1bGUgd2l0aG91dCBuYW1lXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXIyO1xufSgpO1xudmFyIHBhcnNlciA9IFBhcnNlciQxO1xudmFyIENvbnRhaW5lciQyID0gY29udGFpbmVyO1xudmFyIFBhcnNlcjIyID0gcGFyc2VyO1xudmFyIElucHV0JDIgPSBpbnB1dDtcbmZ1bmN0aW9uIHBhcnNlJDMoY3NzLCBvcHRzKSB7XG4gICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQyKGNzcywgb3B0cyk7XG4gICAgdmFyIHBhcnNlcjIgPSBuZXcgUGFyc2VyMjIoaW5wdXQyKTtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZXIyLnBhcnNlKCk7XG4gICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGUyLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiBvcHRzICYmIG9wdHMuZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmICgvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tZXNzYWdlICs9IFwiXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCB0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgdHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTI7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIyLnJvb3Q7XG59XG52YXIgcGFyc2VfMSA9IHBhcnNlJDM7XG5wYXJzZSQzLmRlZmF1bHQgPSBwYXJzZSQzO1xuQ29udGFpbmVyJDIucmVnaXN0ZXJQYXJzZShwYXJzZSQzKTtcbnZhciBpc0NsZWFuID0gc3ltYm9scy5pc0NsZWFuLCBteSA9IHN5bWJvbHMubXk7XG52YXIgTWFwR2VuZXJhdG9yJDEgPSBtYXBHZW5lcmF0b3I7XG52YXIgc3RyaW5naWZ5JDIgPSBzdHJpbmdpZnlfMTtcbnZhciBDb250YWluZXIkMSA9IGNvbnRhaW5lcjtcbnZhciBEb2N1bWVudCQyID0gZG9jdW1lbnQkMSQyO1xudmFyIHdhcm5PbmNlJDEgPSB3YXJuT25jZSQyO1xudmFyIFJlc3VsdCQyID0gcmVzdWx0O1xudmFyIHBhcnNlJDIgPSBwYXJzZV8xO1xudmFyIFJvb3QkMyA9IHJvb3Q7XG52YXIgVFlQRV9UT19DTEFTU19OQU1FID0ge1xuICAgIGF0cnVsZTogXCJBdFJ1bGVcIixcbiAgICBjb21tZW50OiBcIkNvbW1lbnRcIixcbiAgICBkZWNsOiBcIkRlY2xhcmF0aW9uXCIsXG4gICAgZG9jdW1lbnQ6IFwiRG9jdW1lbnRcIixcbiAgICByb290OiBcIlJvb3RcIixcbiAgICBydWxlOiBcIlJ1bGVcIlxufTtcbnZhciBQTFVHSU5fUFJPUFMgPSB7XG4gICAgQXRSdWxlOiB0cnVlLFxuICAgIEF0UnVsZUV4aXQ6IHRydWUsXG4gICAgQ29tbWVudDogdHJ1ZSxcbiAgICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbjogdHJ1ZSxcbiAgICBEZWNsYXJhdGlvbkV4aXQ6IHRydWUsXG4gICAgRG9jdW1lbnQ6IHRydWUsXG4gICAgRG9jdW1lbnRFeGl0OiB0cnVlLFxuICAgIE9uY2U6IHRydWUsXG4gICAgT25jZUV4aXQ6IHRydWUsXG4gICAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgICBwcmVwYXJlOiB0cnVlLFxuICAgIFJvb3Q6IHRydWUsXG4gICAgUm9vdEV4aXQ6IHRydWUsXG4gICAgUnVsZTogdHJ1ZSxcbiAgICBSdWxlRXhpdDogdHJ1ZVxufTtcbnZhciBOT1RfVklTSVRPUlMgPSB7XG4gICAgT25jZTogdHJ1ZSxcbiAgICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICAgIHByZXBhcmU6IHRydWVcbn07XG52YXIgQ0hJTERSRU4gPSAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihvYmopKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50cyhub2RlMikge1xuICAgIHZhciBrZXkgPSBmYWxzZTtcbiAgICB2YXIgdHlwZSA9IFRZUEVfVE9fQ0xBU1NfTkFNRVtub2RlMi50eXBlXTtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAga2V5ID0gbm9kZTIucHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBrZXkgPSBub2RlMi5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChrZXkgJiYgbm9kZTIuYXBwZW5kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCIsXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0LVwiICsga2V5XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayhub2RlMikge1xuICAgIHZhciBldmVudHM7XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICBldmVudHMgPSBbXG4gICAgICAgICAgICBcIkRvY3VtZW50XCIsXG4gICAgICAgICAgICBDSElMRFJFTixcbiAgICAgICAgICAgIFwiRG9jdW1lbnRFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiUm9vdFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICBcIlJvb3RFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHMgPSBnZXRFdmVudHMobm9kZTIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudEluZGV4OiAwLFxuICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgaXRlcmF0b3I6IDAsXG4gICAgICAgIG5vZGU6IG5vZGUyLFxuICAgICAgICB2aXNpdG9ySW5kZXg6IDAsXG4gICAgICAgIHZpc2l0b3JzOiBbXVxuICAgIH07XG59XG5mdW5jdGlvbiBjbGVhbk1hcmtzKG5vZGUyKSB7XG4gICAgbm9kZTJbaXNDbGVhbl0gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuTWFya3MoaTIpO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlMjtcbn1cbnZhciBwb3N0Y3NzJDIgPSB7fTtcbnZhciBMYXp5UmVzdWx0JDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExhenlSZXN1bHQyKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgaWYgKCh0eXBlb2YgY3NzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGNzcykpID09PSBcIm9iamVjdFwiICYmIGNzcyAhPT0gbnVsbCAmJiAoY3NzLnR5cGUgPT09IFwicm9vdFwiIHx8IGNzcy50eXBlID09PSBcImRvY3VtZW50XCIpKSB7XG4gICAgICAgICAgICByb290MiA9IGNsZWFuTWFya3MoY3NzKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihjc3MsIExhenlSZXN1bHQyKSB8fCBfaW5zdGFuY2VvZihjc3MsIFJlc3VsdCQyKSkge1xuICAgICAgICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzKGNzcy5yb290KTtcbiAgICAgICAgICAgIGlmIChjc3MubWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1hcCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0cy5tYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDI7XG4gICAgICAgICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlcjIgPSBvcHRzLnN5bnRheC5wYXJzZTtcbiAgICAgICAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyMiA9IG9wdHMucGFyc2VyO1xuICAgICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHBhcnNlcjIgPSBwYXJzZXIyLnBhcnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290MiAmJiAhcm9vdDJbbXldKSB7XG4gICAgICAgICAgICAgICAgQ29udGFpbmVyJDEucmVidWlsZChyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDIocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBfZXh0ZW5kcyh7fSwgcG9zdGNzcyQyLCB7XG4gICAgICAgICAgICBwb3N0Y3NzOiBwb3N0Y3NzJDIsXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMucmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnByb2Nlc3Nvci5wbHVnaW5zLm1hcChmdW5jdGlvbihwbHVnaW4yMikge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5wcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwbHVnaW4yMiwgcGx1Z2luMjIucHJlcGFyZShfdGhpcy5yZXN1bHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExhenlSZXN1bHQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IHRoaXMucnVuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXN5bmNFcnJvciA9IGZ1bmN0aW9uIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChub2RlMikgbm9kZTIuYWRkVG9FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmICFlcnJvci5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBwbHVnaW5WZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYTJbMF0gIT09IGJbMF0gfHwgcGFyc2VJbnQoYTJbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwYXJlVmlzaXRvcnMgPSBmdW5jdGlvbiBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihwbHVnaW4yMiwgdHlwZSwgY2IpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzW3R5cGVdKSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtcbiAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZXZlbnQgaW4gcGx1Z2luMjIpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QU1tldmVudF0gJiYgL15bQS1aXS8udGVzdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXZlbnQgXCIgKyBldmVudCArIFwiIGluIFwiICsgcGx1Z2luMjIucG9zdGNzc1BsdWdpbiArIFwiLiBUcnkgdG8gdXBkYXRlIFBvc3RDU1MgKFwiICsgdGhpcy5wcm9jZXNzb3IudmVyc2lvbiArIFwiIG5vdykuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlX29mKHBsdWdpbjIyW2V2ZW50XSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGZpbHRlciBpbiBwbHVnaW4yMltldmVudF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdW2ZpbHRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCArIFwiLVwiICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyW2V2ZW50XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbjIyLCBldmVudCwgcGx1Z2luMjJbZXZlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyID0gT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnMpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuQXN5bmMgPSBmdW5jdGlvbiBydW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaTIsIHBsdWdpbjIyLCBwcm9taXNlLCBlcnJvciwgcm9vdDIsIHN0YWNrLCBwcm9taXNlMSwgZTIsIG5vZGUyLCBfbG9vcCwgX2l0ZXJhdG9yLCBfc3RlcDtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbHVnaW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaTIgPCBfdGhpcy5wbHVnaW5zLmxlbmd0aCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luMjIgPSBfdGhpcy5wbHVnaW5zW2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBfdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UocHJvbWlzZSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaGFzTGlzdGVuZXIpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyID0gX3RoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyb290Mltpc0NsZWFuXSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdDJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdGFjayhyb290MilcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTEgPSBfdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UocHJvbWlzZTEpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTFcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3N0ZXBfdmFsdWUsIHBsdWdpbjIyLCB2aXNpdG9yLCByb290cywgZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzID0gcm9vdDIubm9kZXMubWFwKGZ1bmN0aW9uKHN1YlJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3Ioc3ViUm9vdCwgX3RoaXMuaGVscGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0b3Iocm9vdDIsIF90aGlzLmhlbHBlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGUyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShfdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90c192YWx1ZXMoX2xvb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0cmluZ2lmeSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bk9uUm9vdCA9IGZ1bmN0aW9uIHJ1bk9uUm9vdChwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihwbHVnaW4yMikpID09PSBcIm9iamVjdFwiICYmIHBsdWdpbjIyLk9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQucm9vdC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAoZnVuY3Rpb24ocm9vdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHJvb3QyLCBfdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2Uocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbjIyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5zdHJpbmdpZmllZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQyO1xuICAgICAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXI7XG4gICAgICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxKHN0ciwgdGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQub3B0cyk7XG4gICAgICAgIHZhciBkYXRhID0gbWFwLmdlbmVyYXRlKCk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGRhdGFbMF07XG4gICAgICAgIHRoaXMucmVzdWx0Lm1hcCA9IGRhdGFbMV07XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4yMik7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHZhciByb290MiA9IHRoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSghcm9vdDJbaXNDbGVhbl0pe1xuICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtTeW5jKHJvb3QyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHJvb3QyLm5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlJvb3QgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgc3ViUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3luYyh0aGlzLmxpc3RlbmVycy5PbmNlRXhpdCwgcm9vdDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5vcHRzKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlJDEoXCJXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwIGFuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoIG9yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by52aXNpdFN5bmMgPSBmdW5jdGlvbiB2aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHZpc2l0b3JzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIHBsdWdpbjIyID0gX3N0ZXBfdmFsdWVbMF0sIHZpc2l0b3IgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdmlzaXRvcihub2RlMiwgdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIucHJveHlPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJyb290XCIgJiYgbm9kZTIudHlwZSAhPT0gXCJkb2N1bWVudFwiICYmICFub2RlMi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnZpc2l0VGljayA9IGZ1bmN0aW9uIHZpc2l0VGljayhzdGFjaykge1xuICAgICAgICB2YXIgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBub2RlMiA9IHZpc2l0Mi5ub2RlLCB2aXNpdG9ycyA9IHZpc2l0Mi52aXNpdG9ycztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXggPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XSwgcGx1Z2luMjIgPSBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleFswXSwgdmlzaXRvciA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzFdO1xuICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZShjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSl7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgICAgICB3aGlsZSh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgICAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0Mi5pdGVyYXRvciA9IG5vZGUyLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrU3luYyA9IGZ1bmN0aW9uIHdhbGtTeW5jKG5vZGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG5vZGUyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlMik7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGV2ZW50cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBldmVudCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSBfdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTGF6eVJlc3VsdDIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjc3NcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS5tZXNzYWdlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9wdHNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicm9vdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTGF6eVJlc3VsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIExhenlSZXN1bHQyO1xufSgpO1xuTGF6eVJlc3VsdCQyLnJlZ2lzdGVyUG9zdGNzcyA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBvc3Rjc3MkMiA9IGRlcGVuZGFudDtcbn07XG52YXIgbGF6eVJlc3VsdCA9IExhenlSZXN1bHQkMjtcbkxhenlSZXN1bHQkMi5kZWZhdWx0ID0gTGF6eVJlc3VsdCQyO1xuUm9vdCQzLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIpO1xuRG9jdW1lbnQkMi5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbnZhciBNYXBHZW5lcmF0b3IyMiA9IG1hcEdlbmVyYXRvcjtcbnZhciBzdHJpbmdpZnkkMSA9IHN0cmluZ2lmeV8xO1xudmFyIHdhcm5PbmNlMjIgPSB3YXJuT25jZSQyO1xudmFyIHBhcnNlJDEgPSBwYXJzZV8xO1xudmFyIFJlc3VsdCQxID0gcmVzdWx0O1xudmFyIE5vV29ya1Jlc3VsdCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBOb1dvcmtSZXN1bHQyKHByb2Nlc3NvcjIsIGNzcywgb3B0cykge1xuICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3IyO1xuICAgICAgICB0aGlzLl9jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgICAgIHZhciByb290MjtcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmeSQxO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSh0aGlzLl9wcm9jZXNzb3IsIHJvb3QyLCB0aGlzLl9vcHRzKTtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gY3NzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvcjIyKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgICAgICAgdmFyIF9tYXBfZ2VuZXJhdGUgPSBtYXAuZ2VuZXJhdGUoKSwgZ2VuZXJhdGVkQ1NTID0gX21hcF9nZW5lcmF0ZVswXSwgZ2VuZXJhdGVkTWFwID0gX21hcF9nZW5lcmF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRDU1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9Xb3JrUmVzdWx0Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFzeW5jID0gZnVuY3Rpb24gYXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoXCJmcm9tXCIgaW4gdGhpcy5fb3B0cykpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZTIyKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9Xb3JrUmVzdWx0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNzc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvcHRzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb2Nlc3NvclwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJvb3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlcjIgPSBwYXJzZSQxO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QyID0gcGFyc2VyMih0aGlzLl9jc3MsIHRoaXMuX29wdHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm9Xb3JrUmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9Xb3JrUmVzdWx0Mjtcbn0oKTtcbnZhciBub1dvcmtSZXN1bHQgPSBOb1dvcmtSZXN1bHQkMTtcbk5vV29ya1Jlc3VsdCQxLmRlZmF1bHQgPSBOb1dvcmtSZXN1bHQkMTtcbnZhciBOb1dvcmtSZXN1bHQyMiA9IG5vV29ya1Jlc3VsdDtcbnZhciBMYXp5UmVzdWx0JDEgPSBsYXp5UmVzdWx0O1xudmFyIERvY3VtZW50JDEgPSBkb2N1bWVudCQxJDI7XG52YXIgUm9vdCQyID0gcm9vdDtcbnZhciBQcm9jZXNzb3IkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc29yMihwbHVnaW5zKSB7XG4gICAgICAgIGlmIChwbHVnaW5zID09PSB2b2lkIDApIHBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI4LjQuMzhcIjtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5ub3JtYWxpemUocGx1Z2lucyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcm9jZXNzb3IyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkyLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaTIucGx1Z2lucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MxKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIyKHRoaXMsIGNzcywgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlSZXN1bHQkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKHBsdWdpbjIyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW1xuICAgICAgICAgICAgcGx1Z2luMjJcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBQcm9jZXNzb3IyO1xufSgpO1xudmFyIHByb2Nlc3NvciA9IFByb2Nlc3NvciQxO1xuUHJvY2Vzc29yJDEuZGVmYXVsdCA9IFByb2Nlc3NvciQxO1xuUm9vdCQyLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxKTtcbkRvY3VtZW50JDEucmVnaXN0ZXJQcm9jZXNzb3IoUHJvY2Vzc29yJDEpO1xudmFyIERlY2xhcmF0aW9uJDEgPSBkZWNsYXJhdGlvbjtcbnZhciBQcmV2aW91c01hcDIyID0gcHJldmlvdXNNYXA7XG52YXIgQ29tbWVudCQxID0gY29tbWVudDtcbnZhciBBdFJ1bGUkMSA9IGF0UnVsZTtcbnZhciBJbnB1dCQxID0gaW5wdXQ7XG52YXIgUm9vdCQxID0gcm9vdDtcbnZhciBSdWxlJDEgPSBydWxlO1xuZnVuY3Rpb24gZnJvbUpTT04kMShqc29uLCBpbnB1dHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgcmV0dXJuIGpzb24ubWFwKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgIHJldHVybiBmcm9tSlNPTiQxKG4yKTtcbiAgICB9KTtcbiAgICB2YXIgb3duSW5wdXRzID0ganNvbi5pbnB1dHMsIGRlZmF1bHRzID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoanNvbiwgW1xuICAgICAgICBcImlucHV0c1wiXG4gICAgXSk7XG4gICAgaWYgKG93bklucHV0cykge1xuICAgICAgICBpbnB1dHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uob3duSW5wdXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGlucHV0MiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlucHV0SHlkcmF0ZWQgPSBfZXh0ZW5kcyh7fSwgaW5wdXQyLCB7XG4gICAgICAgICAgICAgICAgX19wcm90b19fOiBJbnB1dCQxLnByb3RvdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgICAgICAgICBpbnB1dEh5ZHJhdGVkLm1hcCA9IF9leHRlbmRzKHt9LCBpbnB1dEh5ZHJhdGVkLm1hcCwge1xuICAgICAgICAgICAgICAgICAgICBfX3Byb3RvX186IFByZXZpb3VzTWFwMjIucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dEh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMubm9kZXMpIHtcbiAgICAgICAgZGVmYXVsdHMubm9kZXMgPSBqc29uLm5vZGVzLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KU09OJDEobjIsIGlucHV0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgICAgIHZhciBfZGVmYXVsdHNfc291cmNlID0gZGVmYXVsdHMuc291cmNlLCBpbnB1dElkID0gX2RlZmF1bHRzX3NvdXJjZS5pbnB1dElkLCBzb3VyY2UgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfZGVmYXVsdHNfc291cmNlLCBbXG4gICAgICAgICAgICBcImlucHV0SWRcIlxuICAgICAgICBdKTtcbiAgICAgICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAoaW5wdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5zb3VyY2UuaW5wdXQgPSBpbnB1dHNbaW5wdXRJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm9vdCQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24kMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bGUkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1lbnQkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXRSdWxlJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIGpzb24udHlwZSk7XG4gICAgfVxufVxudmFyIGZyb21KU09OXzEgPSBmcm9tSlNPTiQxO1xuZnJvbUpTT04kMS5kZWZhdWx0ID0gZnJvbUpTT04kMTtcbnZhciBDc3NTeW50YXhFcnJvcjIyID0gY3NzU3ludGF4RXJyb3I7XG52YXIgRGVjbGFyYXRpb24yMiA9IGRlY2xhcmF0aW9uO1xudmFyIExhenlSZXN1bHQyMiA9IGxhenlSZXN1bHQ7XG52YXIgQ29udGFpbmVyMjIgPSBjb250YWluZXI7XG52YXIgUHJvY2Vzc29yMjIgPSBwcm9jZXNzb3I7XG52YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5XzE7XG52YXIgZnJvbUpTT04gPSBmcm9tSlNPTl8xO1xudmFyIERvY3VtZW50MjIyID0gZG9jdW1lbnQkMSQyO1xudmFyIFdhcm5pbmcyMiA9IHdhcm5pbmc7XG52YXIgQ29tbWVudDIyID0gY29tbWVudDtcbnZhciBBdFJ1bGUyMiA9IGF0UnVsZTtcbnZhciBSZXN1bHQyMiA9IHJlc3VsdDtcbnZhciBJbnB1dDIyID0gaW5wdXQ7XG52YXIgcGFyc2UgPSBwYXJzZV8xO1xudmFyIGxpc3QgPSBsaXN0XzE7XG52YXIgUnVsZTIyID0gcnVsZTtcbnZhciBSb290MjIgPSByb290O1xudmFyIE5vZGUyMiA9IG5vZGU7XG5mdW5jdGlvbiBwb3N0Y3NzKCkge1xuICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbnMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkocGx1Z2luc1swXSkpIHtcbiAgICAgICAgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvY2Vzc29yMjIocGx1Z2lucyk7XG59XG5wb3N0Y3NzLnBsdWdpbiA9IGZ1bmN0aW9uIHBsdWdpbjIobmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgICB2YXIgd2FybmluZ1ByaW50ZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjcmVhdG9yKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiAhd2FybmluZ1ByaW50ZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdQcmludGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuaHR0cHM6Ly9ldmlsbWFydGlhbnMuY29tL2Nocm9uaWNsZXMvcG9zdGNzcy04LXBsdWdpbi1taWdyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTEFORyAmJiBwcm9jZXNzLmVudi5MQU5HLnN0YXJ0c1dpdGgoXCJjblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCI6IOmHjOmdoiBwb3N0Y3NzLnBsdWdpbiDooqvlvIPnlKguIOi/geenu+aMh+WNlzpcXG5odHRwczovL3d3dy53M2N0ZWNoLmNvbS90b3BpYy8yMjI2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IGluaXRpYWxpemVyLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgdHJhbnNmb3JtZXIucG9zdGNzc1BsdWdpbiA9IG5hbWU7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcjIyKCkudmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyO1xuICAgIH1cbiAgICB2YXIgY2FjaGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0b3IsIFwicG9zdGNzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZSkgY2FjaGUgPSBjcmVhdG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbihjc3MsIHByb2Nlc3NPcHRzLCBwbHVnaW5PcHRzKSB7XG4gICAgICAgIHJldHVybiBwb3N0Y3NzKFtcbiAgICAgICAgICAgIGNyZWF0b3IocGx1Z2luT3B0cylcbiAgICAgICAgXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdG9yO1xufTtcbnBvc3Rjc3Muc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xucG9zdGNzcy5wYXJzZSA9IHBhcnNlO1xucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OO1xucG9zdGNzcy5saXN0ID0gbGlzdDtcbnBvc3Rjc3MuY29tbWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBDb21tZW50MjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuYXRSdWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IEF0UnVsZTIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzLmRlY2wgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24yMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5ydWxlID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5yb290ID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IFJvb3QyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5kb2N1bWVudCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudDIyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5Dc3NTeW50YXhFcnJvciA9IENzc1N5bnRheEVycm9yMjI7XG5wb3N0Y3NzLkRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24yMjtcbnBvc3Rjc3MuQ29udGFpbmVyID0gQ29udGFpbmVyMjI7XG5wb3N0Y3NzLlByb2Nlc3NvciA9IFByb2Nlc3NvcjIyO1xucG9zdGNzcy5Eb2N1bWVudCA9IERvY3VtZW50MjIyO1xucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudDIyO1xucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZzIyO1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGUyMjtcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0MjI7XG5wb3N0Y3NzLklucHV0ID0gSW5wdXQyMjtcbnBvc3Rjc3MuUnVsZSA9IFJ1bGUyMjtcbnBvc3Rjc3MuUm9vdCA9IFJvb3QyMjtcbnBvc3Rjc3MuTm9kZSA9IE5vZGUyMjtcbkxhenlSZXN1bHQyMi5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcyk7XG52YXIgcG9zdGNzc18xID0gcG9zdGNzcztcbnBvc3Rjc3MuZGVmYXVsdCA9IHBvc3Rjc3M7XG52YXIgcG9zdGNzcyQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvc3Rjc3NfMSk7XG5wb3N0Y3NzJDEuc3RyaW5naWZ5O1xucG9zdGNzcyQxLmZyb21KU09OO1xucG9zdGNzcyQxLnBsdWdpbjtcbnBvc3Rjc3MkMS5wYXJzZTtcbnBvc3Rjc3MkMS5saXN0O1xucG9zdGNzcyQxLmRvY3VtZW50O1xucG9zdGNzcyQxLmNvbW1lbnQ7XG5wb3N0Y3NzJDEuYXRSdWxlO1xucG9zdGNzcyQxLnJ1bGU7XG5wb3N0Y3NzJDEuZGVjbDtcbnBvc3Rjc3MkMS5yb290O1xucG9zdGNzcyQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxLkRlY2xhcmF0aW9uO1xucG9zdGNzcyQxLkNvbnRhaW5lcjtcbnBvc3Rjc3MkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEuRG9jdW1lbnQ7XG5wb3N0Y3NzJDEuQ29tbWVudDtcbnBvc3Rjc3MkMS5XYXJuaW5nO1xucG9zdGNzcyQxLkF0UnVsZTtcbnBvc3Rjc3MkMS5SZXN1bHQ7XG5wb3N0Y3NzJDEuSW5wdXQ7XG5wb3N0Y3NzJDEuUnVsZTtcbnBvc3Rjc3MkMS5Sb290O1xucG9zdGNzcyQxLk5vZGU7XG52YXIgQmFzZVJSTm9kZSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQmFzZVJSTm9kZSgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50RWxlbWVudFwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJwYXJlbnROb2RlXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm93bmVyRG9jdW1lbnRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiZmlyc3RDaGlsZFwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJsYXN0Q2hpbGRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicHJldmlvdXNTaWJsaW5nXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5leHRTaWJsaW5nXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIkVMRU1FTlRfTk9ERVwiLCAxKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJURVhUX05PREVcIiwgMyk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibm9kZVR5cGVcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibm9kZU5hbWVcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiUlJOb2RlVHlwZVwiKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEJhc2VSUk5vZGUucHJvdG90eXBlO1xuICAgIF9wcm90by5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUyKSB7XG4gICAgICAgIGlmICghX2luc3RhbmNlb2Yobm9kZTIsIEJhc2VSUk5vZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUyLm93bmVyRG9jdW1lbnQgIT09IHRoaXMub3duZXJEb2N1bWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChub2RlMiA9PT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgICAgIHdoaWxlKG5vZGUyLnBhcmVudE5vZGUpe1xuICAgICAgICAgICAgaWYgKG5vZGUyLnBhcmVudE5vZGUgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbm9kZTIgPSBub2RlMi5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfcHJvdG8uYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZChfbmV3Q2hpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmRDaGlsZCcgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShfbmV3Q2hpbGQsIF9yZWZDaGlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSUkRvbUV4Y2VwdGlvbjogRmFpbGVkIHRvIGV4ZWN1dGUgJ2luc2VydEJlZm9yZScgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoX25vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdyZW1vdmVDaGlsZCcgb24gJ1JSTm9kZSc6IFRoaXMgUlJOb2RlIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiUlJOb2RlXCI7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKEJhc2VSUk5vZGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoaWxkTm9kZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzMiA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEl0ZXJhdG9yID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlKGNoaWxkSXRlcmF0b3Ipe1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzMi5wdXNoKGNoaWxkSXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZXJhdG9yID0gY2hpbGRJdGVyYXRvci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZXMyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEJhc2VSUk5vZGU7XG59KCk7XG52YXIgdGVzdGFibGVBY2Nlc3NvcnMgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNoaWxkTm9kZXNcIixcbiAgICAgICAgXCJwYXJlbnROb2RlXCIsXG4gICAgICAgIFwicGFyZW50RWxlbWVudFwiLFxuICAgICAgICBcInRleHRDb250ZW50XCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJob3N0XCIsXG4gICAgICAgIFwic3R5bGVTaGVldHNcIlxuICAgIF0sXG4gICAgRWxlbWVudDogW1xuICAgICAgICBcInNoYWRvd1Jvb3RcIixcbiAgICAgICAgXCJxdWVyeVNlbGVjdG9yXCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvckFsbFwiXG4gICAgXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXVxufTtcbnZhciB0ZXN0YWJsZU1ldGhvZHMgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNvbnRhaW5zXCIsXG4gICAgICAgIFwiZ2V0Um9vdE5vZGVcIlxuICAgIF0sXG4gICAgU2hhZG93Um9vdDogW1xuICAgICAgICBcImdldFNlbGVjdGlvblwiXG4gICAgXSxcbiAgICBFbGVtZW50OiBbXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIlxuICAgIF1cbn07XG52YXIgdW50YWludGVkQmFzZVByb3RvdHlwZSA9IHt9O1xudmFyIGlzQW5ndWxhclpvbmVQcmVzZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5ab25lO1xufTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpIHtcbiAgICBpZiAodW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldKSByZXR1cm4gdW50YWludGVkQmFzZVByb3RvdHlwZVtrZXldO1xuICAgIHZhciBkZWZhdWx0T2JqID0gZ2xvYmFsVGhpc1trZXldO1xuICAgIHZhciBkZWZhdWx0UHJvdG90eXBlID0gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgdmFyIGFjY2Vzc29yTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVBY2Nlc3NvcnMgPyB0ZXN0YWJsZUFjY2Vzc29yc1trZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZEFjY2Vzc29ycyA9IEJvb2xlYW4oYWNjZXNzb3JOYW1lcyAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIDIzNDVcbiAgICBhY2Nlc3Nvck5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGFjY2Vzc29yKSB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoX2IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0UHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICB2YXIgbWV0aG9kTmFtZXMgPSBrZXkgaW4gdGVzdGFibGVNZXRob2RzID8gdGVzdGFibGVNZXRob2RzW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkTWV0aG9kcyA9IEJvb2xlYW4obWV0aG9kTmFtZXMgJiYgbWV0aG9kTmFtZXMuZXZlcnkoLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICBpZiAoaXNVbnRhaW50ZWRBY2Nlc3NvcnMgJiYgaXNVbnRhaW50ZWRNZXRob2RzICYmICFpc0FuZ3VsYXJab25lUHJlc2VudCgpKSB7XG4gICAgICAgIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZhciBpZnJhbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICB2YXIgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICAgICAgaWYgKCF3aW4pIHJldHVybiBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHVudGFpbnRlZE9iamVjdCA9IHdpbltrZXldLnByb3RvdHlwZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWVFbCk7XG4gICAgICAgIGlmICghdW50YWludGVkT2JqZWN0KSByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgIH1cbn1cbnZhciB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihrZXksIGluc3RhbmNlLCBhY2Nlc3Nvcikge1xuICAgIHZhciBfYTI7XG4gICAgdmFyIGNhY2hlS2V5ID0ga2V5ICsgXCIuXCIgKyBTdHJpbmcoYWNjZXNzb3IpO1xuICAgIGlmICh1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGVbY2FjaGVLZXldLmNhbGwoaW5zdGFuY2UpO1xuICAgIHZhciB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KTtcbiAgICB2YXIgdW50YWludGVkQWNjZXNzb3IgPSAoX2EyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih1bnRhaW50ZWRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQ7XG4gICAgaWYgKCF1bnRhaW50ZWRBY2Nlc3NvcikgcmV0dXJuIGluc3RhbmNlW2FjY2Vzc29yXTtcbiAgICB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZEFjY2Vzc29yO1xuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbnZhciB1bnRhaW50ZWRNZXRob2RDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkTWV0aG9kKGtleSwgaW5zdGFuY2UsIG1ldGhvZCkge1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKG1ldGhvZCk7XG4gICAgaWYgKHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XS5iaW5kKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZE1ldGhvZCA9IHVudGFpbnRlZFByb3RvdHlwZVttZXRob2RdO1xuICAgIGlmICh0eXBlb2YgdW50YWludGVkTWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBpbnN0YW5jZVttZXRob2RdO1xuICAgIHVudGFpbnRlZE1ldGhvZENhY2hlW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kLmJpbmQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2hpbGROb2RlcyhuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwiY2hpbGROb2Rlc1wiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInBhcmVudE5vZGVcIik7XG59XG5mdW5jdGlvbiBwYXJlbnRFbGVtZW50KG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnRFbGVtZW50XCIpO1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnQobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcInRleHRDb250ZW50XCIpO1xufVxuZnVuY3Rpb24gY29udGFpbnMobjIsIG90aGVyKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiY29udGFpbnNcIikob3RoZXIpO1xufVxuZnVuY3Rpb24gZ2V0Um9vdE5vZGUobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkTWV0aG9kKFwiTm9kZVwiLCBuMiwgXCJnZXRSb290Tm9kZVwiKSgpO1xufVxuZnVuY3Rpb24gaG9zdChuMikge1xuICAgIGlmICghbjIgfHwgIShcImhvc3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIlNoYWRvd1Jvb3RcIiwgbjIsIFwiaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIHN0eWxlU2hlZXRzKG4yKSB7XG4gICAgcmV0dXJuIG4yLnN0eWxlU2hlZXRzO1xufVxuZnVuY3Rpb24gc2hhZG93Um9vdChuMikge1xuICAgIGlmICghbjIgfHwgIShcInNoYWRvd1Jvb3RcIiBpbiBuMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwic2hhZG93Um9vdFwiKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvclwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChuMiwgc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvcigpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkUHJvdG90eXBlKFwiTXV0YXRpb25PYnNlcnZlclwiKS5jb25zdHJ1Y3Rvcjtcbn1cbnZhciBpbmRleCA9IHtcbiAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGdldFJvb3ROb2RlOiBnZXRSb290Tm9kZSxcbiAgICBob3N0OiBob3N0LFxuICAgIHN0eWxlU2hlZXRzOiBzdHlsZVNoZWV0cyxcbiAgICBzaGFkb3dSb290OiBzaGFkb3dSb290LFxuICAgIHF1ZXJ5U2VsZWN0b3I6IHF1ZXJ5U2VsZWN0b3IsXG4gICAgcXVlcnlTZWxlY3RvckFsbDogcXVlcnlTZWxlY3RvckFsbCxcbiAgICBtdXRhdGlvbk9ic2VydmVyOiBtdXRhdGlvbk9ic2VydmVyQ3RvclxufTtcbmZ1bmN0aW9uIG9uKHR5cGUsIGZuLCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHRhcmdldCA9IGRvY3VtZW50O1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgIH07XG59XG52YXIgREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HID0gXCJQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsXFxyXFxubm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsXFxyXFxub3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLlwiO1xudmFyIF9taXJyb3IgPSB7XG4gICAgbWFwOiB7fSxcbiAgICBnZXRJZDogZnVuY3Rpb24gZ2V0SWQoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgZ2V0Tm9kZTogZnVuY3Rpb24gZ2V0Tm9kZSgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGVGcm9tTWFwOiBmdW5jdGlvbiByZW1vdmVOb2RlRnJvbU1hcCgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgfVxufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Qcm94eSAmJiB3aW5kb3cuUmVmbGVjdCkge1xuICAgIF9taXJyb3IgPSBuZXcgUHJveHkoX21pcnJvciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJtYXBcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va1NldHRlcih0YXJnZXQsIGtleSwgZCwgaXNSZXZva2VkLCB3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgb3JpZ2luYWwgPSB3aW4uT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkID8gZCA6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGQuc2V0LmNhbGwoX3RoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNldCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIG9yaWdpbmFsIHx8IHt9LCB0cnVlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0Y2goc291cmNlLCBuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gc291cmNlW25hbWVdO1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdyYXBwZWQucHJvdG90eXBlID0gd3JhcHBlZC5wcm90b3R5cGUgfHwge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XG4gICAgICAgICAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzb3VyY2VbbmFtZV0gPSBvcmlnaW5hbDtcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbn1cbnZhciBub3dUaW1lc3RhbXAgPSBEYXRlLm5vdztcbmlmICghLyogQF9fUFVSRV9fICovIC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSB7XG4gICAgbm93VGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbCh3aW4pIHtcbiAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZG9jLnNjcm9sbGluZ0VsZW1lbnQgPyBkb2Muc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0IDogd2luLnBhZ2VYT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVhPZmZzZXQgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2EyID0gaW5kZXgucGFyZW50RWxlbWVudChkb2MuYm9keSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuc2Nyb2xsTGVmdCkgfHwgKChfYiA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY3JvbGxMZWZ0KSB8fCAwLFxuICAgICAgICB0b3A6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wIDogd2luLnBhZ2VZT2Zmc2V0ICE9PSB2b2lkIDAgPyB3aW4ucGFnZVlPZmZzZXQgOiAoZG9jID09IG51bGwgPyB2b2lkIDAgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgfHwgKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpICYmICgoX2MgPSBpbmRleC5wYXJlbnRFbGVtZW50KGRvYy5ib2R5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnNjcm9sbFRvcCkgfHwgKChfZCA9IGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfZC5zY3JvbGxUb3ApIHx8IDBcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1dpZHRoKCkge1xuICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG5vZGUyKSB7XG4gICAgaWYgKCFub2RlMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsID0gbm9kZTIubm9kZVR5cGUgPT09IG5vZGUyLkVMRU1FTlRfTk9ERSA/IG5vZGUyIDogaW5kZXgucGFyZW50RWxlbWVudChub2RlMik7XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUyLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xuICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWwgPSBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlMik7XG4gICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMgJiYgZWwuY2xvc2VzdChcIi5cIiArIGJsb2NrQ2xhc3MpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgYmxvY2tDbGFzcywgY2hlY2tBbmNlc3RvcnMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoYmxvY2tTZWxlY3RvcikgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWQobjIsIG1pcnJvcjIpIHtcbiAgICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgIT09IC0xO1xufVxuZnVuY3Rpb24gaXNJZ25vcmVkKG4yLCBtaXJyb3IyLCBzbGltRE9NT3B0aW9ucykge1xuICAgIGlmIChuMi50YWdOYW1lID09PSBcIlRJVExFXCIgJiYgc2xpbURPTU9wdGlvbnMuaGVhZFRpdGxlTXV0YXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWlycm9yMi5nZXRJZChuMikgPT09IElHTk9SRURfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldCwgbWlycm9yMikge1xuICAgIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICBpZiAoIW1pcnJvcjIuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodGFyZ2V0KTtcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gdGFyZ2V0LkRPQ1VNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHBhcmVudCwgbWlycm9yMik7XG59XG5mdW5jdGlvbiBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xufVxuZnVuY3Rpb24gcG9seWZpbGwkMSh3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHdpbiA9IHdpbmRvdztcbiAgICBpZiAoXCJOb2RlTGlzdFwiIGluIHdpbiAmJiAhd2luLk5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgICAgIHdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIH1cbiAgICBpZiAoXCJET01Ub2tlbkxpc3RcIiBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yMikge1xuICAgIHJldHVybiBCb29sZWFuKG4yLm5vZGVOYW1lID09PSBcIklGUkFNRVwiICYmIG1pcnJvcjIuZ2V0TWV0YShuMikpO1xufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkU3R5bGVzaGVldChuMiwgbWlycm9yMikge1xuICAgIHJldHVybiBCb29sZWFuKG4yLm5vZGVOYW1lID09PSBcIkxJTktcIiAmJiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFICYmIG4yLmdldEF0dHJpYnV0ZSAmJiBuMi5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IFwic3R5bGVzaGVldFwiICYmIG1pcnJvcjIuZ2V0TWV0YShuMikpO1xufVxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuMikge1xuICAgIGlmICghbjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoX2luc3RhbmNlb2YobjIsIEJhc2VSUk5vZGUpICYmIFwic2hhZG93Um9vdFwiIGluIG4yKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKG4yLnNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihpbmRleC5zaGFkb3dSb290KG4yKSk7XG59XG52YXIgU3R5bGVTaGVldE1pcnJvciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldE1pcnJvcigpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIsIDEpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3R5bGVJRE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZFN0eWxlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldE1pcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldElkID0gZnVuY3Rpb24gZ2V0SWQoc3R5bGVzaGVldCkge1xuICAgICAgICB2YXIgX3RoaXNfc3R5bGVJRE1hcF9nZXQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfc3R5bGVJRE1hcF9nZXQgPSB0aGlzLnN0eWxlSURNYXAuZ2V0KHN0eWxlc2hlZXQpKSAhPSBudWxsID8gX3RoaXNfc3R5bGVJRE1hcF9nZXQgOiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoc3R5bGVzaGVldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBAcmV0dXJucyBJZiB0aGUgc3R5bGVzaGVldCBpcyBpbiB0aGUgbWlycm9yLCByZXR1cm5zIHRoZSBpZCBvZiB0aGUgc3R5bGVzaGVldC4gSWYgbm90LCByZXR1cm4gdGhlIG5ldyBhc3NpZ25lZCBpZC5cbiAgICovIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3R5bGVzaGVldCwgaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKHN0eWxlc2hlZXQpKSByZXR1cm4gdGhpcy5nZXRJZChzdHlsZXNoZWV0KTtcbiAgICAgICAgdmFyIG5ld0lkO1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbmV3SWQgPSB0aGlzLmlkKys7XG4gICAgICAgIH0gZWxzZSBuZXdJZCA9IGlkO1xuICAgICAgICB0aGlzLnN0eWxlSURNYXAuc2V0KHN0eWxlc2hlZXQsIG5ld0lkKTtcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XG4gICAgICAgIHJldHVybiBuZXdJZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkU3R5bGVNYXAuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmlkU3R5bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlkID0gMTtcbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQrKztcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZVNoZWV0TWlycm9yO1xufSgpO1xuZnVuY3Rpb24gZ2V0U2hhZG93SG9zdChuMikge1xuICAgIHZhciBfYTI7XG4gICAgdmFyIHNoYWRvd0hvc3QgPSBudWxsO1xuICAgIGlmIChcImdldFJvb3ROb2RlXCIgaW4gbjIgJiYgKChfYTIgPSBpbmRleC5nZXRSb290Tm9kZShuMikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubm9kZVR5cGUpID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpKSBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChpbmRleC5nZXRSb290Tm9kZShuMikpO1xuICAgIHJldHVybiBzaGFkb3dIb3N0O1xufVxuZnVuY3Rpb24gZ2V0Um9vdFNoYWRvd0hvc3QobjIpIHtcbiAgICB2YXIgcm9vdFNoYWRvd0hvc3QgPSBuMjtcbiAgICB2YXIgc2hhZG93SG9zdDtcbiAgICB3aGlsZShzaGFkb3dIb3N0ID0gZ2V0U2hhZG93SG9zdChyb290U2hhZG93SG9zdCkpcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xuICAgIHJldHVybiByb290U2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIHNoYWRvd0hvc3RJbkRvbShuMikge1xuICAgIHZhciBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNoYWRvd0hvc3QgPSBnZXRSb290U2hhZG93SG9zdChuMik7XG4gICAgcmV0dXJuIGluZGV4LmNvbnRhaW5zKGRvYywgc2hhZG93SG9zdCk7XG59XG5mdW5jdGlvbiBpbkRvbShuMikge1xuICAgIHZhciBkb2MgPSBuMi5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGluZGV4LmNvbnRhaW5zKGRvYywgbjIpIHx8IHNoYWRvd0hvc3RJbkRvbShuMik7XG59XG52YXIgRXZlbnRUeXBlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKEV2ZW50VHlwZTIpIHtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJEb21Db250ZW50TG9hZGVkXCJdID0gMF0gPSBcIkRvbUNvbnRlbnRMb2FkZWRcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJMb2FkXCJdID0gMV0gPSBcIkxvYWRcIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJGdWxsU25hcHNob3RcIl0gPSAyXSA9IFwiRnVsbFNuYXBzaG90XCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiSW5jcmVtZW50YWxTbmFwc2hvdFwiXSA9IDNdID0gXCJJbmNyZW1lbnRhbFNuYXBzaG90XCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTWV0YVwiXSA9IDRdID0gXCJNZXRhXCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiQ3VzdG9tXCJdID0gNV0gPSBcIkN1c3RvbVwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIlBsdWdpblwiXSA9IDZdID0gXCJQbHVnaW5cIjtcbiAgICByZXR1cm4gRXZlbnRUeXBlMjtcbn0oRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBJbmNyZW1lbnRhbFNvdXJjZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihJbmNyZW1lbnRhbFNvdXJjZTIpIHtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VNb3ZlXCJdID0gMV0gPSBcIk1vdXNlTW92ZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNb3VzZUludGVyYWN0aW9uXCJdID0gMl0gPSBcIk1vdXNlSW50ZXJhY3Rpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJWaWV3cG9ydFJlc2l6ZVwiXSA9IDRdID0gXCJWaWV3cG9ydFJlc2l6ZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJJbnB1dFwiXSA9IDVdID0gXCJJbnB1dFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1lZGlhSW50ZXJhY3Rpb25cIl0gPSA3XSA9IFwiTWVkaWFJbnRlcmFjdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTdHlsZVNoZWV0UnVsZVwiXSA9IDhdID0gXCJTdHlsZVNoZWV0UnVsZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJGb250XCJdID0gMTBdID0gXCJGb250XCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkxvZ1wiXSA9IDExXSA9IFwiTG9nXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVEZWNsYXJhdGlvblwiXSA9IDEzXSA9IFwiU3R5bGVEZWNsYXJhdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTZWxlY3Rpb25cIl0gPSAxNF0gPSBcIlNlbGVjdGlvblwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ3VzdG9tRWxlbWVudFwiXSA9IDE2XSA9IFwiQ3VzdG9tRWxlbWVudFwiO1xuICAgIHJldHVybiBJbmNyZW1lbnRhbFNvdXJjZTI7XG59KEluY3JlbWVudGFsU291cmNlIHx8IHt9KTtcbnZhciBNb3VzZUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihNb3VzZUludGVyYWN0aW9uczIpIHtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlRG93blwiXSA9IDFdID0gXCJNb3VzZURvd25cIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRGJsQ2xpY2tcIl0gPSA0XSA9IFwiRGJsQ2xpY2tcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoU3RhcnRcIl0gPSA3XSA9IFwiVG91Y2hTdGFydFwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoQ2FuY2VsXCJdID0gMTBdID0gXCJUb3VjaENhbmNlbFwiO1xuICAgIHJldHVybiBNb3VzZUludGVyYWN0aW9uczI7XG59KE1vdXNlSW50ZXJhY3Rpb25zIHx8IHt9KTtcbnZhciBQb2ludGVyVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oUG9pbnRlclR5cGVzMikge1xuICAgIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIk1vdXNlXCJdID0gMF0gPSBcIk1vdXNlXCI7XG4gICAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiUGVuXCJdID0gMV0gPSBcIlBlblwiO1xuICAgIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlRvdWNoXCJdID0gMl0gPSBcIlRvdWNoXCI7XG4gICAgcmV0dXJuIFBvaW50ZXJUeXBlczI7XG59KFBvaW50ZXJUeXBlcyB8fCB7fSk7XG52YXIgQ2FudmFzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihDYW52YXNDb250ZXh0Mikge1xuICAgIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiMkRcIl0gPSAwXSA9IFwiMkRcIjtcbiAgICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XG4gICAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XG4gICAgcmV0dXJuIENhbnZhc0NvbnRleHQyO1xufShDYW52YXNDb250ZXh0IHx8IHt9KTtcbnZhciBNZWRpYUludGVyYWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihNZWRpYUludGVyYWN0aW9uczIpIHtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlNlZWtlZFwiXSA9IDJdID0gXCJTZWVrZWRcIjtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJSYXRlQ2hhbmdlXCJdID0gNF0gPSBcIlJhdGVDaGFuZ2VcIjtcbiAgICByZXR1cm4gTWVkaWFJbnRlcmFjdGlvbnMyO1xufShNZWRpYUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgTm9kZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTm9kZVR5cGUyKSB7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcbiAgICByZXR1cm4gTm9kZVR5cGUyO1xufShOb2RlVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3QobjIpIHtcbiAgICByZXR1cm4gXCJfX2xuXCIgaW4gbjI7XG59XG52YXIgRG91YmxlTGlua2VkTGlzdCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRG91YmxlTGlua2VkTGlzdCgpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhlYWRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWlsXCIsIG51bGwpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRG91YmxlTGlua2VkTGlzdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG91dHNpZGUgb2YgbGlzdCByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgZm9yKHZhciBpbmRleDIgPSAwOyBpbmRleDIgPCBwb3NpdGlvbjsgaW5kZXgyKyspe1xuICAgICAgICAgICAgY3VycmVudCA9IChjdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUobjIpIHtcbiAgICAgICAgdmFyIG5vZGUyID0ge1xuICAgICAgICAgICAgdmFsdWU6IG4yLFxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG4yLl9fbG4gPSBub2RlMjtcbiAgICAgICAgaWYgKG4yLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3QobjIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xuICAgICAgICAgICAgbm9kZTIubmV4dCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBub2RlMi5wcmV2aW91cyA9IG4yLnByZXZpb3VzU2libGluZy5fX2xuO1xuICAgICAgICAgICAgbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGUyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gbm9kZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobjIubmV4dFNpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLm5leHRTaWJsaW5nKSAmJiBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudDEgPSBuMi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzO1xuICAgICAgICAgICAgbm9kZTIucHJldmlvdXMgPSBjdXJyZW50MTtcbiAgICAgICAgICAgIG5vZGUyLm5leHQgPSBuMi5uZXh0U2libGluZy5fX2xuO1xuICAgICAgICAgICAgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudDEubmV4dCA9IG5vZGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZTIubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGUyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiByZW1vdmVOb2RlKG4yKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbjIuX19sbjtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLl9fbG4pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuMi5fX2xuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfTtcbiAgICByZXR1cm4gRG91YmxlTGlua2VkTGlzdDtcbn0oKTtcbnZhciBtb3ZlS2V5ID0gZnVuY3Rpb24oaWQsIHBhcmVudElkKSB7XG4gICAgcmV0dXJuIGlkICsgXCJAXCIgKyBwYXJlbnRJZDtcbn07XG52YXIgTXV0YXRpb25CdWZmZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE11dGF0aW9uQnVmZmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0ZXh0c1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdHRyaWJ1dGVzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF0dHJpYnV0ZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW1vdmVzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hcFJlbW92ZXNcIiwgW10pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibW92ZWRNYXBcIiwge30pO1xuICAgICAgICAvKipcbiAgICAgKiB0aGUgYnJvd3NlciBNdXRhdGlvbk9ic2VydmVyIGVtaXRzIG11bHRpcGxlIG11dGF0aW9ucyBhZnRlclxuICAgICAqIGEgZGVsYXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIG1ha2luZyB0cmFjaW5nIGFkZGVkIG5vZGVzIGhhcmRcbiAgICAgKiBpbiBvdXIgYHByb2Nlc3NNdXRhdGlvbnNgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB3ZSBhcHBlbmQgYW4gZWxlbWVudCBlbF8xIGludG8gYm9keSwgYW5kIHRoZW4gYXBwZW5kXG4gICAgICogYW5vdGhlciBlbGVtZW50IGVsXzIgaW50byBlbF8xLCB0aGVzZSB0d28gbXV0YXRpb25zIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogY2FsbGJhY2sgZnVuY3Rpb24gdG9nZXRoZXIgd2hlbiB0aGUgdHdvIG9wZXJhdGlvbnMgd2VyZSBkb25lLlxuICAgICAqIEdlbmVyYWxseSB3ZSBuZWVkIHRvIHRyYWNlIGNoaWxkIG5vZGVzIG9mIG5ld2x5IGFkZGVkIG5vZGVzLCBidXQgaW4gdGhpc1xuICAgICAqIGNhc2UgaWYgd2UgY291bnQgZWxfMiBhcyBlbF8xJ3MgY2hpbGQgbm9kZSBpbiB0aGUgZmlyc3QgbXV0YXRpb24gcmVjb3JkLFxuICAgICAqIHRoZW4gd2Ugd2lsbCBjb3VudCBlbF8yIGFnYWluIGluIHRoZSBzZWNvbmQgbXV0YXRpb24gcmVjb3JkIHdoaWNoIHdhc1xuICAgICAqIGR1cGxpY2F0ZWQuXG4gICAgICogVG8gYXZvaWQgb2YgZHVwbGljYXRlIGNvdW50aW5nIGFkZGVkIG5vZGVzLCB3ZSB1c2UgYSBTZXQgdG8gc3RvcmVcbiAgICAgKiBhZGRlZCBub2RlcyBhbmQgaXRzIGNoaWxkIG5vZGVzIGR1cmluZyBpdGVyYXRlIG11dGF0aW9uIHJlY29yZHMuIFRoZW5cbiAgICAgKiBjb2xsZWN0IGFkZGVkIG5vZGVzIGZyb20gdGhlIFNldCB3aGljaCBoYXZlIG5vIGR1cGxpY2F0ZSBjb3B5LiBCdXRcbiAgICAgKiB0aGlzIGFsc28gY2F1c2VzIG5ld2x5IGFkZGVkIG5vZGVzIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQgd2l0aCBpZCBBU0FQLFxuICAgICAqIHdoaWNoIG1lYW5zIGFsbCB0aGUgaWQgcmVsYXRlZCBjYWxjdWxhdGlvbiBzaG91bGQgYmUgbGF6eSB0b28uXG4gICAgICovIF9fcHVibGljRmllbGQodGhpcywgXCJhZGRlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdmVkU2V0XCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZHJvcHBlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbW92ZXNTdWJUcmVlQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvY2tDbGFzc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb2NrU2VsZWN0b3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXNrVGV4dENsYXNzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRTZWxlY3RvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlubGluZVN0eWxlc2hlZXRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXNrSW5wdXRPcHRpb25zXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRGblwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tJbnB1dEZuXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2VlcElmcmFtZVNyY0ZuXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVjb3JkQ2FudmFzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5saW5lSW1hZ2VzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2xpbURPTU9wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhVVJMT3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvY1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZU1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNoYWRvd0RvbU1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjYW52YXNNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1bmF0dGFjaGVkRG9jXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uc1wiLCBmdW5jdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKF90aGlzLnByb2Nlc3NNdXRhdGlvbik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW1pdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5mcm96ZW4gfHwgX3RoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZGRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2YXIgYWRkTGlzdCA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KCk7XG4gICAgICAgICAgICB2YXIgZ2V0TmV4dElkID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSBuMjtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gSUdOT1JFRF9OT0RFO1xuICAgICAgICAgICAgICAgIHdoaWxlKG5leHRJZCA9PT0gSUdOT1JFRF9OT0RFKXtcbiAgICAgICAgICAgICAgICAgICAgbnMgPSBucyAmJiBucy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkID0gbnMgJiYgX3RoaXMubWlycm9yLmdldElkKG5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcHVzaEFkZCA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFpbkRvbShuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3NzQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAobjIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnQudGFnTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRhZyA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50VGFnID09PSBcIlNUWUxFXCIgJiYgX3RoaXMuYWRkZWRTZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QocGFyZW50KSA/IF90aGlzLm1pcnJvci5nZXRJZChnZXRTaGFkb3dIb3N0KG4yKSkgOiBfdGhpcy5taXJyb3IuZ2V0SWQocGFyZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gZ2V0TmV4dElkKG4yKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IC0xIHx8IG5leHRJZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzbiA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQobjIsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBfdGhpcy5kb2MsXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcjogX3RoaXMubWlycm9yLFxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBfdGhpcy5ibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBfdGhpcy5ibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBfdGhpcy5tYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBfdGhpcy5tYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBfdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBfdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBfdGhpcy5tYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogX3RoaXMubWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBfdGhpcy5zbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IF90aGlzLmRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IF90aGlzLnJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBfdGhpcy5pbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiBmdW5jdGlvbihjdXJyZW50Tikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShjdXJyZW50TiwgX3RoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KGN1cnJlbnROLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChjdXJyZW50Tik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIF90aGlzLmRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogZnVuY3Rpb24oaWZyYW1lLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IGZ1bmN0aW9uKGxpbmssIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmssIGNoaWxkU24pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjc3NDYXB0dXJlZDogY3NzQ2FwdHVyZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc24pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbmV4dElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogc25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSWRzLmFkZChzbi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlKF90aGlzLm1hcFJlbW92ZXMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAoX3RoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLm1vdmVkU2V0KSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQoX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSwgbjIsIF90aGlzLm1pcnJvcikgJiYgIV90aGlzLm1vdmVkU2V0LmhhcyhpbmRleC5wYXJlbnROb2RlKG4yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2hBZGQobjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLmFkZGVkU2V0KSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBuMjEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FuY2VzdG9ySW5TZXQoX3RoaXMuZHJvcHBlZFNldCwgbjIxKSAmJiAhaXNQYXJlbnRSZW1vdmVkKF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yMSwgX3RoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4yMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQoX3RoaXMubW92ZWRTZXQsIG4yMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuMjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuYWRkKG4yMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZShhZGRMaXN0Lmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5wYXJlbnROb2RlKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkID0gZ2V0TmV4dElkKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEgJiYgbmV4dElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFpbE5vZGUgPSBhZGRMaXN0LnRhaWw7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRhaWxOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZDEgPSBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXgucGFyZW50Tm9kZShfbm9kZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SWQxID0gZ2V0TmV4dElkKF9ub2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElkMSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudElkMSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuaGFuZGxlZE5vZGUgPSBfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGluZGV4LnBhcmVudE5vZGUodW5oYW5kbGVkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dIb3N0ID0gaW5kZXguaG9zdChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkMiA9IF90aGlzLm1pcnJvci5nZXRJZChzaGFkb3dIb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIgPSBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGFkZExpc3QuaGVhZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUoYWRkTGlzdC5oZWFkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZTIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKG5vZGUyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBwdXNoQWRkKG5vZGUyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHRleHRzOiBfdGhpcy50ZXh0cy5tYXAoZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjIgPSB0ZXh0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24ocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IF90aGlzLm1pcnJvci5nZXRJZChuMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYWRkZWRJZHMuaGFzKHRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5taXJyb3IuaGFzKHRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF90aGlzLmF0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuc3R5bGVEaWZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmNoYW5nZWRBc1N0ciA9IEpTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZS5fdW5jaGFuZ2VkU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmQXNTdHIubGVuZ3RoIDwgYXR0cmlidXRlcy5zdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZBc1N0ciArIHVuY2hhbmdlZEFzU3RyKS5zcGxpdChcInZhcihcIikubGVuZ3RoID09PSBhdHRyaWJ1dGVzLnN0eWxlLnNwbGl0KFwidmFyKFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IGF0dHJpYnV0ZS5zdHlsZURpZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX3RoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhYWRkZWRJZHMuaGFzKGF0dHJpYnV0ZS5pZCk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IF90aGlzLnJlbW92ZXMsXG4gICAgICAgICAgICAgICAgYWRkczogYWRkc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcGF5bG9hZC50ZXh0cy5sZW5ndGggJiYgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiYgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiYgIXBheWxvYWQuYWRkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy50ZXh0cyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVzID0gW107XG4gICAgICAgICAgICBfdGhpcy5hZGRlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5tb3ZlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgX3RoaXMubW92ZWRNYXAgPSB7fTtcbiAgICAgICAgICAgIF90aGlzLm11dGF0aW9uQ2IocGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uXCIsIGZ1bmN0aW9uKHRleHRhcmVhKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmF0dHJpYnV0ZU1hcC5nZXQodGV4dGFyZWEpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGV4dGFyZWEsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxuICAgICAgICAgICAgICAgICAgICBfdW5jaGFuZ2VkU3R5bGVzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZU1hcC5zZXQodGV4dGFyZWEsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzLnZhbHVlID0gQXJyYXkuZnJvbShpbmRleC5jaGlsZE5vZGVzKHRleHRhcmVhKSwgZnVuY3Rpb24oY24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgudGV4dENvbnRlbnQoY24pIHx8IFwiXCI7XG4gICAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvblwiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG0udGFyZ2V0LCBfdGhpcy5taXJyb3IsIF90aGlzLnNsaW1ET01PcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaChtLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4LnRleHRDb250ZW50KG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgJiYgdmFsdWUgIT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5lZWRNYXNraW5nVGV4dChtLnRhcmdldCwgX3RoaXMubWFza1RleHRDbGFzcywgX3RoaXMubWFza1RleHRTZWxlY3RvciwgdHJ1ZSkgJiYgdmFsdWUgPyBfdGhpcy5tYXNrVGV4dEZuID8gX3RoaXMubWFza1RleHRGbih2YWx1ZSwgY2xvc2VzdEVsZW1lbnRPZk5vZGUobS50YXJnZXQpKSA6IHZhbHVlLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKSA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlc1wiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG0uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTEgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTEgPSBtYXNrSW5wdXRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogX3RoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBfdGhpcy5tYXNrSW5wdXRGblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpIHx8IHZhbHVlMSA9PT0gbS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuYXR0cmlidXRlTWFwLmdldChtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgJiYgYXR0cmlidXRlTmFtZSA9PT0gXCJzcmNcIiAmJiAhX3RoaXMua2VlcElmcmFtZVNyY0ZuKHZhbHVlMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IFwicnJfc3JjXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInR5cGVcIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIChtLm9sZFZhbHVlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJyLWlzLXBhc3N3b3JkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhcmdldC50YWdOYW1lLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShfdGhpcy5kb2MsIHRvTG93ZXJDYXNlKHRhcmdldC50YWdOYW1lKSwgdG9Mb3dlckNhc2UoYXR0cmlidXRlTmFtZSksIHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnVuYXR0YWNoZWREb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5hdHRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bmF0dGFjaGVkRG9jID0gX3RoaXMuZG9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGQgPSBfdGhpcy51bmF0dGFjaGVkRG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIG0ub2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgfHwgbmV3UHJpb3JpdHkgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQcmlvcml0eSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl91bmNoYW5nZWRTdHlsZXNbcG5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKG9sZC5zdHlsZSkpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG5hbWUxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lMSkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZTFdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwib3BlblwiICYmIHRhcmdldC50YWdOYW1lID09PSBcIkRJQUxPR1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcyhcImRpYWxvZzptb2RhbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW1wicnJfb3Blbl9tb2RlXCJdID0gXCJtb2RhbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyaWJ1dGVzW1wicnJfb3Blbl9tb2RlXCJdID0gXCJub24tbW9kYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImNoaWxkTGlzdFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCB0cnVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udGFyZ2V0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbihtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbS5hZGRlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2VuQWRkcyhuMiwgbS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF90aGlzLm1pcnJvci5nZXRJZChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gaXNTaGFkb3dSb290KG0udGFyZ2V0KSA/IF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KG0udGFyZ2V0KSkgOiBfdGhpcy5taXJyb3IuZ2V0SWQobS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCBpc0lnbm9yZWQobjIsIF90aGlzLm1pcnJvciwgX3RoaXMuc2xpbURPTU9wdGlvbnMpIHx8ICFpc1NlcmlhbGl6ZWQobjIsIF90aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWRkZWRTZXQuaGFzKG4yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKF90aGlzLmFkZGVkU2V0LCBuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmFkZGVkU2V0LmhhcyhtLnRhcmdldCkgJiYgbm9kZUlkID09PSAtMSkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCBfdGhpcy5taXJyb3IpKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMubW92ZWRTZXQuaGFzKG4yKSAmJiBfdGhpcy5tb3ZlZE1hcFttb3ZlS2V5KG5vZGVJZCwgcGFyZW50SWQpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwRGVsZXRlKF90aGlzLm1vdmVkU2V0LCBuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NoYWRvdzogaXNTaGFkb3dSb290KG0udGFyZ2V0KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShtLnRhcmdldCkgPyB0cnVlIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUmVtb3ZlcyhuMiwgX3RoaXMucmVtb3Zlc1N1YlRyZWVDYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcFJlbW92ZXMucHVzaChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgeW91IGNoZWNrIGlmIGBuYCdzIHBhcmVudCBpcyBibG9ja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAqLyBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2VuQWRkc1wiLCBmdW5jdGlvbihuMiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuMiwgX3RoaXMpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWRkZWRTZXQuaGFzKG4yKSB8fCBfdGhpcy5tb3ZlZFNldC5oYXMobjIpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoX3RoaXMubWlycm9yLmhhc05vZGUobjIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JlZChuMiwgX3RoaXMubWlycm9yLCBfdGhpcy5zbGltRE9NT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlZFNldC5hZGQobjIpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiBfdGhpcy5taXJyb3IuaGFzTm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gX3RoaXMubWlycm9yLmdldElkKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJZCAmJiB0YXJnZXRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW92ZWRNYXBbbW92ZUtleShfdGhpcy5taXJyb3IuZ2V0SWQobjIpLCB0YXJnZXRJZCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldC5kZWxldGUobjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobjIsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMobjIpLmZvckVhY2goZnVuY3Rpb24oY2hpbGROKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZW5BZGRzKGNoaWxkTik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmNoaWxkTm9kZXMoaW5kZXguc2hhZG93Um9vdChuMikpLmZvckVhY2goZnVuY3Rpb24oY2hpbGROKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzZWROb2RlTWFuYWdlci5hZGQoY2hpbGROLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5BZGRzKGNoaWxkTiwgbjIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTXV0YXRpb25CdWZmZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFtcbiAgICAgICAgICAgIFwibXV0YXRpb25DYlwiLFxuICAgICAgICAgICAgXCJibG9ja0NsYXNzXCIsXG4gICAgICAgICAgICBcImJsb2NrU2VsZWN0b3JcIixcbiAgICAgICAgICAgIFwibWFza1RleHRDbGFzc1wiLFxuICAgICAgICAgICAgXCJtYXNrVGV4dFNlbGVjdG9yXCIsXG4gICAgICAgICAgICBcImlubGluZVN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgIFwibWFza0lucHV0T3B0aW9uc1wiLFxuICAgICAgICAgICAgXCJtYXNrVGV4dEZuXCIsXG4gICAgICAgICAgICBcIm1hc2tJbnB1dEZuXCIsXG4gICAgICAgICAgICBcImtlZXBJZnJhbWVTcmNGblwiLFxuICAgICAgICAgICAgXCJyZWNvcmRDYW52YXNcIixcbiAgICAgICAgICAgIFwiaW5saW5lSW1hZ2VzXCIsXG4gICAgICAgICAgICBcInNsaW1ET01PcHRpb25zXCIsXG4gICAgICAgICAgICBcImRhdGFVUkxPcHRpb25zXCIsXG4gICAgICAgICAgICBcImRvY1wiLFxuICAgICAgICAgICAgXCJtaXJyb3JcIixcbiAgICAgICAgICAgIFwiaWZyYW1lTWFuYWdlclwiLFxuICAgICAgICAgICAgXCJzdHlsZXNoZWV0TWFuYWdlclwiLFxuICAgICAgICAgICAgXCJzaGFkb3dEb21NYW5hZ2VyXCIsXG4gICAgICAgICAgICBcImNhbnZhc01hbmFnZXJcIixcbiAgICAgICAgICAgIFwicHJvY2Vzc2VkTm9kZU1hbmFnZXJcIlxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xuICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc0Zyb3plbiA9IGZ1bmN0aW9uIGlzRnJvemVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm96ZW47XG4gICAgfTtcbiAgICBfcHJvdG8ubG9jayA9IGZ1bmN0aW9uIGxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmxvY2soKTtcbiAgICB9O1xuICAgIF9wcm90by51bmxvY2sgPSBmdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5yZXNldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE11dGF0aW9uQnVmZmVyO1xufSgpO1xuZnVuY3Rpb24gZGVlcERlbGV0ZShhZGRzU2V0LCBuMikge1xuICAgIGFkZHNTZXQuZGVsZXRlKG4yKTtcbiAgICBpbmRleC5jaGlsZE5vZGVzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTikge1xuICAgICAgICByZXR1cm4gZGVlcERlbGV0ZShhZGRzU2V0LCBjaGlsZE4pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JlbW92ZXMobjIsIGNhY2hlKSB7XG4gICAgdmFyIHF1ZXVlID0gW1xuICAgICAgICBuMlxuICAgIF07XG4gICAgd2hpbGUocXVldWUubGVuZ3RoKXtcbiAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKGNhY2hlLmhhcyhuZXh0KSkgY29udGludWU7XG4gICAgICAgIGNhY2hlLmFkZChuZXh0KTtcbiAgICAgICAgaW5kZXguY2hpbGROb2RlcyhuZXh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4yMikge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLnB1c2gobjIyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGlzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMiwgbWlycm9yMikge1xuICAgIGlmIChyZW1vdmVzLnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMik7XG59XG5mdW5jdGlvbiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4yLCBfbWlycm9yMikge1xuICAgIHZhciBub2RlMiA9IGluZGV4LnBhcmVudE5vZGUobjIpO1xuICAgIGlmICghbm9kZTIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVtb3Zlcy5oYXMobm9kZTIpO1xufVxuZnVuY3Rpb24gaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgICBpZiAoc2V0LnNpemUgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIG4yKTtcbn1cbmZ1bmN0aW9uIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuMikge1xuICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZXQuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50KTtcbn1cbnZhciBlcnJvckhhbmRsZXI7XG5mdW5jdGlvbiByZWdpc3RlckVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG4gICAgZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKSB7XG4gICAgZXJyb3JIYW5kbGVyID0gdm9pZCAwO1xufVxudmFyIGNhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNiO1xuICAgIH1cbiAgICB2YXIgcnJ3ZWJXcmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHJlc3RbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyICYmIGVycm9ySGFuZGxlcihlcnJvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcbn07XG52YXIgbXV0YXRpb25CdWZmZXJzID0gW107XG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJwYXRoXCIgaW4gZXZlbnQgJiYgZXZlbnQucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wYXRoWzBdO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZXZlbnQgJiYgZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsKSB7XG4gICAgdmFyIG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XG4gICAgbXV0YXRpb25CdWZmZXJzLnB1c2gobXV0YXRpb25CdWZmZXIpO1xuICAgIG11dGF0aW9uQnVmZmVyLmluaXQob3B0aW9ucyk7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IChtdXRhdGlvbk9ic2VydmVyQ3RvcigpKShjYWxsYmFja1dyYXBwZXIobXV0YXRpb25CdWZmZXIucHJvY2Vzc011dGF0aW9ucy5iaW5kKG11dGF0aW9uQnVmZmVyKSkpO1xuICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgbW91c2Vtb3ZlQ2IgPSBwYXJhbS5tb3VzZW1vdmVDYiwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yO1xuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgdGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xuICAgIHZhciBjYWxsYmFja1RocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA9PT0gXCJudW1iZXJcIiA/IHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrIDogNTAwO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICB2YXIgdGltZUJhc2VsaW5lO1xuICAgIHZhciB3cmFwcGVkQ2IgPSB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciB0b3RhbE9mZnNldCA9IERhdGUubm93KCkgLSB0aW1lQmFzZWxpbmU7XG4gICAgICAgIG1vdXNlbW92ZUNiKHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcC50aW1lT2Zmc2V0IC09IHRvdGFsT2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pLCBzb3VyY2UpO1xuICAgICAgICBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGltZUJhc2VsaW5lID0gbnVsbDtcbiAgICB9KSwgY2FsbGJhY2tUaHJlc2hvbGQpO1xuICAgIHZhciB1cGRhdGVQb3NpdGlvbiA9IGNhbGxiYWNrV3JhcHBlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xuICAgICAgICB2YXIgX3JlZiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZ0KSA/IGV2dC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2dCwgY2xpZW50WCA9IF9yZWYuY2xpZW50WCwgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgICAgaWYgKCF0aW1lQmFzZWxpbmUpIHtcbiAgICAgICAgICAgIHRpbWVCYXNlbGluZSA9IG5vd1RpbWVzdGFtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgICAgICB5OiBjbGllbnRZLFxuICAgICAgICAgICAgaWQ6IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KSxcbiAgICAgICAgICAgIHRpbWVPZmZzZXQ6IG5vd1RpbWVzdGFtcCgpIC0gdGltZUJhc2VsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfaW5zdGFuY2VvZihldnQsIERyYWdFdmVudCkgPyBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnIDogX2luc3RhbmNlb2YoZXZ0LCBNb3VzZUV2ZW50KSA/IEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSA6IEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSk7XG4gICAgfSksIHRocmVzaG9sZCwge1xuICAgICAgICB0cmFpbGluZzogZmFsc2VcbiAgICB9KSk7XG4gICAgdmFyIGhhbmRsZXJzID0gW1xuICAgICAgICBvbihcIm1vdXNlbW92ZVwiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKSxcbiAgICAgICAgb24oXCJ0b3VjaG1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgICAgIG9uKFwiZHJhZ1wiLCB1cGRhdGVQb3NpdGlvbiwgZG9jKVxuICAgIF07XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgbW91c2VJbnRlcmFjdGlvbkNiID0gcGFyYW0ubW91c2VJbnRlcmFjdGlvbkNiLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZztcbiAgICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIHZhciBkaXNhYmxlTWFwID0gc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdHJ1ZSB8fCBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB2b2lkIDAgPyB7fSA6IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb247XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgdmFyIGdldEhhbmRsZXIgPSBmdW5jdGlvbihldmVudEtleSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRoaXNFdmVudEtleSA9IGV2ZW50S2V5O1xuICAgICAgICAgICAgaWYgKFwicG9pbnRlclR5cGVcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChldmVudC5wb2ludGVyVHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuTW91c2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5QZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSBcIlRvdWNoU3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFdmVudEtleSA9IFwiVG91Y2hFbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aChcIlRvdWNoXCIpICYmIHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuVG91Y2ggfHwgdGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJNb3VzZVwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IGN1cnJlbnRQb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGUyID0gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICAgICAgaWYgKCFlMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IG1pcnJvcjIuZ2V0SWQodGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBjbGllbnRYID0gZTIuY2xpZW50WCwgY2xpZW50WSA9IGUyLmNsaWVudFk7XG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIobW91c2VJbnRlcmFjdGlvbkNiKShfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgdHlwZTogTW91c2VJbnRlcmFjdGlvbnNbdGhpc0V2ZW50S2V5XSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiBjbGllbnRZXG4gICAgICAgICAgICB9LCBwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhNb3VzZUludGVyYWN0aW9ucykuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlcihrZXkpKSAmJiAha2V5LmVuZHNXaXRoKFwiX0RlcGFydGVkXCIpICYmIGRpc2FibGVNYXBba2V5XSAhPT0gZmFsc2U7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihldmVudEtleSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGdldEhhbmRsZXIoZXZlbnRLZXkpO1xuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgc3dpdGNoKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSl7XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwOlxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZShcIm1vdXNlXCIsIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0OlxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hFbmQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRTY3JvbGxPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBzY3JvbGxDYiA9IHBhcmFtLnNjcm9sbENiLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZztcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XG4gICAgICAgICAgICBzY3JvbGxDYih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHg6IHNjcm9sbExlZnRUb3AubGVmdCxcbiAgICAgICAgICAgICAgICB5OiBzY3JvbGxMZWZ0VG9wLnRvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxDYih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHg6IHRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRhcmdldC5zY3JvbGxUb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSksIHNhbXBsaW5nLnNjcm9sbCB8fCAxMDApKTtcbiAgICByZXR1cm4gb24oXCJzY3JvbGxcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyk7XG59XG5mdW5jdGlvbiBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcihwYXJhbSwgcGFyYW0xKSB7XG4gICAgdmFyIHZpZXdwb3J0UmVzaXplQ2IgPSBwYXJhbS52aWV3cG9ydFJlc2l6ZUNiO1xuICAgIHZhciB3aW4gPSBwYXJhbTEud2luO1xuICAgIHZhciBsYXN0SCA9IC0xO1xuICAgIHZhciBsYXN0VyA9IC0xO1xuICAgIHZhciB1cGRhdGVEaW1lbnNpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZ2V0V2luZG93SGVpZ2h0KCk7XG4gICAgICAgIHZhciB3aWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IE51bWJlcih3aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0SCA9IGhlaWdodDtcbiAgICAgICAgICAgIGxhc3RXID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICB9KSwgMjAwKSk7XG4gICAgcmV0dXJuIG9uKFwicmVzaXplXCIsIHVwZGF0ZURpbWVuc2lvbiwgd2luKTtcbn1cbnZhciBJTlBVVF9UQUdTID0gW1xuICAgIFwiSU5QVVRcIixcbiAgICBcIlRFWFRBUkVBXCIsXG4gICAgXCJTRUxFQ1RcIlxuXTtcbnZhciBsYXN0SW5wdXRWYWx1ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaW5pdElucHV0T2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgaW5wdXRDYiA9IHBhcmFtLmlucHV0Q2IsIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBpZ25vcmVDbGFzcyA9IHBhcmFtLmlnbm9yZUNsYXNzLCBpZ25vcmVTZWxlY3RvciA9IHBhcmFtLmlnbm9yZVNlbGVjdG9yLCBtYXNrSW5wdXRPcHRpb25zID0gcGFyYW0ubWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0Rm4gPSBwYXJhbS5tYXNrSW5wdXRGbiwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBwYXJhbS51c2VyVHJpZ2dlcmVkT25JbnB1dDtcbiAgICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgdmFyIHVzZXJUcmlnZ2VyZWQgPSBldmVudC5pc1RydXN0ZWQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lO1xuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhZ05hbWUgPT09IFwiT1BUSU9OXCIpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4LnBhcmVudEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFnTmFtZSB8fCBJTlBVVF9UQUdTLmluZGV4T2YodGFnTmFtZSkgPCAwIHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoaWdub3JlQ2xhc3MpIHx8IGlnbm9yZVNlbGVjdG9yICYmIHRhcmdldC5tYXRjaGVzKGlnbm9yZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgaXNDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCkgfHwgXCJcIjtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICAgIGlzQ2hlY2tlZCA9IHRhcmdldC5jaGVja2VkO1xuICAgICAgICB9IGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBtYXNrSW5wdXRPcHRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNiV2l0aERlZHVwKHRhcmdldCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPyB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaXNDaGVja2VkOiBpc0NoZWNrZWQsXG4gICAgICAgICAgICB1c2VyVHJpZ2dlcmVkOiB1c2VyVHJpZ2dlcmVkXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaXNDaGVja2VkOiBpc0NoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgbmFtZSAmJiBpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dDIgPSBlbC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2JXaXRoRGVkdXAoZWwsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoZWNrZWQ6ICFpc0NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyVHJpZ2dlcmVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoZWNrZWQ6ICFpc0NoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2JXaXRoRGVkdXAodGFyZ2V0LCB2Mikge1xuICAgICAgICB2YXIgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFsYXN0SW5wdXRWYWx1ZSB8fCBsYXN0SW5wdXRWYWx1ZS50ZXh0ICE9PSB2Mi50ZXh0IHx8IGxhc3RJbnB1dFZhbHVlLmlzQ2hlY2tlZCAhPT0gdjIuaXNDaGVja2VkKSB7XG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZU1hcC5zZXQodGFyZ2V0LCB2Mik7XG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoaW5wdXRDYikoX2V4dGVuZHMoe30sIHYyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV2ZW50cyA9IHNhbXBsaW5nLmlucHV0ID09PSBcImxhc3RcIiA/IFtcbiAgICAgICAgXCJjaGFuZ2VcIlxuICAgIF0gOiBbXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgXCJjaGFuZ2VcIlxuICAgIF07XG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzLm1hcChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlciksIGRvYyk7XG4gICAgfSk7XG4gICAgdmFyIGN1cnJlbnRXaW5kb3cgPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFjdXJyZW50V2luZG93KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IGN1cnJlbnRXaW5kb3cuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCBcInZhbHVlXCIpO1xuICAgIHZhciBob29rUHJvcGVydGllcyA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJjaGVja2VkXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwidmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICAvLyBTb21lIFVJIGxpYnJhcnkgdXNlIHNlbGVjdGVkSW5kZXggdG8gc2V0IHNlbGVjdCB2YWx1ZVxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwic2VsZWN0ZWRJbmRleFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTE9wdGlvbkVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJzZWxlY3RlZFwiXG4gICAgICAgIF1cbiAgICBdO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IgJiYgcHJvcGVydHlEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICB2YXIgX2hhbmRsZXJzO1xuICAgICAgICAoX2hhbmRsZXJzID0gaGFuZGxlcnMpLnB1c2guYXBwbHkoX2hhbmRsZXJzLCBbXS5jb25jYXQoaG9va1Byb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBob29rU2V0dGVyKHBbMF0sIHBbMV0sIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUcnVzdGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSwgY3VycmVudFdpbmRvdyk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHJ1bGUyKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoY2hpbGRSdWxlLCBwb3MpIHtcbiAgICAgICAgaWYgKGhhc05lc3RlZENTU1J1bGUoXCJDU1NHcm91cGluZ1J1bGVcIikgJiYgX2luc3RhbmNlb2YoY2hpbGRSdWxlLnBhcmVudFJ1bGUsIENTU0dyb3VwaW5nUnVsZSkgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU01lZGlhUnVsZVwiKSAmJiBfaW5zdGFuY2VvZihjaGlsZFJ1bGUucGFyZW50UnVsZSwgQ1NTTWVkaWFSdWxlKSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NTdXBwb3J0c1J1bGUpIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NDb25kaXRpb25SdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NDb25kaXRpb25SdWxlKSkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzMiA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHJ1bGVzMi5pbmRleE9mKGNoaWxkUnVsZSk7XG4gICAgICAgICAgICBwb3MudW5zaGlmdChpbmRleDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkUnVsZS5wYXJlbnRTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMyMSA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xuICAgICAgICAgICAgdmFyIGluZGV4MjEgPSBydWxlczIxLmluZGV4T2YoY2hpbGRSdWxlKTtcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4MjEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHJldHVybiByZWN1cnNlKHJ1bGUyLCBwb3NpdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0SWRBbmRTdHlsZUlkKHNoZWV0LCBtaXJyb3IyLCBzdHlsZU1pcnJvcikge1xuICAgIHZhciBpZCwgc3R5bGVJZDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm4ge307XG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSkgaWQgPSBtaXJyb3IyLmdldElkKHNoZWV0Lm93bmVyTm9kZSk7XG4gICAgZWxzZSBzdHlsZUlkID0gc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgIGlkOiBpZFxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0U3R5bGVTaGVldE9ic2VydmVyKHBhcmFtLCBwYXJhbTEpIHtcbiAgICB2YXIgc3R5bGVTaGVldFJ1bGVDYiA9IHBhcmFtLnN0eWxlU2hlZXRSdWxlQ2IsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyID0gcGFyYW0uc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdmFyIHdpbiA9IHBhcmFtMS53aW47XG4gICAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgaW5zZXJ0UnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KGluc2VydFJ1bGUsIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgIHZhciBydWxlMiA9IGFyZ3VtZW50c0xpc3RbMF0sIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMV07XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmFkZFJ1bGUgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3R5bGVCbG9jaywgaW5kZXgyKSB7XG4gICAgICAgIGlmIChpbmRleDIgPT09IHZvaWQgMCkgaW5kZXgyID0gdGhpcy5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBydWxlMiA9IHNlbGVjdG9yICsgXCIgeyBcIiArIHN0eWxlQmxvY2sgKyBcIiB9XCI7XG4gICAgICAgIHJldHVybiB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZS5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICBydWxlMixcbiAgICAgICAgICAgIGluZGV4MlxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHZhciBkZWxldGVSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGU7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbihpbmRleDIpIHtcbiAgICAgICAgcmV0dXJuIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgIGluZGV4MlxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlO1xuICAgIGlmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSkge1xuICAgICAgICByZXBsYWNlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2U7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gbmV3IFByb3h5KHJlcGxhY2UsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciByZXBsYWNlU3luYztcbiAgICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jKSB7XG4gICAgICAgIHJlcGxhY2VTeW5jID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jO1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSBuZXcgUHJveHkocmVwbGFjZVN5bmMsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3luYzogdGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XG4gICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0dyb3VwaW5nUnVsZVwiKSkge1xuICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTTWVkaWFSdWxlXCIpKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0NvbmRpdGlvblJ1bGUgPSB3aW4uQ1NTQ29uZGl0aW9uUnVsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKFwiQ1NTU3VwcG9ydHNSdWxlXCIpKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTU3VwcG9ydHNSdWxlID0gd2luLkNTU1N1cHBvcnRzUnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5tb2RpZmllZEZ1bmN0aW9ucyA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgdHlwZUtleSA9IHBhcmFtWzBdLCB0eXBlID0gcGFyYW1bMV07XG4gICAgICAgIHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0gPSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgZGVsZXRlUnVsZTogdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZVxuICAgICAgICB9O1xuICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZSwge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnVsZTIgPSBhcmd1bWVudHNMaXN0WzBdLCBpbmRleDIgPSBhcmd1bWVudHNMaXN0WzFdO1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW10uY29uY2F0KGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MiB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSwge1xuICAgICAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgyID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogW10uY29uY2F0KGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGluc2VydFJ1bGU7XG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZGVsZXRlUnVsZTtcbiAgICAgICAgcmVwbGFjZSAmJiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlKTtcbiAgICAgICAgcmVwbGFjZVN5bmMgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYyA9IHJlcGxhY2VTeW5jKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgdHlwZUtleSA9IHBhcmFtWzBdLCB0eXBlID0gcGFyYW1bMV07XG4gICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlID0gdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlO1xuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcihwYXJhbSwgaG9zdDIpIHtcbiAgICB2YXIgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIgPSBwYXJhbS5zdHlsZXNoZWV0TWFuYWdlcjtcbiAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgdmFyIGhvc3RJZCA9IG51bGw7XG4gICAgaWYgKGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiKSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGhvc3QyKTtcbiAgICBlbHNlIGhvc3RJZCA9IG1pcnJvcjIuZ2V0SWQoaW5kZXguaG9zdChob3N0MikpO1xuICAgIHZhciBwYXRjaFRhcmdldCA9IGhvc3QyLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiID8gKF9hMiA9IGhvc3QyLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLkRvY3VtZW50IDogKF9jID0gKF9iID0gaG9zdDIub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2MuU2hhZG93Um9vdDtcbiAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IgPSAocGF0Y2hUYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGNoVGFyZ2V0LnByb3RvdHlwZSkgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhdGNoVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIpIDogdm9pZCAwO1xuICAgIGlmIChob3N0SWQgPT09IG51bGwgfHwgaG9zdElkID09PSAtMSB8fCAhcGF0Y2hUYXJnZXQgfHwgIW9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yKSByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdDIsIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgIHJldHVybiAoX2EzID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNoZWV0cykge1xuICAgICAgICAgICAgdmFyIF9hMztcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMsIHNoZWV0cyk7XG4gICAgICAgICAgICBpZiAoaG9zdElkICE9PSBudWxsICYmIGhvc3RJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlMikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QyLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBnZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIHNldDogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihwYXJhbSwgcGFyYW0xKSB7XG4gICAgdmFyIHN0eWxlRGVjbGFyYXRpb25DYiA9IHBhcmFtLnN0eWxlRGVjbGFyYXRpb25DYiwgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgaWdub3JlQ1NTQXR0cmlidXRlcyA9IHBhcmFtLmlnbm9yZUNTU0F0dHJpYnV0ZXMsIHN0eWxlc2hlZXRNYW5hZ2VyID0gcGFyYW0uc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdmFyIHdpbiA9IHBhcmFtMS53aW47XG4gICAgdmFyIHNldFByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5O1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IG5ldyBQcm94eShzZXRQcm9wZXJ0eSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50c0xpc3RbMF0sIHZhbHVlID0gYXJndW1lbnRzTGlzdFsxXSwgcHJpb3JpdHkgPSBhcmd1bWVudHNMaXN0WzJdO1xuICAgICAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgdmFyIHJlbW92ZVByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5O1xuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IG5ldyBQcm94eShyZW1vdmVQcm9wZXJ0eSwge1xuICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICBpZiAoaWdub3JlQ1NTQXR0cmlidXRlcy5oYXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVByb3BlcnR5LmFwcGx5KHRoaXNBcmcsIFtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZ2V0SWRBbmRTdHlsZUlkID0gZ2V0SWRBbmRTdHlsZUlkKChfYTIgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucGFyZW50U3R5bGVTaGVldCwgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcucGFyZW50UnVsZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBtZWRpYUludGVyYWN0aW9uQ2IgPSBwYXJhbS5tZWRpYUludGVyYWN0aW9uQ2IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3RvciwgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgc2FtcGxpbmcgPSBwYXJhbS5zYW1wbGluZywgZG9jID0gcGFyYW0uZG9jO1xuICAgIHZhciBoYW5kbGVyID0gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGFyZ2V0LmN1cnJlbnRUaW1lLCB2b2x1bWUgPSB0YXJnZXQudm9sdW1lLCBtdXRlZCA9IHRhcmdldC5tdXRlZCwgcGxheWJhY2tSYXRlID0gdGFyZ2V0LnBsYXliYWNrUmF0ZSwgbG9vcCA9IHRhcmdldC5sb29wO1xuICAgICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGlkOiBtaXJyb3IyLmdldElkKHRhcmdldCksXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIHZvbHVtZTogdm9sdW1lLFxuICAgICAgICAgICAgICAgIG11dGVkOiBtdXRlZCxcbiAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSxcbiAgICAgICAgICAgICAgICBsb29wOiBsb29wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHNhbXBsaW5nLm1lZGlhIHx8IDUwMCk7XG4gICAgfSk7XG4gICAgdmFyIGhhbmRsZXJzID0gW1xuICAgICAgICBvbihcInBsYXlcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QbGF5KSwgZG9jKSxcbiAgICAgICAgb24oXCJwYXVzZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlBhdXNlKSwgZG9jKSxcbiAgICAgICAgb24oXCJzZWVrZWRcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5TZWVrZWQpLCBkb2MpLFxuICAgICAgICBvbihcInZvbHVtZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlZvbHVtZUNoYW5nZSksIGRvYyksXG4gICAgICAgIG9uKFwicmF0ZWNoYW5nZVwiLCBoYW5kbGVyKE1lZGlhSW50ZXJhY3Rpb25zLlJhdGVDaGFuZ2UpLCBkb2MpXG4gICAgXTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdEZvbnRPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBmb250Q2IgPSBwYXJhbS5mb250Q2IsIGRvYyA9IHBhcmFtLmRvYztcbiAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB2YXIgZm9udE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBvcmlnaW5hbEZvbnRGYWNlID0gd2luLkZvbnRGYWNlO1xuICAgIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlMihmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGZvbnRGYWNlID0gbmV3IG9yaWdpbmFsRm9udEZhY2UoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKTtcbiAgICAgICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcbiAgICAgICAgICAgIGZhbWlseTogZmFtaWx5LFxuICAgICAgICAgICAgYnVmZmVyOiB0eXBlb2Ygc291cmNlICE9PSBcInN0cmluZ1wiLFxuICAgICAgICAgICAgZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzLFxuICAgICAgICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiA/IHNvdXJjZSA6IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoc291cmNlKSkpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9udEZhY2U7XG4gICAgfTtcbiAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChkb2MuZm9udHMsIFwiYWRkXCIsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihmb250RmFjZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBmb250TWFwLmdldChmb250RmFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udENiKHApO1xuICAgICAgICAgICAgICAgICAgICBmb250TWFwLmRlbGV0ZShmb250RmFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICBmb250RmFjZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgaGFuZGxlcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLkZvbnRGYWNlID0gb3JpZ2luYWxGb250RmFjZTtcbiAgICB9KTtcbiAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNlbGVjdGlvbk9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvciwgYmxvY2tDbGFzcyA9IHBhcmFtLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBwYXJhbS5ibG9ja1NlbGVjdG9yLCBzZWxlY3Rpb25DYiA9IHBhcmFtLnNlbGVjdGlvbkNiO1xuICAgIHZhciBjb2xsYXBzZWQgPSB0cnVlO1xuICAgIHZhciB1cGRhdGVTZWxlY3Rpb24gPSBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8IGNvbGxhcHNlZCAmJiAoc2VsZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpKSByZXR1cm47XG4gICAgICAgIGNvbGxhcHNlZCA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCBmYWxzZTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICB2YXIgY291bnQgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudCB8fCAwO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBjb3VudDsgaTIrKyl7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpMik7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldCwgZW5kQ29udGFpbmVyID0gcmFuZ2UuZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZCA9IGlzQmxvY2tlZChzdGFydENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkgfHwgaXNCbG9ja2VkKGVuZENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoYmxvY2tlZCkgY29udGludWU7XG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1pcnJvcjIuZ2V0SWQoc3RhcnRDb250YWluZXIpLFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmQ6IG1pcnJvcjIuZ2V0SWQoZW5kQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQ6IGVuZE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uQ2Ioe1xuICAgICAgICAgICAgcmFuZ2VzOiByYW5nZXNcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIG9uKFwic2VsZWN0aW9uY2hhbmdlXCIsIHVwZGF0ZVNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIGRvYyA9IHBhcmFtLmRvYywgY3VzdG9tRWxlbWVudENiID0gcGFyYW0uY3VzdG9tRWxlbWVudENiO1xuICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCF3aW4gfHwgIXdpbi5jdXN0b21FbGVtZW50cykgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2god2luLmN1c3RvbUVsZW1lbnRzLCBcImRlZmluZVwiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgY29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudENiKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgZmFpbGVkIGZvciBcIiArIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN0b3JlSGFuZGxlcjtcbn1cbmZ1bmN0aW9uIG1lcmdlSG9va3MobzIsIGhvb2tzKSB7XG4gICAgdmFyIG11dGF0aW9uQ2IgPSBvMi5tdXRhdGlvbkNiLCBtb3VzZW1vdmVDYiA9IG8yLm1vdXNlbW92ZUNiLCBtb3VzZUludGVyYWN0aW9uQ2IgPSBvMi5tb3VzZUludGVyYWN0aW9uQ2IsIHNjcm9sbENiID0gbzIuc2Nyb2xsQ2IsIHZpZXdwb3J0UmVzaXplQ2IgPSBvMi52aWV3cG9ydFJlc2l6ZUNiLCBpbnB1dENiID0gbzIuaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiID0gbzIubWVkaWFJbnRlcmFjdGlvbkNiLCBzdHlsZVNoZWV0UnVsZUNiID0gbzIuc3R5bGVTaGVldFJ1bGVDYiwgc3R5bGVEZWNsYXJhdGlvbkNiID0gbzIuc3R5bGVEZWNsYXJhdGlvbkNiLCBjYW52YXNNdXRhdGlvbkNiID0gbzIuY2FudmFzTXV0YXRpb25DYiwgZm9udENiID0gbzIuZm9udENiLCBzZWxlY3Rpb25DYiA9IG8yLnNlbGVjdGlvbkNiLCBjdXN0b21FbGVtZW50Q2IgPSBvMi5jdXN0b21FbGVtZW50Q2I7XG4gICAgbzIubXV0YXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubXV0YXRpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIubW91c2Vtb3ZlQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubW91c2Vtb3ZlKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tb3VzZW1vdmUuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlbW92ZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1vdXNlSW50ZXJhY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tb3VzZUludGVyYWN0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuc2Nyb2xsQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc2Nyb2xsKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zY3JvbGwuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbENiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnZpZXdwb3J0UmVzaXplQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Mudmlld3BvcnRSZXNpemUpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnZpZXdwb3J0UmVzaXplLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmlucHV0Q2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmlucHV0LmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dENiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1lZGlhSW50ZXJhY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5tZWRpYUludGVhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLm1lZGlhSW50ZWFjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnN0eWxlU2hlZXRSdWxlQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc3R5bGVTaGVldFJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnN0eWxlU2hlZXRSdWxlLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVNoZWV0UnVsZUNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnN0eWxlRGVjbGFyYXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zdHlsZURlY2xhcmF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuY2FudmFzTXV0YXRpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5jYW52YXNNdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuY2FudmFzTXV0YXRpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhc011dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuZm9udENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmZvbnQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmZvbnQuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zZWxlY3Rpb25DYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLnNlbGVjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uQ2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuY3VzdG9tRWxlbWVudENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGMyID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjMltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuY3VzdG9tRWxlbWVudC5hcHBseShfaG9va3MsIFtdLmNvbmNhdChjMikpO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbUVsZW1lbnRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChjMikpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8yLCBob29rcykge1xuICAgIGlmIChob29rcyA9PT0gdm9pZCAwKSBob29rcyA9IHt9O1xuICAgIHZhciBjdXJyZW50V2luZG93ID0gbzIuZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghY3VycmVudFdpbmRvdykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgbWVyZ2VIb29rcyhvMiwgaG9va3MpO1xuICAgIHZhciBtdXRhdGlvbk9ic2VydmVyO1xuICAgIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKG8yLCBvMi5kb2MpO1xuICAgIH1cbiAgICB2YXIgbW91c2Vtb3ZlSGFuZGxlciA9IGluaXRNb3ZlT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBzY3JvbGxIYW5kbGVyID0gaW5pdFNjcm9sbE9ic2VydmVyKG8yKTtcbiAgICB2YXIgdmlld3BvcnRSZXNpemVIYW5kbGVyID0gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIobzIsIHtcbiAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgfSk7XG4gICAgdmFyIGlucHV0SGFuZGxlciA9IGluaXRJbnB1dE9ic2VydmVyKG8yKTtcbiAgICB2YXIgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgc3R5bGVTaGVldE9ic2VydmVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIGZvbnRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgaWYgKG8yLnJlY29yZERPTSkge1xuICAgICAgICBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0U3R5bGVTaGVldE9ic2VydmVyKG8yLCB7XG4gICAgICAgICAgICB3aW46IGN1cnJlbnRXaW5kb3dcbiAgICAgICAgfSk7XG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSBpbml0QWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcihvMiwgbzIuZG9jKTtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyID0gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihvMiwge1xuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobzIuY29sbGVjdEZvbnRzKSB7XG4gICAgICAgICAgICBmb250T2JzZXJ2ZXIgPSBpbml0Rm9udE9ic2VydmVyKG8yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VsZWN0aW9uT2JzZXJ2ZXIgPSBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIobzIpO1xuICAgIHZhciBjdXN0b21FbGVtZW50T2JzZXJ2ZXIgPSBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKG8yKTtcbiAgICB2YXIgcGx1Z2luSGFuZGxlcnMgPSBbXTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShvMi5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICB2YXIgcGx1Z2luMyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBwbHVnaW5IYW5kbGVycy5wdXNoKHBsdWdpbjMub2JzZXJ2ZXIocGx1Z2luMy5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luMy5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xuICAgICAgICBtb3VzZUludGVyYWN0aW9uSGFuZGxlcigpO1xuICAgICAgICBzY3JvbGxIYW5kbGVyKCk7XG4gICAgICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xuICAgICAgICBpbnB1dEhhbmRsZXIoKTtcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgICAgIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoKTtcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKCk7XG4gICAgICAgIGZvbnRPYnNlcnZlcigpO1xuICAgICAgICBzZWxlY3Rpb25PYnNlcnZlcigpO1xuICAgICAgICBjdXN0b21FbGVtZW50T2JzZXJ2ZXIoKTtcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhc05lc3RlZENTU1J1bGUocHJvcCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2Ygd2luZG93W3Byb3BdICE9PSBcInVuZGVmaW5lZFwiICYmIC8vIE5vdGU6IEdlbmVyYWxseSwgdGhpcyBjaGVjayBfc2hvdWxkbid0XyBiZSBuZWNlc3NhcnlcbiAgICAvLyBIb3dldmVyLCBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBqc2RvbSkgdGhpcyBjYW4gc29tZXRpbWVzIGZhaWwsIHNvIHdlIGNoZWNrIGZvciBpdCBoZXJlXG4gICAgd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImluc2VydFJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlICYmIFwiZGVsZXRlUnVsZVwiIGluIHdpbmRvd1twcm9wXS5wcm90b3R5cGUpO1xufVxudmFyIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDcm9zc09yaWdpbklmcmFtZU1pcnJvcihnZW5lcmF0ZUlkRm4pIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZUlkVG9SZW1vdGVJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVSZW1vdGVJZFRvSWRNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlSWRGbiA9IGdlbmVyYXRlSWRGbjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChpZnJhbWUsIHJlbW90ZUlkLCBpZFRvUmVtb3RlTWFwLCByZW1vdGVUb0lkTWFwKSB7XG4gICAgICAgIHZhciBpZFRvUmVtb3RlSWRNYXAgPSBpZFRvUmVtb3RlTWFwIHx8IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSByZW1vdGVUb0lkTWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgICAgIHZhciBpZCA9IGlkVG9SZW1vdGVJZE1hcC5nZXQocmVtb3RlSWQpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuZ2VuZXJhdGVJZEZuKCk7XG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAuc2V0KHJlbW90ZUlkLCBpZCk7XG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAuc2V0KGlkLCByZW1vdGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkcyA9IGZ1bmN0aW9uIGdldElkcyhpZnJhbWUsIHJlbW90ZUlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldElkKGlmcmFtZSwgaWQsIGlkVG9SZW1vdGVJZE1hcCwgcmVtb3RlSWRUb0lkTWFwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVtb3RlSWQgPSBmdW5jdGlvbiBnZXRSZW1vdGVJZChpZnJhbWUsIGlkLCBtYXApIHtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IG1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSBcIm51bWJlclwiKSByZXR1cm4gaWQ7XG4gICAgICAgIHZhciByZW1vdGVJZCA9IHJlbW90ZUlkVG9JZE1hcC5nZXQoaWQpO1xuICAgICAgICBpZiAoIXJlbW90ZUlkKSByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiByZW1vdGVJZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRSZW1vdGVJZHMgPSBmdW5jdGlvbiBnZXRSZW1vdGVJZHMoaWZyYW1lLCBpZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgICAgIHJldHVybiBpZHMubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgcmVtb3RlSWRUb0lkTWFwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldChpZnJhbWUpIHtcbiAgICAgICAgaWYgKCFpZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmRlbGV0ZShpZnJhbWUpO1xuICAgICAgICB0aGlzLmlmcmFtZVJlbW90ZUlkVG9JZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJZFRvUmVtb3RlSWRNYXAgPSBmdW5jdGlvbiBnZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKSB7XG4gICAgICAgIHZhciBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5nZXQoaWZyYW1lKTtcbiAgICAgICAgaWYgKCFpZFRvUmVtb3RlSWRNYXApIHtcbiAgICAgICAgICAgIGlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5zZXQoaWZyYW1lLCBpZFRvUmVtb3RlSWRNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFRvUmVtb3RlSWRNYXA7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVtb3RlSWRUb0lkTWFwID0gZnVuY3Rpb24gZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSkge1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZ2V0KGlmcmFtZSk7XG4gICAgICAgIGlmICghcmVtb3RlSWRUb0lkTWFwKSB7XG4gICAgICAgICAgICByZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuc2V0KGlmcmFtZSwgcmVtb3RlSWRUb0lkTWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3RlSWRUb0lkTWFwO1xuICAgIH07XG4gICAgcmV0dXJuIENyb3NzT3JpZ2luSWZyYW1lTWlycm9yO1xufSgpO1xudmFyIElmcmFtZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElmcmFtZU1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWZyYW1lc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZU1pcnJvclwiLCBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IoZ2VuSWQpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid3JhcHBlZEVtaXRcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2FkTGlzdGVuZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNoZWV0TWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29yZENyb3NzT3JpZ2luSWZyYW1lc1wiKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLndyYXBwZWRFbWl0ID0gb3B0aW9ucy53cmFwcGVkRW1pdDtcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0TWFuYWdlciA9IG9wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gb3B0aW9ucy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXM7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcih0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yLmdlbmVyYXRlSWQuYmluZCh0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSk7XG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgICAgIGlmICh0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSWZyYW1lTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZElmcmFtZSA9IGZ1bmN0aW9uIGFkZElmcmFtZShpZnJhbWVFbCkge1xuICAgICAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuc2V0KGlmcmFtZUVsLmNvbnRlbnRXaW5kb3csIGlmcmFtZUVsKTtcbiAgICB9O1xuICAgIF9wcm90by5hZGRMb2FkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMb2FkTGlzdGVuZXIoY2IpIHtcbiAgICAgICAgdGhpcy5sb2FkTGlzdGVuZXIgPSBjYjtcbiAgICB9O1xuICAgIF9wcm90by5hdHRhY2hJZnJhbWUgPSBmdW5jdGlvbiBhdHRhY2hJZnJhbWUoaWZyYW1lRWwsIGNoaWxkU24pIHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XG4gICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkU25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpIChfYTIgPSBpZnJhbWVFbC5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgKF9iID0gdGhpcy5sb2FkTGlzdGVuZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGlmcmFtZUVsKTtcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMubGVuZ3RoID4gMCkgdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEudHlwZSAhPT0gXCJycndlYlwiIHx8IC8vIFRvIGZpbHRlciBvdXQgdGhlIHJyd2ViIG1lc3NhZ2VzIHdoaWNoIGFyZSBmb3J3YXJkZWQgYnkgc29tZSBzaXRlcy5cbiAgICAgICAgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQub3JpZ2luICE9PSBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICB2YXIgaWZyYW1lU291cmNlV2luZG93ID0gbWVzc2FnZS5zb3VyY2U7XG4gICAgICAgIGlmICghaWZyYW1lU291cmNlV2luZG93KSByZXR1cm47XG4gICAgICAgIHZhciBpZnJhbWVFbCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuZ2V0KG1lc3NhZ2Uuc291cmNlKTtcbiAgICAgICAgaWYgKCFpZnJhbWVFbCkgcmV0dXJuO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRFdmVudCA9IHRoaXMudHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5ldmVudCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZEV2ZW50KSB0aGlzLndyYXBwZWRFbWl0KHRyYW5zZm9ybWVkRXZlbnQsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuaXNDaGVja291dCk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudCA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGUyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHN3aXRjaChlMi50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShlMi5kYXRhLm5vZGUsIGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RJZCA9IGUyLmRhdGEubm9kZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5zZXQoaWZyYW1lRWwsIHJvb3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2hSb290SWRPbk5vZGUoZTIuZGF0YS5ub2RlLCByb290SWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBlMi50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUyLmRhdGEubm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5NZXRhOlxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuTG9hZDpcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuUGx1Z2luOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLnBheWxvYWQsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dElkXCJcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGUyLmRhdGEuc291cmNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLmFkZHMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzSWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRPbk5vZGUobjIubm9kZSwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RJZCA9IF90aGlzLmNyb3NzT3JpZ2luSWZyYW1lUm9vdElkTWFwLmdldChpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290SWQgJiYgX3RoaXMucGF0Y2hSb290SWRPbk5vZGUobjIubm9kZSwgcm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEucmVtb3Zlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyZW50SWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEudGV4dHMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuRHJhZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMocCwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGw6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZVNoZWV0UnVsZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkZvbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKGUyLmRhdGEsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0eWxlSWRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYTIgPSBlMi5kYXRhLnN0eWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlU3R5bGVJZHMoc3R5bGUsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoaWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGtleXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gXCJudW1iZXJcIikgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoaWZyYW1lRWwsIG9ialtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWQoaWZyYW1lRWwsIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VJZHMgPSBmdW5jdGlvbiByZXBsYWNlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlU3R5bGVJZHMgPSBmdW5jdGlvbiByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZUlkT25Ob2RlID0gZnVuY3Rpb24gcmVwbGFjZUlkT25Ob2RlKG5vZGUyLCBpZnJhbWVFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlcGxhY2VJZHMobm9kZTIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICBcInJvb3RJZFwiXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoXCJjaGlsZE5vZGVzXCIgaW4gbm9kZTIpIHtcbiAgICAgICAgICAgIG5vZGUyLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZE9uTm9kZShjaGlsZCwgaWZyYW1lRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXRjaFJvb3RJZE9uTm9kZSA9IGZ1bmN0aW9uIHBhdGNoUm9vdElkT25Ob2RlKG5vZGUyLCByb290SWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IE5vZGVUeXBlLkRvY3VtZW50ICYmICFub2RlMi5yb290SWQpIG5vZGUyLnJvb3RJZCA9IHJvb3RJZDtcbiAgICAgICAgaWYgKFwiY2hpbGROb2Rlc1wiIGluIG5vZGUyKSB7XG4gICAgICAgICAgICBub2RlMi5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShjaGlsZCwgcm9vdElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSWZyYW1lTWFuYWdlcjtcbn0oKTtcbnZhciBTaGFkb3dEb21NYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dEb21NYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNoYWRvd0RvbXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjcm9sbENiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYnlwYXNzT3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc3RvcmVIYW5kbGVyc1wiLCBbXSk7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy5zY3JvbGxDYiA9IG9wdGlvbnMuc2Nyb2xsQ2I7XG4gICAgICAgIHRoaXMuYnlwYXNzT3B0aW9ucyA9IG9wdGlvbnMuYnlwYXNzT3B0aW9ucztcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTaGFkb3dEb21NYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5wYXRjaEF0dGFjaFNoYWRvdyhFbGVtZW50LCBkb2N1bWVudCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkU2hhZG93Um9vdCA9IGZ1bmN0aW9uIGFkZFNoYWRvd1Jvb3Qoc2hhZG93Um9vdDIsIGRvYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QyKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dEb21zLmhhcyhzaGFkb3dSb290MikpIHJldHVybjtcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zLmFkZChzaGFkb3dSb290Mik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKF9leHRlbmRzKHt9LCB0aGlzLmJ5cGFzc09wdGlvbnMsIHtcbiAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLFxuICAgICAgICAgICAgbWlycm9yOiB0aGlzLm1pcnJvcixcbiAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXI6IHRoaXNcbiAgICAgICAgfSksIHNoYWRvd1Jvb3QyKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGluaXRTY3JvbGxPYnNlcnZlcihfZXh0ZW5kcyh7fSwgdGhpcy5ieXBhc3NPcHRpb25zLCB7XG4gICAgICAgICAgICBzY3JvbGxDYjogdGhpcy5zY3JvbGxDYixcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3ByYXZlZW5wdWdsaWEvMDgzMmRhNjg3ZWQ1YTVkN2EwOTA3MDQ2YzllZjE4MTNcbiAgICAgICAgICAgIC8vIHNjcm9sbCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIHRoZSBib3VuZGFyeSwgc28gd2UgbmVlZCB0byBsaXN0ZW4gdGhlIHNoYWRvdyBkb2N1bWVudFxuICAgICAgICAgICAgZG9jOiBzaGFkb3dSb290MixcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICAgICAgfSkpKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMgJiYgc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApIF90aGlzLmJ5cGFzc09wdGlvbnMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGFkb3dSb290Mi5hZG9wdGVkU3R5bGVTaGVldHMsIF90aGlzLm1pcnJvci5nZXRJZChpbmRleC5ob3N0KHNoYWRvd1Jvb3QyKSkpO1xuICAgICAgICAgICAgX3RoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIoe1xuICAgICAgICAgICAgICAgIG1pcnJvcjogX3RoaXMubWlycm9yLFxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBfdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyXG4gICAgICAgICAgICB9LCBzaGFkb3dSb290MikpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBNb25rZXkgcGF0Y2ggJ2F0dGFjaFNoYWRvdycgb2YgYW4gSUZyYW1lRWxlbWVudCB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi8gX3Byb3RvLm9ic2VydmVBdHRhY2hTaGFkb3cgPSBmdW5jdGlvbiBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFpZnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3cgfHwgIWlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93LkVsZW1lbnQsIGlmcmFtZUVsZW1lbnQuY29udGVudERvY3VtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgKiBQYXRjaCAnYXR0YWNoU2hhZG93JyB0byBvYnNlcnZlIG5ld2x5IGFkZGVkIHNoYWRvdyBkb21zLlxuICAgKi8gX3Byb3RvLnBhdGNoQXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gcGF0Y2hBdHRhY2hTaGFkb3coZWxlbWVudCwgZG9jKSB7XG4gICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChwYXRjaChlbGVtZW50LnByb3RvdHlwZSwgXCJhdHRhY2hTaGFkb3dcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc1Jvb3QgPSBvcmlnaW5hbC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIHNoYWRvd1Jvb3RFbCA9IGluZGV4LnNoYWRvd1Jvb3QodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3RFbCAmJiBpbkRvbSh0aGlzKSkgbWFuYWdlci5hZGRTaGFkb3dSb290KHNoYWRvd1Jvb3RFbCwgZG9jKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc1Jvb3Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhZG93RG9tTWFuYWdlcjtcbn0oKTtcbnZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xudmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yKHZhciBpJDEgPSAwOyBpJDEgPCBjaGFycy5sZW5ndGg7IGkkMSsrKXtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpJDEpXSA9IGkkMTtcbn1cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksIGkyLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG4gICAgZm9yKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpe1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTJdID4+IDJdO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKGJ5dGVzW2kyXSAmIDMpIDw8IDQgfCBieXRlc1tpMiArIDFdID4+IDRdO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKGJ5dGVzW2kyICsgMV0gJiAxNSkgPDwgMiB8IGJ5dGVzW2kyICsgMl0gPj4gNl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpMiArIDJdICYgNjNdO1xuICAgIH1cbiAgICBpZiAobGVuICUgMyA9PT0gMikge1xuICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG52YXIgY2FudmFzVmFyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHZhcmlhYmxlTGlzdEZvciQxKGN0eCwgY3Rvcikge1xuICAgIHZhciBjb250ZXh0TWFwID0gY2FudmFzVmFyTWFwLmdldChjdHgpO1xuICAgIGlmICghY29udGV4dE1hcCkge1xuICAgICAgICBjb250ZXh0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY2FudmFzVmFyTWFwLnNldChjdHgsIGNvbnRleHRNYXApO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHRNYXAuaGFzKGN0b3IpKSB7XG4gICAgICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRNYXAuZ2V0KGN0b3IpO1xufVxudmFyIHNhdmVXZWJHTFZhciA9IGZ1bmN0aW9uKHZhbHVlLCB3aW4sIGN0eCkge1xuICAgIGlmICghdmFsdWUgfHwgIShpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIpKSByZXR1cm47XG4gICAgdmFyIG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHZhciBsaXN0MiA9IHZhcmlhYmxlTGlzdEZvciQxKGN0eCwgbmFtZSk7XG4gICAgdmFyIGluZGV4MiA9IGxpc3QyLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpbmRleDIgPT09IC0xKSB7XG4gICAgICAgIGluZGV4MiA9IGxpc3QyLmxlbmd0aDtcbiAgICAgICAgbGlzdDIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDI7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQXJnKHZhbHVlLCB3aW4sIGN0eCkge1xuICAgIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgQXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBGbG9hdDMyQXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBGbG9hdDY0QXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBJbnQzMkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgVWludDMyQXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBVaW50OEFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgVWludDE2QXJyYXkpIHx8IF9pbnN0YW5jZW9mKHZhbHVlLCBJbnQxNkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgSW50OEFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgVWludDhDbGFtcGVkQXJyYXkpKSB7XG4gICAgICAgIHZhciBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh2YWx1ZSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKC8vIFNoYXJlZEFycmF5QnVmZmVyIGRpc2FibGVkIG9uIG1vc3QgYnJvd3NlcnMgZHVlIHRvIHNwZWN0cmUuXG4gICAgLy8gTW9yZSBpbmZvOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TaGFyZWRBcnJheUJ1ZmZlci9TaGFyZWRBcnJheUJ1ZmZlclxuICAgIC8vIHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIgfHxcbiAgICBfaW5zdGFuY2VvZih2YWx1ZSwgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHZhciBuYW1lMSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHZhciBiYXNlNjQgPSBlbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTEsXG4gICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIERhdGFWaWV3KSkge1xuICAgICAgICB2YXIgbmFtZTIgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTIsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmJ1ZmZlciwgd2luLCBjdHgpLFxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEhUTUxJbWFnZUVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBuYW1lMyA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHZhciBzcmMgPSB2YWx1ZS5zcmM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lMyxcbiAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG4gICAgICAgIHZhciBuYW1lNCA9IFwiSFRNTEltYWdlRWxlbWVudFwiO1xuICAgICAgICB2YXIgc3JjMSA9IHZhbHVlLnRvRGF0YVVSTCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTQsXG4gICAgICAgICAgICBzcmM6IHNyYzFcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBJbWFnZURhdGEpKSB7XG4gICAgICAgIHZhciBuYW1lNSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lNSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVBcmcodmFsdWUuZGF0YSwgd2luLCBjdHgpLFxuICAgICAgICAgICAgICAgIHZhbHVlLndpZHRoLFxuICAgICAgICAgICAgICAgIHZhbHVlLmhlaWdodFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBuYW1lNiA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHZhciBpbmRleDIgPSBzYXZlV2ViR0xWYXIodmFsdWUsIHdpbiwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWU2LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG52YXIgc2VyaWFsaXplQXJncyA9IGZ1bmN0aW9uKGFyZ3MsIHdpbiwgY3R4KSB7XG4gICAgcmV0dXJuIGFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpO1xuICAgIH0pO1xufTtcbnZhciBpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlLCB3aW4pIHtcbiAgICB2YXIgd2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gW1xuICAgICAgICBcIldlYkdMQWN0aXZlSW5mb1wiLFxuICAgICAgICBcIldlYkdMQnVmZmVyXCIsXG4gICAgICAgIFwiV2ViR0xGcmFtZWJ1ZmZlclwiLFxuICAgICAgICBcIldlYkdMUHJvZ3JhbVwiLFxuICAgICAgICBcIldlYkdMUmVuZGVyYnVmZmVyXCIsXG4gICAgICAgIFwiV2ViR0xTaGFkZXJcIixcbiAgICAgICAgXCJXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdFwiLFxuICAgICAgICBcIldlYkdMVGV4dHVyZVwiLFxuICAgICAgICBcIldlYkdMVW5pZm9ybUxvY2F0aW9uXCIsXG4gICAgICAgIFwiV2ViR0xWZXJ0ZXhBcnJheU9iamVjdFwiLFxuICAgICAgICAvLyBJbiBvbGQgQ2hyb21lIHZlcnNpb25zLCB2YWx1ZSB3b24ndCBiZSBhbiBpbnN0YW5jZW9mIFdlYkdMVmVydGV4QXJyYXlPYmplY3QuXG4gICAgICAgIFwiV2ViR0xWZXJ0ZXhBcnJheU9iamVjdE9FU1wiXG4gICAgXTtcbiAgICB2YXIgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gd2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luW25hbWVdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfSk7XG4gICAgcmV0dXJuIEJvb2xlYW4oc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbmQoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gX2luc3RhbmNlb2YodmFsdWUsIHdpbltuYW1lXSk7XG4gICAgfSkpO1xufTtcbmZ1bmN0aW9uIGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZVtwcm9wXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKF90aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZWNvcmRBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2Mikge1xuICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIHByb3BzMkQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSk7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocHJvcHMyRCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KV9sb29wKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpIHtcbiAgICByZXR1cm4gY29udGV4dFR5cGUgPT09IFwiZXhwZXJpbWVudGFsLXdlYmdsXCIgPyBcIndlYmdsXCIgOiBjb250ZXh0VHlwZTtcbn1cbmZ1bmN0aW9uIGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCBcImdldENvbnRleHRcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0VHlwZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4TmFtZSA9IGdldE5vcm1hbGl6ZWRDb250ZXh0TmFtZShjb250ZXh0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKFwiX19jb250ZXh0XCIgaW4gdGhpcykpIHRoaXMuX19jb250ZXh0ID0gY3R4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldFByZXNlcnZlRHJhd2luZ0J1ZmZlclRvVHJ1ZSAmJiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsMlwiXG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoY3R4TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdICYmIF90eXBlX29mKGFyZ3NbMF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRBdHRyaWJ1dGVzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFR5cGVcbiAgICAgICAgICAgICAgICBdLCBhcmdzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIHBhdGNoIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS5nZXRDb250ZXh0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhdGNoR0xQcm90b3R5cGUocHJvdG90eXBlLCB0eXBlLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmICgvL3Byb3Auc3RhcnRzV2l0aCgnZ2V0JykgfHwgIC8vIGUuZy4gZ2V0UHJvZ3JhbVBhcmFtZXRlciwgYnV0IHRvbyByaXNreVxuICAgICAgICBbXG4gICAgICAgICAgICBcImlzQ29udGV4dExvc3RcIixcbiAgICAgICAgICAgIFwiY2FudmFzXCIsXG4gICAgICAgICAgICBcImRyYXdpbmdCdWZmZXJXaWR0aFwiLFxuICAgICAgICAgICAgXCJkcmF3aW5nQnVmZmVySGVpZ2h0XCJcbiAgICAgICAgXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGVbcHJvcF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChwcm90b3R5cGUsIHByb3AsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQyID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVXZWJHTFZhcihyZXN1bHQyLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0YWdOYW1lXCIgaW4gdGhpcy5jYW52YXMgJiYgIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCBtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIocHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MlxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xuICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHByb3BzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspX2xvb3AoKTtcbiAgICByZXR1cm4gaGFuZGxlcnM7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICB2YXIgX2hhbmRsZXJzO1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIChfaGFuZGxlcnMgPSBoYW5kbGVycykucHVzaC5hcHBseShfaGFuZGxlcnMsIFtdLmNvbmNhdChwYXRjaEdMUHJvdG90eXBlKHdpbi5XZWJHTFJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgd2luKSkpO1xuICAgIGlmICh0eXBlb2Ygd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIF9oYW5kbGVyczE7XG4gICAgICAgIChfaGFuZGxlcnMxID0gaGFuZGxlcnMpLnB1c2guYXBwbHkoX2hhbmRsZXJzMSwgW10uY29uY2F0KHBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMMiwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHdpbikpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG52YXIgZW5jb2RlZEpzID0gXCJLR1oxYm1OMGFXOXVLQ2tnZXdvZ0lDSjFjMlVnYzNSeWFXTjBJanNLSUNCMllYSWdZMmhoY25NZ1BTQWlRVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMVJWVmxkWVdWcGhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVqQXhNak0wTlRZM09Ea3JMeUk3Q2lBZ2RtRnlJR3h2YjJ0MWNDQTlJSFI1Y0dWdlppQlZhVzUwT0VGeWNtRjVJRDA5UFNBaWRXNWtaV1pwYm1Wa0lpQS9JRnRkSURvZ2JtVjNJRlZwYm5RNFFYSnlZWGtvTWpVMktUc0tJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdOb1lYSnpMbXhsYm1kMGFEc2dhU3NyS1NCN0NpQWdJQ0JzYjI5cmRYQmJZMmhoY25NdVkyaGhja052WkdWQmRDaHBLVjBnUFNCcE93b2dJSDBLSUNCMllYSWdaVzVqYjJSbElEMGdablZ1WTNScGIyNG9ZWEp5WVhsaWRXWm1aWElwSUhzS0lDQWdJSFpoY2lCaWVYUmxjeUE5SUc1bGR5QlZhVzUwT0VGeWNtRjVLR0Z5Y21GNVluVm1abVZ5S1N3Z2FUSXNJR3hsYmlBOUlHSjVkR1Z6TG14bGJtZDBhQ3dnWW1GelpUWTBJRDBnSWlJN0NpQWdJQ0JtYjNJZ0tHa3lJRDBnTURzZ2FUSWdQQ0JzWlc0N0lHa3lJQ3M5SURNcElIc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6VzJKNWRHVnpXMmt5WFNBK1BpQXlYVHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKeld5aGllWFJsYzF0cE1sMGdKaUF6S1NBOFBDQTBJSHdnWW5sMFpYTmJhVElnS3lBeFhTQStQaUEwWFRzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXeWhpZVhSbGMxdHBNaUFySURGZElDWWdNVFVwSUR3OElESWdmQ0JpZVhSbGMxdHBNaUFySURKZElENCtJRFpkT3dvZ0lDQWdJQ0JpWVhObE5qUWdLejBnWTJoaGNuTmJZbmwwWlhOYmFUSWdLeUF5WFNBbUlEWXpYVHNLSUNBZ0lIMEtJQ0FnSUdsbUlDaHNaVzRnSlNBeklEMDlQU0F5S1NCN0NpQWdJQ0FnSUdKaGMyVTJOQ0E5SUdKaGMyVTJOQzV6ZFdKemRISnBibWNvTUN3Z1ltRnpaVFkwTG14bGJtZDBhQ0F0SURFcElDc2dJajBpT3dvZ0lDQWdmU0JsYkhObElHbG1JQ2hzWlc0Z0pTQXpJRDA5UFNBeEtTQjdDaUFnSUNBZ0lHSmhjMlUyTkNBOUlHSmhjMlUyTkM1emRXSnpkSEpwYm1jb01Dd2dZbUZ6WlRZMExteGxibWQwYUNBdElESXBJQ3NnSWowOUlqc0tJQ0FnSUgwS0lDQWdJSEpsZEhWeWJpQmlZWE5sTmpRN0NpQWdmVHNLSUNCamIyNXpkQ0JzWVhOMFFteHZZazFoY0NBOUlDOHFJRUJmWDFCVlVrVmZYeUFxTHlCdVpYY2dUV0Z3S0NrN0NpQWdZMjl1YzNRZ2RISmhibk53WVhKbGJuUkNiRzlpVFdGd0lEMGdMeW9nUUY5ZlVGVlNSVjlmSUNvdklHNWxkeUJOWVhBb0tUc0tJQ0JoYzNsdVl5Qm1kVzVqZEdsdmJpQm5aWFJVY21GdWMzQmhjbVZ1ZEVKc2IySkdiM0lvZDJsa2RHZ3NJR2hsYVdkb2RDd2daR0YwWVZWU1RFOXdkR2x2Ym5NcElIc0tJQ0FnSUdOdmJuTjBJR2xrSUQwZ1lDUjdkMmxrZEdoOUxTUjdhR1ZwWjJoMGZXQTdDaUFnSUNCcFppQW9JazltWm5OamNtVmxia05oYm5aaGN5SWdhVzRnWjJ4dlltRnNWR2hwY3lrZ2V3b2dJQ0FnSUNCcFppQW9kSEpoYm5Od1lYSmxiblJDYkc5aVRXRndMbWhoY3locFpDa3BJSEpsZEhWeWJpQjBjbUZ1YzNCaGNtVnVkRUpzYjJKTllYQXVaMlYwS0dsa0tUc0tJQ0FnSUNBZ1kyOXVjM1FnYjJabWMyTnlaV1Z1SUQwZ2JtVjNJRTltWm5OamNtVmxia05oYm5aaGN5aDNhV1IwYUN3Z2FHVnBaMmgwS1RzS0lDQWdJQ0FnYjJabWMyTnlaV1Z1TG1kbGRFTnZiblJsZUhRb0lqSmtJaWs3Q2lBZ0lDQWdJR052Ym5OMElHSnNiMklnUFNCaGQyRnBkQ0J2Wm1aelkzSmxaVzR1WTI5dWRtVnlkRlJ2UW14dllpaGtZWFJoVlZKTVQzQjBhVzl1Y3lrN0NpQWdJQ0FnSUdOdmJuTjBJR0Z5Y21GNVFuVm1abVZ5SUQwZ1lYZGhhWFFnWW14dllpNWhjbkpoZVVKMVptWmxjaWdwT3dvZ0lDQWdJQ0JqYjI1emRDQmlZWE5sTmpRZ1BTQmxibU52WkdVb1lYSnlZWGxDZFdabVpYSXBPd29nSUNBZ0lDQjBjbUZ1YzNCaGNtVnVkRUpzYjJKTllYQXVjMlYwS0dsa0xDQmlZWE5sTmpRcE93b2dJQ0FnSUNCeVpYUjFjbTRnWW1GelpUWTBPd29nSUNBZ2ZTQmxiSE5sSUhzS0lDQWdJQ0FnY21WMGRYSnVJQ0lpT3dvZ0lDQWdmUW9nSUgwS0lDQmpiMjV6ZENCM2IzSnJaWElnUFNCelpXeG1Pd29nSUhkdmNtdGxjaTV2Ym0xbGMzTmhaMlVnUFNCaGMzbHVZeUJtZFc1amRHbHZiaWhsS1NCN0NpQWdJQ0JwWmlBb0lrOW1abk5qY21WbGJrTmhiblpoY3lJZ2FXNGdaMnh2WW1Gc1ZHaHBjeWtnZXdvZ0lDQWdJQ0JqYjI1emRDQjdJR2xrTENCaWFYUnRZWEFzSUhkcFpIUm9MQ0JvWldsbmFIUXNJR1JoZEdGVlVreFBjSFJwYjI1eklIMGdQU0JsTG1SaGRHRTdDaUFnSUNBZ0lHTnZibk4wSUhSeVlXNXpjR0Z5Wlc1MFFtRnpaVFkwSUQwZ1oyVjBWSEpoYm5Od1lYSmxiblJDYkc5aVJtOXlLQW9nSUNBZ0lDQWdJSGRwWkhSb0xBb2dJQ0FnSUNBZ0lHaGxhV2RvZEN3S0lDQWdJQ0FnSUNCa1lYUmhWVkpNVDNCMGFXOXVjd29nSUNBZ0lDQXBPd29nSUNBZ0lDQmpiMjV6ZENCdlptWnpZM0psWlc0Z1BTQnVaWGNnVDJabWMyTnlaV1Z1UTJGdWRtRnpLSGRwWkhSb0xDQm9aV2xuYUhRcE93b2dJQ0FnSUNCamIyNXpkQ0JqZEhnZ1BTQnZabVp6WTNKbFpXNHVaMlYwUTI5dWRHVjRkQ2dpTW1RaUtUc0tJQ0FnSUNBZ1kzUjRMbVJ5WVhkSmJXRm5aU2hpYVhSdFlYQXNJREFzSURBcE93b2dJQ0FnSUNCaWFYUnRZWEF1WTJ4dmMyVW9LVHNLSUNBZ0lDQWdZMjl1YzNRZ1lteHZZaUE5SUdGM1lXbDBJRzltWm5OamNtVmxiaTVqYjI1MlpYSjBWRzlDYkc5aUtHUmhkR0ZWVWt4UGNIUnBiMjV6S1RzS0lDQWdJQ0FnWTI5dWMzUWdkSGx3WlNBOUlHSnNiMkl1ZEhsd1pUc0tJQ0FnSUNBZ1kyOXVjM1FnWVhKeVlYbENkV1ptWlhJZ1BTQmhkMkZwZENCaWJHOWlMbUZ5Y21GNVFuVm1abVZ5S0NrN0NpQWdJQ0FnSUdOdmJuTjBJR0poYzJVMk5DQTlJR1Z1WTI5a1pTaGhjbkpoZVVKMVptWmxjaWs3Q2lBZ0lDQWdJR2xtSUNnaGJHRnpkRUpzYjJKTllYQXVhR0Z6S0dsa0tTQW1KaUJoZDJGcGRDQjBjbUZ1YzNCaGNtVnVkRUpoYzJVMk5DQTlQVDBnWW1GelpUWTBLU0I3Q2lBZ0lDQWdJQ0FnYkdGemRFSnNiMkpOWVhBdWMyVjBLR2xrTENCaVlYTmxOalFwT3dvZ0lDQWdJQ0FnSUhKbGRIVnliaUIzYjNKclpYSXVjRzl6ZEUxbGMzTmhaMlVvZXlCcFpDQjlLVHNLSUNBZ0lDQWdmUW9nSUNBZ0lDQnBaaUFvYkdGemRFSnNiMkpOWVhBdVoyVjBLR2xrS1NBOVBUMGdZbUZ6WlRZMEtTQnlaWFIxY200Z2QyOXlhMlZ5TG5CdmMzUk5aWE56WVdkbEtIc2dhV1FnZlNrN0NpQWdJQ0FnSUhkdmNtdGxjaTV3YjNOMFRXVnpjMkZuWlNoN0NpQWdJQ0FnSUNBZ2FXUXNDaUFnSUNBZ0lDQWdkSGx3WlN3S0lDQWdJQ0FnSUNCaVlYTmxOalFzQ2lBZ0lDQWdJQ0FnZDJsa2RHZ3NDaUFnSUNBZ0lDQWdhR1ZwWjJoMENpQWdJQ0FnSUgwcE93b2dJQ0FnSUNCc1lYTjBRbXh2WWsxaGNDNXpaWFFvYVdRc0lHSmhjMlUyTkNrN0NpQWdJQ0I5SUdWc2MyVWdld29nSUNBZ0lDQnlaWFIxY200Z2QyOXlhMlZ5TG5CdmMzUk5aWE56WVdkbEtIc2dhV1E2SUdVdVpHRjBZUzVwWkNCOUtUc0tJQ0FnSUgwS0lDQjlPd3A5S1NncE93b3ZMeU1nYzI5MWNtTmxUV0Z3Y0dsdVoxVlNURDFwYldGblpTMWlhWFJ0WVhBdFpHRjBZUzExY213dGQyOXlhMlZ5TFVsS2NFTTNaMTlpTG1wekxtMWhjQW89XCI7XG52YXIgZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKGJhc2U2NCksIGZ1bmN0aW9uKGMyKSB7XG4gICAgICAgIHJldHVybiBjMi5jaGFyQ29kZUF0KDApO1xuICAgIH0pO1xufTtcbnZhciBibG9iID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuQmxvYiAmJiBuZXcgQmxvYihbXG4gICAgZGVjb2RlQmFzZTY0KGVuY29kZWRKcylcbl0sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04XCJcbn0pO1xuZnVuY3Rpb24gV29ya2VyV3JhcHBlcihvcHRpb25zKSB7XG4gICAgdmFyIG9ialVSTDtcbiAgICB0cnkge1xuICAgICAgICBvYmpVUkwgPSBibG9iICYmICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaWYgKCFvYmpVUkwpIHRocm93IFwiXCI7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKG9ialVSTCwge1xuICAgICAgICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKG9ialVSTCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKFwiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7YmFzZTY0LFwiICsgZW5jb2RlZEpzLCB7XG4gICAgICAgICAgICBuYW1lOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWVcbiAgICAgICAgfSk7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICBvYmpVUkwgJiYgKHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCkucmV2b2tlT2JqZWN0VVJMKG9ialVSTCk7XG4gICAgfVxufVxudmFyIENhbnZhc01hbmFnZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhc01hbmFnZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVuZGluZ0NhbnZhc011dGF0aW9uc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhZlN0YW1wc1wiLCB7XG4gICAgICAgICAgICBsYXRlc3RJZDogMCxcbiAgICAgICAgICAgIGludm9rZUlkOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlc2V0T2JzZXJ2ZXJzXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJvemVuXCIsIGZhbHNlKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9jZXNzTXV0YXRpb25cIiwgZnVuY3Rpb24odGFyZ2V0LCBtdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIG5ld0ZyYW1lID0gX3RoaXMucmFmU3RhbXBzLmludm9rZUlkICYmIF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCAhPT0gX3RoaXMucmFmU3RhbXBzLmludm9rZUlkO1xuICAgICAgICAgICAgaWYgKG5ld0ZyYW1lIHx8ICFfdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpIF90aGlzLnJhZlN0YW1wcy5pbnZva2VJZCA9IF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZDtcbiAgICAgICAgICAgIGlmICghX3RoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuc2V0KHRhcmdldCwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQodGFyZ2V0KS5wdXNoKG11dGF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfb3B0aW9uc19zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcsIHNhbXBsaW5nID0gX29wdGlvbnNfc2FtcGxpbmcgPT09IHZvaWQgMCA/IFwiYWxsXCIgOiBfb3B0aW9uc19zYW1wbGluZywgd2luID0gb3B0aW9ucy53aW4sIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIHJlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCBkYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnM7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcbiAgICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiBzYW1wbGluZyA9PT0gXCJhbGxcIikgdGhpcy5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICBpZiAocmVjb3JkQ2FudmFzICYmIHR5cGVvZiBzYW1wbGluZyA9PT0gXCJudW1iZXJcIikgdGhpcy5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIoc2FtcGxpbmcsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwge1xuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ2FudmFzTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcbiAgICB9O1xuICAgIF9wcm90by5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by51bmZyZWV6ZSA9IGZ1bmN0aW9uIHVuZnJlZXplKCkge1xuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmxvY2sgPSBmdW5jdGlvbiBsb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8udW5sb2NrID0gZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmluaXRDYW52YXNGUFNPYnNlcnZlciA9IGZ1bmN0aW9uIGluaXRDYW52YXNGUFNPYnNlcnZlcihmcHMsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dFJlc2V0ID0gaW5pdENhbnZhc0NvbnRleHRPYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xuICAgICAgICB2YXIgc25hcHNob3RJblByb2dyZXNzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXJXcmFwcGVyKCk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgICAgdmFyIGlkID0gZTIuZGF0YS5pZDtcbiAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghKFwiYmFzZTY0XCIgaW4gZTIuZGF0YSkpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBfZTJfZGF0YSA9IGUyLmRhdGEsIGJhc2U2NCA9IF9lMl9kYXRhLmJhc2U2NCwgdHlwZSA9IF9lMl9kYXRhLnR5cGUsIHdpZHRoID0gX2UyX2RhdGEud2lkdGgsIGhlaWdodCA9IF9lMl9kYXRhLmhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0W1wiMkRcIl0sXG4gICAgICAgICAgICAgICAgY29tbWFuZHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiY2xlYXJSZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXBlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwiZHJhd0ltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3cyAoc2VtaS10cmFuc3BhcmVudCkgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiSW1hZ2VCaXRtYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiQmxvYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogXCJBcnJheUJ1ZmZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGltZUJldHdlZW5TbmFwc2hvdHMgPSAxZTMgLyBmcHM7XG4gICAgICAgIHZhciBsYXN0U25hcHNob3RUaW1lID0gMDtcbiAgICAgICAgdmFyIHJhZklkO1xuICAgICAgICB2YXIgZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZENhbnZhcyA9IFtdO1xuICAgICAgICAgICAgd2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYW52YXNcIikuZm9yRWFjaChmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChjYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW52YXMucHVzaChjYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRDYW52YXM7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YWtlQ2FudmFzU25hcHNob3RzID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFNuYXBzaG90VGltZSAmJiB0aW1lc3RhbXAgLSBsYXN0U25hcHNob3RUaW1lIDwgdGltZUJldHdlZW5TbmFwc2hvdHMpIHtcbiAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U25hcHNob3RUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgdmFyIF90aGlzMSA9IF90aGlzO1xuICAgICAgICAgICAgZ2V0Q2FudmFzKCkuZm9yRWFjaCgvKiNfX1BVUkVfXyovIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMiwgaWQsIGNvbnRleHQsIGJpdG1hcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfdGhpczEubWlycm9yLmdldElkKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90SW5Qcm9ncmVzc01hcC5nZXQoaWQpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2ViZ2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJnbDJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoY2FudmFzLl9fY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGNhbnZhcy5fX2NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChfYTIgPSBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIucHJlc2VydmVEcmF3aW5nQnVmZmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xlYXIoY29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRtYXAgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0bWFwOiBiaXRtYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhcnRSQUZUaW1lc3RhbXBpbmcoKTtcbiAgICAgICAgdGhpcy5zdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKTtcbiAgICAgICAgdmFyIGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBmYWxzZSk7XG4gICAgICAgIHZhciBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2FudmFzV2ViR0wxYW5kMlJlc2V0ID0gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcbiAgICAgICAgICAgIGNhbnZhczJEUmVzZXQoKTtcbiAgICAgICAgICAgIGNhbnZhc1dlYkdMMWFuZDJSZXNldCgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlciA9IGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydFJBRlRpbWVzdGFtcGluZyA9IGZ1bmN0aW9uIHN0YXJ0UkFGVGltZXN0YW1waW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0TGF0ZXN0UkFGVGltZXN0YW1wID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgICAgICBfdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zID0gZnVuY3Rpb24gZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihfdmFsdWVzLCBjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLm1pcnJvci5nZXRJZChjYW52YXMpO1xuICAgICAgICAgICAgX3RoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yID0gZnVuY3Rpb24gZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IoY2FudmFzLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5mcm96ZW4gfHwgdGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVzV2l0aFR5cGUgPSB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KGNhbnZhcyk7XG4gICAgICAgIGlmICghdmFsdWVzV2l0aFR5cGUgfHwgaWQgPT09IC0xKSByZXR1cm47XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnR5cGU7IHZhciByZXN0ID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UodmFsdWUsIFtcbiAgICAgICAgICAgICAgICBcInR5cGVcIlxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eXBlID0gdmFsdWVzV2l0aFR5cGVbMF0udHlwZTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb21tYW5kczogdmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FudmFzTWFuYWdlcjtcbn0oKTtcbnZhciBTdHlsZXNoZWV0TWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVzaGVldE1hbmFnZXIob3B0aW9ucykge1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHJhY2tlZExpbmtFbGVtZW50c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtdXRhdGlvbkNiXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWRvcHRlZFN0eWxlU2hlZXRDYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlTWlycm9yXCIsIG5ldyBTdHlsZVNoZWV0TWlycm9yKCkpO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYiA9IG9wdGlvbnMuYWRvcHRlZFN0eWxlU2hlZXRDYjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlc2hlZXRNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXR0YWNoTGlua0VsZW1lbnQgPSBmdW5jdGlvbiBhdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pIHtcbiAgICAgICAgaWYgKFwiX2Nzc1RleHRcIiBpbiBjaGlsZFNuLmF0dHJpYnV0ZXMpIHRoaXMubXV0YXRpb25DYih7XG4gICAgICAgICAgICBhZGRzOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkU24uaWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNoaWxkU24uYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhY2tMaW5rRWxlbWVudChsaW5rRWwpO1xuICAgIH07XG4gICAgX3Byb3RvLnRyYWNrTGlua0VsZW1lbnQgPSBmdW5jdGlvbiB0cmFja0xpbmtFbGVtZW50KGxpbmtFbCkge1xuICAgICAgICBpZiAodGhpcy50cmFja2VkTGlua0VsZW1lbnRzLmhhcyhsaW5rRWwpKSByZXR1cm47XG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cy5hZGQobGlua0VsKTtcbiAgICAgICAgdGhpcy50cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KGxpbmtFbCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRvcHRTdHlsZVNoZWV0cyA9IGZ1bmN0aW9uIGFkb3B0U3R5bGVTaGVldHMoc2hlZXRzLCBob3N0SWQpIHtcbiAgICAgICAgdmFyIF90aGlzLCBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc3R5bGVNaXJyb3IuaGFzKHNoZWV0KSkge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQgPSBfdGhpcy5zdHlsZU1pcnJvci5hZGQoc2hlZXQpO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmZyb20oc2hlZXQucnVsZXMgfHwgQ1NTUnVsZSwgZnVuY3Rpb24ocjIsIGluZGV4Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBzdHJpbmdpZnlSdWxlKHIyLCBzaGVldC5ocmVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHN0eWxlSWQgPSBfdGhpcy5zdHlsZU1pcnJvci5nZXRJZChzaGVldCk7XG4gICAgICAgICAgICBhZG9wdGVkU3R5bGVTaGVldERhdGEuc3R5bGVJZHMucHVzaChzdHlsZUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNoZWV0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSA9IHtcbiAgICAgICAgICAgIGlkOiBob3N0SWQsXG4gICAgICAgICAgICBzdHlsZUlkczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShzaGVldHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOylfdGhpcyA9IHRoaXMsIF9sb29wKCk7XG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiKGFkb3B0ZWRTdHlsZVNoZWV0RGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdHlsZU1pcnJvci5yZXNldCgpO1xuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IHRha2Ugc25hcHNob3Qgb24gc3R5bGVzaGVldCByZWxvYWQgYnkgYXBwbHlpbmcgZXZlbnQgbGlzdGVuZXJcbiAgICBfcHJvdG8udHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudCA9IGZ1bmN0aW9uIHRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQoX2xpbmtFbCkge307XG4gICAgcmV0dXJuIFN0eWxlc2hlZXRNYW5hZ2VyO1xufSgpO1xudmFyIFByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzZWROb2RlTWFuYWdlcigpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm5vZGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aXZlXCIsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByb2Nlc3NlZE5vZGVNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaW5PdGhlckJ1ZmZlciA9IGZ1bmN0aW9uIGluT3RoZXJCdWZmZXIobm9kZTIsIHRoaXNCdWZmZXIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgJiYgQXJyYXkuZnJvbShidWZmZXJzKS5zb21lKGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlciAhPT0gdGhpc0J1ZmZlcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5vZGUyLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZTIsICh0aGlzLm5vZGVNYXAuZ2V0KG5vZGUyKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKS5hZGQoYnVmZmVyKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgICByZXR1cm4gUHJvY2Vzc2VkTm9kZU1hbmFnZXI7XG59KCk7XG52YXIgd3JhcHBlZEVtaXQ7XG52YXIgdGFrZUZ1bGxTbmFwc2hvdCQxO1xudmFyIGNhbnZhc01hbmFnZXI7XG52YXIgcmVjb3JkaW5nID0gZmFsc2U7XG50cnkge1xuICAgIGlmIChBcnJheS5mcm9tKFtcbiAgICAgICAgMVxuICAgIF0sIGZ1bmN0aW9uKHgyKSB7XG4gICAgICAgIHJldHVybiB4MiAqIDI7XG4gICAgfSlbMF0gIT09IDIpIHtcbiAgICAgICAgdmFyIGNsZWFuRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsZWFuRnJhbWUpO1xuICAgICAgICBBcnJheS5mcm9tID0gKChfYSA9IGNsZWFuRnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLkFycmF5LmZyb20pIHx8IEFycmF5LmZyb207XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY2xlYW5GcmFtZSk7XG4gICAgfVxufSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlVuYWJsZSB0byBvdmVycmlkZSBBcnJheS5mcm9tXCIsIGVycik7XG59XG52YXIgbWlycm9yID0gY3JlYXRlTWlycm9yJDIoKTtcbmZ1bmN0aW9uIHJlY29yZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBlbWl0ID0gb3B0aW9ucy5lbWl0LCBjaGVja291dEV2ZXJ5Tm1zID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5Tm1zLCBjaGVja291dEV2ZXJ5TnRoID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5TnRoLCBfb3B0aW9uc19ibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja0NsYXNzID0gX29wdGlvbnNfYmxvY2tDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1ibG9ja1wiIDogX29wdGlvbnNfYmxvY2tDbGFzcywgX29wdGlvbnNfYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgYmxvY2tTZWxlY3RvciA9IF9vcHRpb25zX2Jsb2NrU2VsZWN0b3IgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9uc19ibG9ja1NlbGVjdG9yLCBfb3B0aW9uc19pZ25vcmVDbGFzcyA9IG9wdGlvbnMuaWdub3JlQ2xhc3MsIGlnbm9yZUNsYXNzID0gX29wdGlvbnNfaWdub3JlQ2xhc3MgPT09IHZvaWQgMCA/IFwicnItaWdub3JlXCIgOiBfb3B0aW9uc19pZ25vcmVDbGFzcywgX29wdGlvbnNfaWdub3JlU2VsZWN0b3IgPSBvcHRpb25zLmlnbm9yZVNlbGVjdG9yLCBpZ25vcmVTZWxlY3RvciA9IF9vcHRpb25zX2lnbm9yZVNlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnNfaWdub3JlU2VsZWN0b3IsIF9vcHRpb25zX21hc2tUZXh0Q2xhc3MgPSBvcHRpb25zLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0Q2xhc3MgPSBfb3B0aW9uc19tYXNrVGV4dENsYXNzID09PSB2b2lkIDAgPyBcInJyLW1hc2tcIiA6IF9vcHRpb25zX21hc2tUZXh0Q2xhc3MsIF9vcHRpb25zX21hc2tUZXh0U2VsZWN0b3IgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIG1hc2tUZXh0U2VsZWN0b3IgPSBfb3B0aW9uc19tYXNrVGV4dFNlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnNfbWFza1RleHRTZWxlY3RvciwgX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0LCBtYXNrQWxsSW5wdXRzID0gb3B0aW9ucy5tYXNrQWxsSW5wdXRzLCBfbWFza0lucHV0T3B0aW9ucyA9IG9wdGlvbnMubWFza0lucHV0T3B0aW9ucywgX3NsaW1ET01PcHRpb25zID0gb3B0aW9ucy5zbGltRE9NT3B0aW9ucywgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBtYXNrVGV4dEZuID0gb3B0aW9ucy5tYXNrVGV4dEZuLCBob29rcyA9IG9wdGlvbnMuaG9va3MsIHBhY2tGbiA9IG9wdGlvbnMucGFja0ZuLCBfb3B0aW9uc19zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcsIHNhbXBsaW5nID0gX29wdGlvbnNfc2FtcGxpbmcgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfc2FtcGxpbmcsIF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucywgbW91c2Vtb3ZlV2FpdCA9IG9wdGlvbnMubW91c2Vtb3ZlV2FpdCwgX29wdGlvbnNfcmVjb3JkRE9NID0gb3B0aW9ucy5yZWNvcmRET00sIHJlY29yZERPTSA9IF9vcHRpb25zX3JlY29yZERPTSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zX3JlY29yZERPTSwgX29wdGlvbnNfcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIHJlY29yZENhbnZhcyA9IF9vcHRpb25zX3JlY29yZENhbnZhcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19yZWNvcmRDYW52YXMsIF9vcHRpb25zX3JlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLCByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBfb3B0aW9uc19yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLCBfb3B0aW9uc19yZWNvcmRBZnRlciA9IG9wdGlvbnMucmVjb3JkQWZ0ZXIsIHJlY29yZEFmdGVyID0gX29wdGlvbnNfcmVjb3JkQWZ0ZXIgPT09IHZvaWQgMCA/IG9wdGlvbnMucmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiID8gb3B0aW9ucy5yZWNvcmRBZnRlciA6IFwibG9hZFwiIDogX29wdGlvbnNfcmVjb3JkQWZ0ZXIsIF9vcHRpb25zX3VzZXJUcmlnZ2VyZWRPbklucHV0ID0gb3B0aW9ucy51c2VyVHJpZ2dlcmVkT25JbnB1dCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBfb3B0aW9uc191c2VyVHJpZ2dlcmVkT25JbnB1dCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc191c2VyVHJpZ2dlcmVkT25JbnB1dCwgX29wdGlvbnNfY29sbGVjdEZvbnRzID0gb3B0aW9ucy5jb2xsZWN0Rm9udHMsIGNvbGxlY3RGb250cyA9IF9vcHRpb25zX2NvbGxlY3RGb250cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19jb2xsZWN0Rm9udHMsIF9vcHRpb25zX2lubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCBpbmxpbmVJbWFnZXMgPSBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfaW5saW5lSW1hZ2VzLCBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zLCBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID09PSB2b2lkIDAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBfb3B0aW9uc19rZWVwSWZyYW1lU3JjRm4sIF9vcHRpb25zX2lnbm9yZUNTU0F0dHJpYnV0ZXMgPSBvcHRpb25zLmlnbm9yZUNTU0F0dHJpYnV0ZXMsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBfb3B0aW9uc19pZ25vcmVDU1NBdHRyaWJ1dGVzID09PSB2b2lkIDAgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXSkgOiBfb3B0aW9uc19pZ25vcmVDU1NBdHRyaWJ1dGVzLCBlcnJvckhhbmRsZXIyID0gb3B0aW9ucy5lcnJvckhhbmRsZXI7XG4gICAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyMik7XG4gICAgdmFyIGluRW1pdHRpbmdGcmFtZSA9IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA/IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdyA6IHRydWU7XG4gICAgdmFyIHBhc3NFbWl0c1RvUGFyZW50ID0gZmFsc2U7XG4gICAgaWYgKCFpbkVtaXR0aW5nRnJhbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucGFyZW50LmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFzc0VtaXRzVG9QYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHBhc3NFbWl0c1RvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtaXQgZnVuY3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmICghaW5FbWl0dGluZ0ZyYW1lICYmICFwYXNzRW1pdHNUb1BhcmVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHZvaWQgMCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHZvaWQgMCkge1xuICAgICAgICBzYW1wbGluZy5tb3VzZW1vdmUgPSBtb3VzZW1vdmVXYWl0O1xuICAgIH1cbiAgICBtaXJyb3IucmVzZXQoKTtcbiAgICB2YXIgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWUgPyB7XG4gICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICBkYXRlOiB0cnVlLFxuICAgICAgICBcImRhdGV0aW1lLWxvY2FsXCI6IHRydWUsXG4gICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICBtb250aDogdHJ1ZSxcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICByYW5nZTogdHJ1ZSxcbiAgICAgICAgc2VhcmNoOiB0cnVlLFxuICAgICAgICB0ZWw6IHRydWUsXG4gICAgICAgIHRleHQ6IHRydWUsXG4gICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgIHVybDogdHJ1ZSxcbiAgICAgICAgd2VlazogdHJ1ZSxcbiAgICAgICAgdGV4dGFyZWE6IHRydWUsXG4gICAgICAgIHNlbGVjdDogdHJ1ZSxcbiAgICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICB9IDogX21hc2tJbnB1dE9wdGlvbnMgIT09IHZvaWQgMCA/IF9tYXNrSW5wdXRPcHRpb25zIDoge1xuICAgICAgICBwYXNzd29yZDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHNsaW1ET01PcHRpb25zID0gX3NsaW1ET01PcHRpb25zID09PSB0cnVlIHx8IF9zbGltRE9NT3B0aW9ucyA9PT0gXCJhbGxcIiA/IHtcbiAgICAgICAgc2NyaXB0OiB0cnVlLFxuICAgICAgICBjb21tZW50OiB0cnVlLFxuICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvZmYgZm9yIHNsaW1ET01PcHRpb25zID09PSB0cnVlLFxuICAgICAgICAvLyBhcyB0aGV5IGRlc3Ryb3kgc29tZSAoaGlkZGVuKSBpbmZvOlxuICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gXCJhbGxcIixcbiAgICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IF9zbGltRE9NT3B0aW9ucyA9PT0gXCJhbGxcIixcbiAgICAgICAgaGVhZFRpdGxlTXV0YXRpb25zOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCJcbiAgICB9IDogX3NsaW1ET01PcHRpb25zID8gX3NsaW1ET01PcHRpb25zIDoge307XG4gICAgcG9seWZpbGwkMSgpO1xuICAgIHZhciBsYXN0RnVsbFNuYXBzaG90RXZlbnQ7XG4gICAgdmFyIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XG4gICAgdmFyIGV2ZW50UHJvY2Vzc29yID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyB8fCBbXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4zID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAocGx1Z2luMy5ldmVudFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGUyID0gcGx1Z2luMy5ldmVudFByb2Nlc3NvcihlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhY2tGbiAmJiAvLyBEaXNhYmxlIHBhY2tpbmcgZXZlbnRzIHdoaWNoIHdpbGwgYmUgZW1pdHRlZCB0byBwYXJlbnQgZnJhbWVzLlxuICAgICAgICAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICAgICAgICAgIGUyID0gcGFja0ZuKGUyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTI7XG4gICAgfTtcbiAgICB3cmFwcGVkRW1pdCA9IGZ1bmN0aW9uKHIyLCBpc0NoZWNrb3V0KSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHZhciBlMiA9IHIyO1xuICAgICAgICBlMi50aW1lc3RhbXAgPSBub3dUaW1lc3RhbXAoKTtcbiAgICAgICAgaWYgKCgoX2EyID0gbXV0YXRpb25CdWZmZXJzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlzRnJvemVuKCkpICYmIGUyLnR5cGUgIT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QgJiYgIShlMi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24pKSB7XG4gICAgICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmLnVuZnJlZXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lKSB7XG4gICAgICAgICAgICBlbWl0ID09IG51bGwgPyB2b2lkIDAgOiBlbWl0KGV2ZW50UHJvY2Vzc29yKGUyKSwgaXNDaGVja291dCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicnJ3ZWJcIixcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRQcm9jZXNzb3IoZTIpLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICAgICAgICBpc0NoZWNrb3V0OiBpc0NoZWNrb3V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZShtZXNzYWdlLCBcIipcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUyLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgICAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGUyO1xuICAgICAgICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChlMi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGUyLmRhdGEuc291cmNlID09PSBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbiAmJiBlMi5kYXRhLmlzQXR0YWNoSWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XG4gICAgICAgICAgICB2YXIgZXhjZWVkQ291bnQgPSBjaGVja291dEV2ZXJ5TnRoICYmIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA+PSBjaGVja291dEV2ZXJ5TnRoO1xuICAgICAgICAgICAgdmFyIGV4Y2VlZFRpbWUgPSBjaGVja291dEV2ZXJ5Tm1zICYmIGUyLnRpbWVzdGFtcCAtIGxhc3RGdWxsU25hcHNob3RFdmVudC50aW1lc3RhbXAgPiBjaGVja291dEV2ZXJ5Tm1zO1xuICAgICAgICAgICAgaWYgKGV4Y2VlZENvdW50IHx8IGV4Y2VlZFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90JDEodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB3cmFwcGVkTXV0YXRpb25FbWl0ID0gZnVuY3Rpb24obSkge1xuICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uXG4gICAgICAgICAgICB9LCBtKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciB3cmFwcGVkU2Nyb2xsRW1pdCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsXG4gICAgICAgICAgICB9LCBwKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvblxuICAgICAgICAgICAgfSwgcClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCA9IGZ1bmN0aW9uKGEyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLkFkb3B0ZWRTdHlsZVNoZWV0XG4gICAgICAgICAgICB9LCBhMilcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgc3R5bGVzaGVldE1hbmFnZXIgPSBuZXcgU3R5bGVzaGVldE1hbmFnZXIoe1xuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldENiOiB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0XG4gICAgfSk7XG4gICAgdmFyIGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XG4gICAgICAgIG1pcnJvcjogbWlycm9yLFxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgIHJlY29yZENyb3NzT3JpZ2luSWZyYW1lczogcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxuICAgICAgICB3cmFwcGVkRW1pdDogd3JhcHBlZEVtaXRcbiAgICB9KTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwbHVnaW5zIHx8IFtdKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICB2YXIgcGx1Z2luMyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBpZiAocGx1Z2luMy5nZXRNaXJyb3IpIHBsdWdpbjMuZ2V0TWlycm9yKHtcbiAgICAgICAgICAgIG5vZGVNaXJyb3I6IG1pcnJvcixcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLFxuICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcHJvY2Vzc2VkTm9kZU1hbmFnZXIgPSBuZXcgUHJvY2Vzc2VkTm9kZU1hbmFnZXIoKTtcbiAgICBjYW52YXNNYW5hZ2VyID0gbmV3IENhbnZhc01hbmFnZXIoe1xuICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgd2luOiB3aW5kb3csXG4gICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgIG1pcnJvcjogbWlycm9yLFxuICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcuY2FudmFzLFxuICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnNcbiAgICB9KTtcbiAgICB2YXIgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxuICAgICAgICBieXBhc3NPcHRpb25zOiB7XG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgIHNhbXBsaW5nOiBzYW1wbGluZyxcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGlmcmFtZU1hbmFnZXI6IGlmcmFtZU1hbmFnZXIsXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgICAgICBjYW52YXNNYW5hZ2VyOiBjYW52YXNNYW5hZ2VyLFxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcjogcHJvY2Vzc2VkTm9kZU1hbmFnZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWlycm9yOiBtaXJyb3JcbiAgICB9KTtcbiAgICB0YWtlRnVsbFNuYXBzaG90JDEgPSBmdW5jdGlvbihpc0NoZWNrb3V0KSB7XG4gICAgICAgIGlmIChpc0NoZWNrb3V0ID09PSB2b2lkIDApIGlzQ2hlY2tvdXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFyZWNvcmRET00pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTWV0YSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBocmVmOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICB3aWR0aDogZ2V0V2luZG93V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlzQ2hlY2tvdXQpO1xuICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5yZXNldCgpO1xuICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmluaXQoKTtcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmLmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBub2RlMiA9IHNuYXBzaG90KGRvY3VtZW50LCB7XG4gICAgICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgbWFza0FsbElucHV0czogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkSWZyYW1lKG4yLCBtaXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKG4yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLmFkZFNoYWRvd1Jvb3QoaW5kZXguc2hhZG93Um9vdChuMiksIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBmdW5jdGlvbihpZnJhbWUsIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xuICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IGZ1bmN0aW9uKGxpbmtFbCwgY2hpbGRTbikge1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmF0dGFjaExpbmtFbGVtZW50KGxpbmtFbCwgY2hpbGRTbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc25hcHNob3QgdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5GdWxsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZTIsXG4gICAgICAgICAgICAgICAgaW5pdGlhbE9mZnNldDogZ2V0V2luZG93U2Nyb2xsKHdpbmRvdylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXNDaGVja291dCk7XG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi51bmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLCBtaXJyb3IuZ2V0SWQoZG9jdW1lbnQpKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgICAgICB2YXIgb2JzZXJ2ZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoaW5pdE9ic2VydmVycykoe1xuICAgICAgICAgICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlQ2I6IGZ1bmN0aW9uKHBvc2l0aW9ucywgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYjogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBkKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBkKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0Q2I6IGZ1bmN0aW9uKHYyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLklucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB2MilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2I6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiOiBmdW5jdGlvbihyMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZVNoZWV0UnVsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcjIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiOiBmdW5jdGlvbihyMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5TdHlsZURlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByMilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW52YXNNdXRhdGlvbkNiOiB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0LFxuICAgICAgICAgICAgICAgIGZvbnRDYjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5Gb250XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkNiOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYjogZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5DdXN0b21FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjMilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNsYXNzOiBpZ25vcmVDbGFzcyxcbiAgICAgICAgICAgICAgICBpZ25vcmVTZWxlY3RvcjogaWdub3JlU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcsXG4gICAgICAgICAgICAgICAgcmVjb3JkRE9NOiByZWNvcmRET00sXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQ6IHVzZXJUcmlnZ2VyZWRPbklucHV0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3RGb250czogY29sbGVjdEZvbnRzLFxuICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxuICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyOiBpZnJhbWVNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyOiBzdHlsZXNoZWV0TWFuYWdlcixcbiAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiBzaGFkb3dEb21NYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyOiBwcm9jZXNzZWROb2RlTWFuYWdlcixcbiAgICAgICAgICAgICAgICBjYW52YXNNYW5hZ2VyOiBjYW52YXNNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXM6IGlnbm9yZUNTU0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luczogKChfYTIgPSBwbHVnaW5zID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLm9ic2VydmVyO1xuICAgICAgICAgICAgICAgIH0pKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcjogcC5vYnNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHAub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBwLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSkgfHwgW11cbiAgICAgICAgICAgIH0sIGhvb2tzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRMb2FkTGlzdGVuZXIoZnVuY3Rpb24oaWZyYW1lRWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QkMSgpO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvYnNlcnZlKGRvY3VtZW50KSk7XG4gICAgICAgICAgICByZWNvcmRpbmcgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuRG9tQ29udGVudExvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwiRE9NQ29udGVudExvYWRlZFwiKSBpbml0KCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9uKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Mb2FkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gXCJsb2FkXCIpIGluaXQoKTtcbiAgICAgICAgICAgIH0sIHdpbmRvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdW5yZWdpc3RlckVycm9ySGFuZGxlcigpO1xuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxufVxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24odGFnLCBwYXlsb2FkKSB7XG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nXCIpO1xuICAgIH1cbiAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5DdXN0b20sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICB9XG4gICAgfSk7XG59O1xucmVjb3JkLmZyZWV6ZVBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5mcmVlemUoKTtcbiAgICB9KTtcbn07XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdCA9IGZ1bmN0aW9uKGlzQ2hlY2tvdXQpIHtcbiAgICBpZiAoIXJlY29yZGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgICB9XG4gICAgdGFrZUZ1bGxTbmFwc2hvdCQxKGlzQ2hlY2tvdXQpO1xufTtcbnJlY29yZC5taXJyb3IgPSBtaXJyb3I7XG52YXIgbjtcbiFmdW5jdGlvbih0Mikge1xuICAgIHQyW3QyLk5vdFN0YXJ0ZWQgPSAwXSA9IFwiTm90U3RhcnRlZFwiLCB0Mlt0Mi5SdW5uaW5nID0gMV0gPSBcIlJ1bm5pbmdcIiwgdDJbdDIuU3RvcHBlZCA9IDJdID0gXCJTdG9wcGVkXCI7XG59KG4gfHwgKG4gPSB7fSkpO1xucmVjb3JkLmFkZEN1c3RvbUV2ZW50O1xucmVjb3JkLmZyZWV6ZVBhZ2U7XG5yZWNvcmQudGFrZUZ1bGxTbmFwc2hvdDtcblxudmFyIHNldEltbWVkaWF0ZSA9IHdpblsnc2V0SW1tZWRpYXRlJ107XG52YXIgYnVpbHRJblByb3AsIGN5Y2xlLCBzY2hlZHVsaW5nUXVldWUsXG4gICAgVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgIGZ1bmN0aW9uIHRpbWVyKGZuKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoZm4pOyB9IDpcbiAgICAgICAgc2V0VGltZW91dDtcblxuLy8gZGFtbWl0LCBJRTguXG50cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwneCcse30pO1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaixuYW1lLHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnICE9PSBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuY2F0Y2ggKGVycikge1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xufVxuXG4vLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcbnNjaGVkdWxpbmdRdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICB2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cbiAgICBmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZm4sc2VsZikge1xuICAgICAgICAgICAgaXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBsYXN0Lm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgICAgICBpdGVtID0gdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICAgICAgZmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChmKSB7XG4gICAgICAgICAgICAgICAgZi5mbi5jYWxsKGYuc2VsZik7XG4gICAgICAgICAgICAgICAgZiA9IGYubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG4gICAgc2NoZWR1bGluZ1F1ZXVlLmFkZChmbixzZWxmKTtcbiAgICBpZiAoIWN5Y2xlKSB7XG4gICAgICAgIGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ1F1ZXVlLmRyYWluKTtcbiAgICB9XG59XG5cbi8vIHByb21pc2UgZHVjayB0eXBpbmdcbmZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuICAgIHZhciBfdGhlbiwgb1R5cGUgPSB0eXBlb2YgbztcblxuICAgIGlmIChvICE9PSBudWxsICYmIChvVHlwZSA9PT0gJ29iamVjdCcgfHwgb1R5cGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIF90aGVuID0gby50aGVuO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIF90aGVuID09PSAnZnVuY3Rpb24nID8gX3RoZW4gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vdGlmeUlzb2xhdGVkKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSAxKSA/IHRoaXMuY2hhaW5baV0uc3VjY2VzcyA6IHRoaXMuY2hhaW5baV0uZmFpbHVyZSxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5baV1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xufVxuXG4vLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4vLyBvcHRpbWl6ZWQgYmV0dGVyXG5mdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG4gICAgdmFyIHJldCwgX3RoZW47XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGNiID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHNlbGYubXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY2IuY2FsbCh2b2lkIDAsc2VsZi5tc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5yZXNvbHZlKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjaGFpbi5yZWplY3QoZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG4gICAgdmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgIGlmIChfdGhlbiA9IGlzVGhlbmFibGUobXNnKSkge1xuICAgICAgICAgICAgc2NoZWR1bGUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVmV3JhcHBlciA9IG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfdGhlbi5jYWxsKG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlJCgpeyByZXNvbHZlLmFwcGx5KGRlZldyYXBwZXIsYXJndW1lbnRzKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZWplY3QkKCl7IHJlamVjdC5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChkZWZXcmFwcGVyLGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLm1zZyA9IG1zZztcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAxO1xuICAgICAgICAgICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KG1zZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuICAgIGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuICAgIHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIC8vIHVud3JhcFxuICAgIGlmIChzZWxmLmRlZikge1xuICAgICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgc2VsZi5zdGF0ZSA9IDI7XG4gICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLHJlc29sdmVyLHJlamVjdGVyKSB7XG4gICAgZm9yICh2YXIgaWR4PTA7IGlkeDxhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAoZnVuY3Rpb24gSUlGRShpZHgpe1xuICAgICAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShhcnJbaWR4XSlcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIoaWR4LG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdGVyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSkoaWR4KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcbiAgICB0aGlzLmRlZiA9IHNlbGY7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG4gICAgdGhpcy5wcm9taXNlID0gc2VsZjtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2hhaW4gPSBbXTtcbiAgICB0aGlzLm1zZyA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gTnBvUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzWydfX05QT19fJ10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBwcm9taXNlJyk7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG4gICAgLy8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2VcbiAgICB0aGlzWydfX05QT19fJ10gPSAxO1xuXG4gICAgdmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG4gICAgdGhpc1sndGhlbiddID0gZnVuY3Rpb24gdGhlbihzdWNjZXNzLGZhaWx1cmUpIHtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0eXBlb2Ygc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IHN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICAgICAgZmFpbHVyZTogdHlwZW9mIGZhaWx1cmUgPT09ICdmdW5jdGlvbicgPyBmYWlsdXJlIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3RcbiAgICAgICAgICAgIC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuICAgICAgICAgICAgLy8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuICAgICAgICBvLnByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbiBleHRyYWN0Q2hhaW4ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWYuY2hhaW4ucHVzaChvKTtcblxuICAgICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShub3RpZnksZGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvLnByb21pc2U7XG4gICAgfTtcbiAgICB0aGlzWydjYXRjaCddID0gZnVuY3Rpb24gJGNhdGNoJChmYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvci5jYWxsKFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVzb2x2ZShtc2cpe1xuICAgICAgICAgICAgICAgIHJlc29sdmUuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0LmNhbGwoZGVmLGVycik7XG4gICAgfVxufVxuXG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IGJ1aWx0SW5Qcm9wKHt9LCdjb25zdHJ1Y3RvcicsTnBvUHJvbWlzZSxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG4gICAgLy8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcbk5wb1Byb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuLy8gYnVpbHQtaW4gXCJicmFuZFwiIHRvIHNpZ25hbCBhbiBcInVuaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG5idWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLCdfX05QT19fJywwLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2Vcbik7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3Jlc29sdmUnLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICAvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG4gICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09PSAnb2JqZWN0JyAmJiBtc2dbJ19fTlBPX18nXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JlamVjdCcsZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdChtc2cpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ2FsbCcsZnVuY3Rpb24gUHJvbWlzZSRhbGwoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcignTm90IGFuIGFycmF5JykpO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpIHtcbiAgICAgICAgICAgIG1zZ3NbaWR4XSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1zZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmFjZScsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG4gICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgIH0scmVqZWN0KTtcbiAgICB9KTtcbn0pO1xuXG52YXIgUHJvbWlzZVBvbHlmaWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBQcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMSkge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIFByb21pc2VQb2x5ZmlsbCA9IE5wb1Byb21pc2U7XG59XG5cbnZhciBDb25maWcgPSB7XG4gICAgREVCVUc6IGZhbHNlLFxuICAgIExJQl9WRVJTSU9OOiAnMi42My4wJ1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiwgZXFlcWVxOiBcIm9mZlwiICovXG5cbi8vIE1heGltdW0gYWxsb3dlZCBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfUkVDT1JESU5HX01TID0gMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMjQgaG91cnNcbi8vIE1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgbWluaW11bSBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgPSA4ICogMTAwMDsgLy8gOCBzZWNvbmRzXG5cbi8qXG4gKiBTYXZlZCByZWZlcmVuY2VzIHRvIGxvbmcgdmFyaWFibGUgbmFtZXMsIHNvIHRoYXQgY2xvc3VyZSBjb21waWxlciBjYW5cbiAqIG1pbmltaXplIGZpbGUgc2l6ZS5cbiAqL1xuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgd2luZG93Q29uc29sZSA9IHdpbi5jb25zb2xlLFxuICAgIG5hdmlnYXRvciA9IHdpbi5uYXZpZ2F0b3IsXG4gICAgZG9jdW1lbnQkMSA9IHdpbi5kb2N1bWVudCxcbiAgICB3aW5kb3dPcGVyYSA9IHdpbi5vcGVyYSxcbiAgICBzY3JlZW4gPSB3aW4uc2NyZWVuLFxuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbnZhciBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVJbmRleE9mID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZU1hcCA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIGJyZWFrZXIgPSB7fTtcblxudmFyIF8gPSB7XG4gICAgdHJpbTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltI1BvbHlmaWxsXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcbiAgICB9XG59O1xuXG4vLyBDb25zb2xlIG92ZXJyaWRlXG52YXIgY29uc29sZSQxID0ge1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2coYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICB3YXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgd2FybmluZzonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4uYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2FybihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGNyaXRpY2FsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nX2Z1bmNfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihmdW5jLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9ICdbJyArIHByZWZpeCArICddICcgKyBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnNvbGUkMSwgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcbnZhciBjb25zb2xlX3dpdGhfcHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9nOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEubG9nLCBwcmVmaXgpLFxuICAgICAgICBlcnJvcjogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmVycm9yLCBwcmVmaXgpLFxuICAgICAgICBjcml0aWNhbDogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmNyaXRpY2FsLCBwcmVmaXgpXG4gICAgfTtcbn07XG5cblxudmFyIHNhZmV3cmFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnSW1wbGVtZW50YXRpb24gZXJyb3IuIFBsZWFzZSB0dXJuIG9uIGRlYnVnIGFuZCBjb250YWN0IHN1cHBvcnRAbWl4cGFuZWwuY29tLicpO1xuICAgICAgICAgICAgaWYgKENvbmZpZy5ERUJVRyl7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBzYWZld3JhcENsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICB2YXIgcHJvdG8gPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgZnVuYyBpbiBwcm90bykge1xuICAgICAgICBpZiAodHlwZW9mKHByb3RvW2Z1bmNdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvdG9bZnVuY10gPSBzYWZld3JhcChwcm90b1tmdW5jXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIFVOREVSU0NPUkVcbi8vIEVtYmVkIHBhcnQgb2YgdGhlIFVuZGVyc2NvcmUgTGlicmFyeVxuXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0ge307XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgIHZhciBzZWxmID0gbmV3IGN0b3IoKTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKT19IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAqL1xuXy5lYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbl8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZnJvbSBhIGNvbW1lbnQgb24gaHR0cDovL2Riai5vcmcvZGJqLz9wPTI4NlxuLy8gZmFpbHMgb24gb25seSBvbmUgdmVyeSByYXJlIGFuZCBkZWxpYmVyYXRlIGN1c3RvbSBvYmplY3Q6XG4vLyB2YXIgYm9tYiA9IHsgdG9TdHJpbmcgOiB1bmRlZmluZWQsIHZhbHVlT2Y6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFwiZnVuY3Rpb24gQk9NQkEhXCI7IH19O1xuXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAvXlxccypcXGJmdW5jdGlvblxcYi8udGVzdChmKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5fLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NhbGxlZScpKTtcbn07XG5cbl8udG9BcnJheSA9IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgaWYgKCFpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZS50b0FycmF5KSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS50b0FycmF5KCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF8udmFsdWVzKGl0ZXJhYmxlKTtcbn07XG5cbl8ubWFwID0gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVNYXAgJiYgYXJyLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfLmVhY2goYXJyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2FsbGJhY2suY2FsbChjb250ZXh0LCBpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59O1xuXG5fLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBrZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgKGZvdW5kID0gKHZhbHVlID09PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyZWFrZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG5fLmluY2x1ZGVzID0gZnVuY3Rpb24oc3RyLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG59O1xuXG4vLyBVbmRlcnNjb3JlIEFkZG9uc1xuXy5pbmhlcml0ID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgc3VwZXJjbGFzcygpO1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzO1xuICAgIHN1YmNsYXNzLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChvYmogPT09IE9iamVjdChvYmopICYmICFfLmlzQXJyYXkob2JqKSk7XG59O1xuXG5fLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn07XG5cbl8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxuXy5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbl8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxuXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59O1xuXG5fLmVuY29kZURhdGVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc0RhdGUodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZm9ybWF0RGF0ZSh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmVuY29kZURhdGVzKHYpOyAvLyByZWN1cnNlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuXG5fLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkKSB7XG4gICAgLy8gWVlZWS1NTS1ERFRISDpNTTpTUyBpbiBVVENcbiAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKTtcbn07XG5cbl8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgXy5lYWNoKHAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcodikgJiYgdi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXRba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iamVjdCBhZnRlciB0cnVuY2F0aW5nIGl0LiAgSWZcbiAqIHBhc3NlZCBhbiBBcnJheSBvciBPYmplY3QgaXQgd2lsbCBpdGVyYXRlIHRocm91Z2ggb2JqIGFuZFxuICogdHJ1bmNhdGUgYWxsIHRoZSB2YWx1ZXMgcmVjdXJzaXZlbHkuXG4gKi9cbl8udHJ1bmNhdGUgPSBmdW5jdGlvbihvYmosIGxlbmd0aCkge1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG9iai5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0LnB1c2goXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCkpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gXy50cnVuY2F0ZSh2YWwsIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuXy5KU09ORW5jb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihtaXhlZF92YWwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWl4ZWRfdmFsO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgICAgICB2YXIgbWV0YSA9IHsgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICAgICAnXCInOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgP1xuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KSArICdcIicgOlxuICAgICAgICAgICAgICAgICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdHIgPSBmdW5jdGlvbihrZXksIGhvbGRlcikge1xuICAgICAgICAgICAgdmFyIGdhcCA9ICcnO1xuICAgICAgICAgICAgdmFyIGluZGVudCA9ICcgICAgJztcbiAgICAgICAgICAgIHZhciBpID0gMDsgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIHZhciBrID0gJyc7IC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdmFyIHYgPSAnJzsgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG1pbmQgPSBnYXA7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ1tcXG4nICsgZ2FwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cbiAgICAgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICcnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnfScgOiAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHN0cignJywge1xuICAgICAgICAgICAgJyc6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iL21hc3Rlci9qc29uX3BhcnNlLmpzXG4gKiBTbGlnaHRseSBtb2RpZmllZCB0byB0aHJvdyBhIHJlYWwgRXJyb3IgcmF0aGVyIHRoYW4gYSBQT0pPXG4gKi9cbl8uSlNPTkRlY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBlc2NhcGVlID0ge1xuICAgICAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICAgICAnYic6ICdcXGInLFxuICAgICAgICAgICAgJ2YnOiAnXFxmJyxcbiAgICAgICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICAgICAncic6ICdcXHInLFxuICAgICAgICAgICAgJ3QnOiAnXFx0J1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IFN5bnRheEVycm9yKG0pO1xuICAgICAgICAgICAgZS5hdCA9IGF0O1xuICAgICAgICAgICAgZS50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIFxcJycgKyBjICsgJ1xcJyBpbnN0ZWFkIG9mIFxcJycgKyBjaCArICdcXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgICAgICBhdCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9LFxuICAgICAgICBudW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJztcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdCYWQgbnVtYmVyJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgc3RyaW5nJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdoaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3b3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIFwiJyArIGNoICsgJ1wiJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLCAvLyBQbGFjZWhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuICAgICAgICBhcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgYXJyYXknKTtcbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIG9iamVjdCcpO1xuICAgICAgICB9O1xuXG4gICAgdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZyxcbiAgICAgICAgLy8gYSBudW1iZXIsIG9yIGEgd29yZC5cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlXG4gICAgLy8gYWJvdmUgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRleHQgPSBzb3VyY2U7XG4gICAgICAgIGF0ID0gMDtcbiAgICAgICAgY2ggPSAnICc7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgZXJyb3IoJ1N5bnRheCBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcblxuXy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG4gICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBlbmMgPSAnJyxcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEgPSBfLnV0ZjhFbmNvZGUoZGF0YSk7XG5cbiAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIHN3aXRjaCAoZGF0YS5sZW5ndGggJSAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMikgKyAnPT0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMSkgKyAnPSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jO1xufTtcblxuXy51dGY4RW5jb2RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gKHN0cmluZyArICcnKS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG5cbiAgICB2YXIgdXRmdGV4dCA9ICcnLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kO1xuICAgIHZhciBzdHJpbmdsID0gMCxcbiAgICAgICAgbjtcblxuICAgIHN0YXJ0ID0gZW5kID0gMDtcbiAgICBzdHJpbmdsID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIGZvciAobiA9IDA7IG4gPCBzdHJpbmdsOyBuKyspIHtcbiAgICAgICAgdmFyIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG4gICAgICAgIHZhciBlbmMgPSBudWxsO1xuXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH0gZWxzZSBpZiAoKGMxID4gMTI3KSAmJiAoYzEgPCAyMDQ4KSkge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gNikgfCAxOTIsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiAxMikgfCAyMjQsICgoYzEgPj4gNikgJiA2MykgfCAxMjgsIChjMSAmIDYzKSB8IDEyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICAgICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZnRleHQ7XG59O1xuXG5fLlVVSUQgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyB1c2UgbmF0aXZlIENyeXB0byBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgcmV0dXJuIHdpblsnY3J5cHRvJ11bJ3JhbmRvbVVVSUQnXSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJhdGluZyBvdXIgb3duIFVVSURcbiAgICAgICAgLy8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2N3b29kLzNiZmY0MmNjMDA1Y2MyMGFiN2VjOThmMGQ4ZTFkNTlkXG4gICAgICAgIHZhciB1dWlkID0gbmV3IEFycmF5KDM2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XG4gICAgICAgICAgICB1dWlkW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpO1xuICAgICAgICB9XG4gICAgICAgIHV1aWRbMTRdID0gNDsgLy8gc2V0IGJpdHMgMTItMTUgb2YgdGltZS1oaWdoLWFuZC12ZXJzaW9uIHRvIDAxMDBcbiAgICAgICAgdXVpZFsxOV0gPSB1dWlkWzE5XSAmPSAtNTsgLy8gc2V0IGJpdCA2IG9mIGNsb2NrLXNlcS1hbmQtcmVzZXJ2ZWQgdG8gemVyb1xuICAgICAgICB1dWlkWzE5XSA9IHV1aWRbMTldIHw9ICgxIDw8IDMpOyAvLyBzZXQgYml0IDcgb2YgY2xvY2stc2VxLWFuZC1yZXNlcnZlZCB0byBvbmVcbiAgICAgICAgdXVpZFs4XSA9IHV1aWRbMTNdID0gdXVpZFsxOF0gPSB1dWlkWzIzXSA9ICctJztcblxuICAgICAgICByZXR1cm4gXy5tYXAodXVpZCwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG59O1xuXG4vLyBfLmlzQmxvY2tlZFVBKClcbi8vIFRoaXMgaXMgdG8gYmxvY2sgdmFyaW91cyB3ZWIgc3BpZGVycyBmcm9tIGV4ZWN1dGluZyBvdXIgSlMgYW5kXG4vLyBzZW5kaW5nIGZhbHNlIHRyYWNraW5nIGRhdGFcbnZhciBCTE9DS0VEX1VBX1NUUlMgPSBbXG4gICAgJ2FocmVmc2JvdCcsXG4gICAgJ2FocmVmc3NpdGVhdWRpdCcsXG4gICAgJ2FtYXpvbmJvdCcsXG4gICAgJ2JhaWR1c3BpZGVyJyxcbiAgICAnYmluZ2JvdCcsXG4gICAgJ2JpbmdwcmV2aWV3JyxcbiAgICAnY2hyb21lLWxpZ2h0aG91c2UnLFxuICAgICdmYWNlYm9va2V4dGVybmFsJyxcbiAgICAncGV0YWxib3QnLFxuICAgICdwaW50ZXJlc3QnLFxuICAgICdzY3JlYW1pbmcgZnJvZycsXG4gICAgJ3lhaG9vISBzbHVycCcsXG4gICAgJ3lhbmRleCcsXG5cbiAgICAvLyBhIHdob2xlIGJ1bmNoIG9mIGdvb2ctc3BlY2lmaWMgY3Jhd2xlcnNcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zZWFyY2gvZG9jcy9hZHZhbmNlZC9jcmF3bGluZy9vdmVydmlldy1nb29nbGUtY3Jhd2xlcnNcbiAgICAnYWRzYm90LWdvb2dsZScsXG4gICAgJ2FwaXMtZ29vZ2xlJyxcbiAgICAnZHVwbGV4d2ViLWdvb2dsZScsXG4gICAgJ2ZlZWRmZXRjaGVyLWdvb2dsZScsXG4gICAgJ2dvb2dsZSBmYXZpY29uJyxcbiAgICAnZ29vZ2xlIHdlYiBwcmV2aWV3JyxcbiAgICAnZ29vZ2xlLXJlYWQtYWxvdWQnLFxuICAgICdnb29nbGVib3QnLFxuICAgICdnb29nbGV3ZWJsaWdodCcsXG4gICAgJ21lZGlhcGFydG5lcnMtZ29vZ2xlJyxcbiAgICAnc3RvcmVib3QtZ29vZ2xlJ1xuXTtcbl8uaXNCbG9ja2VkVUEgPSBmdW5jdGlvbih1YSkge1xuICAgIHZhciBpO1xuICAgIHVhID0gdWEudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgQkxPQ0tFRF9VQV9TVFJTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKEJMT0NLRURfVUFfU1RSU1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZm9ybWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJnX3NlcGFyYXRvclxuICovXG5fLkhUVFBCdWlsZFF1ZXJ5ID0gZnVuY3Rpb24oZm9ybWRhdGEsIGFyZ19zZXBhcmF0b3IpIHtcbiAgICB2YXIgdXNlX3ZhbCwgdXNlX2tleSwgdG1wX2FyciA9IFtdO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoYXJnX3NlcGFyYXRvcikpIHtcbiAgICAgICAgYXJnX3NlcGFyYXRvciA9ICcmJztcbiAgICB9XG5cbiAgICBfLmVhY2goZm9ybWRhdGEsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIHVzZV92YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICB1c2Vfa2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgIHRtcF9hcnJbdG1wX2Fyci5sZW5ndGhdID0gdXNlX2tleSArICc9JyArIHVzZV92YWw7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG1wX2Fyci5qb2luKGFyZ19zZXBhcmF0b3IpO1xufTtcblxuXy5nZXRRdWVyeVBhcmFtID0gZnVuY3Rpb24odXJsLCBwYXJhbSkge1xuICAgIC8vIEV4cGVjdHMgYSByYXcgVVJMXG5cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1tbXS9nLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS9nLCAnXFxcXF0nKTtcbiAgICB2YXIgcmVnZXhTID0gJ1tcXFxcPyZdJyArIHBhcmFtICsgJz0oW14mI10qKScsXG4gICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFMpLFxuICAgICAgICByZXN1bHRzID0gcmVnZXguZXhlYyh1cmwpO1xuICAgIGlmIChyZXN1bHRzID09PSBudWxsIHx8IChyZXN1bHRzICYmIHR5cGVvZihyZXN1bHRzWzFdKSAhPT0gJ3N0cmluZycgJiYgcmVzdWx0c1sxXS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1sxXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdTa2lwcGluZyBkZWNvZGluZyBmb3IgbWFsZm9ybWVkIHF1ZXJ5IHBhcmFtOiAnICsgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIH1cbn07XG5cblxuLy8gXy5jb29raWVcbi8vIE1ldGhvZHMgcGFydGlhbGx5IGJvcnJvd2VkIGZyb20gcXVpcmtzbW9kZS5vcmcvanMvY29va2llcy5odG1sXG5fLmNvb2tpZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50JDEuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvb2tpZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvb2tpZSA9IF8uSlNPTkRlY29kZShfLmNvb2tpZS5nZXQobmFtZSkpIHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG5cbiAgICBzZXRfc2Vjb25kczogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHNlY29uZHMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJyxcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnJyxcbiAgICAgICAgICAgIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoc2Vjb25kcyAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZGF5cywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLCBleHBpcmVzID0gJycsIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19jb29raWVfdmFsID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmV3X2Nvb2tpZV92YWw7XG4gICAgICAgIHJldHVybiBuZXdfY29va2llX3ZhbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lLCBpc19jcm9zc19zdWJkb21haW4sIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICBfLmNvb2tpZS5zZXQobmFtZSwgJycsIC0xLCBpc19jcm9zc19zdWJkb21haW4sIGZhbHNlLCBmYWxzZSwgZG9tYWluX292ZXJyaWRlKTtcbiAgICB9XG59O1xuXG52YXIgX3Rlc3RTdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIga2V5ID0gJ19fbXBsc3NfJyArIGNoZWFwX2d1aWQoOCksXG4gICAgICAgICAgICB2YWwgPSAneHl6JztcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcbiAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXkpICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn07XG5cbnZhciBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gX3Rlc3RTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZSk7XG59O1xuXG52YXIgX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBzZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uKHN0b3JhZ2UsIGZvcmNlQ2hlY2spIHtcbiAgICBpZiAoX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsICYmICFmb3JjZUNoZWNrKSB7XG4gICAgICAgIHJldHVybiBfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBfc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQgPSBfdGVzdFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSB8fCB3aW4uc2Vzc2lvblN0b3JhZ2UpO1xufTtcblxuZnVuY3Rpb24gX3N0b3JhZ2VXcmFwcGVyKHN0b3JhZ2UsIG5hbWUsIGlzX3N1cHBvcnRlZF9mbikge1xuICAgIHZhciBsb2dfZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKG5hbWUgKyAnIGVycm9yOiAnICsgbXNnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNfc3VwcG9ydGVkOiBmdW5jdGlvbihmb3JjZUNoZWNrKSB7XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gaXNfc3VwcG9ydGVkX2ZuKHN0b3JhZ2UsIGZvcmNlQ2hlY2spO1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IobmFtZSArICcgdW5zdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBsb2dfZXJyb3IsXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uSlNPTkRlY29kZShzdG9yYWdlLmdldEl0ZW0oa2V5KSkgfHwge307XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ19lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXy5sb2NhbFN0b3JhZ2UgPSBfc3RvcmFnZVdyYXBwZXIod2luLmxvY2FsU3RvcmFnZSwgJ2xvY2FsU3RvcmFnZScsIGxvY2FsU3RvcmFnZVN1cHBvcnRlZCk7XG5fLnNlc3Npb25TdG9yYWdlID0gX3N0b3JhZ2VXcmFwcGVyKHdpbi5zZXNzaW9uU3RvcmFnZSwgJ3Nlc3Npb25TdG9yYWdlJywgc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQpO1xuXG5fLnJlZ2lzdGVyX2V2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIHdyaXR0ZW4gYnkgRGVhbiBFZHdhcmRzLCAyMDA1XG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIFRpbm8gWmlqZGVsIC0gY3Jpc3BAeHM0YWxsLm5sXG4gICAgLy8gd2l0aCBpbnB1dCBmcm9tIENhcmwgU3ZlcnJlIC0gbWFpbEBjYXJsc3ZlcnJlLmNvbVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBNaXhwYW5lbFxuICAgIC8vIGh0dHA6Ly9kZWFuLmVkd2FyZHMubmFtZS93ZWJsb2cvMjAwNS8xMC9hZGQtZXZlbnQvXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTkzMDQ0MFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKil9IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvbGRTY2hvb2xcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1c2VDYXB0dXJlXG4gICAgICovXG4gICAgdmFyIHJlZ2lzdGVyX2V2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb2xkU2Nob29sLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdObyB2YWxpZCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlZ2lzdGVyX2V2ZW50Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyICYmICFvbGRTY2hvb2wpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCAhIXVzZUNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9udHlwZSA9ICdvbicgKyB0eXBlO1xuICAgICAgICAgICAgdmFyIG9sZF9oYW5kbGVyID0gZWxlbWVudFtvbnR5cGVdOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICBlbGVtZW50W29udHlwZV0gPSBtYWtlSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBvbGRfaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUhhbmRsZXIoZWxlbWVudCwgbmV3X2hhbmRsZXIsIG9sZF9oYW5kbGVycykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IGZpeEV2ZW50KHdpbi5ldmVudCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgYmFzaWNhbGx5IGhhcHBlbnMgaW4gZmlyZWZveCB3aGVuZXZlciBhbm90aGVyIHNjcmlwdFxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlcyB0aGUgb25sb2FkIGNhbGxiYWNrIGFuZCBkb2Vzbid0IHBhc3MgdGhlIGV2ZW50XG4gICAgICAgICAgICAvLyBvYmplY3QgdG8gcHJldmlvdXNseSBkZWZpbmVkIGNhbGxiYWNrcy4gIEFsbCB0aGUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRoYXQgZG9uJ3QgZGVmaW5lIHdpbmRvdy5ldmVudCBpbXBsZW1lbnQgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICAgLy8gc28gdGhlIGRvbV9sb2FkZWQgaGFuZGxlciB3aWxsIHN0aWxsIGJlIGZpcmVkIGFzIHVzdWFsLlxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZF9yZXN1bHQsIG5ld19yZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2xkX2hhbmRsZXJzKSkge1xuICAgICAgICAgICAgICAgIG9sZF9yZXN1bHQgPSBvbGRfaGFuZGxlcnMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3X3Jlc3VsdCA9IG5ld19oYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoKGZhbHNlID09PSBvbGRfcmVzdWx0KSB8fCAoZmFsc2UgPT09IG5ld19yZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZpeEV2ZW50LnByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZml4RXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlZ2lzdGVyX2V2ZW50O1xufSkoKTtcblxuXG52YXIgVE9LRU5fTUFUQ0hfUkVHRVggPSBuZXcgUmVnRXhwKCdeKFxcXFx3KilcXFxcWyhcXFxcdyspKFs9flxcXFx8XFxcXF5cXFxcJFxcXFwqXT8pPT9cIj8oW15cXFxcXVwiXSopXCI/XFxcXF0kJyk7XG5cbl8uZG9tX3F1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qIGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICAtIHJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudCBvYmplY3RzIGZyb20gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICBtYXRjaGluZyB0aGUgQ1NTIHNlbGVjdG9yLiBTZWxlY3RvcnMgY2FuIGNvbnRhaW4gZWxlbWVudCBuYW1lcyxcbiAgICBjbGFzcyBuYW1lcyBhbmQgaWRzIGFuZCBjYW4gYmUgbmVzdGVkLiBGb3IgZXhhbXBsZTpcblxuICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKCdkaXYjbWFpbiBwIGEuZXh0ZXJuYWwnKVxuXG4gICAgV2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsICdhJyBlbGVtZW50cyB3aXRoICdleHRlcm5hbCcgaW4gdGhlaXJcbiAgICBjbGFzcyBhdHRyaWJ1dGUgdGhhdCBhcmUgY29udGFpbmVkIGluc2lkZSAncCcgZWxlbWVudHMgdGhhdCBhcmVcbiAgICBjb250YWluZWQgaW5zaWRlIHRoZSAnZGl2JyBlbGVtZW50IHdoaWNoIGhhcyBpZD1cIm1haW5cIlxuXG4gICAgTmV3IGluIHZlcnNpb24gMC40OiBTdXBwb3J0IGZvciBDU1MyIGFuZCBDU1MzIGF0dHJpYnV0ZSBzZWxlY3RvcnM6XG4gICAgU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cbiAgICBWZXJzaW9uIDAuNCAtIFNpbW9uIFdpbGxpc29uLCBNYXJjaCAyNXRoIDIwMDNcbiAgICAtLSBXb3JrcyBpbiBQaG9lbml4IDAuNSwgTW96aWxsYSAxLjMsIE9wZXJhIDcsIEludGVybmV0IEV4cGxvcmVyIDYsIEludGVybmV0IEV4cGxvcmVyIDUgb24gV2luZG93c1xuICAgIC0tIE9wZXJhIDcgZmFpbHNcblxuICAgIFZlcnNpb24gMC41IC0gQ2FybCBTdmVycmUsIEphbiA3dGggMjAxM1xuICAgIC0tIE5vdyB1c2VzIGpRdWVyeS1lc3F1ZSBgaGFzQ2xhc3NgIGZvciB0ZXN0aW5nIGNsYXNzIG5hbWVcbiAgICBlcXVhbGl0eS4gIFRoaXMgZml4ZXMgYSBidWcgcmVsYXRlZCB0byAnLScgY2hhcmFjdGVycyBiZWluZ1xuICAgIGNvbnNpZGVyZWQgbm90IHBhcnQgb2YgYSAnd29yZCcgaW4gcmVnZXguXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKGUpIHtcbiAgICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGRyZW4gb2YgZWxlbWVudC4gV29ya2Fyb3VuZCByZXF1aXJlZCBmb3IgSUU1L1dpbmRvd3MuIFVnaC5cbiAgICAgICAgcmV0dXJuIGUuYWxsID8gZS5hbGwgOiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgfVxuXG4gICAgdmFyIGJhZF93aGl0ZXNwYWNlID0gL1tcXHRcXHJcXG5dL2c7XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJyAnICsgc2VsZWN0b3IgKyAnICc7XG4gICAgICAgIHJldHVybiAoKCcgJyArIGVsZW0uY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKGJhZF93aGl0ZXNwYWNlLCAnICcpLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBmYWlsIGdyYWNlZnVsbHkgaW4gbGVzc2VyIGJyb3dzZXJzXG4gICAgICAgIGlmICghZG9jdW1lbnQkMS5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwbGl0IHNlbGVjdG9yIGluIHRvIHRva2Vuc1xuICAgICAgICB2YXIgdG9rZW5zID0gc2VsZWN0b3Iuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIHRva2VuLCBiaXRzLCB0YWdOYW1lLCBmb3VuZCwgZm91bmRDb3VudCwgaSwgaiwgaywgZWxlbWVudHMsIGN1cnJlbnRDb250ZXh0SW5kZXg7XG4gICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IFtkb2N1bWVudCQxXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV0ucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignIycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBpcyBhbiBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnIycpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgKHRhZ05hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9IHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgbm90IGZvdW5kIG9yIHRhZyB3aXRoIHRoYXQgSUQgbm90IGZvdW5kLCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudENvbnRleHQgdG8gY29udGFpbiBqdXN0IHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW2VsZW1lbnRdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGNvbnRhaW5zIGEgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRhZywgZmlsdGVyIHRoZW0gZm9yIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kW2pdLmNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc1N0cmluZyhmb3VuZFtqXS5jbGFzc05hbWUpICYmIC8vIHNvbWUgU1ZHIGVsZW1lbnRzIGhhdmUgY2xhc3NOYW1lcyB3aGljaCBhcmUgbm90IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzKGZvdW5kW2pdLCBjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvZGUgdG8gZGVhbCB3aXRoIGF0dHJpYnV0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgIHZhciB0b2tlbl9tYXRjaCA9IHRva2VuLm1hdGNoKFRPS0VOX01BVENIX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICh0b2tlbl9tYXRjaCkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbl9tYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0b2tlbl9tYXRjaFsyXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck9wZXJhdG9yID0gdG9rZW5fbWF0Y2hbM107XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRva2VuX21hdGNoWzRdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHcmFiIGFsbCBvZiB0aGUgdGFnTmFtZSBlbGVtZW50cyB3aXRoaW4gY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGdldEFsbENoaWxkcmVuKGN1cnJlbnRDb250ZXh0W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tGdW5jdGlvbjsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gZmlsdGVyIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0ck9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOiAvLyBFcXVhbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSA9PSBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd+JzogLy8gTWF0Y2ggb25lIG9mIHNwYWNlIHNlcGVyYXRlZCB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdcXFxcYicgKyBhdHRyVmFsdWUgKyAnXFxcXGInKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzogLy8gTWF0Y2ggc3RhcnQgd2l0aCB2YWx1ZSBmb2xsb3dlZCBieSBvcHRpb25hbCBoeXBoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBhdHRyVmFsdWUgKyAnLT8nKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzogLy8gTWF0Y2ggc3RhcnRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZSAtIGZhaWxzIHdpdGggXCJXYXJuaW5nXCIgaW4gT3BlcmEgN1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sYXN0SW5kZXhPZihhdHRyVmFsdWUpID09IGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5sZW5ndGggLSBhdHRyVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6IC8vIE1hdGNoIGVuZHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHRlc3QgZm9yIGV4aXN0ZW5jZSBvZiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0Z1bmN0aW9uKGZvdW5kW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRbY3VycmVudENvbnRleHRJbmRleCsrXSA9IGZvdW5kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KCdBdHRyaWJ1dGUgU2VsZWN0b3I6ICcrdGFnTmFtZSsnICcrYXR0ck5hbWUrJyAnK2F0dHJPcGVyYXRvcisnICcrYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdG9rZW4gaXMgSlVTVCBhbiBlbGVtZW50IChub3QgYSBjbGFzcyBvciBJRCBzZWxlY3RvcilcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0b2tlbjtcbiAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICBmb3VuZENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gY3VycmVudENvbnRleHRbal0uZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVsZW1lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgaWYgKF8uaXNFbGVtZW50KHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtxdWVyeV07XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChxdWVyeSkgJiYgIV8uaXNVbmRlZmluZWQocXVlcnkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlTZWxlY3Rvci5jYWxsKHRoaXMsIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG52YXIgQ0FNUEFJR05fS0VZV09SRFMgPSBbJ3V0bV9zb3VyY2UnLCAndXRtX21lZGl1bScsICd1dG1fY2FtcGFpZ24nLCAndXRtX2NvbnRlbnQnLCAndXRtX3Rlcm0nLCAndXRtX2lkJywgJ3V0bV9zb3VyY2VfcGxhdGZvcm0nLCd1dG1fY2FtcGFpZ25faWQnLCAndXRtX2NyZWF0aXZlX2Zvcm1hdCcsICd1dG1fbWFya2V0aW5nX3RhY3RpYyddO1xudmFyIENMSUNLX0lEUyA9IFsnZGNsaWQnLCAnZmJjbGlkJywgJ2djbGlkJywgJ2tvX2NsaWNrX2lkJywgJ2xpX2ZhdF9pZCcsICdtc2Nsa2lkJywgJ3NjY2lkJywgJ3R0Y2xpZCcsICd0d2NsaWQnLCAnd2JyYWlkJ107XG5cbl8uaW5mbyA9IHtcbiAgICBjYW1wYWlnblBhcmFtczogZnVuY3Rpb24oZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB2YXIga3cgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goQ0FNUEFJR05fS0VZV09SRFMsIGZ1bmN0aW9uKGt3a2V5KSB7XG4gICAgICAgICAgICBrdyA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwga3drZXkpO1xuICAgICAgICAgICAgaWYgKGt3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBrdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2t3a2V5XSA9IGRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIGNsaWNrUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENMSUNLX0lEUywgZnVuY3Rpb24oaWRrZXkpIHtcbiAgICAgICAgICAgIGlkID0gXy5nZXRRdWVyeVBhcmFtKGRvY3VtZW50JDEuVVJMLCBpZGtleSk7XG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2lka2V5XSA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBtYXJrZXRpbmdQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5pbmZvLmNhbXBhaWduUGFyYW1zKCksIF8uaW5mby5jbGlja1BhcmFtcygpKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoRW5naW5lOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZ29vZ2xlLihbXi8/XSopJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZ29vZ2xlJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKiliaW5nLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKXlhaG9vLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3lhaG9vJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilkdWNrZHVja2dvLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2R1Y2tkdWNrZ28nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VhcmNoSW5mbzogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IF8uaW5mby5zZWFyY2hFbmdpbmUocmVmZXJyZXIpLFxuICAgICAgICAgICAgcGFyYW0gPSAoc2VhcmNoICE9ICd5YWhvbycpID8gJ3EnIDogJ3AnLFxuICAgICAgICAgICAgcmV0ID0ge307XG5cbiAgICAgICAgaWYgKHNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0Wyckc2VhcmNoX2VuZ2luZSddID0gc2VhcmNoO1xuXG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IF8uZ2V0UXVlcnlQYXJhbShyZWZlcnJlciwgcGFyYW0pO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0WydtcF9rZXl3b3JkJ10gPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgaXMgcnVubmluZyB0aGlzIHNjcmlwdC5cbiAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIGNoZWNrcyBhcmUgaW1wb3J0YW50IHNpbmNlIG1hbnkgdXNlciBhZ2VudHNcbiAgICAgKiBpbmNsdWRlIGtleSB3b3JkcyB1c2VkIGluIGxhdGVyIGNoZWNrcy5cbiAgICAgKi9cbiAgICBicm93c2VyOiBmdW5jdGlvbih1c2VyX2FnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZlbmRvciA9IHZlbmRvciB8fCAnJzsgLy8gdmVuZG9yIGlzIHVuZGVmaW5lZCBmb3IgYXQgbGVhc3QgSUU5XG4gICAgICAgIGlmIChvcGVyYSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICcgT1BSLycpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTWluaScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPcGVyYSBNaW5pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnT3BlcmEnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnSUVNb2JpbGUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdXUERlc2t0b3AnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1NhbXN1bmdCcm93c2VyLycpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5zYW1zdW5nLmNvbS9pbnRlcm5ldC91c2VyLWFnZW50LXN0cmluZy1mb3JtYXRcbiAgICAgICAgICAgIHJldHVybiAnU2Ftc3VuZyBJbnRlcm5ldCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNaWNyb3NvZnQgRWRnZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRkJJT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGYWNlYm9vayBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Nocm9tZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ3JpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ1dFQicpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDQnJvd3NlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1VDIEJyb3dzZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Z4aU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModmVuZG9yLCAnQXBwbGUnKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01vYmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb2JpbGUgU2FmYXJpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdBbmRyb2lkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0tvbnF1ZXJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0tvbnF1ZXJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRmlyZWZveCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01TSUUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdUcmlkZW50LycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdHZWNrbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vemlsbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIHZlcnNpb24gaXMgcnVubmluZyB0aGlzIHNjcmlwdCxcbiAgICAgKiBwYXJzaW5nIG1ham9yIGFuZCBtaW5vciB2ZXJzaW9uIChlLmcuLCA0Mi4xKS4gVXNlciBhZ2VudCBzdHJpbmdzIGZyb206XG4gICAgICogaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL3VzZXJhZ2VudHN0cmluZy5waHBcbiAgICAgKi9cbiAgICBicm93c2VyVmVyc2lvbjogZnVuY3Rpb24odXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKTtcbiAgICAgICAgdmFyIHZlcnNpb25SZWdleHMgPSB7XG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJzogL3J2OihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01pY3Jvc29mdCBFZGdlJzogL0VkZ2U/XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lJzogL0Nocm9tZVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSBpT1MnOiAvQ3JpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdVQyBCcm93c2VyJyA6IC8oVUNCcm93c2VyfFVDV0VCKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW9iaWxlIFNhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnT3BlcmEnOiAvKE9wZXJhfE9QUilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94JzogL0ZpcmVmb3hcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94IGlPUyc6IC9GeGlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0tvbnF1ZXJvcic6IC9Lb25xdWVyb3I6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQmxhY2tCZXJyeSc6IC9CbGFja0JlcnJ5IChcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0FuZHJvaWQgTW9iaWxlJzogL2FuZHJvaWRcXHMoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYW1zdW5nIEludGVybmV0JzogL1NhbXN1bmdCcm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXInOiAvKHJ2OnxNU0lFICkoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb3ppbGxhJzogL3J2OihcXGQrKFxcLlxcZCspPykvXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWdleCA9IHZlcnNpb25SZWdleHNbYnJvd3Nlcl07XG4gICAgICAgIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDJdKTtcbiAgICB9LFxuXG4gICAgb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHVzZXJBZ2VudDtcbiAgICAgICAgaWYgKC9XaW5kb3dzL2kudGVzdChhKSkge1xuICAgICAgICAgICAgaWYgKC9QaG9uZS8udGVzdChhKSB8fCAvV1BEZXNrdG9wLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL01hYy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFjIE9TIFgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9MaW51eC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0NyT1MvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIE9TJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXZpY2U6IGZ1bmN0aW9uKHVzZXJfYWdlbnQpIHtcbiAgICAgICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1c2VyX2FnZW50KSB8fCAvV1BEZXNrdG9wLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGFkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQYWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUG9kLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQb2QgVG91Y2gnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGhvbmUvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZmVycmluZ0RvbWFpbjogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gcmVmZXJyZXIuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICBjdXJyZW50VXJsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbi5sb2NhdGlvbi5ocmVmO1xuICAgIH0sXG5cbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbihleHRyYV9wcm9wcykge1xuICAgICAgICBpZiAodHlwZW9mIGV4dHJhX3Byb3BzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXh0cmFfcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRyZWZlcnJlcic6IGRvY3VtZW50JDEucmVmZXJyZXIsXG4gICAgICAgICAgICAnJHJlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKGRvY3VtZW50JDEucmVmZXJyZXIpLFxuICAgICAgICAgICAgJyRkZXZpY2UnOiBfLmluZm8uZGV2aWNlKHVzZXJBZ2VudClcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiBfLmluZm8uY3VycmVudFVybCgpLFxuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSksXG4gICAgICAgICAgICAnJHNjcmVlbl9oZWlnaHQnOiBzY3JlZW4uaGVpZ2h0LFxuICAgICAgICAgICAgJyRzY3JlZW5fd2lkdGgnOiBzY3JlZW4ud2lkdGgsXG4gICAgICAgICAgICAnbXBfbGliJzogJ3dlYicsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJyRpbnNlcnRfaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICAgICAndGltZSc6IF8udGltZXN0YW1wKCkgLyAxMDAwIC8vIGVwb2NoIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICB9LCBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoZXh0cmFfcHJvcHMpKTtcbiAgICB9LFxuXG4gICAgcGVvcGxlX3Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICckb3MnOiBfLmluZm8ub3MoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcic6IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGJyb3dzZXJfdmVyc2lvbic6IF8uaW5mby5icm93c2VyVmVyc2lvbih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbXBQYWdlVmlld1Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICdjdXJyZW50X3BhZ2VfdGl0bGUnOiBkb2N1bWVudCQxLnRpdGxlLFxuICAgICAgICAgICAgJ2N1cnJlbnRfZG9tYWluJzogd2luLmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3BhdGgnOiB3aW4ubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfcHJvdG9jb2wnOiB3aW4ubG9jYXRpb24ucHJvdG9jb2wsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfc2VhcmNoJzogd2luLmxvY2F0aW9uLnNlYXJjaFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgcnVuIGF0IG1vc3QgZXZlcnkgYHdhaXRNc2AgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV4dCBpbnZvY2F0aW9uLlxuICogVGhyb3R0bGVkIGNhbGxzIHdpbGwgYnVpbGQgdXAgYSBiYXRjaCBvZiBhcmdzIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYWxsIGFyZ3Mgc2luY2UgdGhlIGxhc3QgaW52b2NhdGlvbi5cbiAqL1xudmFyIGJhdGNoZWRUaHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgd2FpdE1zKSB7XG4gICAgdmFyIHRpbWVvdXRQcm9taXNlID0gbnVsbDtcbiAgICB2YXIgdGhyb3R0bGVkSXRlbXMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aHJvdHRsZWRJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIGlmICghdGltZW91dFByb21pc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBmbi5hcHBseShzZWxmLCBbdGhyb3R0bGVkSXRlbXNdKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWRJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LCB3YWl0TXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVvdXRQcm9taXNlO1xuICAgIH07XG59O1xuXG52YXIgY2hlYXBfZ3VpZCA9IGZ1bmN0aW9uKG1heGxlbikge1xuICAgIHZhciBndWlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgcmV0dXJuIG1heGxlbiA/IGd1aWQuc3Vic3RyaW5nKDAsIG1heGxlbikgOiBndWlkO1xufTtcblxuLy8gbmFpdmUgd2F5IHRvIGV4dHJhY3QgZG9tYWluIG5hbWUgKGV4YW1wbGUuY29tKSBmcm9tIGZ1bGwgaG9zdG5hbWUgKG15LnN1Yi5leGFtcGxlLmNvbSlcbnZhciBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYID0gL1thLXowLTldW2EtejAtOS1dKlxcLlthLXpdKyQvaTtcbi8vIHRoaXMgbmV4dCBvbmUgYXR0ZW1wdHMgdG8gYWNjb3VudCBmb3Igc29tZSBjY1NMRHMsIGUuZy4gZXh0cmFjdGluZyBveGZvcmQuYWMudWsgZnJvbSB3d3cub3hmb3JkLmFjLnVrXG52YXIgRE9NQUlOX01BVENIX1JFR0VYID0gL1thLXowLTldW2EtejAtOS1dK1xcLlthLXouXXsyLDZ9JC9pO1xuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRyYWN0IG1haW4gZG9tYWluIG5hbWUgZnJvbSBmdWxsIGhvc3RuYW1lLCB1c2luZyBhIGZldyBibHVudCBoZXVyaXN0aWNzLiBGb3JcbiAqIGNvbW1vbiBUTERzIGxpa2UgLmNvbS8ub3JnIHRoYXQgYWx3YXlzIGhhdmUgYSBzaW1wbGUgU0xELlRMRCBzdHJ1Y3R1cmUgKGV4YW1wbGUuY29tKSwgd2VcbiAqIHNpbXBseSBleHRyYWN0IHRoZSBsYXN0IHR3byAuLXNlcGFyYXRlZCBwYXJ0cyBvZiB0aGUgaG9zdG5hbWUgKFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVgpLlxuICogRm9yIG90aGVycywgd2UgYXR0ZW1wdCB0byBhY2NvdW50IGZvciBzaG9ydCBjY1NMRCtUTEQgY29tYm9zICguYWMudWspIHdpdGggdGhlIGxlZ2FjeVxuICogRE9NQUlOX01BVENIX1JFR0VYIChrZXB0IHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgTWl4cGFuZWxcbiAqIGludGVncmF0aW9ucykuIFRoZSBvbmx5IF9yZWxpYWJsZV8gd2F5IHRvIGV4dHJhY3QgZG9tYWluIGZyb20gaG9zdG5hbWUgaXMgd2l0aCBhbiB1cC10by1kYXRlXG4gKiBsaXN0IGxpa2UgYXQgaHR0cHM6Ly9wdWJsaWNzdWZmaXgub3JnLyBzbyBmb3IgY2FzZXMgdGhhdCB0aGlzIGhlbHBlciBmYWlscyBhdCwgdGhlIFNES1xuICogb2ZmZXJzIHRoZSAnY29va2llX2RvbWFpbicgY29uZmlnIG9wdGlvbiB0byBzZXQgaXQgZXhwbGljaXRseS5cbiAqIEBleGFtcGxlXG4gKiBleHRyYWN0X2RvbWFpbignbXkuc3ViLmV4YW1wbGUuY29tJylcbiAqIC8vICdleGFtcGxlLmNvbSdcbiAqL1xudmFyIGV4dHJhY3RfZG9tYWluID0gZnVuY3Rpb24oaG9zdG5hbWUpIHtcbiAgICB2YXIgZG9tYWluX3JlZ2V4ID0gRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIHZhciBwYXJ0cyA9IGhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIHRsZCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0bGQubGVuZ3RoID4gNCB8fCB0bGQgPT09ICdjb20nIHx8IHRsZCA9PT0gJ29yZycpIHtcbiAgICAgICAgZG9tYWluX3JlZ2V4ID0gU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB9XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0bmFtZS5tYXRjaChkb21haW5fcmVnZXgpO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1swXSA6ICcnO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHdlIGhhdmUgbmV0d29yayBjb25uZWN0aW9uLiBkZWZhdWx0IHRvIHRydWUgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBuYXZpZ2F0b3Iub25MaW5lIChJRSlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNPbmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb25MaW5lID0gd2luLm5hdmlnYXRvclsnb25MaW5lJ107XG4gICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob25MaW5lKSB8fCBvbkxpbmU7XG59O1xuXG52YXIgTk9PUF9GVU5DID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBKU09OU3RyaW5naWZ5ID0gbnVsbCwgSlNPTlBhcnNlID0gbnVsbDtcbmlmICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU09OU3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTlBhcnNlID0gSlNPTi5wYXJzZTtcbn1cbkpTT05TdHJpbmdpZnkgPSBKU09OU3RyaW5naWZ5IHx8IF8uSlNPTkVuY29kZTtcbkpTT05QYXJzZSA9IEpTT05QYXJzZSB8fCBfLkpTT05EZWNvZGU7XG5cbi8vIFVOTUlOSUZJRUQgRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5fWydpbmZvJ10gICAgICAgICAgICAgICAgICAgPSBfLmluZm87XG5fWydpbmZvJ11bJ2Jyb3dzZXInXSAgICAgICAgPSBfLmluZm8uYnJvd3Nlcjtcbl9bJ2luZm8nXVsnYnJvd3NlclZlcnNpb24nXSA9IF8uaW5mby5icm93c2VyVmVyc2lvbjtcbl9bJ2luZm8nXVsnZGV2aWNlJ10gICAgICAgICA9IF8uaW5mby5kZXZpY2U7XG5fWydpbmZvJ11bJ3Byb3BlcnRpZXMnXSAgICAgPSBfLmluZm8ucHJvcGVydGllcztcbl9bJ2lzQmxvY2tlZFVBJ10gICAgICAgICAgICA9IF8uaXNCbG9ja2VkVUE7XG5fWydpc0VtcHR5T2JqZWN0J10gICAgICAgICAgPSBfLmlzRW1wdHlPYmplY3Q7XG5fWydpc09iamVjdCddICAgICAgICAgICAgICAgPSBfLmlzT2JqZWN0O1xuX1snSlNPTkRlY29kZSddICAgICAgICAgICAgID0gXy5KU09ORGVjb2RlO1xuX1snSlNPTkVuY29kZSddICAgICAgICAgICAgID0gXy5KU09ORW5jb2RlO1xuX1sndG9BcnJheSddICAgICAgICAgICAgICAgID0gXy50b0FycmF5O1xuX1snTlBPJ10gICAgICAgICAgICAgICAgICAgID0gTnBvUHJvbWlzZTtcblxudmFyIE1JWFBBTkVMX0RCX05BTUUgPSAnbWl4cGFuZWxCcm93c2VyRGInO1xuXG52YXIgUkVDT1JESU5HX0VWRU5UU19TVE9SRV9OQU1FID0gJ21peHBhbmVsUmVjb3JkaW5nRXZlbnRzJztcbnZhciBSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRSA9ICdtaXhwYW5lbFJlY29yZGluZ1JlZ2lzdHJ5JztcblxuLy8gbm90ZTogaW5jcmVtZW50IHRoZSB2ZXJzaW9uIG51bWJlciB3aGVuIGFkZGluZyBuZXcgb2JqZWN0IHN0b3Jlc1xudmFyIERCX1ZFUlNJT04gPSAxO1xudmFyIE9CSkVDVF9TVE9SRVMgPSBbUkVDT1JESU5HX0VWRU5UU19TVE9SRV9OQU1FLCBSRUNPUkRJTkdfUkVHSVNUUllfU1RPUkVfTkFNRV07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi93cmFwcGVyJykuU3RvcmFnZVdyYXBwZXJ9XG4gKi9cbnZhciBJREJTdG9yYWdlV3JhcHBlciA9IGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxJREJEYXRhYmFzZT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRiUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuX29wZW5EYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IHdpbi5pbmRleGVkREIub3BlbihNSVhQQU5FTF9EQl9OQU1FLCBEQl9WRVJTSU9OKTtcbiAgICAgICAgb3BlblJlcXVlc3RbJ29uZXJyb3InXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlblJlcXVlc3RbJ29uc3VjY2VzcyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShvcGVuUmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5SZXF1ZXN0WydvbnVwZ3JhZGVuZWVkZWQnXSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRiID0gZXYudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgT0JKRUNUX1NUT1JFUy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpbi5pbmRleGVkREIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZWplY3QoJ2luZGV4ZWREQiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kYlByb21pc2UpIHtcbiAgICAgICAgdGhpcy5kYlByb21pc2UgPSB0aGlzLl9vcGVuRGIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYlByb21pc2VcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRiT3JFcnJvcikge1xuICAgICAgICAgICAgaWYgKGRiT3JFcnJvciBpbnN0YW5jZW9mIHdpblsnSURCRGF0YWJhc2UnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdChkYk9yRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtJREJUcmFuc2FjdGlvbk1vZGV9IG1vZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSURCT2JqZWN0U3RvcmUpOiB2b2lkfSBzdG9yZUNiXG4gKi9cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5tYWtlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAobW9kZSwgc3RvcmVDYikge1xuICAgIHZhciBzdG9yZU5hbWUgPSB0aGlzLnN0b3JlTmFtZTtcbiAgICB2YXIgZG9UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChkYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihzdG9yZU5hbWUsIG1vZGUpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWplY3QodHJhbnNhY3Rpb24uZXJyb3IpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3RvcmVDYih0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZVxuICAgICAgICAudGhlbihkb1RyYW5zYWN0aW9uKVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnJbJ25hbWUnXSA9PT0gJ0ludmFsaWRTdGF0ZUVycm9yJykge1xuICAgICAgICAgICAgICAgIC8vIHRyeSByZW9wZW5pbmcgdGhlIERCIGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZFxuICAgICAgICAgICAgICAgIHRoaXMuZGJQcm9taXNlID0gdGhpcy5fb3BlbkRiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlLnRoZW4oZG9UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgb2JqZWN0U3RvcmUucHV0KHZhbHVlLCBrZXkpO1xuICAgIH0pO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlcTtcbiAgICByZXR1cm4gdGhpcy5tYWtlVHJhbnNhY3Rpb24oJ3JlYWRvbmx5JywgZnVuY3Rpb24gKG9iamVjdFN0b3JlKSB7XG4gICAgICAgIHJlcSA9IG9iamVjdFN0b3JlLmdldChrZXkpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxLnJlc3VsdDtcbiAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1ha2VUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZnVuY3Rpb24gKG9iamVjdFN0b3JlKSB7XG4gICAgICAgIG9iamVjdFN0b3JlLmRlbGV0ZShrZXkpO1xuICAgIH0pO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVxO1xuICAgIHJldHVybiB0aGlzLm1ha2VUcmFuc2FjdGlvbigncmVhZG9ubHknLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgcmVxID0gb2JqZWN0U3RvcmUuZ2V0QWxsKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXEucmVzdWx0O1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBHRFBSIHV0aWxzXG4gKlxuICogVGhlIEdlbmVyYWwgRGF0YSBQcm90ZWN0aW9uIFJlZ3VsYXRpb24gKEdEUFIpIGlzIGEgcmVndWxhdGlvbiBpbiBFVSBsYXcgb24gZGF0YSBwcm90ZWN0aW9uXG4gKiBhbmQgcHJpdmFjeSBmb3IgYWxsIGluZGl2aWR1YWxzIHdpdGhpbiB0aGUgRXVyb3BlYW4gVW5pb24uIEl0IGFkZHJlc3NlcyB0aGUgZXhwb3J0IG9mIHBlcnNvbmFsXG4gKiBkYXRhIG91dHNpZGUgdGhlIEVVLiBUaGUgR0RQUiBhaW1zIHByaW1hcmlseSB0byBnaXZlIGNvbnRyb2wgYmFjayB0byBjaXRpemVucyBhbmQgcmVzaWRlbnRzXG4gKiBvdmVyIHRoZWlyIHBlcnNvbmFsIGRhdGEgYW5kIHRvIHNpbXBsaWZ5IHRoZSByZWd1bGF0b3J5IGVudmlyb25tZW50IGZvciBpbnRlcm5hdGlvbmFsIGJ1c2luZXNzXG4gKiBieSB1bmlmeWluZyB0aGUgcmVndWxhdGlvbiB3aXRoaW4gdGhlIEVVLlxuICpcbiAqIFRoaXMgc2V0IG9mIHV0aWxpdGllcyBpcyBpbnRlbmRlZCB0byBlbmFibGUgb3B0IGluL291dCBmdW5jdGlvbmFsaXR5IGluIHRoZSBNaXhwYW5lbCBKUyBTREsuXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgU0RLIGFuZCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHB1YmxpY2x5IGV4cG9zZWQuXG4gKi9cblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCB0byB0cmFjayBhIE1peHBhbmVsIGV2ZW50IChlLmcuIE1peHBhbmVsTGliLnRyYWNrKVxuICogQGNhbGxiYWNrIHRyYWNrRnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC4gVGhpcyBjYW4gYmUgYW55dGhpbmcgdGhlIHVzZXIgZG9lcyAtICdCdXR0b24gQ2xpY2snLCAnU2lnbiBVcCcsICdJdGVtIFB1cmNoYXNlZCcsIGV0Yy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nLiBUaGVzZSBkZXNjcmliZSB0aGUgdXNlciB3aG8gZGlkIHRoZSBldmVudCBvciBkZXRhaWxzIGFib3V0IHRoZSBldmVudCBpdHNlbGYuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5cbi8qKiBQdWJsaWMgKiovXG5cbnZhciBHRFBSX0RFRkFVTFRfUEVSU0lTVEVOQ0VfUFJFRklYID0gJ19fbXBfb3B0X2luX291dF8nO1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3RyYWNrRnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSAtIGZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tFdmVudE5hbWVdIC0gZXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrUHJvcGVydGllc10gLSBzZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0SW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICBfb3B0SW5PdXQodHJ1ZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LW91dCBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBfb3B0SW5PdXQoZmFsc2UsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBpbiB0byB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzEnO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRG50XSAtIGZsYWcgdG8gaWdub3JlIGJyb3dzZXIgRE5UIHNldHRpbmdzIGFuZCBhbHdheXMgcmV0dXJuIGZhbHNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIGlmIChfaGFzRG9Ob3RUcmFja0ZsYWdPbihvcHRpb25zKSkge1xuICAgICAgICBjb25zb2xlJDEud2FybignVGhpcyBicm93c2VyIGhhcyBcIkRvIE5vdCBUcmFja1wiIGVuYWJsZWQuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLiBUbyBpZ25vcmUgdGhlIFwiRG8gTm90IFRyYWNrXCIgYnJvd3NlciBzZXR0aW5nLCBpbml0aWFsaXplIHRoZSBNaXhwYW5lbCBpbnN0YW5jZSB3aXRoIHRoZSBjb25maWcgXCJpZ25vcmVfZG50OiB0cnVlXCInKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcHRlZE91dCA9IF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMCc7XG4gICAgaWYgKG9wdGVkT3V0KSB7XG4gICAgICAgIGNvbnNvbGUkMS53YXJuKCdZb3UgYXJlIG9wdGVkIG91dCBvZiBNaXhwYW5lbCB0cmFja2luZy4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIE1peHBhbmVsIFNESyBmcm9tIHNlbmRpbmcgYW55IGRhdGEuJyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRlZE91dDtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxMaWIgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsUGVvcGxlIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxHcm91cCBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlcidzIG9wdCBpbi9vdXQgc3RhdHVzIG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gY2xlYXJPcHRJbk91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF9nZXRTdG9yYWdlKG9wdGlvbnMpLnJlbW92ZShcbiAgICAgICAgX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpLCAhIW9wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWUsIG9wdGlvbnMuY29va2llRG9tYWluXG4gICAgKTtcbn1cblxuLyoqIFByaXZhdGUgKiovXG5cbi8qKlxuICogR2V0IHN0b3JhZ2UgdXRpbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV1cbiAqIEByZXR1cm5zIHtvYmplY3R9IGVpdGhlciBfLmNvb2tpZSBvciBfLmxvY2Fsc3RvcmFnZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucGVyc2lzdGVuY2VUeXBlID09PSAnbG9jYWxTdG9yYWdlJyA/IF8ubG9jYWxTdG9yYWdlIDogXy5jb29raWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb29raWUgdGhhdCBpcyB1c2VkIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGUgKHRyYWNraW5nLCBjb29raWUsIGV0Yy4pXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgY29va2llIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gKG9wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXggfHwgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCkgKyB0b2tlbjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgdGhhdCBpcyB1c2VkIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGUgKHRyYWNraW5nLCBjb29raWUsIGV0Yy4pXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2Uob3B0aW9ucykuZ2V0KF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgc2V0IHRoZSBETlQvZG9Ob3RUcmFjayBzZXR0aW5nIHRvIHRydWUgaW4gdGhlaXIgYnJvd3NlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndpbmRvd10gLSBhbHRlcm5hdGUgd2luZG93IG9iamVjdCB0byBjaGVjazsgdXNlZCB0byBmb3JjZSB2YXJpb3VzIEROVCBzZXR0aW5ncyBpbiBicm93c2VyIHRlc3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIEROVCBzZXR0aW5nIGlzIHRydWVcbiAqL1xuZnVuY3Rpb24gX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWdub3JlRG50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHdpbiQxID0gKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3cpIHx8IHdpbjtcbiAgICB2YXIgbmF2ID0gd2luJDFbJ25hdmlnYXRvciddIHx8IHt9O1xuICAgIHZhciBoYXNEbnRPbiA9IGZhbHNlO1xuXG4gICAgXy5lYWNoKFtcbiAgICAgICAgbmF2Wydkb05vdFRyYWNrJ10sIC8vIHN0YW5kYXJkXG4gICAgICAgIG5hdlsnbXNEb05vdFRyYWNrJ10sXG4gICAgICAgIHdpbiQxWydkb05vdFRyYWNrJ11cbiAgICBdLCBmdW5jdGlvbihkbnRWYWx1ZSkge1xuICAgICAgICBpZiAoXy5pbmNsdWRlcyhbdHJ1ZSwgMSwgJzEnLCAneWVzJ10sIGRudFZhbHVlKSkge1xuICAgICAgICAgICAgaGFzRG50T24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGFzRG50T247XG59XG5cbi8qKlxuICogU2V0IGNvb2tpZS9sb2NhbHN0b3JhZ2UgZm9yIHRoZSB1c2VyIGluZGljYXRpbmcgdGhhdCB0aGV5IGFyZSBvcHRlZCBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRWYWx1ZSAtIHdoZXRoZXIgdG8gb3B0IHRoZSB1c2VyIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3RyYWNrRnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSAtIGZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tFdmVudE5hbWVdIC0gZXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrUHJvcGVydGllc10gLSBzZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIF9vcHRJbk91dChvcHRWYWx1ZSwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcodG9rZW4pIHx8ICF0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdnZHByLicgKyAob3B0VmFsdWUgPyAnb3B0SW4nIDogJ29wdE91dCcpICsgJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHRva2VuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIF9nZXRTdG9yYWdlKG9wdGlvbnMpLnNldChcbiAgICAgICAgX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpLFxuICAgICAgICBvcHRWYWx1ZSA/IDEgOiAwLFxuICAgICAgICBfLmlzTnVtYmVyKG9wdGlvbnMuY29va2llRXhwaXJhdGlvbikgPyBvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24gOiBudWxsLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWUsXG4gICAgICAgICEhb3B0aW9ucy5zZWN1cmVDb29raWUsXG4gICAgICAgICEhb3B0aW9ucy5jcm9zc1NpdGVDb29raWUsXG4gICAgICAgIG9wdGlvbnMuY29va2llRG9tYWluXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLnRyYWNrICYmIG9wdFZhbHVlKSB7IC8vIG9ubHkgdHJhY2sgZXZlbnQgaWYgb3B0aW5nIGluIChvcHRWYWx1ZT10cnVlKVxuICAgICAgICBvcHRpb25zLnRyYWNrKG9wdGlvbnMudHJhY2tFdmVudE5hbWUgfHwgJyRvcHRfaW4nLCBvcHRpb25zLnRyYWNrUHJvcGVydGllcywge1xuICAgICAgICAgICAgJ3NlbmRfaW1tZWRpYXRlbHknOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBXcmFwIGEgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0Q29uZmlnVmFsdWUgLSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBNaXhwYW5lbCBBUEkgdG9rZW4gYW5kIG90aGVyIG9wdGlvbnMgdG8gYmUgdXNlZCB3aXRoIG9wdC1vdXQgY2hlY2tcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZ2V0Q29uZmlnVmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRlZE91dCA9IGZhbHNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd0b2tlbicpO1xuICAgICAgICAgICAgdmFyIGlnbm9yZURudCA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ2lnbm9yZV9kbnQnKTtcbiAgICAgICAgICAgIHZhciBwZXJzaXN0ZW5jZVR5cGUgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBwZXJzaXN0ZW5jZVByZWZpeCA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpO1xuICAgICAgICAgICAgdmFyIHdpbiA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ3dpbmRvdycpOyAvLyB1c2VkIHRvIG92ZXJyaWRlIHdpbmRvdyBkdXJpbmcgYnJvd3NlciB0ZXN0c1xuXG4gICAgICAgICAgICBpZiAodG9rZW4pIHsgLy8gaWYgdGhlcmUgd2FzIGFuIGlzc3VlIGdldHRpbmcgdGhlIHRva2VuLCBjb250aW51ZSBtZXRob2QgZXhlY3V0aW9uIGFzIG5vcm1hbFxuICAgICAgICAgICAgICAgIG9wdGVkT3V0ID0gaGFzT3B0ZWRPdXQodG9rZW4sIHtcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlRG50OiBpZ25vcmVEbnQsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlVHlwZTogcGVyc2lzdGVuY2VUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVByZWZpeDogcGVyc2lzdGVuY2VQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzogd2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3Igd2hlbiBjaGVja2luZyB0cmFja2luZyBvcHQtb3V0IHN0YXR1czogJyArIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGVkT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfTtcbn1cblxudmFyIGxvZ2dlciQ1ID0gY29uc29sZV93aXRoX3ByZWZpeCgnbG9jaycpO1xuXG4vKipcbiAqIFNoYXJlZExvY2s6IGEgbXV0ZXggYnVpbHQgb24gSFRNTDUgbG9jYWxTdG9yYWdlLCB0byBlbnN1cmUgdGhhdCBvbmx5IG9uZSBicm93c2VyXG4gKiB3aW5kb3cvdGFiIGF0IGEgdGltZSB3aWxsIGJlIGFibGUgdG8gYWNjZXNzIHNoYXJlZCByZXNvdXJjZXMuXG4gKlxuICogQmFzZWQgb24gdGhlIEFsdXIgYW5kIFRhdWJlbmZlbGQgZmFzdCBsb2NrXG4gKiAoaHR0cDovL3d3dy5jcy5yb2NoZXN0ZXIuZWR1L3Jlc2VhcmNoL3N5bmNocm9uaXphdGlvbi9wc2V1ZG9jb2RlL2Zhc3Rsb2NrLmh0bWwpXG4gKiB3aXRoIGFuIGFkZGVkIHRpbWVvdXQgdG8gZW5zdXJlIHRoZXJlIHdpbGwgYmUgZXZlbnR1YWwgcHJvZ3Jlc3MgaW4gdGhlIGV2ZW50XG4gKiB0aGF0IGEgd2luZG93IGlzIGNsb3NlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgdmVyc2lvbiBieSBEYXZpZCBXb2xldmVyIChodHRwczovL2dpdGh1Yi5jb20vd29sZXZlcilcbiAqIGF0IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3dvbGV2ZXIvNWZkNzU3M2QxZWY2MTY2ZThmOGM0YWYyODZhNjk0MzIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG15TG9jayA9IG5ldyBTaGFyZWRMb2NrKCdzb21lLWtleScpO1xuICogbXlMb2NrLndpdGhMb2NrKGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZygnSSBob2xkIHRoZSBtdXRleCEnKTtcbiAqIH0pO1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2hhcmVkTG9jayA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5zdG9yYWdlS2V5ID0ga2V5O1xuICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZSB8fCB3aW4ubG9jYWxTdG9yYWdlO1xuICAgIHRoaXMucG9sbEludGVydmFsTVMgPSBvcHRpb25zLnBvbGxJbnRlcnZhbE1TIHx8IDEwMDtcbiAgICB0aGlzLnRpbWVvdXRNUyA9IG9wdGlvbnMudGltZW91dE1TIHx8IDIwMDA7XG5cbiAgICAvLyBkZXBlbmRlbmN5LWluamVjdCBwcm9taXNlIGltcGxlbWVudGF0aW9uIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgdGhpcy5wcm9taXNlSW1wbCA9IG9wdGlvbnMucHJvbWlzZUltcGwgfHwgUHJvbWlzZVBvbHlmaWxsO1xufTtcblxuLy8gcGFzcyBpbiBhIHNwZWNpZmljIHBpZCB0byB0ZXN0IGNvbnRlbnRpb24gc2NlbmFyaW9zOyBvdGhlcndpc2Vcbi8vIGl0IGlzIGNob3NlbiByYW5kb21seSBmb3IgZWFjaCBhY3F1aXNpdGlvbiBhdHRlbXB0XG5TaGFyZWRMb2NrLnByb3RvdHlwZS53aXRoTG9jayA9IGZ1bmN0aW9uKGxvY2tlZENCLCBwaWQpIHtcbiAgICB2YXIgUHJvbWlzZSA9IHRoaXMucHJvbWlzZUltcGw7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpID0gcGlkIHx8IChuZXcgRGF0ZSgpLmdldFRpbWUoKSArICd8JyArIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHZhciBwb2xsSW50ZXJ2YWxNUyA9IHRoaXMucG9sbEludGVydmFsTVM7XG4gICAgICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLnRpbWVvdXRNUztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIGtleVggPSBrZXkgKyAnOlgnO1xuICAgICAgICB2YXIga2V5WSA9IGtleSArICc6WSc7XG4gICAgICAgIHZhciBrZXlaID0ga2V5ICsgJzpaJztcblxuICAgICAgICB2YXIgZGVsYXkgPSBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGltZW91dE1TKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDUuZXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgbXV0ZXggb24gJyArIGtleSArICc7IGNsZWFyaW5nIGxvY2suIFsnICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHBvbGxJbnRlcnZhbE1TICogKE1hdGgucmFuZG9tKCkgKyAwLjEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd2FpdEZvciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKHByZWRpY2F0ZSwgY2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTZXRZID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsWSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXlZKTtcbiAgICAgICAgICAgIGlmICh2YWxZICYmIHZhbFkgIT09IGkpIHsgLy8gaWYgWSA9PSBpIHRoZW4gdGhpcyBwcm9jZXNzIGFscmVhZHkgaGFzIHRoZSBsb2NrICh1c2VmdWwgZm9yIHRlc3QgY2FzZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgZHJvcHBlZCB3aGlsZSBhY3F1aXJpbmcgbG9jaycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WCwgaSk7XG5cbiAgICAgICAgICAgIHdhaXRGb3IoZ2V0U2V0WSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBjcml0aWNhbFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RvcmFnZS5nZXRJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgICAgICB9LCBjcml0aWNhbFNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyaXRpY2FsU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVosICcxJyk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxvY2tlZENCKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIExvY2FsU3RvcmFnZVdyYXBwZXIgPSBmdW5jdGlvbiAoc3RvcmFnZU92ZXJyaWRlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZU92ZXJyaWRlIHx8IHdpbi5sb2NhbFN0b3JhZ2U7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTlN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtID0gSlNPTlBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkNCA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdFF1ZXVlOiBxdWV1ZSBmb3IgYmF0Y2hpbmcgQVBJIHJlcXVlc3RzIHdpdGggbG9jYWxTdG9yYWdlIGJhY2t1cCBmb3IgcmV0cmllcy5cbiAqIE1haW50YWlucyBhbiBpbi1tZW1vcnkgcXVldWUgd2hpY2ggcmVwcmVzZW50cyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudFxuICogcGFnZSwgYnV0IGFsc28gd3JpdGVzIGFsbCBpdGVtcyBvdXQgdG8gYSBjb3B5IGluIHRoZSBicm93c2VyJ3MgbG9jYWxTdG9yYWdlLCB3aGljaFxuICogY2FuIGJlIHJlYWQgb24gc3Vic2VxdWVudCBwYWdlbG9hZHMgYW5kIHJldHJpZWQuIEZvciBiYXRjaGFiaWxpdHksIGFsbCB0aGUgcmVxdWVzdFxuICogaXRlbXMgaW4gdGhlIHF1ZXVlIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlIChldmVudHMsIHBlb3BsZSB1cGRhdGVzLCBncm91cCB1cGRhdGVzKVxuICogc28gdGhleSBjYW4gYmUgc2VudCBpbiBhIHNpbmdsZSByZXF1ZXN0IHRvIHRoZSBzYW1lIEFQSSBlbmRwb2ludC5cbiAqXG4gKiBMb2NhbFN0b3JhZ2Uga2V5aW5nIGFuZCBsb2NraW5nOiBJbiBvcmRlciBmb3IgcmVsb2FkcyBhbmQgc3Vic2VxdWVudCBwYWdlbG9hZHMgb2ZcbiAqIHRoZSBzYW1lIHNpdGUgdG8gYWNjZXNzIHRoZSBzYW1lIHBlcnNpc3RlZCBkYXRhLCB0aGV5IG11c3Qgc2hhcmUgdGhlIHNhbWUgbG9jYWxTdG9yYWdlXG4gKiBrZXkgKGZvciBpbnN0YW5jZSBiYXNlZCBvbiBwcm9qZWN0IHRva2VuIGFuZCBxdWV1ZSB0eXBlKS4gVGhlcmVmb3JlIGFjY2VzcyB0byB0aGVcbiAqIGxvY2FsU3RvcmFnZSBlbnRyeSBpcyBndWFyZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBtdXRleCAoU2hhcmVkTG9jaykgdG8gcHJldmVudFxuICogc2ltdWx0YW5lb3VzbHkgb3BlbiB3aW5kb3dzL3RhYnMgZnJvbSBvdmVyd3JpdGluZyBlYWNoIG90aGVyJ3MgZGF0YSAod2hpY2ggd291bGQgbGVhZFxuICogdG8gZGF0YSBsb3NzIGluIHNvbWUgc2l0dWF0aW9ucykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uIChzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gb3B0aW9ucy51c2VQZXJzaXN0ZW5jZTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG9wdGlvbnMucXVldWVTdG9yYWdlIHx8IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKCk7XG4gICAgICAgIHRoaXMubG9jayA9IG5ldyBTaGFyZWRMb2NrKHN0b3JhZ2VLZXksIHtcbiAgICAgICAgICAgIHN0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZSxcbiAgICAgICAgICAgIHRpbWVvdXRNUzogb3B0aW9ucy5zaGFyZWRMb2NrVGltZW91dE1TLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZXBvcnRFcnJvciA9IG9wdGlvbnMuZXJyb3JSZXBvcnRlciB8fCBfLmJpbmQobG9nZ2VyJDQuZXJyb3IsIGxvZ2dlciQ0KTtcblxuICAgIHRoaXMucGlkID0gb3B0aW9ucy5waWQgfHwgbnVsbDsgLy8gcGFzcyBwaWQgdG8gdGVzdCBvdXQgc3RvcmFnZSBsb2NrIGNvbnRlbnRpb24gc2NlbmFyaW9zXG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5xdWV1ZVRocm90dGxlTXMpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlUGVyc2lzdGVkID0gYmF0Y2hlZFRocm90dGxlKF8uYmluZCh0aGlzLl9lbnF1ZXVlUGVyc2lzdGVkLCB0aGlzKSwgb3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlUGVyc2lzdGVkID0gXy5iaW5kKGZ1bmN0aW9uIChxdWV1ZUVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5xdWV1ZVBlcnNpc3RlZChbcXVldWVFbnRyeV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVuc3VyZUluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlXG4gICAgICAgIC5pbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgcXVldWUgcGVyc2lzdGVuY2UuIERpc2FibGluZyBwZXJzaXN0ZW5jZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuIFRoZSBxdWV1ZWQgZW50cnkgaW5jbHVkZXNcbiAqIHRoZSBnaXZlbiBpdGVtIGFsb25nIHdpdGggYW4gYXV0by1nZW5lcmF0ZWQgSUQgYW5kIGEgXCJmbHVzaC1hZnRlclwiIHRpbWVzdGFtcC5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGl0ZW0gd2lsbCBiZSBzZW50IG92ZXIgdGhlIG5ldHdvcmsgYW5kIGRlcXVldWVkXG4gKiBiZWZvcmUgdGhlIGZsdXNoLWFmdGVyIHRpbWU7IGlmIHRoaXMgZG9lc24ndCBoYXBwZW4gaXQgaXMgY29uc2lkZXJlZCBvcnBoYW5lZFxuICogKGUuZy4sIHRoZSBvcmlnaW5hbCB0YWIgd2hlcmUgaXQgd2FzIGVucXVldWVkIGdvdCBjbG9zZWQgYmVmb3JlIGl0IGNvdWxkIGJlXG4gKiBzZW50KSBhbmQgdGhlIGl0ZW0gY2FuIGJlIHNlbnQgYnkgYW55IHRhYiB0aGF0IGZpbmRzIGl0IGluIGxvY2FsU3RvcmFnZS5cbiAqXG4gKiBUaGUgZmluYWwgY2FsbGJhY2sgcGFyYW0gaXMgY2FsbGVkIHdpdGggYSBwYXJhbSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3JcbiAqIGZhaWx1cmUgb2YgdGhlIGVucXVldWUgb3BlcmF0aW9uOyBpdCBpcyBhc3luY2hyb25vdXMgYmVjYXVzZSB0aGUgbG9jYWxTdG9yYWdlXG4gKiBsb2NrIGlzIGFzeW5jaHJvbm91cy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0sIGZsdXNoSW50ZXJ2YWwpIHtcbiAgICB2YXIgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgJ2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAnZmx1c2hBZnRlcic6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZmx1c2hJbnRlcnZhbCAqIDIsXG4gICAgICAgICdwYXlsb2FkJzogaXRlbVxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZVBlcnNpc3RlZChxdWV1ZUVudHJ5KTtcbiAgICB9XG59O1xuXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLl9lbnF1ZXVlUGVyc2lzdGVkID0gZnVuY3Rpb24gKHF1ZXVlRW50cmllcykge1xuICAgIHZhciBlbnF1ZXVlSXRlbSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUuY29uY2F0KHF1ZXVlRW50cmllcykpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIGluLW1lbW9yeSBxdWV1ZSB3aGVuIHN0b3JhZ2Ugc3VjY2VlZHNcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtUXVldWUgPSB0aGlzLm1lbVF1ZXVlLmNvbmNhdChxdWV1ZUVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgaXRlbXMnLCBlcnIsIHF1ZXVlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAud2l0aExvY2soZW5xdWV1ZUl0ZW0sIHRoaXMucGlkKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIFJlYWQgb3V0IHRoZSBnaXZlbiBudW1iZXIgb2YgcXVldWUgZW50cmllcy4gSWYgdGhpcy5tZW1RdWV1ZVxuICogaGFzIGZld2VyIHRoYW4gYmF0Y2hTaXplIGl0ZW1zLCB0aGVuIGxvb2sgZm9yIFwib3JwaGFuZWRcIiBpdGVtc1xuICogaW4gdGhlIHBlcnNpc3RlZCBxdWV1ZSAoaXRlbXMgd2hlcmUgdGhlICdmbHVzaEFmdGVyJyB0aW1lIGhhc1xuICogYWxyZWFkeSBwYXNzZWQpLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmZpbGxCYXRjaCA9IGZ1bmN0aW9uIChiYXRjaFNpemUpIHtcbiAgICB2YXIgYmF0Y2ggPSB0aGlzLm1lbVF1ZXVlLnNsaWNlKDAsIGJhdGNoU2l6ZSk7XG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UgJiYgYmF0Y2gubGVuZ3RoIDwgYmF0Y2hTaXplKSB7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgbG9jayBqdXN0IHRvIHJlYWQgZXZlbnRzOyBsb2NhbFN0b3JhZ2UgaXMgdGhyZWFkLXNhZmVcbiAgICAgICAgLy8gYW5kIHRoZSB3b3JzdCB0aGF0IGNvdWxkIGhhcHBlbiBpcyBhIGR1cGxpY2F0ZSBzZW5kIG9mIHNvbWVcbiAgICAgICAgLy8gb3JwaGFuZWQgZXZlbnRzLCB3aGljaCB3aWxsIGJlIGRlZHVwbGljYXRlZCBvbiB0aGUgc2VydmVyIHNpZGVcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkc0luQmF0Y2ggPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9ycGhhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgJ2lkJyBmcm9tIGFycmF5IChpbW11dGFibHkpXG4gKiBhbHNvIHJlbW92ZSBhbnkgaXRlbSB3aXRob3V0IGEgdmFsaWQgaWQgKGUuZy4sIG1hbGZvcm1lZFxuICogc3RvcmFnZSBlbnRyaWVzKS5cbiAqL1xudmFyIGZpbHRlck91dElEc0FuZEludmFsaWQgPSBmdW5jdGlvbiAoaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWydpZCddICYmICFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nIElEcyBmcm9tIGJvdGggaW4tbWVtb3J5IHF1ZXVlXG4gKiBhbmQgcGVyc2lzdGVkIHF1ZXVlXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVtb3ZlSXRlbXNCeUlEID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpZFNldCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgIF8uZWFjaChpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZFNldFtpZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQodGhpcy5tZW1RdWV1ZSwgaWRTZXQpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlbW92ZUZyb21TdG9yYWdlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgY2hlY2s6IGRpZCBzdG9yYWdlIHJlcG9ydCBzdWNjZXNzIGJ1dCBzb21laG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBhcmUgc3RpbGwgdGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCByZW1vdmVkIGZyb20gc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZW1vdmluZyBpdGVtcycsIGVyciwgaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKHJlbW92ZUZyb21TdG9yYWdlLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHRoaXMubG9jay5zdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIGxvY2FsU3RvcmFnZSB3cml0ZXMgaGF2ZSBzdG9wcGVkIHdvcmtpbmcgc29tZXRpbWUgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gKHByb2JhYmx5IGZ1bGwpLCBhbmQgc28gbm9ib2R5IGNhbiBhY3F1aXJlIGxvY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueW1vcmUuIENvbnNpZGVyIGl0IHRlbXBvcmFyaWx5IHNhZmUgdG8gcmVtb3ZlIGl0ZW1zIHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvY2ssIHNpbmNlIG5vYm9keSdzIHdyaXRpbmcgc3VjY2Vzc2Z1bGx5IGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21TdG9yYWdlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPSywgd2UgY291bGRuJ3QgZXZlbiB3cml0ZSBvdXQgdGhlIHNtYWxsZXIgcXVldWUuIFRyeSBjbGVhcmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGNsZWFyaW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG59O1xuXG4vLyBpbnRlcm5hbCBoZWxwZXIgZm9yIFJlcXVlc3RRdWV1ZS51cGRhdGVQYXlsb2Fkc1xudmFyIHVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGV4aXN0aW5nSXRlbXMsIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB2YXIgbmV3SXRlbXMgPSBbXTtcbiAgICBfLmVhY2goZXhpc3RpbmdJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXlsb2FkID0gaXRlbXNUb1VwZGF0ZVtpZF07XG4gICAgICAgICAgICBpZiAobmV3UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bJ3BheWxvYWQnXSA9IG5ld1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdJdGVtcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHBheWxvYWRzIG9mIGdpdmVuIGl0ZW1zIGluIGJvdGggaW4tbWVtb3J5IHF1ZXVlIGFuZFxuICogcGVyc2lzdGVkIHF1ZXVlLiBJdGVtcyBzZXQgdG8gbnVsbCBhcmUgcmVtb3ZlZCBmcm9tIHF1ZXVlcy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS51cGRhdGVQYXlsb2FkcyA9IGZ1bmN0aW9uIChpdGVtc1RvVXBkYXRlKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IHVwZGF0ZVBheWxvYWRzKHRoaXMubWVtUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKF8uYmluZChmdW5jdGlvbiBsb2NrQWNxdWlyZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlID0gdXBkYXRlUGF5bG9hZHMoc3RvcmVkUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGl0ZW1zJywgaXRlbXNUb1VwZGF0ZSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyksIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcGFyc2UgaXRlbXMgYXJyYXkgZnJvbSBsb2NhbFN0b3JhZ2UgZW50cnksIGhhbmRsaW5nXG4gKiBtYWxmb3JtZWQvbWlzc2luZyBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZWFkRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNBcnJheShzdG9yYWdlRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0ludmFsaWQgc3RvcmFnZSBlbnRyeTonLCBzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlRW50cnkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlRW50cnkgfHwgW107XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gaXRlbXMgYXJyYXkgdG8gbG9jYWxTdG9yYWdlLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnNhdmVUb1N0b3JhZ2UgPSBmdW5jdGlvbiAocXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgcXVldWUpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igc2F2aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMudXNlUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxufTtcblxuLy8gbWF4aW11bSBpbnRlcnZhbCBiZXR3ZWVuIHJlcXVlc3QgcmV0cmllcyBhZnRlciBleHBvbmVudGlhbCBiYWNrb2ZmXG52YXIgTUFYX1JFVFJZX0lOVEVSVkFMX01TID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcblxudmFyIGxvZ2dlciQzID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0QmF0Y2hlcjogbWFuYWdlcyB0aGUgcXVldWVpbmcsIGZsdXNoaW5nLCByZXRyeSBldGMgb2YgcmVxdWVzdHMgb2Ygb25lXG4gKiB0eXBlIChldmVudHMsIHBlb3BsZSwgZ3JvdXBzKS5cbiAqIFVzZXMgUmVxdWVzdFF1ZXVlIHRvIG1hbmFnZSB0aGUgYmFja2luZyBzdG9yZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdEJhdGNoZXIgPSBmdW5jdGlvbihzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lcnJvclJlcG9ydGVyID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyO1xuICAgIHRoaXMucXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKHN0b3JhZ2VLZXksIHtcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogXy5iaW5kKHRoaXMucmVwb3J0RXJyb3IsIHRoaXMpLFxuICAgICAgICBxdWV1ZVN0b3JhZ2U6IG9wdGlvbnMucXVldWVTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSxcbiAgICAgICAgc2hhcmVkTG9ja1RpbWVvdXRNUzogb3B0aW9ucy5zaGFyZWRMb2NrVGltZW91dE1TLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogb3B0aW9ucy51c2VQZXJzaXN0ZW5jZSxcbiAgICAgICAgZW5xdWV1ZVRocm90dGxlTXM6IG9wdGlvbnMuZW5xdWV1ZVRocm90dGxlTXNcbiAgICB9KTtcblxuICAgIHRoaXMubGliQ29uZmlnID0gb3B0aW9ucy5saWJDb25maWc7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCA9IG9wdGlvbnMuc2VuZFJlcXVlc3RGdW5jO1xuICAgIHRoaXMuYmVmb3JlU2VuZEhvb2sgPSBvcHRpb25zLmJlZm9yZVNlbmRIb29rO1xuICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nID0gb3B0aW9ucy5zdG9wQWxsQmF0Y2hpbmdGdW5jO1xuXG4gICAgLy8gc2VlZCB2YXJpYWJsZSBiYXRjaCBzaXplICsgZmx1c2ggaW50ZXJ2YWwgd2l0aCBjb25maWd1cmVkIHZhbHVlc1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXTtcblxuICAgIHRoaXMuc3RvcHBlZCA9ICF0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfYXV0b3N0YXJ0J107XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG5cbiAgICAvLyBleHRyYSBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5ID0ge307XG5cbiAgICAvLyBNYWtlIHRoZSBmbHVzaCBvY2N1ciBhdCB0aGUgaW50ZXJ2YWwgc3BlY2lmaWVkIGJ5IGZsdXNoSW50ZXJ2YWxNcywgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGF0dGVtcHQgY29uc2VjdXRpdmUgZmx1c2hlc1xuICAgIC8vIGFzIGxvbmcgYXMgdGhlIHF1ZXVlIGlzIG5vdCBlbXB0eS4gVGhpcyBpcyB1c2VmdWwgZm9yIGhpZ2gtZnJlcXVlbmN5IGV2ZW50cyBsaWtlIFNlc3Npb24gUmVwbGF5IHdoZXJlIHdlIG1pZ2h0IGVuZCB1cFxuICAgIC8vIGluIGEgcmVxdWVzdCBsb29wIGFuZCBnZXQgcmF0ZWxpbWl0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICB0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgPSBvcHRpb25zLmZsdXNoT25seU9uSW50ZXJ2YWwgfHwgZmFsc2U7XG5cbiAgICB0aGlzLl9mbHVzaFByb21pc2UgPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmVucXVldWUoaXRlbSwgdGhpcy5mbHVzaEludGVydmFsKTtcbn07XG5cbi8qKlxuICogU3RhcnQgZmx1c2hpbmcgYmF0Y2hlcyBhdCB0aGUgY29uZmlndXJlZCB0aW1lIGludGVydmFsLiBNdXN0IGNhbGxcbiAqIHRoaXMgbWV0aG9kIHVwb24gU0RLIGluaXQgaW4gb3JkZXIgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGZsdXNoaW5nIGJhdGNoZXMuIENhbiBiZSByZXN0YXJ0ZWQgYnkgY2FsbGluZyBzdGFydCgpLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMudGltZW91dElEID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBiYXRjaCBzaXplIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0QmF0Y2hTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGZsdXNoIGludGVydmFsIHRpbWUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2NoZWR1bGVGbHVzaCh0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnXSk7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlIHRoZSBuZXh0IGZsdXNoIGluIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2NoZWR1bGVGbHVzaCA9IGZ1bmN0aW9uKGZsdXNoTVMpIHtcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSBmbHVzaE1TO1xuICAgIGlmICghdGhpcy5zdG9wcGVkKSB7IC8vIGRvbid0IHNjaGVkdWxlIGFueW1vcmUgaWYgYmF0Y2hpbmcgaGFzIGJlZW4gc3RvcHBlZFxuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IHNldFRpbWVvdXQoXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFByb21pc2UgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdXNpbmcgdGhlIHNlbmRSZXF1ZXN0IGNhbGxiYWNrLCBidXQgcHJvbWlzaWZpZWQuXG4gKiBUT0RPOiBzZW5kUmVxdWVzdCBzaG91bGQgYmUgcHJvbWlzaWZpZWQgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc2VuZFJlcXVlc3RQcm9taXNlID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoZGF0YSwgb3B0aW9ucywgcmVzb2x2ZSk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuXG4vKipcbiAqIEZsdXNoIG9uZSBiYXRjaCB0byBuZXR3b3JrLiBEZXBlbmRpbmcgb24gc3VjY2Vzcy9mYWlsdXJlIG1vZGVzLCBpdCB3aWxsIGVpdGhlclxuICogcmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBxdWV1ZSBvciBsZWF2ZSBpdCBpbiBmb3IgcmV0cnksIGFuZCBzY2hlZHVsZSB0aGUgbmV4dFxuICogZmx1c2guIEluIGNhc2VzIG9mIG1vc3QgbmV0d29yayBvciBBUEkgZmFpbHVyZXMsIGl0IHdpbGwgYmFjayBvZmYgZXhwb25lbnRpYWxseVxuICogd2hlbiByZXRyeWluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VuZEJlYWNvbl0gLSB3aGV0aGVyIHRvIHNlbmQgYmF0Y2ggd2l0aFxuICogbmF2aWdhdG9yLnNlbmRCZWFjb24gKG9ubHkgdXNlZnVsIGZvciBzZW5kaW5nIGJhdGNoZXMgYmVmb3JlIHBhZ2UgdW5sb2FkcywgYXNcbiAqIHNlbmRCZWFjb24gb2ZmZXJzIG5vIGNhbGxiYWNrcyBvciBzdGF0dXMgaW5kaWNhdGlvbnMpXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcykge1xuICAgICAgICBsb2dnZXIkMy5sb2coJ0ZsdXNoOiBSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IHRydWU7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGltZW91dE1TID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyddO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgY3VycmVudEJhdGNoU2l6ZSA9IHRoaXMuYmF0Y2hTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMucXVldWUuZmlsbEJhdGNoKGN1cnJlbnRCYXRjaFNpemUpXG4gICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbihiYXRjaCkge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG1vcmUgaXRlbXMgaW4gdGhlIHF1ZXVlIHRoYW4gdGhlIGJhdGNoIHNpemUsIGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIGZsdXNoIGFnYWluIGFmdGVyIHRoZSBjdXJyZW50IGJhdGNoIGlzIGRvbmUuXG4gICAgICAgICAgICB2YXIgYXR0ZW1wdFNlY29uZGFyeUZsdXNoID0gYmF0Y2gubGVuZ3RoID09PSBjdXJyZW50QmF0Y2hTaXplO1xuICAgICAgICAgICAgdmFyIGRhdGFGb3JSZXF1ZXN0ID0gW107XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRJdGVtcyA9IHt9O1xuICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBpdGVtWydwYXlsb2FkJ107XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVmb3JlU2VuZEhvb2sgJiYgIWl0ZW0ub3JwaGFuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMuYmVmb3JlU2VuZEhvb2socGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1wX3NlbnRfYnlfbGliX3ZlcnNpb24gcHJvcCBjYXB0dXJlcyB3aGljaCBsaWIgdmVyc2lvbiBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBzZW5kcyBlYWNoIGV2ZW50IChyZWdhcmRsZXNzIG9mIHdoaWNoIHZlcnNpb24gb3JpZ2luYWxseSBxdWV1ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZm9yIHNlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkWydldmVudCddICYmIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddID0gXy5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsncHJvcGVydGllcyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnbXBfc2VudF9ieV9saWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTn1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFBheWxvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMCkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcywgbm90IHNlbmRpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBheWxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFGb3JSZXF1ZXN0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJdGVtc1tpdGVtWydpZCddXSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFGb3JSZXF1ZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7IC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlSXRlbXNCeUlEKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5tYXAoYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBkZWR1cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA9IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc1NlbnQ6IHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEIHdoaWxlIHJlbW92aW5nJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbHVzaE9ubHlPbkludGVydmFsICYmICFhdHRlbXB0U2Vjb25kYXJ5Rmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7IC8vIHNjaGVkdWxlIG5leHQgYmF0Y2ggd2l0aCBhIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7IC8vIGhhbmRsZSBuZXh0IGJhdGNoIGlmIHRoZSBxdWV1ZSBpc24ndCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignVG9vIG1hbnkgcXVldWUgZmFpbHVyZXM7IGRpc2FibGluZyBiYXRjaGluZyBzeXN0ZW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbEJhdGNoaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGJhdGNoU2VuZENhbGxiYWNrID0gXy5iaW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIEFQSSByZXNwb25zZSBpbiBhIHRyeS1jYXRjaCB0byBtYWtlIHN1cmUgd2UgY2FuIHJlc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaCBvcGVyYXRpb24gaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwZXJzaXN0ZWQgZGF0YSB0byBpbmNsdWRlIGhvb2sgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS51cGRhdGVQYXlsb2Fkcyh0cmFuc2Zvcm1lZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPj0gdGltZW91dE1TXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignTmV0d29yayB0aW1lb3V0OyByZXRyeWluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNPYmplY3QocmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmh0dHBTdGF0dXNDb2RlID49IDUwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQyOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAocmVzLmh0dHBTdGF0dXNDb2RlIDw9IDAgJiYgIWlzT25saW5lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5lcnJvciA9PT0gJ3RpbWVvdXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgb3IgQVBJIGVycm9yLCBvciA0MjkgVG9vIE1hbnkgUmVxdWVzdHMsIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0cnlNUyA9IHRoaXMuZmx1c2hJbnRlcnZhbCAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gKHBhcnNlSW50KHJlcy5yZXRyeUFmdGVyLCAxMCkgKiAxMDAwKSB8fCByZXRyeU1TO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IE1hdGgubWluKE1BWF9SRVRSWV9JTlRFUlZBTF9NUywgcmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvcjsgcmV0cnkgaW4gJyArIHJldHJ5TVMgKyAnIG1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRmx1c2gocmV0cnlNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJlcykgJiYgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQxMyBQYXlsb2FkIFRvbyBMYXJnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFsdmVkQmF0Y2hTaXplID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihjdXJyZW50QmF0Y2hTaXplIC8gMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5iYXRjaFNpemUsIGhhbHZlZEJhdGNoU2l6ZSwgYmF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignNDEzIHJlc3BvbnNlOyByZWR1Y2luZyBiYXRjaCBzaXplIHRvICcgKyB0aGlzLmJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1NpbmdsZS1ldmVudCByZXF1ZXN0IHRvbyBsYXJnZTsgZHJvcHBpbmcnLCBiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEJhdGNoU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBuZXR3b3JrIHJlcXVlc3QrcmVzcG9uc2U7IHJlbW92ZSBlYWNoIGl0ZW0gaW4gYmF0Y2ggZnJvbSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV2ZW4gaWYgaXQgd2FzIGUuZy4gYSA0MDAsIGluIHdoaWNoIGNhc2UgcmV0cnlpbmcgd29uJ3QgaGVscClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtc0Zyb21RdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgaGFuZGxpbmcgQVBJIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVfanNvbl9lcnJvcnM6IHRydWUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICAgICAgdGltZW91dF9tczogdGltZW91dE1TIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMudHJhbnNwb3J0ID0gJ3NlbmRCZWFjb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDMubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicsIGRhdGFGb3JSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0UHJvbWlzZShkYXRhRm9yUmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpLnRoZW4oYmF0Y2hTZW5kQ2FsbGJhY2spO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGZsdXNoaW5nIHJlcXVlc3QgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogTG9nIGVycm9yIHRvIGdsb2JhbCBsb2dnZXIgYW5kIG9wdGlvbmFsIHVzZXItZGVmaW5lZCBsb2dnZXIuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDMuZXJyb3IuYXBwbHkobG9nZ2VyJDMuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuZXJyb3JSZXBvcnRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVwb3J0ZXIobXNnLCBlcnIpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDMuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vc2Vzc2lvbi1yZWNvcmRpbmcnKS5TZXJpYWxpemVkUmVjb3JkaW5nfSBzZXJpYWxpemVkUmVjb3JkaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzUmVjb3JkaW5nRXhwaXJlZCA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gIXNlcmlhbGl6ZWRSZWNvcmRpbmcgfHwgbm93ID4gc2VyaWFsaXplZFJlY29yZGluZ1snbWF4RXhwaXJlcyddIHx8IG5vdyA+IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2lkbGVFeHBpcmVzJ107XG59O1xuXG52YXIgUkVDT1JEX0VOUVVFVUVfVEhST1RUTEVfTVMgPSAyNTA7XG5cbnZhciBsb2dnZXIkMiA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG52YXIgQ29tcHJlc3Npb25TdHJlYW0gPSB3aW5bJ0NvbXByZXNzaW9uU3RyZWFtJ107XG5cbnZhciBSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUcgPSB7XG4gICAgJ2JhdGNoX3NpemUnOiAxMDAwLFxuICAgICdiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyc6IDEwICogMTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogOTAgKiAxMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiB0cnVlXG59O1xuXG52YXIgQUNUSVZFX1NPVVJDRVMgPSBuZXcgU2V0KFtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGwsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuRHJhZyxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5TZWxlY3Rpb24sXG5dKTtcblxuZnVuY3Rpb24gaXNVc2VyRXZlbnQoZXYpIHtcbiAgICByZXR1cm4gZXYudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgQUNUSVZFX1NPVVJDRVMuaGFzKGV2LmRhdGEuc291cmNlKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkUmVjb3JkaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWRsZUV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhFeHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVwbGF5U3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2VxTm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYXRjaFN0YXJ0VXJsXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVwbGF5SWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWJJZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcGxheVN0YXJ0VXJsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29wdGlvbnMucmVwbGF5SWRdIC0gdW5pcXVlIHV1aWQgZm9yIGEgc2luZ2xlIHJlcGxheVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25JZGxlVGltZW91dF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaWRsZSB0aW1lb3V0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWRdIC0gY2FsbGJhY2sgd2hlbiBhIHJlY29yZGluZyByZWFjaGVzIGl0cyBtYXhpbXVtIGxlbmd0aFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMucnJ3ZWJSZWNvcmRdIC0gcnJ3ZWIncyBgcmVjb3JkYCBmdW5jdGlvblxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29wdGlvbnMub25CYXRjaFNlbnRdIC0gY2FsbGJhY2sgd2hlbiBhIGJhdGNoIG9mIGV2ZW50cyBpcyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIEBwcm9wZXJ0eSB7U3RvcmFnZX0gW29wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2VdIC0gb3B0aW9uYWwgc3RvcmFnZSBmb3Igc2hhcmVkIGxvY2ssIHVzZWQgZm9yIHRlc3QgZGVwZW5kZW5jeSBpbmplY3Rpb25cbiAqIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIGRlc2VyaWFsaXphdGlvbjpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZGxlRXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBsYXlTdGFydFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXFOb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhdGNoU3RhcnRVcmxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXBsYXlTdGFydFVybFxuICovXG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyBhIHNpbmdsZSBzZXNzaW9uIHJlY29yZGluZyBhbmQgaXRzIGxpZmVjeWNsZS5cbiAqIEBwYXJhbSB7U2Vzc2lvblJlY29yZGluZ09wdGlvbnN9IG9wdGlvbnNcbiAqL1xudmFyIFNlc3Npb25SZWNvcmRpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBvcHRpb25zLm1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5fb25JZGxlVGltZW91dCA9IG9wdGlvbnMub25JZGxlVGltZW91dCB8fCBOT09QX0ZVTkM7XG4gICAgdGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkID0gb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWQgfHwgTk9PUF9GVU5DO1xuICAgIHRoaXMuX29uQmF0Y2hTZW50ID0gb3B0aW9ucy5vbkJhdGNoU2VudCB8fCBOT09QX0ZVTkM7XG4gICAgdGhpcy5fcnJ3ZWJSZWNvcmQgPSBvcHRpb25zLnJyd2ViUmVjb3JkIHx8IG51bGw7XG5cbiAgICAvLyBpbnRlcm5hbCBycndlYiBzdG9wUmVjb3JkaW5nIGZ1bmN0aW9uXG4gICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgdGhpcy5yZXBsYXlJZCA9IG9wdGlvbnMucmVwbGF5SWQ7XG5cbiAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBvcHRpb25zLmJhdGNoU3RhcnRVcmwgfHwgbnVsbDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gb3B0aW9ucy5yZXBsYXlTdGFydFVybCB8fCBudWxsO1xuICAgIHRoaXMuaWRsZUV4cGlyZXMgPSBvcHRpb25zLmlkbGVFeHBpcmVzIHx8IG51bGw7XG4gICAgdGhpcy5tYXhFeHBpcmVzID0gb3B0aW9ucy5tYXhFeHBpcmVzIHx8IG51bGw7XG4gICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBvcHRpb25zLnJlcGxheVN0YXJ0VGltZSB8fCBudWxsO1xuICAgIHRoaXMuc2VxTm8gPSBvcHRpb25zLnNlcU5vIHx8IDA7XG5cbiAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubWF4VGltZW91dElkID0gbnVsbDtcblxuICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgIHRoaXMucmVjb3JkTWluTXMgPSAwO1xuXG4gICAgLy8gZGlzYWJsZSBwZXJzaXN0ZW5jZSBpZiBsb2NhbFN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZFxuICAgIC8vIHJlcXVlc3QtcXVldWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc2FibGUgcGVyc2lzdGVuY2UgaWYgaW5kZXhlZERCIGZhaWxzIHRvIGluaXRpYWxpemVcbiAgICB2YXIgdXNlUGVyc2lzdGVuY2UgPSBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQob3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSwgdHJ1ZSk7XG5cbiAgICAvLyBlYWNoIHJlcGxheSBoYXMgaXRzIG93biBiYXRjaGVyIGtleSB0byBhdm9pZCBjb25mbGljdHMgYmV0d2VlbiBycndlYiBldmVudHMgb2YgZGlmZmVyZW50IHJlY29yZGluZ3NcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW1wb3J0YW50IHdoZW4gcGVyc2lzdGVuY2UgaXMgaW50cm9kdWNlZFxuICAgIHRoaXMuYmF0Y2hlcktleSA9ICdfX21wcmVjXycgKyB0aGlzLmdldENvbmZpZygnbmFtZScpICsgJ18nICsgdGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnXycgKyB0aGlzLnJlcGxheUlkO1xuICAgIHRoaXMucXVldWVTdG9yYWdlID0gbmV3IElEQlN0b3JhZ2VXcmFwcGVyKFJFQ09SRElOR19FVkVOVFNfU1RPUkVfTkFNRSk7XG4gICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKHRoaXMuYmF0Y2hlcktleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLnJlcG9ydEVycm9yLmJpbmQodGhpcyksXG4gICAgICAgIGZsdXNoT25seU9uSW50ZXJ2YWw6IHRydWUsXG4gICAgICAgIGxpYkNvbmZpZzogUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHLFxuICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IHRoaXMuZmx1c2hFdmVudHNXaXRoT3B0T3V0LmJpbmQodGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogdGhpcy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogdXNlUGVyc2lzdGVuY2UsXG4gICAgICAgIHN0b3BBbGxCYXRjaGluZ0Z1bmM6IHRoaXMuc3RvcFJlY29yZGluZy5iaW5kKHRoaXMpLFxuXG4gICAgICAgIC8vIGluY3JlYXNlZCB0aHJvdHRsZSBhbmQgc2hhcmVkIGxvY2sgdGltZW91dCBiZWNhdXNlIHJlY29yZGluZyBldmVudHMgYXJlIHZlcnkgaGlnaCBmcmVxdWVuY3kuXG4gICAgICAgIC8vIHRoaXMgd2lsbCBtaW5pbWl6ZSB0aGUgYW1vdW50IG9mIGxvY2sgY29udGVudGlvbiBiZXR3ZWVuIGVucXVldWVkIGV2ZW50cy5cbiAgICAgICAgLy8gZm9yIHNlc3Npb24gcmVjb3JkaW5ncyB0aGVyZSBpcyBhIGxvY2sgZm9yIGVhY2ggdGFiIGFueXdheSwgc28gdGhlcmUncyBubyByaXNrIG9mIGRlYWRsb2NrIGJldHdlZW4gdGFicy5cbiAgICAgICAgZW5xdWV1ZVRocm90dGxlTXM6IFJFQ09SRF9FTlFVRVVFX1RIUk9UVExFX01TLFxuICAgICAgICBzaGFyZWRMb2NrVGltZW91dE1TOiAxMCAqIDEwMDAsXG4gICAgfSk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS51bmxvYWRQZXJzaXN0ZWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5mbHVzaCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuYmF0Y2hlcktleSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25maWdWYXIpO1xufTtcblxuLy8gQWxpYXMgZm9yIGdldENvbmZpZywgdXNlZCBieSB0aGUgY29tbW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIgZnVuY3Rpb24gd2hpY2hcbi8vIHJlYWNoZXMgaW50byB0aGlzIGNsYXNzIGluc3RhbmNlIGFuZCBleHBlY3RzIHRoZSBzbmFrZSBjYXNlIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ1Zhcikge1xuICAgIHJldHVybiB0aGlzLmdldENvbmZpZyhjb25maWdWYXIpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc2hvdWxkU3RvcEJhdGNoZXIpIHtcbiAgICBpZiAodGhpcy5fcnJ3ZWJSZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcigncnJ3ZWIgcmVjb3JkIGZ1bmN0aW9uIG5vdCBwcm92aWRlZC4gJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RvcFJlY29yZGluZyAhPT0gbnVsbCkge1xuICAgICAgICBsb2dnZXIkMi5sb2coJ1JlY29yZGluZyBhbHJlYWR5IGluIHByb2dyZXNzLCBza2lwcGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVjb3JkTWF4TXMgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX21heF9tcycpO1xuICAgIGlmICh0aGlzLnJlY29yZE1heE1zID4gTUFYX1JFQ09SRElOR19NUykge1xuICAgICAgICB0aGlzLnJlY29yZE1heE1zID0gTUFYX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDIuY3JpdGljYWwoJ3JlY29yZF9tYXhfbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1JFQ09SRElOR19NUyArICdtcy4gQ2FwcGluZyB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubWF4RXhwaXJlcykge1xuICAgICAgICB0aGlzLm1heEV4cGlyZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMucmVjb3JkTWF4TXM7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWluX21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWluTXMgPiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNaW5NcyA9IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDIuY3JpdGljYWwoJ3JlY29yZF9taW5fbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5yZXBsYXlTdGFydFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFN0b3BCYXRjaGVyIHx8IHRoaXMucmVjb3JkTWluTXMgPiAwKSB7XG4gICAgICAgIC8vIHRoZSBwcmltYXJ5IGNhc2UgZm9yIHNob3VsZFN0b3BCYXRjaGVyIGlzIHdoZW4gd2UncmUgc3RhcnRpbmcgcmVjb3JkaW5nIGFmdGVyIGEgcmVzZXRcbiAgICAgICAgLy8gYW5kIGRvbid0IHdhbnQgdG8gc2VuZCBhbnl0aGluZyBvdmVyIHRoZSBuZXR3b3JrIHVudGlsIHRoZXJlJ3NcbiAgICAgICAgLy8gYWN0dWFsIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgLy8gdGhpcyBhbHNvIGFwcGxpZXMgaWYgdGhlIG1pbmltdW0gcmVjb3JkaW5nIGxlbmd0aCBoYXMgbm90IGJlZW4gaGl0IHlldFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IHNlbmQgZGF0YSB1bnRpbCB3ZSBrbm93IHRoZSByZWNvcmRpbmcgd2lsbCBiZSBsb25nIGVub3VnaFxuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdGFydCgpO1xuICAgIH1cblxuICAgIHZhciByZXNldElkbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICAgICAgdmFyIGlkbGVUaW1lb3V0TXMgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX2lkbGVfdGltZW91dF9tcycpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uSWRsZVRpbWVvdXQsIGlkbGVUaW1lb3V0TXMpO1xuICAgICAgICB0aGlzLmlkbGVFeHBpcmVzID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBpZGxlVGltZW91dE1zO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICByZXNldElkbGVUaW1lb3V0KCk7XG5cbiAgICB2YXIgYmxvY2tTZWxlY3RvciA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfc2VsZWN0b3InKTtcbiAgICBpZiAoYmxvY2tTZWxlY3RvciA9PT0gJycgfHwgYmxvY2tTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICBibG9ja1NlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRpbmcgPSB0aGlzLl9ycndlYlJlY29yZCh7XG4gICAgICAgICAgICAnZW1pdCc6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkbGVFeHBpcmVzICYmIHRoaXMuaWRsZUV4cGlyZXMgPCBldi50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25JZGxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1VzZXJFdmVudChldikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkICYmIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5yZXBsYXlTdGFydFRpbWUgPj0gdGhpcy5yZWNvcmRNaW5Ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZmx1c2hpbmcgYWdhaW4gYWZ0ZXIgdXNlciBhY3Rpdml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzZXRJZGxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlIG9ubHkgdXNlZCB0byBhd2FpdCBkdXJpbmcgdGVzdHNcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW5xdWV1ZVByb21pc2UgPSB0aGlzLmJhdGNoZXIuZW5xdWV1ZShldik7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAnYmxvY2tDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfYmxvY2tfY2xhc3MnKSxcbiAgICAgICAgICAgICdibG9ja1NlbGVjdG9yJzogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICdjb2xsZWN0Rm9udHMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NvbGxlY3RfZm9udHMnKSxcbiAgICAgICAgICAgICdkYXRhVVJMT3B0aW9ucyc6IHsgLy8gY2FudmFzIGltYWdlIG9wdGlvbnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC90b0RhdGFVUkwpXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAgICAgJ3F1YWxpdHknOiAwLjZcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFza0FsbElucHV0cyc6IHRydWUsXG4gICAgICAgICAgICAnbWFza1RleHRDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X2NsYXNzJyksXG4gICAgICAgICAgICAnbWFza1RleHRTZWxlY3Rvcic6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJyksXG4gICAgICAgICAgICAncmVjb3JkQ2FudmFzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9jYW52YXMnKSxcbiAgICAgICAgICAgICdzYW1wbGluZyc6IHtcbiAgICAgICAgICAgICAgICAnY2FudmFzJzogMTVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3Igd2hlbiBzdGFydGluZyBycndlYiByZWNvcmRpbmcuJywgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcigncnJ3ZWIgZmFpbGVkIHRvIHN0YXJ0LCBza2lwcGluZyB0aGlzIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpOyAvLyBzdG9wIGJhdGNoZXIgbG9vcGluZyBhbmQgYW55IHRpbWVvdXRzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF4VGltZW91dE1zID0gdGhpcy5tYXhFeHBpcmVzIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZC5iaW5kKHRoaXMpLCBtYXhUaW1lb3V0TXMpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uIChza2lwRmx1c2gpIHtcbiAgICBpZiAoIXRoaXMuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHdpdGggcnJ3ZWIgc3RvcFJlY29yZGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZsdXNoUHJvbWlzZTtcbiAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQpIHtcbiAgICAgICAgLy8gbmV2ZXIgZ290IHVzZXIgYWN0aXZpdHkgdG8gZmx1c2ggYWZ0ZXIgcmVzZXQsIHNvIGp1c3QgY2xlYXIgdGhlIGJhdGNoZXJcbiAgICAgICAgZmx1c2hQcm9taXNlID0gdGhpcy5iYXRjaGVyLmNsZWFyKCk7XG4gICAgfSBlbHNlIGlmICghc2tpcEZsdXNoKSB7XG4gICAgICAgIC8vIGZsdXNoIGFueSByZW1haW5pbmcgZXZlbnRzIGZyb20gcnVubmluZyBiYXRjaGVyXG4gICAgICAgIGZsdXNoUHJvbWlzZSA9IHRoaXMuYmF0Y2hlci5mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWF4VGltZW91dElkKTtcbiAgICByZXR1cm4gZmx1c2hQcm9taXNlO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuaXNScndlYlN0b3BwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BSZWNvcmRpbmcgPT09IG51bGw7XG59O1xuXG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaCBvZiBldmVudHMgdG8gdGhlIHNlcnZlciwgYnV0IHBhc3NlcyBhbiBvcHQtb3V0IGNhbGxiYWNrIHRvIG1ha2Ugc3VyZVxuICogd2Ugc3RvcCByZWNvcmRpbmcgYW5kIGR1bXAgYW55IHF1ZXVlZCBldmVudHMgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dC5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZmx1c2hFdmVudHNXaXRoT3B0T3V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIG9uT3B0T3V0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgLy8gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBpbnZva2VzIHRoaXMgZnVuY3Rpb24gd2l0aCBjb2RlPTAgd2hlbiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgIGNiKHtlcnJvcjogJ1RyYWNraW5nIGhhcyBiZWVuIG9wdGVkIG91dCwgc3RvcHBpbmcgcmVjb3JkaW5nLid9KTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2ZsdXNoRXZlbnRzKGRhdGEsIG9wdGlvbnMsIGNiLCBvbk9wdE91dCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtTZXJpYWxpemVkUmVjb3JkaW5nfVxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZG9uJ3QgYnJlYWsgaWYgbWl4cGFuZWwgaW5zdGFuY2Ugd2FzIGRlc3Ryb3llZCBhdCBzb21lIHBvaW50XG4gICAgdmFyIHRhYklkO1xuICAgIHRyeSB7XG4gICAgICAgIHRhYklkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3RhYl9pZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZ2V0dGluZyB0YWIgSUQgZm9yIHNlcmlhbGl6YXRpb24gJywgZSk7XG4gICAgICAgIHRhYklkID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAncmVwbGF5SWQnOiB0aGlzLnJlcGxheUlkLFxuICAgICAgICAnc2VxTm8nOiB0aGlzLnNlcU5vLFxuICAgICAgICAncmVwbGF5U3RhcnRUaW1lJzogdGhpcy5yZXBsYXlTdGFydFRpbWUsXG4gICAgICAgICdiYXRjaFN0YXJ0VXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAncmVwbGF5U3RhcnRVcmwnOiB0aGlzLnJlcGxheVN0YXJ0VXJsLFxuICAgICAgICAnaWRsZUV4cGlyZXMnOiB0aGlzLmlkbGVFeHBpcmVzLFxuICAgICAgICAnbWF4RXhwaXJlcyc6IHRoaXMubWF4RXhwaXJlcyxcbiAgICAgICAgJ3RhYklkJzogdGFiSWQsXG4gICAgfTtcbn07XG5cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1NlcmlhbGl6ZWRSZWNvcmRpbmd9IHNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqIEBwYXJhbSB7U2Vzc2lvblJlY29yZGluZ09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtTZXNzaW9uUmVjb3JkaW5nfVxuICovXG5TZXNzaW9uUmVjb3JkaW5nLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWRSZWNvcmRpbmcsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVjb3JkaW5nID0gbmV3IFNlc3Npb25SZWNvcmRpbmcoXy5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcmVwbGF5SWQ6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3JlcGxheUlkJ10sXG4gICAgICAgIGJhdGNoU3RhcnRVcmw6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2JhdGNoU3RhcnRVcmwnXSxcbiAgICAgICAgcmVwbGF5U3RhcnRVcmw6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3JlcGxheVN0YXJ0VXJsJ10sXG4gICAgICAgIGlkbGVFeHBpcmVzOiBzZXJpYWxpemVkUmVjb3JkaW5nWydpZGxlRXhwaXJlcyddLFxuICAgICAgICBtYXhFeHBpcmVzOiBzZXJpYWxpemVkUmVjb3JkaW5nWydtYXhFeHBpcmVzJ10sXG4gICAgICAgIHJlcGxheVN0YXJ0VGltZTogc2VyaWFsaXplZFJlY29yZGluZ1sncmVwbGF5U3RhcnRUaW1lJ10sXG4gICAgICAgIHNlcU5vOiBzZXJpYWxpemVkUmVjb3JkaW5nWydzZXFObyddLFxuICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSxcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gcmVjb3JkaW5nO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX3NlbmRSZXF1ZXN0ID0gZnVuY3Rpb24oY3VycmVudFJlcGxheUlkLCByZXFQYXJhbXMsIHJlcUJvZHksIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9uU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzcGVjaWZpYyBwcm9wcyBvbmx5IGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsIHRvIGd1YXJhbnRlZSBvcmRlcmluZy5cbiAgICAgICAgLy8gUmVxdWVzdEJhdGNoZXIgd2lsbCBhbHdheXMgZmx1c2ggdGhlIG5leHQgYmF0Y2ggYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBzdWNjZWVkcy5cbiAgICAgICAgLy8gZXh0cmEgY2hlY2sgdG8gc2VlIGlmIHRoZSByZXBsYXkgSUQgaGFzIGNoYW5nZWQgc28gdGhhdCB3ZSBkb24ndCBpbmNyZW1lbnQgdGhlIHNlcU5vIG9uIHRoZSB3cm9uZyByZXBsYXlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHRoaXMucmVwbGF5SWQgPT09IGN1cnJlbnRSZXBsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXFObysrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uQmF0Y2hTZW50KCk7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZUJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgIHJldHJ5QWZ0ZXI6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdSZXRyeS1BZnRlcicpXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHdpblsnZmV0Y2gnXSh0aGlzLmdldENvbmZpZygnYXBpX2hvc3QnKSArICcvJyArIHRoaXMuZ2V0Q29uZmlnKCdhcGlfcm91dGVzJylbJ3JlY29yZCddICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXFQYXJhbXMpLCB7XG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdoZWFkZXJzJzoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgIH0sXG4gICAgICAgICdib2R5JzogcmVxQm9keSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzcG9uc2UsIHJlc3BvbnNlQm9keSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvciwgaHR0cFN0YXR1c0NvZGU6IDB9KTtcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9mbHVzaEV2ZW50cyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG51bUV2ZW50cyA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKG51bUV2ZW50cyA+IDApIHtcbiAgICAgICAgdmFyIHJlcGxheUlkID0gdGhpcy5yZXBsYXlJZDtcblxuICAgICAgICAvLyBlYWNoIHJyd2ViIGV2ZW50IGhhcyBhIHRpbWVzdGFtcCAtIGxldmVyYWdlIHRob3NlIHRvIGdldCB0aW1lIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGJhdGNoU3RhcnRUaW1lID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBiYXRjaEVuZFRpbWUgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBoYXNGdWxsU25hcHNob3QgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FdmVudHM7IGkrKykge1xuICAgICAgICAgICAgYmF0Y2hTdGFydFRpbWUgPSBNYXRoLm1pbihiYXRjaFN0YXJ0VGltZSwgZGF0YVtpXS50aW1lc3RhbXApO1xuICAgICAgICAgICAgYmF0Y2hFbmRUaW1lID0gTWF0aC5tYXgoYmF0Y2hFbmRUaW1lLCBkYXRhW2ldLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXS50eXBlID09PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgaGFzRnVsbFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcU5vID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0Z1bGxTbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtlcnJvcjogJ0ZpcnN0IGJhdGNoIGRvZXMgbm90IGNvbnRhaW4gYSBmdWxsIHNuYXBzaG90LiBBYm9ydGluZyByZWNvcmRpbmcuJ30pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignUmVwbGF5IHN0YXJ0IHRpbWUgbm90IHNldCBidXQgc2VxTm8gaXMgbm90IDAuIFVzaW5nIGN1cnJlbnQgYmF0Y2ggc3RhcnQgdGltZSBhcyBhIGZhbGxiYWNrLicpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBiYXRjaFN0YXJ0VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXBsYXlMZW5ndGhNcyA9IGJhdGNoRW5kVGltZSAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICdiYXRjaF9zdGFydF90aW1lJzogYmF0Y2hTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogU3RyaW5nKHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpKSxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlJZCxcbiAgICAgICAgICAgICdyZXBsYXlfbGVuZ3RoX21zJzogcmVwbGF5TGVuZ3RoTXMsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3RpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3VybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICAgICAnc2VxJzogdGhpcy5zZXFOb1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXZlbnRzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgICAgIC8vIHNlbmQgSUQgbWFuYWdlbWVudCBwcm9wcyBpZiB0aGV5IGV4aXN0XG4gICAgICAgIHZhciBkZXZpY2VJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snJGRldmljZV9pZCddID0gZGV2aWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICAgICAgcmVxUGFyYW1zWyckdXNlcl9pZCddID0gdXNlcklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbXByZXNzaW9uU3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIganNvblN0cmVhbSA9IG5ldyBCbG9iKFtldmVudHNKc29uXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pLnN0cmVhbSgpO1xuICAgICAgICAgICAgdmFyIGd6aXBTdHJlYW0gPSBqc29uU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZ3ppcCcpKTtcbiAgICAgICAgICAgIG5ldyBSZXNwb25zZShnemlwU3RyZWFtKVxuICAgICAgICAgICAgICAgIC5ibG9iKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihjb21wcmVzc2VkQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2d6aXAnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBjb21wcmVzc2VkQmxvYiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJ2Zvcm1hdCddID0gJ2JvZHknO1xuICAgICAgICAgICAgdGhpcy5fc2VuZFJlcXVlc3QocmVwbGF5SWQsIHJlcVBhcmFtcywgZXZlbnRzSnNvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQyLmVycm9yLmFwcGx5KGxvZ2dlciQyLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldENvbmZpZygnZXJyb3JfcmVwb3J0ZXInKShtc2csIGVycik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDIuZXJyb3IoZXJyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgaGFuZGxpbmcgdGhlIHN0b3JhZ2UgYW5kIHJldHJpZXZhbCBvZiByZWNvcmRpbmcgbWV0YWRhdGEgYXMgd2VsbCBhcyBhbnkgYWN0aXZlIHJlY29yZGluZ3MuXG4gKiBNYWtlcyBzdXJlIHRoYXQgb25seSBvbmUgdGFiIGNhbiBiZSByZWNvcmRpbmcgYXQgYSB0aW1lLlxuICovXG52YXIgUmVjb3JkaW5nUmVnaXN0cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuaWRiID0gbmV3IElEQlN0b3JhZ2VXcmFwcGVyKFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FKTtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5taXhwYW5lbEluc3RhbmNlID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuc2hhcmVkTG9ja1N0b3JhZ2UgPSBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlO1xufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMuZXJyb3JSZXBvcnRlcignSW5kZXhlZERCIGVycm9yOiAnLCBlcnIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlcmlhbGl6ZWRSZWNvcmRpbmd9IHNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqL1xuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLnNldEFjdGl2ZVJlY29yZGluZyA9IGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgdmFyIHRhYklkID0gc2VyaWFsaXplZFJlY29yZGluZ1sndGFiSWQnXTtcbiAgICBpZiAoIXRhYklkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gdGFiIElEIGlzIHNldCwgY2Fubm90IHBlcnNpc3QgcmVjb3JkaW5nIG1ldGFkYXRhLicpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYi5zZXRJdGVtKHRhYklkLCBzZXJpYWxpemVkUmVjb3JkaW5nKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL3Nlc3Npb24tcmVjb3JkaW5nJykuU2VyaWFsaXplZFJlY29yZGluZz59XG4gKi9cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRiLmluaXQoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIuZ2V0SXRlbSh0aGlzLm1peHBhbmVsSW5zdGFuY2UuZ2V0X3RhYl9pZCgpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVjb3JkaW5nRXhwaXJlZChzZXJpYWxpemVkUmVjb3JkaW5nKSA/IG51bGwgOiBzZXJpYWxpemVkUmVjb3JkaW5nO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xufTtcblxuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmNsZWFyQWN0aXZlUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1hcmsgcmVjb3JkaW5nIGFzIGV4cGlyZWQgaW5zdGVhZCBvZiBkZWxldGluZyBpdCBpbiBjYXNlIHRoZSBwYWdlIHVubG9hZHMgbWlkLWZsdXNoIGFuZCBkb2Vzbid0IG1ha2UgaXQgdG8gaW5nZXN0aW9uLlxuICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgdGhlIG5leHQgcGFnZWxvYWQgd2lsbCBmbHVzaCB0aGUgcmVtYWluaW5nIGV2ZW50cywgYnV0IG5vdCB0cnkgdG8gY29udGludWUgdGhlIHJlY29yZGluZy5cbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVSZWNvcmRpbmcoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkUmVjb3JkaW5nWydtYXhFeHBpcmVzJ10gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZVJlY29yZGluZyhzZXJpYWxpemVkUmVjb3JkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogRmx1c2ggYW55IGluYWN0aXZlIHJlY29yZGluZ3MgZnJvbSB0aGUgcmVnaXN0cnkgdG8gbWluaW1pemUgZGF0YSBsb3NzLlxuICogVGhlIG1haW4gaWRlYSBoZXJlIGlzIHRoYXQgd2UgY2FuIGZsdXNoIHJlbWFpbmluZyBycndlYiBldmVudHMgb24gdGhlIG5leHQgcGFnZSBsb2FkIGlmIGEgdGFiIGlzIGNsb3NlZCBtaWQtYmF0Y2guXG4gKi9cblJlY29yZGluZ1JlZ2lzdHJ5LnByb3RvdHlwZS5mbHVzaEluYWN0aXZlUmVjb3JkaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLmdldEFsbCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5ncykge1xuICAgICAgICAgICAgLy8gY2xlYW4gdXAgYW55IGV4cGlyZWQgcmVjb3JkaW5ncyBmcm9tIHRoZSByZWdpc3RyeSwgbm9uLWV4cGlyZWQgb25lcyBtYXkgYmUgYWN0aXZlIGluIG90aGVyIHRhYnNcbiAgICAgICAgICAgIHZhciB1bmxvYWRQcm9taXNlcyA9IHNlcmlhbGl6ZWRSZWNvcmRpbmdzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWNvcmRpbmdFeHBpcmVkKHNlcmlhbGl6ZWRSZWNvcmRpbmcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvblJlY29yZGluZyA9IFNlc3Npb25SZWNvcmRpbmcuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlY29yZGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5taXhwYW5lbEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IHRoaXMuc2hhcmVkTG9ja1N0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uUmVjb3JkaW5nLnVubG9hZFBlcnNpc3RlZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGlyZWQgcmVjb3JkaW5nIHdhcyBzdWNjZXNzZnVsbHkgZmx1c2hlZCwgd2UgY2FuIGNsZWFuIGl0IHVwIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLnJlbW92ZUl0ZW0oc2VyaWFsaXplZFJlY29yZGluZ1sndGFiSWQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLmFsbCh1bmxvYWRQcm9taXNlcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG59O1xuXG52YXIgbG9nZ2VyJDEgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xuXG4vKipcbiAqIFJlY29yZGVyIEFQSTogYnVuZGxlcyBycndlYiBhbmQgYW5kIGV4cG9zZXMgbWV0aG9kcyB0byBzdGFydCBhbmQgc3RvcCByZWNvcmRpbmdzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1peHBhbmVsSW5zdGFuY2VdIC0gcmVmZXJlbmNlIHRvIHRoZSBjb3JlIE1peHBhbmVsTGliXG4qL1xudmFyIE1peHBhbmVsUmVjb3JkZXIgPSBmdW5jdGlvbihtaXhwYW5lbEluc3RhbmNlLCBycndlYlJlY29yZCwgc2hhcmVkTG9ja1N0b3JhZ2UpIHtcbiAgICB0aGlzLm1peHBhbmVsSW5zdGFuY2UgPSBtaXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMucnJ3ZWJSZWNvcmQgPSBycndlYlJlY29yZCB8fCByZWNvcmQ7XG4gICAgdGhpcy5zaGFyZWRMb2NrU3RvcmFnZSA9IHNoYXJlZExvY2tTdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7aW1wb3J0KCcuL3JlZ2lzdHJ5JykuUmVjb3JkaW5nUmVnaXN0cnl9XG4gICAgICovXG4gICAgdGhpcy5yZWNvcmRpbmdSZWdpc3RyeSA9IG5ldyBSZWNvcmRpbmdSZWdpc3RyeSh7XG4gICAgICAgIG1peHBhbmVsSW5zdGFuY2U6IHRoaXMubWl4cGFuZWxJbnN0YW5jZSxcbiAgICAgICAgZXJyb3JSZXBvcnRlcjogbG9nZ2VyJDEuZXJyb3IsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBzaGFyZWRMb2NrU3RvcmFnZVxuICAgIH0pO1xuICAgIHRoaXMuX2ZsdXNoSW5hY3RpdmVQcm9taXNlID0gdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5mbHVzaEluYWN0aXZlUmVjb3JkaW5ncygpO1xuXG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBudWxsO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uSWRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlciQxLmxvZygnSWRsZSB0aW1lb3V0IHJlYWNoZWQsIHJlc3RhcnRpbmcgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLnJlc2V0UmVjb3JkaW5nKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIG9uTWF4TGVuZ3RoUmVhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyJDEubG9nKCdNYXggcmVjb3JkaW5nIGxlbmd0aCByZWFjaGVkLCBzdG9wcGluZyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMucmVzZXRSZWNvcmRpbmcoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgb25CYXRjaFNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuc2V0QWN0aXZlUmVjb3JkaW5nKHRoaXMuYWN0aXZlUmVjb3JkaW5nLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdGhpc1snX19mbHVzaFByb21pc2UnXSA9IHRoaXMuYWN0aXZlUmVjb3JkaW5nLmJhdGNoZXIuX2ZsdXNoUHJvbWlzZTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuL3Nlc3Npb24tcmVjb3JkaW5nJykuU2Vzc2lvblJlY29yZGluZ09wdGlvbnN9XG4gICAgICovXG4gICAgdmFyIHNlc3Npb25SZWNvcmRpbmdPcHRpb25zID0ge1xuICAgICAgICBtaXhwYW5lbEluc3RhbmNlOiB0aGlzLm1peHBhbmVsSW5zdGFuY2UsXG4gICAgICAgIG9uQmF0Y2hTZW50OiBvbkJhdGNoU2VudCxcbiAgICAgICAgb25JZGxlVGltZW91dDogb25JZGxlVGltZW91dCxcbiAgICAgICAgb25NYXhMZW5ndGhSZWFjaGVkOiBvbk1heExlbmd0aFJlYWNoZWQsXG4gICAgICAgIHJlcGxheUlkOiBfLlVVSUQoKSxcbiAgICAgICAgcnJ3ZWJSZWNvcmQ6IHRoaXMucnJ3ZWJSZWNvcmQsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiB0aGlzLnNoYXJlZExvY2tTdG9yYWdlXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBTZXNzaW9uUmVjb3JkaW5nLmRlc2VyaWFsaXplKG9wdGlvbnMuYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZywgc2Vzc2lvblJlY29yZGluZ09wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbmV3IFNlc3Npb25SZWNvcmRpbmcoc2Vzc2lvblJlY29yZGluZ09wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKG9wdGlvbnMuc2hvdWxkU3RvcEJhdGNoZXIpO1xuICAgIHJldHVybiB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LnNldEFjdGl2ZVJlY29yZGluZyh0aGlzLmFjdGl2ZVJlY29yZGluZy5zZXJpYWxpemUoKSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0b3BQcm9taXNlID0gdGhpcy5fc3RvcEN1cnJlbnRSZWNvcmRpbmcoZmFsc2UpO1xuICAgIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuY2xlYXJBY3RpdmVSZWNvcmRpbmcoKTtcbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG4gICAgcmV0dXJuIHN0b3BQcm9taXNlO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucGF1c2VSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcEN1cnJlbnRSZWNvcmRpbmcoZmFsc2UpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuX3N0b3BDdXJyZW50UmVjb3JkaW5nID0gZnVuY3Rpb24oc2tpcEZsdXNoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVJlY29yZGluZy5zdG9wUmVjb3JkaW5nKHNraXBGbHVzaCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUucmVzdW1lUmVjb3JkaW5nID0gZnVuY3Rpb24gKHN0YXJ0TmV3SWZJbmFjdGl2ZSkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiB0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0YXJ0UmVjb3JkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LmdldEFjdGl2ZVJlY29yZGluZygpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UmVjb3JkaW5nKHthY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nOiBhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0TmV3SWZJbmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UmVjb3JkaW5nKHtzaG91bGRTdG9wQmF0Y2hlcjogZmFsc2V9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEubG9nKCdObyByZXN1bWFibGUgcmVjb3JkaW5nIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xufTtcblxuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5yZXNldFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKHtzaG91bGRTdG9wQmF0Y2hlcjogdHJ1ZX0pO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuZ2V0QWN0aXZlUmVwbGF5SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmICF0aGlzLmFjdGl2ZVJlY29yZGluZy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVJlY29yZGluZy5yZXBsYXlJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBnZXR0ZXIgc28gdGhhdCBvbGRlciBtaXhwYW5lbC1jb3JlIHZlcnNpb25zIGNhbiBzdGlsbCByZXRyaWV2ZSB0aGUgcmVwbGF5IElEXG4vLyB3aGVuIHB1bGxpbmcgdGhlIGxhdGVzdCByZWNvcmRlciBidW5kbGUgZnJvbSB0aGUgQ0ROXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUsICdyZXBsYXlJZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlUmVwbGF5SWQoKTtcbiAgICB9XG59KTtcblxud2luWydfX21wX3JlY29yZGVyJ10gPSBNaXhwYW5lbFJlY29yZGVyO1xuXG4vLyBzdGF0ZWxlc3MgdXRpbHNcbi8vIG1vc3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9taXhwYW5lbC9taXhwYW5lbC1qcy9ibG9iLzk4OWFkYTUwZjUxOGVkYWI0N2I5YzRmZDk1MzVmOWZiZDVlYzVmYzAvc3JjL2F1dG90cmFjay11dGlscy5qc1xuXG5cbnZhciBFVl9DSEFOR0UgPSAnY2hhbmdlJztcbnZhciBFVl9DTElDSyA9ICdjbGljayc7XG52YXIgRVZfSEFTSENIQU5HRSA9ICdoYXNoY2hhbmdlJztcbnZhciBFVl9NUF9MT0NBVElPTl9DSEFOR0UgPSAnbXBfbG9jYXRpb25jaGFuZ2UnO1xudmFyIEVWX1BPUFNUQVRFID0gJ3BvcHN0YXRlJztcbi8vIFRPRE8gc2Nyb2xsZW5kIGlzbid0IGF2YWlsYWJsZSBpbiBTYWZhcmk6IGRvY3VtZW50IG9yIHBvbHlmaWxsP1xudmFyIEVWX1NDUk9MTEVORCA9ICdzY3JvbGxlbmQnO1xudmFyIEVWX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ0xJQ0tfRVZFTlRfUFJPUFMgPSBbXG4gICAgJ2NsaWVudFgnLCAnY2xpZW50WScsXG4gICAgJ29mZnNldFgnLCAnb2Zmc2V0WScsXG4gICAgJ3BhZ2VYJywgJ3BhZ2VZJyxcbiAgICAnc2NyZWVuWCcsICdzY3JlZW5ZJyxcbiAgICAneCcsICd5J1xuXTtcbnZhciBPUFRfSU5fQ0xBU1NFUyA9IFsnbXAtaW5jbHVkZSddO1xudmFyIE9QVF9PVVRfQ0xBU1NFUyA9IFsnbXAtbm8tdHJhY2snXTtcbnZhciBTRU5TSVRJVkVfREFUQV9DTEFTU0VTID0gT1BUX09VVF9DTEFTU0VTLmNvbmNhdChbJ21wLXNlbnNpdGl2ZSddKTtcbnZhciBUUkFDS0VEX0FUVFJTID0gW1xuICAgICdhcmlhLWxhYmVsJywgJ2FyaWEtbGFiZWxsZWRieScsICdhcmlhLWRlc2NyaWJlZGJ5JyxcbiAgICAnaHJlZicsICduYW1lJywgJ3JvbGUnLCAndGl0bGUnLCAndHlwZSdcbl07XG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdhdXRvY2FwdHVyZScpO1xuXG5cbmZ1bmN0aW9uIGdldENsYXNzZXMoZWwpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBjbGFzc0xpc3QgPSBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuLypcbiAqIEdldCB0aGUgY2xhc3NOYW1lIG9mIGFuIGVsZW1lbnQsIGFjY291bnRpbmcgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgZWxlbWVudC5jbGFzc05hbWUgaXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBnZXQgdGhlIGNsYXNzTmFtZSBvZlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGVsZW1lbnQncyBjbGFzc1xuICovXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgICBzd2l0Y2godHlwZW9mIGVsLmNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGNsYXNzTmFtZSBtaWdodCBiZSBTVkdBbmltYXRlZFN0cmluZyBvciBzb21lIG90aGVyIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGZ1dHVyZSBwcm9vZlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhlbCkge1xuICAgIGlmIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHJldHVybiBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChlbCAmJiAhaXNFbGVtZW50Tm9kZShlbCkpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBleHRyYUF0dHJzLCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICckY2xhc3Nlcyc6IGdldENsYXNzTmFtZShlbCkuc3BsaXQoJyAnKSxcbiAgICAgICAgJyR0YWdfbmFtZSc6IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgdmFyIGVsSWQgPSBlbC5pZDtcbiAgICBpZiAoZWxJZCkge1xuICAgICAgICBwcm9wc1snJGlkJ10gPSBlbElkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSkge1xuICAgICAgICBfLmVhY2goVFJBQ0tFRF9BVFRSUy5jb25jYXQoZXh0cmFBdHRycyksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikgJiYgIWJsb2NrQXR0cnNTZXRbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVHJhY2tWYWx1ZShhdHRyVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGF0dHItJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBudGhDaGlsZCA9IDE7XG4gICAgdmFyIG50aE9mVHlwZSA9IDE7XG4gICAgdmFyIGN1cnJlbnRFbGVtID0gZWw7XG4gICAgd2hpbGUgKGN1cnJlbnRFbGVtID0gZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhjdXJyZW50RWxlbSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBudGhDaGlsZCsrO1xuICAgICAgICBpZiAoY3VycmVudEVsZW0udGFnTmFtZSA9PT0gZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgbnRoT2ZUeXBlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHNbJyRudGhfY2hpbGQnXSA9IG50aENoaWxkO1xuICAgIHByb3BzWyckbnRoX29mX3R5cGUnXSA9IG50aE9mVHlwZTtcblxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcHNGb3JET01FdmVudChldiwgY29uZmlnKSB7XG4gICAgdmFyIGFsbG93RWxlbWVudENhbGxiYWNrID0gY29uZmlnLmFsbG93RWxlbWVudENhbGxiYWNrO1xuICAgIHZhciBhbGxvd1NlbGVjdG9ycyA9IGNvbmZpZy5hbGxvd1NlbGVjdG9ycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tBdHRycyA9IGNvbmZpZy5ibG9ja0F0dHJzIHx8IFtdO1xuICAgIHZhciBibG9ja0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5ibG9ja0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYmxvY2tTZWxlY3RvcnMgPSBjb25maWcuYmxvY2tTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGNhcHR1cmVUZXh0Q29udGVudCA9IGNvbmZpZy5jYXB0dXJlVGV4dENvbnRlbnQgfHwgZmFsc2U7XG4gICAgdmFyIGNhcHR1cmVFeHRyYUF0dHJzID0gY29uZmlnLmNhcHR1cmVFeHRyYUF0dHJzIHx8IFtdO1xuXG4gICAgLy8gY29udmVydCBhcnJheSB0byBzZXQgZXZlcnkgdGltZSwgYXMgdGhlIGNvbmZpZyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgdmFyIGJsb2NrQXR0cnNTZXQgPSB7fTtcbiAgICBfLmVhY2goYmxvY2tBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBibG9ja0F0dHJzU2V0W2F0dHJdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHZhciBwcm9wcyA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIGV2LnRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyBldi5zcmNFbGVtZW50IDogZXYudGFyZ2V0O1xuICAgIGlmIChpc1RleHROb2RlKHRhcmdldCkpIHsgLy8gZGVmZWF0IFNhZmFyaSBidWcgKHNlZTogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sKVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgIHNob3VsZFRyYWNrRG9tRXZlbnQodGFyZ2V0LCBldikgJiZcbiAgICAgICAgaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpICYmXG4gICAgICAgICFpc0VsZW1lbnRCbG9ja2VkKHRhcmdldCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycylcbiAgICApIHtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRMaXN0ID0gW3RhcmdldF07XG4gICAgICAgIHZhciBjdXJFbCA9IHRhcmdldDtcbiAgICAgICAgd2hpbGUgKGN1ckVsLnBhcmVudE5vZGUgJiYgIWlzVGFnKGN1ckVsLCAnYm9keScpKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50TGlzdC5wdXNoKGN1ckVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzSnNvbiA9IFtdO1xuICAgICAgICB2YXIgaHJlZiwgZXhwbGljaXROb1RyYWNrID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaCh0YXJnZXRFbGVtZW50TGlzdCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUcmFja0RldGFpbHMgPSBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgb3IgYSBwYXJlbnQgZWxlbWVudCBpcyBhbiBhbmNob3IgdGFnXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSBocmVmIGFzIGEgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFsnaHJlZiddICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIGhyZWYgPSBzaG91bGRUcmFja0RldGFpbHMgJiYgc2hvdWxkVHJhY2tWYWx1ZShocmVmKSAmJiBocmVmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdE5vVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50c0pzb24ucHVzaChnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQoZWwsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghZXhwbGljaXROb1RyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50JDFbJ2RvY3VtZW50RWxlbWVudCddO1xuICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgJyRldmVudF90eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICAnJGhvc3QnOiB3aW4ubG9jYXRpb24uaG9zdCxcbiAgICAgICAgICAgICAgICAnJHBhdGhuYW1lJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICckZWxlbWVudHMnOiAgZWxlbWVudHNKc29uLFxuICAgICAgICAgICAgICAgICckZWxfYXR0cl9faHJlZic6IGhyZWYsXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydEhlaWdodCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudEhlaWdodCddLCB3aW5bJ2lubmVySGVpZ2h0J10gfHwgMCksXG4gICAgICAgICAgICAgICAgJyR2aWV3cG9ydFdpZHRoJzogTWF0aC5tYXgoZG9jRWxlbWVudFsnY2xpZW50V2lkdGgnXSwgd2luWydpbm5lcldpZHRoJ10gfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfLmVhY2goY2FwdHVyZUV4dHJhQXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrQXR0cnNTZXRbYXR0cl0gJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRUcmFja1ZhbHVlKGF0dHJWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1snJGVsX2F0dHJfXycgKyBhdHRyXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUZXh0ID0gZ2V0U2FmZVRleHQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgJiYgZWxlbWVudFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfdGV4dCddID0gZWxlbWVudFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gRVZfQ0xJQ0spIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goQ0xJQ0tfRVZFTlRfUFJPUFMsIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckJyArIHByb3BdID0gZXZbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBndWVzc1JlYWxDbGlja1RhcmdldChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmlvcml0aXplIHRleHQgY29udGVudCBmcm9tIFwicmVhbFwiIGNsaWNrIHRhcmdldCBpZiBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChjYXB0dXJlVGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgbWF5IGhhdmUgYmVlbiByZWNhbGN1bGF0ZWQ7IGNoZWNrIGFsbG93bGlzdHMgYW5kIGJsb2NrbGlzdHMgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFpc0VsZW1lbnRBbGxvd2VkKHRhcmdldCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wcyA9IGdldFByb3BlcnRpZXNGcm9tRWxlbWVudCh0YXJnZXQsIGV2LCBibG9ja0F0dHJzU2V0LCBjYXB0dXJlRXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBwcm9wc1snJHRhcmdldCddID0gdGFyZ2V0UHJvcHM7XG4gICAgICAgICAgICAgICAgLy8gcHVsbCB1cCBtb3JlIHByb3BzIG9udG8gbWFpbiBldmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIHByb3BzWyckZWxfY2xhc3NlcyddID0gdGFyZ2V0UHJvcHNbJyRjbGFzc2VzJ107XG4gICAgICAgICAgICAgICAgXy5leHRlbmQocHJvcHMsIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgICAgICckZWxfaWQnOiB0YXJnZXRQcm9wc1snJGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICckZWxfdGFnX25hbWUnOiB0YXJnZXRQcm9wc1snJHRhZ19uYW1lJ11cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRpcmVjdCB0ZXh0IGNvbnRlbnQgb2YgYW4gZWxlbWVudCwgcHJvdGVjdGluZyBhZ2FpbnN0IHNlbnNpdGl2ZSBkYXRhIGNvbGxlY3Rpb24uXG4gKiBDb25jYXRzIHRleHRDb250ZW50IG9mIGVhY2ggb2YgdGhlIGVsZW1lbnQncyB0ZXh0IG5vZGUgY2hpbGRyZW47IHRoaXMgYXZvaWRzIHBvdGVudGlhbFxuICogY29sbGVjdGlvbiBvZiBzZW5zaXRpdmUgZGF0YSB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSB1c2VkIGVsZW1lbnQudGV4dENvbnRlbnQgYW5kIHRoZVxuICogZWxlbWVudCBoYWQgc2Vuc2l0aXZlIGNoaWxkIGVsZW1lbnRzLCBzaW5jZSBlbGVtZW50LnRleHRDb250ZW50IGluY2x1ZGVzIGNoaWxkIGNvbnRlbnQuXG4gKiBTY3J1YnMgdmFsdWVzIHRoYXQgbG9vayBsaWtlIHRoZXkgY291bGQgYmUgc2Vuc2l0aXZlIChpLmUuIGNjIG9yIHNzbiBudW1iZXIpLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSB0ZXh0IG9mXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFsbG93U2VsZWN0b3JzIC0gQ1NTIHNlbGVjdG9ycyBmb3IgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgZGlyZWN0IHRleHQgY29udGVudFxuICovXG5mdW5jdGlvbiBnZXRTYWZlVGV4dChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIHZhciBlbFRleHQgPSAnJztcblxuICAgIGlmIChzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJiBlbC5jaGlsZE5vZGVzICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChlbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY2hpbGQpICYmIGNoaWxkLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxUZXh0ICs9IF8udHJpbShjaGlsZC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NydWIgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcihzaG91bGRUcmFja1ZhbHVlKS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKS5yZXBsYWNlKC9bIF0rL2csICcgJylcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCAyNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy50cmltKGVsVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGd1ZXNzUmVhbENsaWNrVGFyZ2V0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICB2YXIgY29tcG9zZWRQYXRoID0gZXZbJ2NvbXBvc2VkUGF0aCddKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NlZFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdhJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdidXR0b24nKSB8fFxuICAgICAgICAgICAgaXNUYWcobm9kZSwgJ2lucHV0JykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdzZWxlY3QnKSB8fFxuICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdidXR0b24nKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRBbGxvd2VkKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgaWYgKGFsbG93RWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGFsbG93RWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWxsb3dTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIGFsbG93bGlzdDsgYWxsIGVsZW1lbnRzIGFyZSBmYWlyIGdhbWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gYWxsb3dTZWxlY3RvcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudEJsb2NrZWQoZWwsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmIChibG9ja0VsZW1lbnRDYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudENhbGxiYWNrKGVsLCBldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGVsZW1lbnQgaW4gYmxvY2tFbGVtZW50Q2FsbGJhY2snLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2tTZWxlY3RvcnMgJiYgYmxvY2tTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyB0aGF0IG1hdGNoIENTUyBzZWxlY3RvcnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsID0gYmxvY2tTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlbFsnbWF0Y2hlcyddKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IHVzZXJzIHRvIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyBieSBhZGRpbmcgZGVmYXVsdCBjbGFzc2VzIHN1Y2ggYXMgJ21wLW5vLXRyYWNrJ1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9PVVRfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2xhc3Nlc1tPUFRfT1VUX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBoYXMgbm9kZVR5cGUgTm9kZS5FTEVNRU5UX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdGhlIGNvcnJlY3Qgbm9kZVR5cGVcbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREUgLSB1c2UgaW50ZWdlciBjb25zdGFudCBmb3IgYnJvd3NlciBwb3J0YWJpbGl0eVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIG9mIGEgZ2l2ZW4gdGFnIHR5cGUuXG4gKiBEdWUgdG8gcG90ZW50aWFsIHJlZmVyZW5jZSBkaXNjcmVwYW5jaWVzIChzdWNoIGFzIHRoZSB3ZWJjb21wb25lbnRzLmpzIHBvbHlmaWxsKSxcbiAqIHdlIHdhbnQgdG8gbWF0Y2ggdGFnTmFtZXMgaW5zdGVhZCBvZiBzcGVjaWZpYyByZWZlcmVuY2VzIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2VcbiAqIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgd29uJ3QgYWx3YXlzIHdvcmsgYmVjYXVzZSBlbGVtZW50IG1pZ2h0IG5vdCBiZSBhIG5hdGl2ZVxuICogZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gdGFnIG5hbWUgKGUuZy4sIFwiZGl2XCIpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBlbCBpcyBvZiB0aGUgZ2l2ZW4gdGFnIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWwsIHRhZykge1xuICAgIHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIG5vZGUgaXMgYSBURVhUX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdHlwZSBOb2RlLlRFWFRfTk9ERVxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzOyAvLyBOb2RlLlRFWFRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbmZ1bmN0aW9uIG1pbkRPTUFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiAhIXRlc3RFbFsnbWF0Y2hlcyddO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBldmVudCBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IC0gZXZlbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0RvbUV2ZW50KGVsLCBldikge1xuICAgIGlmICghZWwgfHwgaXNUYWcoZWwsICdodG1sJykgfHwgIWlzRWxlbWVudE5vZGUoZWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9TVUJNSVQ7XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgIGlmIChbJ2J1dHRvbicsICdzdWJtaXQnXS5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0hBTkdFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DSEFOR0U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBlbGVtZW50IHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWlzRWxlbWVudEFsbG93ZWQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjdXJFbCA9IGVsOyBjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKTsgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjdXJFbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBTRU5TSVRJVkVfREFUQV9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1tTRU5TSVRJVkVfREFUQV9DTEFTU0VTW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbENsYXNzZXMgPSBnZXRDbGFzc2VzKGVsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgT1BUX0lOX0NMQVNTRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsQ2xhc3Nlc1tPUFRfSU5fQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc2VuZCBkYXRhIGZyb20gaW5wdXRzIG9yIHNpbWlsYXIgZWxlbWVudHMgc2luY2UgdGhlcmUgd2lsbCBhbHdheXMgYmVcbiAgICAvLyBhIHJpc2sgb2YgY2xpZW50c2lkZSBqYXZhc2NyaXB0IHBsYWNpbmcgc2Vuc2l0aXZlIGRhdGEgaW4gYXR0cmlidXRlc1xuICAgIGlmIChcbiAgICAgICAgaXNUYWcoZWwsICdpbnB1dCcpIHx8XG4gICAgICAgIGlzVGFnKGVsLCAnc2VsZWN0JykgfHxcbiAgICAgICAgaXNUYWcoZWwsICd0ZXh0YXJlYScpIHx8XG4gICAgICAgIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgaW5jbHVkZSBoaWRkZW4gb3IgcGFzc3dvcmQgZmllbGRzXG4gICAgdmFyIHR5cGUgPSBlbC50eXBlIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHsgLy8gaXQncyBwb3NzaWJsZSBmb3IgZWwudHlwZSB0byBiZSBhIERPTSBlbGVtZW50IGlmIGVsIGlzIGEgZm9ybSB3aXRoIGEgY2hpbGQgaW5wdXRbbmFtZT1cInR5cGVcIl1cbiAgICAgICAgc3dpdGNoKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBkYXRhIGZyb20gZmllbGRzIHRoYXQgbG9vayBsaWtlIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICB2YXIgbmFtZSA9IGVsLm5hbWUgfHwgZWwuaWQgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgeyAvLyBpdCdzIHBvc3NpYmxlIGZvciBlbC5uYW1lIG9yIGVsLmlkIHRvIGJlIGEgRE9NIGVsZW1lbnQgaWYgZWwgaXMgYSBmb3JtIHdpdGggYSBjaGlsZCBpbnB1dFtuYW1lPVwibmFtZVwiXVxuICAgICAgICB2YXIgc2Vuc2l0aXZlTmFtZVJlZ2V4ID0gL15jY3xjYXJkbnVtfGNjbnVtfGNyZWRpdGNhcmR8Y3NjfGN2Y3xjdnZ8ZXhwfHBhc3N8cHdkfHJvdXRpbmd8c2VjY29kZXxzZWN1cml0eWNvZGV8c2VjdXJpdHludW18c29jaWFsc2VjfHNvY3NlY3xzc24vaTtcbiAgICAgICAgaWYgKHNlbnNpdGl2ZU5hbWVSZWdleC50ZXN0KG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIHZhbHVlIHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlID0gXy50cmltKHZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIGNyZWRpdCBjYXJkIG51bWJlclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDRzMjAuaHRtbFxuICAgICAgICB2YXIgY2NSZWdleCA9IC9eKD86KDRbMC05XXsxMn0oPzpbMC05XXszfSk/KXwoNVsxLTVdWzAtOV17MTR9KXwoNig/OjAxMXw1WzAtOV17Mn0pWzAtOV17MTJ9KXwoM1s0N11bMC05XXsxM30pfCgzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX0pfCgoPzoyMTMxfDE4MDB8MzVbMC05XXszfSlbMC05XXsxMX0pKSQvO1xuICAgICAgICBpZiAoY2NSZWdleC50ZXN0KCh2YWx1ZSB8fCAnJykucmVwbGFjZSgvWy0gXS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIHNvY2lhbCBzZWN1cml0eSBudW1iZXJcbiAgICAgICAgdmFyIHNzblJlZ2V4ID0gLyheXFxkezN9LT9cXGR7Mn0tP1xcZHs0fSQpLztcbiAgICAgICAgaWYgKHNzblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIEFVVE9DQVBUVVJFX0NPTkZJR19LRVkgPSAnYXV0b2NhcHR1cmUnO1xudmFyIExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZID0gJ3RyYWNrX3BhZ2V2aWV3JztcblxudmFyIFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCA9ICdmdWxsLXVybCc7XG52YXIgUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyA9ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIID0gJ3VybC13aXRoLXBhdGgnO1xuXG52YXIgQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYWxsb3dfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0FMTE9XX1NFTEVDVE9SUyA9ICdhbGxvd19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19BTExPV19VUkxfUkVHRVhFUyA9ICdhbGxvd191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0JMT0NLX0FUVFJTID0gJ2Jsb2NrX2F0dHJzJztcbnZhciBDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyA9ICdibG9ja19lbGVtZW50X2NhbGxiYWNrJztcbnZhciBDT05GSUdfQkxPQ0tfU0VMRUNUT1JTID0gJ2Jsb2NrX3NlbGVjdG9ycyc7XG52YXIgQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTID0gJ2Jsb2NrX3VybF9yZWdleGVzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyA9ICdjYXB0dXJlX2V4dHJhX2F0dHJzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQgPSAnY2FwdHVyZV90ZXh0X2NvbnRlbnQnO1xudmFyIENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwgPSAnc2Nyb2xsX2NhcHR1cmVfYWxsJztcbnZhciBDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTID0gJ3Njcm9sbF9kZXB0aF9wZXJjZW50X2NoZWNrcG9pbnRzJztcbnZhciBDT05GSUdfVFJBQ0tfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19JTlBVVCA9ICdpbnB1dCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VWSUVXID0gJ3BhZ2V2aWV3JztcbnZhciBDT05GSUdfVFJBQ0tfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgQ09ORklHX1RSQUNLX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ09ORklHX0RFRkFVTFRTID0ge307XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0FMTE9XX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19CTE9DS19FTEVNRU5UX0NBTExCQUNLXSA9IG51bGw7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0JMT0NLX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfRVhUUkFfQVRUUlNdID0gW107XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTExdID0gZmFsc2U7XG5DT05GSUdfREVGQVVMVFNbQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UU10gPSBbMjUsIDUwLCA3NSwgMTAwXTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfSU5QVVRdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfUEFHRVZJRVddID0gUEFHRVZJRVdfT1BUSU9OX0ZVTExfVVJMO1xuQ09ORklHX0RFRkFVTFRTW0NPTkZJR19UUkFDS19TQ1JPTExdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfVFJBQ0tfU1VCTUlUXSA9IHRydWU7XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICAgICckbXBfYXV0b2NhcHR1cmUnOiB0cnVlXG59O1xuXG52YXIgTVBfRVZfQ0xJQ0sgPSAnJG1wX2NsaWNrJztcbnZhciBNUF9FVl9JTlBVVCA9ICckbXBfaW5wdXRfY2hhbmdlJztcbnZhciBNUF9FVl9TQ1JPTEwgPSAnJG1wX3Njcm9sbCc7XG52YXIgTVBfRVZfU1VCTUlUID0gJyRtcF9zdWJtaXQnO1xuXG4vKipcbiAqIEF1dG9jYXB0dXJlOiBtYW5hZ2VzIGF1dG9tYXRpYyBldmVudCB0cmFja2luZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBdXRvY2FwdHVyZSA9IGZ1bmN0aW9uKG1wKSB7XG4gICAgdGhpcy5tcCA9IG1wO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1pbkRPTUFwaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBsb2dnZXIuY3JpdGljYWwoJ0F1dG9jYXB0dXJlIHVuYXZhaWxhYmxlOiBtaXNzaW5nIHJlcXVpcmVkIERPTSBBUElzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRQYWdldmlld1RyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdElucHV0VHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRTY3JvbGxUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdFN1Ym1pdFRyYWNraW5nKCk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuZ2V0RnVsbENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdXRvY2FwdHVyZUNvbmZpZyA9IHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKTtcbiAgICBpZiAoIWF1dG9jYXB0dXJlQ29uZmlnKSB7XG4gICAgICAgIC8vIEF1dG9jYXB0dXJlIGlzIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXV0b2NhcHR1cmVDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTLCBhdXRvY2FwdHVyZUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0b2NhcHR1cmUgY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGdWxsQ29uZmlnKClba2V5XTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5jdXJyZW50VXJsQmxvY2tlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIHZhciBhbGxvd1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmIChhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlJ3JlIHVzaW5nIGFuIGFsbG93bGlzdCwgb25seSB0cmFjayBpZiBjdXJyZW50IFVSTCBtYXRjaGVzXG4gICAgICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxvd1VybFJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbGxvd1JlZ2V4ID0gYWxsb3dVcmxSZWdleGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChhbGxvd1JlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBhbGxvd1JlZ2V4LCBlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgLy8gd2Fzbid0IGFsbG93ZWQgYnkgYW55IHJlZ2V4XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBibG9ja1VybFJlZ2V4ZXMgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfVVJMX1JFR0VYRVMpIHx8IFtdO1xuICAgIGlmICghYmxvY2tVcmxSZWdleGVzIHx8ICFibG9ja1VybFJlZ2V4ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tVcmxSZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFVybC5tYXRjaChibG9ja1VybFJlZ2V4ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBibG9ja1VybFJlZ2V4ZXNbaV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUucGFnZXZpZXdUcmFja2luZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHN1cHBvcnRzIGJvdGggYXV0b2NhcHR1cmUgY29uZmlnIGFuZCBvbGQgdHJhY2tfcGFnZXZpZXcgY29uZmlnXG4gICAgaWYgKHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VWSUVXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tcC5nZXRfY29uZmlnKExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZKTtcbiAgICB9XG59O1xuXG4vLyBoZWxwZXIgZm9yIGV2ZW50IGhhbmRsZXJzXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUudHJhY2tEb21FdmVudCA9IGZ1bmN0aW9uKGV2LCBtcEV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIHtcbiAgICAgICAgYWxsb3dFbGVtZW50Q2FsbGJhY2s6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19FTEVNRU5UX0NBTExCQUNLKSxcbiAgICAgICAgYWxsb3dTZWxlY3RvcnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19TRUxFQ1RPUlMpLFxuICAgICAgICBibG9ja0F0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfQVRUUlMpLFxuICAgICAgICBibG9ja0VsZW1lbnRDYWxsYmFjazogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0spLFxuICAgICAgICBibG9ja1NlbGVjdG9yczogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1NFTEVDVE9SUyksXG4gICAgICAgIGNhcHR1cmVFeHRyYUF0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyksXG4gICAgICAgIGNhcHR1cmVUZXh0Q29udGVudDogdGhpcy5nZXRDb25maWcoQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UKVxuICAgIH0pO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBfLmV4dGVuZChwcm9wcywgREVGQVVMVF9QUk9QUyk7XG4gICAgICAgIHRoaXMubXAudHJhY2sobXBFdmVudE5hbWUsIHByb3BzKTtcbiAgICB9XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdENsaWNrVHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgdGhpcy5saXN0ZW5lckNsaWNrKTtcblxuICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ0luaXRpYWxpemluZyBjbGljayB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lckNsaWNrID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0xJQ0ssIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0NMSUNLKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfQ0xJQ0spO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdElucHV0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfSU5QVVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIGlucHV0IHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLmxpc3RlbmVyQ2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfQ0hBTkdFLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19JTlBVVCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrRG9tRXZlbnQoZXYsIE1QX0VWX0lOUFVUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRQYWdldmlld1RyYWNraW5nID0gZnVuY3Rpb24oKSB7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfUE9QU1RBVEUsIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgdGhpcy5saXN0ZW5lckhhc2hjaGFuZ2UpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlKTtcblxuICAgIGlmICghdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKCdJbml0aWFsaXppbmcgcGFnZXZpZXcgdHJhY2tpbmcnKTtcblxuICAgIHZhciBwcmV2aW91c1RyYWNrZWRVcmwgPSAnJztcbiAgICB2YXIgdHJhY2tlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgIHRyYWNrZWQgPSB0aGlzLm1wLnRyYWNrX3BhZ2V2aWV3KERFRkFVTFRfUFJPUFMpO1xuICAgIH1cbiAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICBwcmV2aW91c1RyYWNrZWRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgIH1cblxuICAgIHRoaXMubGlzdGVuZXJQb3BzdGF0ZSA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1BPUFNUQVRFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJIYXNoY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfSEFTSENIQU5HRSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICB9KTtcbiAgICB2YXIgbmF0aXZlUHVzaFN0YXRlID0gd2luLmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUHVzaFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUHVzaFN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBuYXRpdmVSZXBsYWNlU3RhdGUgPSB3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgaWYgKHR5cGVvZiBuYXRpdmVSZXBsYWNlU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICBuYXRpdmVSZXBsYWNlU3RhdGUuY2FsbCh3aW4uaGlzdG9yeSwgc3RhdGUsIHVudXNlZCwgdXJsKTtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lckxvY2F0aW9uY2hhbmdlID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpZFBhdGhDaGFuZ2UgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXSAhPT0gcHJldmlvdXNUcmFja2VkVXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXTtcbiAgICAgICAgdmFyIHRyYWNrUGFnZXZpZXdPcHRpb24gPSB0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKTtcbiAgICAgICAgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsICE9PSBwcmV2aW91c1RyYWNrZWRVcmw7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tQYWdldmlld09wdGlvbiA9PT0gUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORykge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBjdXJyZW50VXJsLnNwbGl0KCcjJylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIKSB7XG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGRpZFBhdGhDaGFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHZhciB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICAgICAgICAgIGlmICh0cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gY3VycmVudFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQYXRoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnUGF0aCBjaGFuZ2U6IHJlLWluaXRpYWxpemluZyBzY3JvbGwgZGVwdGggY2hlY2twb2ludHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTY3JvbGxUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHNjcm9sbCB0cmFja2luZycpO1xuICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSAwO1xuXG4gICAgdGhpcy5saXN0ZW5lclNjcm9sbCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1NDUk9MTCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXJsQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVHJhY2sgPSB0aGlzLmdldENvbmZpZyhDT05GSUdfU0NST0xMX0NBUFRVUkVfQUxMKTtcbiAgICAgICAgdmFyIHNjcm9sbENoZWNrcG9pbnRzID0gKHRoaXMuZ2V0Q29uZmlnKENPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFMpIHx8IFtdKVxuICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luLnNjcm9sbFk7XG4gICAgICAgIHZhciBwcm9wcyA9IF8uZXh0ZW5kKHsnJHNjcm9sbF90b3AnOiBzY3JvbGxUb3B9LCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudCQxLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSBNYXRoLnJvdW5kKChzY3JvbGxUb3AgLyAoc2Nyb2xsSGVpZ2h0IC0gd2luLmlubmVySGVpZ2h0KSkgKiAxMDApO1xuICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfaGVpZ2h0J10gPSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9wZXJjZW50YWdlJ10gPSBzY3JvbGxQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFBlcmNlbnRhZ2UgPiB0aGlzLmxhc3RTY3JvbGxDaGVja3BvaW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JvbGxDaGVja3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2twb2ludCA9IHNjcm9sbENoZWNrcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQZXJjZW50YWdlID49IGNoZWNrcG9pbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPCBjaGVja3BvaW50XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRzY3JvbGxfY2hlY2twb2ludCddID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSBjaGVja3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2FsY3VsYXRpbmcgc2Nyb2xsIHBlcmNlbnRhZ2UnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5tcC50cmFjayhNUF9FVl9TQ1JPTEwsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTdWJtaXRUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgdGhpcy5saXN0ZW5lclN1Ym1pdCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TVUJNSVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSW5pdGlhbGl6aW5nIHN1Ym1pdCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lclN1Ym1pdCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfU1VCTUlUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLy8gVE9ETyBpbnRlZ3JhdGUgZXJyb3JfcmVwb3J0ZXIgZnJvbSBtaXhwYW5lbCBpbnN0YW5jZVxuc2FmZXdyYXBDbGFzcyhBdXRvY2FwdHVyZSk7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuXG4vKipcbiAqIERvbVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERvbVRyYWNrZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8vIGludGVyZmFjZVxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5Eb21UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5tcCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPX0gdXNlcl9jYWxsYmFja1xuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uKHF1ZXJ5LCBldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCB1c2VyX2NhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBlbGVtZW50cyA9IF8uZG9tX3F1ZXJ5KHF1ZXJ5KTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdUaGUgRE9NIHF1ZXJ5ICgnICsgcXVlcnkgKyAnKSByZXR1cm5lZCAwIGVsZW1lbnRzJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgXy5yZWdpc3Rlcl9ldmVudChlbGVtZW50LCB0aGlzLm92ZXJyaWRlX2V2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhhdC5jcmVhdGVfcHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0aGlzKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhhdC5tcC5nZXRfY29uZmlnKCd0cmFja19saW5rc190aW1lb3V0Jyk7XG5cbiAgICAgICAgICAgIHRoYXQuZXZlbnRfaGFuZGxlcihlLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgbWl4cGFuZWwgc2VydmVycyBkb24ndCBnZXQgYmFjayB0byB1cyBpbiB0aW1lXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0cnVlKSwgdGltZW91dCk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIHRyYWNraW5nIGV2ZW50XG4gICAgICAgICAgICB0aGF0Lm1wLnRyYWNrKGV2ZW50X25hbWUsIHByb3BzLCB0aGF0LnRyYWNrX2NhbGxiYWNrKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHVzZXJfY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtib29sZWFuPX0gdGltZW91dF9vY2N1cmVkXG4gKi9cbkRvbVRyYWNrZXIucHJvdG90eXBlLnRyYWNrX2NhbGxiYWNrID0gZnVuY3Rpb24odXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCkge1xuICAgIHRpbWVvdXRfb2NjdXJlZCA9IHRpbWVvdXRfb2NjdXJlZCB8fCBmYWxzZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgaXMgcmVmZXJlbmNlZCBmcm9tIGJvdGggY2FsbGJhY2tzLCBzbyB3ZSBjYW4gaGF2ZVxuICAgICAgICAvLyBhICdsb2NrJyBvZiBzb3J0cyB0byBlbnN1cmUgb25seSBvbmUgZmlyZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2tfZmlyZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh1c2VyX2NhbGxiYWNrICYmIHVzZXJfY2FsbGJhY2sodGltZW91dF9vY2N1cmVkLCBwcm9wcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyB1c2VyIGNhbiBwcmV2ZW50IHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgYnlcbiAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSBmcm9tIHRoZWlyIGNhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmFmdGVyX3RyYWNrX2hhbmRsZXIocHJvcHMsIG9wdGlvbnMsIHRpbWVvdXRfb2NjdXJlZCk7XG4gICAgfTtcbn07XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcztcblxuICAgIGlmICh0eXBlb2YocHJvcGVydGllcykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wZXJ0aWVzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbi8qKlxuICogTGlua1RyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIExpbmtUcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdjbGljayc7XG59O1xuXy5pbmhlcml0KExpbmtUcmFja2VyLCBEb21UcmFja2VyKTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydGllcywgZWxlbWVudCkge1xuICAgIHZhciBwcm9wcyA9IExpbmtUcmFja2VyLnN1cGVyY2xhc3MuY3JlYXRlX3Byb3BlcnRpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmIChlbGVtZW50LmhyZWYpIHsgcHJvcHNbJ3VybCddID0gZWxlbWVudC5ocmVmOyB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMubmV3X3RhYiA9IChcbiAgICAgICAgZXZ0LndoaWNoID09PSAyIHx8XG4gICAgICAgIGV2dC5tZXRhS2V5IHx8XG4gICAgICAgIGV2dC5jdHJsS2V5IHx8XG4gICAgICAgIGVsZW1lbnQudGFyZ2V0ID09PSAnX2JsYW5rJ1xuICAgICk7XG4gICAgb3B0aW9ucy5ocmVmID0gZWxlbWVudC5ocmVmO1xuXG4gICAgaWYgKCFvcHRpb25zLm5ld190YWIpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm5ld190YWIpIHsgcmV0dXJuOyB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBvcHRpb25zLmhyZWY7XG4gICAgfSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcm1UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBGb3JtVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnc3VibWl0Jztcbn07XG5fLmluaGVyaXQoRm9ybVRyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuZXZlbnRfaGFuZGxlciA9IGZ1bmN0aW9uKGV2dCwgZWxlbWVudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG5Gb3JtVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb3B0aW9ucy5lbGVtZW50LnN1Ym1pdCgpO1xuICAgIH0sIDApO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG5cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9BQ1RJT04gICAgICA9ICckc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX0FDVElPTiA9ICckc2V0X29uY2UnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfQUNUSU9OICAgID0gJyR1bnNldCc7XG4vKiogQGNvbnN0ICovIHZhciBBRERfQUNUSU9OICAgICAgPSAnJGFkZCc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfQUNUSU9OICAgPSAnJGFwcGVuZCc7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9BQ1RJT04gICAgPSAnJHVuaW9uJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFTU9WRV9BQ1RJT04gICA9ICckcmVtb3ZlJztcbi8qKiBAY29uc3QgKi8gdmFyIERFTEVURV9BQ1RJT04gICA9ICckZGVsZXRlJztcblxuLy8gQ29tbW9uIGludGVybmFsIG1ldGhvZHMgZm9yIG1peHBhbmVsLnBlb3BsZSBhbmQgbWl4cGFuZWwuZ3JvdXAgQVBJcy5cbi8vIFRoZXNlIG1ldGhvZHMgc2hvdWxkbid0IGludm9sdmUgbmV0d29yayBJL08uXG52YXIgYXBpQWN0aW9ucyA9IHtcbiAgICBzZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldFtwcm9wXSA9IHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtTRVRfQUNUSU9OXSA9ICRzZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bnNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bnNldCA9IFtdO1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgcHJvcCA9IFtwcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgJHVuc2V0LnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGRhdGFbVU5TRVRfQUNUSU9OXSA9ICR1bnNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHNldF9vbmNlX2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXRfb25jZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXRfb25jZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0X29uY2VbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1NFVF9PTkNFX0FDVElPTl0gPSAkc2V0X29uY2U7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICB1bmlvbl9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5pb24gPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHVuaW9uW2tdID0gXy5pc0FycmF5KHYpID8gdiA6IFt2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR1bmlvbltsaXN0X25hbWVdID0gXy5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1VOSU9OX0FDVElPTl0gPSAkdW5pb247XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBhcHBlbmRfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkYXBwZW5kID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRhcHBlbmRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFwcGVuZFtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtBUFBFTkRfQUNUSU9OXSA9ICRhcHBlbmQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICByZW1vdmVfYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkcmVtb3ZlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICRyZW1vdmVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJlbW92ZVtsaXN0X25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtSRU1PVkVfQUNUSU9OXSA9ICRyZW1vdmU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBkZWxldGVfYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtERUxFVEVfQUNUSU9OXSA9ICcnO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgR3JvdXAgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsR3JvdXAgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbEdyb3VwLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UsIGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHRoaXMuX2dyb3VwX2tleSA9IGdyb3VwX2tleTtcbiAgICB0aGlzLl9ncm91cF9pZCA9IGdyb3VwX2lkO1xufTtcblxuLyoqXG4gKiBTZXQgcHJvcGVydGllcyBvbiBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0KCdMb2NhdGlvbicsICc0MDUgSG93YXJkJyk7XG4gKlxuICogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuICogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgZ3JvdXAgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiAqIGdyb3VwLnNldCgpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2UoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldF9vbmNlKHtcbiAqICAgICAgICAgICdMb2NhdGlvbic6ICc0MDUgSG93YXJkJyxcbiAqICAgICAgICAgICdGb3VuZGVkJyA6IDIwMDksXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGxpc3RzIG9yIGRhdGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9vbmNlX2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAgcGVybWFuZW50bHkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bnNldCgnRm91bmRlZCcpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBncm91cCBwcm9wZXJ0eSwgZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykudW5pb24oJ0xvY2F0aW9uJywgWydTYW4gRnJhbmNpc2NvJywgJ0xvbmRvbiddKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdF9uYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFBlcm1hbmVudGx5IGRlbGV0ZSBhIGdyb3VwLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuZGVsZXRlKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAvLyBicmFja2V0IG5vdGF0aW9uIGFib3ZlIHByZXZlbnRzIGEgbWluaWZpY2F0aW9uIGVycm9yIHJlbGF0ZWQgdG8gcmVzZXJ2ZWQgd29yZHNcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGVsZXRlX2FjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgZnJvbSBhIGdyb3VwLiBUaGUgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGlmIGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5yZW1vdmUoJ0xvY2F0aW9uJywgJ0xvbmRvbicpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gcmVtb3ZlIGZyb20gdGhlIGdpdmVuIGdyb3VwIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyRncm91cF9rZXknXSA9IHRoaXMuX2dyb3VwX2tleTtcbiAgICBkYXRhWyckZ3JvdXBfaWQnXSA9IHRoaXMuX2dyb3VwX2lkO1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdncm91cHMnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX2dldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyAgdGhpcy5fZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWydncm91cHMnXSxcbiAgICAgICAgYmF0Y2hlcjogdGhpcy5fbWl4cGFuZWwucmVxdWVzdF9iYXRjaGVycy5ncm91cHNcbiAgICB9LCBjYWxsYmFjayk7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5faXNfcmVzZXJ2ZWRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICckZ3JvdXBfa2V5JyB8fCBwcm9wID09PSAnJGdyb3VwX2lkJztcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmYpO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcuZ3JvdXAuJyArIHRoaXMuX2dyb3VwX2tleSArICcuJyArIHRoaXMuX2dyb3VwX2lkO1xufTtcblxuLy8gTWl4cGFuZWxHcm91cCBFeHBvcnRzXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsncmVtb3ZlJ10gICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydzZXQnXSAgICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldF9vbmNlJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZTtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bmlvbiddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5pb247XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndW5zZXQnXSAgICA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuc2V0O1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZztcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKipcbiAqIE1peHBhbmVsIFBlb3BsZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZW9wbGUgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG59O1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KCdnZW5kZXInLCAnbScpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCh7XG4qICAgICAgICAgJ0NvbXBhbnknOiAnQWNtZScsXG4qICAgICAgICAgJ1BsYW4nOiAnUHJlbWl1bScsXG4qICAgICAgICAgJ1VwZ3JhZGUgZGF0ZSc6IG5ldyBEYXRlKClcbiogICAgIH0pO1xuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSByZWZlcnJlciBpbmZvIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIHNhdmVkXG4gICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudC5yZWZlcnJlcik7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlICRzZXQgb2JqZWN0IHdpdGggZGVmYXVsdCBwZW9wbGUgcHJvcGVydGllc1xuICAgIGRhdGFbU0VUX0FDVElPTl0gPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wZW9wbGVfcHJvcGVydGllcygpLFxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgcGVvcGxlIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4qIHBlb3BsZS5zZXQoKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKCdGaXJzdCBMb2dpbiBEYXRlJywgbmV3IERhdGUoKSk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2Uoe1xuKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKSxcbiogICAgICAgICAnU3RhcnRpbmcgUGxhbic6ICdQcmVtaXVtJ1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycyBvciBkYXRlc1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQgKHBlcm1hbmVudGx5IHJlbW92ZXMgdGhlIHByb3BlcnRpZXMgYW5kIHRoZWlyIHZhbHVlcyBmcm9tIGEgcHJvZmlsZSkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldCgnZ2VuZGVyJyk7XG4qXG4qICAgICAvLyBvciB1bnNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldChbJ2dlbmRlcicsICdDb21wYW55J10pO1xuKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIGFycmF5LCB0aGlzIGlzIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBJbmNyZW1lbnQvZGVjcmVtZW50IG51bWVyaWMgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0aWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJywgMSk7XG4qXG4qICAgICAvLyBvciwgZm9yIGNvbnZlbmllbmNlLCBpZiB5b3UncmUganVzdCBpbmNyZW1lbnRpbmcgYSBjb3VudGVyIGJ5XG4qICAgICAvLyAxLCB5b3UgY2FuIHNpbXBseSBkb1xuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycpO1xuKlxuKiAgICAgLy8gdG8gZGVjcmVtZW50IGEgY291bnRlciwgcGFzcyBhIG5lZ2F0aXZlIG51bWJlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgnY3JlZGl0c19sZWZ0JywgLTEpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gaW5jcmVtZW50IG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KHtcbiogICAgICAgICBjb3VudGVyMTogMSxcbiogICAgICAgICBjb3VudGVyMjogNlxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgbnVtZXJpYyB2YWx1ZXMuXG4qIEBwYXJhbSB7TnVtYmVyfSBbYnldIEFuIGFtb3VudCB0byBpbmNyZW1lbnQgdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgYnksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgJGFkZCA9IHt9O1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBpbmNyZW1lbnQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkYWRkW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjYWxsYmFjayA9IGJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlbmllbmNlOiBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwcm9wZXJ0eScpOyB3aWxsXG4gICAgICAgIC8vIGluY3JlbWVudCAncHJvcGVydHknIGJ5IDFcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoYnkpKSB7XG4gICAgICAgICAgICBieSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgJGFkZFtwcm9wXSA9IGJ5O1xuICAgIH1cbiAgICBkYXRhW0FERF9BQ1RJT05dID0gJGFkZDtcblxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gYXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCh7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgQW4gaXRlbSB0byBhcHBlbmQgdG8gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuYXBwZW5kID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLmFwcGVuZF9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogUmVtb3ZlIGEgdmFsdWUgZnJvbSBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5yZW1vdmUoJ1NjaG9vbCcsICdVQ0InKTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogTWVyZ2UgYSBnaXZlbiBsaXN0IHdpdGggYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LFxuKiBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gbWVyZ2UgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6ICdib2InLFxuKiAgICAgICAgIGxpc3QyOiAxMjNcbiogICAgIH0pO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyB2YWx1ZXMgdG8gdGhlIHNhbWUgbGlzdDpcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbih7XG4qICAgICAgICAgbGlzdDE6IFsnYm9iJywgJ2JpbGx5J11cbiogICAgIH0pO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gVmFsdWUgLyB2YWx1ZXMgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5pb24gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4gKiBSZWNvcmQgdGhhdCB5b3UgaGF2ZSBjaGFyZ2VkIHRoZSBjdXJyZW50IHVzZXIgYSBjZXJ0YWluIGFtb3VudFxuICogb2YgbW9uZXkuIENoYXJnZXMgcmVjb3JkZWQgd2l0aCB0cmFja19jaGFyZ2UoKSB3aWxsIGFwcGVhciBpbiB0aGVcbiAqIE1peHBhbmVsIHJldmVudWUgcmVwb3J0LlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkNTBcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDUwKTtcbiAqXG4gKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkMzAuNTAgb24gdGhlIDJuZCBvZiBqYW51YXJ5XG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSgzMC41MCwge1xuICogICAgICAgICAnJHRpbWUnOiBuZXcgRGF0ZSgnamFuIDEgMjAxMicpXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIG1vbmV5IGNoYXJnZWQgdG8gdGhlIGN1cnJlbnQgdXNlclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhcmdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlc3BvbmRzXG4gKiBAZGVwcmVjYXRlZFxuICovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihhbW91bnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKGFtb3VudCkpIHtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdChhbW91bnQpO1xuICAgICAgICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlIC0gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKCckdHJhbnNhY3Rpb25zJywgXy5leHRlbmQoe1xuICAgICAgICAnJGFtb3VudCc6IGFtb3VudFxuICAgIH0sIHByb3BlcnRpZXMpLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFBlcm1hbmVudGx5IGNsZWFyIGFsbCByZXZlbnVlIHJlcG9ydCB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcbiAqIGN1cnJlbnQgdXNlcidzIHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLnBlb3BsZS5jbGVhcl9jaGFyZ2VzKCk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJyR0cmFuc2FjdGlvbnMnLCBbXSwgY2FsbGJhY2spO1xufTtcblxuLypcbiogUGVybWFuZW50bHkgZGVsZXRlcyB0aGUgY3VycmVudCBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUgZnJvbVxuKiBNaXhwYW5lbCAodXNpbmcgdGhlIGN1cnJlbnQgZGlzdGluY3RfaWQpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyByZW1vdmUgdGhlIGFsbCBkYXRhIHlvdSBoYXZlIHN0b3JlZCBhYm91dCB0aGUgY3VycmVudCB1c2VyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKTtcbipcbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignbWl4cGFuZWwucGVvcGxlLmRlbGV0ZV91c2VyKCkgcmVxdWlyZXMgeW91IHRvIGNhbGwgaWRlbnRpZnkoKSBmaXJzdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkYXRhID0geyckZGVsZXRlJzogdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCl9O1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSk7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwudG9TdHJpbmcoKSArICcucGVvcGxlJztcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fc2VuZF9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBkYXRhWyckdG9rZW4nXSA9IHRoaXMuX2dldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgZGF0YVsnJGRpc3RpbmN0X2lkJ10gPSB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB2YXIgZGV2aWNlX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJyk7XG4gICAgdmFyIHVzZXJfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgdmFyIGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJyk7XG4gICAgaWYgKGRldmljZV9pZCkge1xuICAgICAgICBkYXRhWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VfaWQ7XG4gICAgfVxuICAgIGlmICh1c2VyX2lkKSB7XG4gICAgICAgIGRhdGFbJyR1c2VyX2lkJ10gPSB1c2VyX2lkO1xuICAgIH1cbiAgICBpZiAoaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCkge1xuICAgICAgICBkYXRhWyckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCddID0gaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZDtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZV9lbmNvZGVkX2RhdGEgPSBfLmVuY29kZURhdGVzKGRhdGEpO1xuXG4gICAgaWYgKCF0aGlzLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9lbnF1ZXVlKGRhdGEpO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygndmVyYm9zZScpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogLTEsIGVycm9yOiBudWxsfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXy50cnVuY2F0ZShkYXRlX2VuY29kZWRfZGF0YSwgMjU1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ3Blb3BsZScsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2VuZ2FnZSddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLnBlb3BsZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZfdmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZl92YXIpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pZGVudGlmeV9jYWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9PT0gdHJ1ZTtcbn07XG5cbi8vIFF1ZXVlIHVwIGVuZ2FnZSBvcGVyYXRpb25zIGlmIGlkZW50aWZ5IGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2VucXVldWUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKFNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFNFVF9PTkNFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTlNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQUREX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQVBQRU5EX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoUkVNT1ZFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5JT05fQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgY2FsbCB0byBfZW5xdWV1ZSgpOicsIGRhdGEpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2hfb25lX3F1ZXVlID0gZnVuY3Rpb24oYWN0aW9uLCBhY3Rpb25fbWV0aG9kLCBjYWxsYmFjaywgcXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcXVldWVkX2RhdGEgPSBfLmV4dGVuZCh7fSwgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShhY3Rpb24pKTtcbiAgICB2YXIgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlZF9kYXRhO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHF1ZXVlZF9kYXRhKSAmJiBfLmlzT2JqZWN0KHF1ZXVlZF9kYXRhKSAmJiAhXy5pc0VtcHR5T2JqZWN0KHF1ZXVlZF9kYXRhKSkge1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgaWYgKHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgICAgICAgICAgYWN0aW9uX3BhcmFtcyA9IHF1ZXVlX3RvX3BhcmFtc19mbihxdWV1ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uX21ldGhvZC5jYWxsKF90aGlzLCBhY3Rpb25fcGFyYW1zLCBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgLy8gb24gYmFkIHJlc3BvbnNlLCB3ZSB3YW50IHRvIGFkZCBpdCBiYWNrIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLy8gRmx1c2ggcXVldWVkIGVuZ2FnZSBvcGVyYXRpb25zIC0gb3JkZXIgZG9lcyBub3QgbWF0dGVyLFxuLy8gYW5kIHRoZXJlIGFyZSBuZXR3b3JrIGxldmVsIHJhY2UgY29uZGl0aW9ucyBhbnl3YXlcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihcbiAgICBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9BQ1RJT04sIHRoaXMuc2V0LCBfc2V0X2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCB0aGlzLnNldF9vbmNlLCBfc2V0X29uY2VfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHRoaXMudW5zZXQsIF91bnNldF9jYWxsYmFjaywgZnVuY3Rpb24ocXVldWUpIHsgcmV0dXJuIF8ua2V5cyhxdWV1ZSk7IH0pO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShBRERfQUNUSU9OLCB0aGlzLmluY3JlbWVudCwgX2FkZF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOSU9OX0FDVElPTiwgdGhpcy51bmlvbiwgX3VuaW9uX2NhbGxiYWNrKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gZmlyZSBvZmYgZWFjaCAkYXBwZW5kIGluZGl2aWR1YWxseSBzaW5jZSB0aGVyZSBpc1xuICAgIC8vIG5vIGNvbmNhdCBtZXRob2Qgc2VydmVyIHNpZGVcbiAgICB2YXIgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRhcHBlbmRfcXVldWUpICYmIF8uaXNBcnJheSgkYXBwZW5kX3F1ZXVlKSAmJiAkYXBwZW5kX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJGFwcGVuZF9pdGVtO1xuICAgICAgICB2YXIgYXBwZW5kX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCAkYXBwZW5kX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9hcHBlbmRfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX2FwcGVuZF9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAkYXBwZW5kX3F1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICAgICAgICAgICRhcHBlbmRfaXRlbSA9ICRhcHBlbmRfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJGFwcGVuZF9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFwcGVuZCgkYXBwZW5kX2l0ZW0sIGFwcGVuZF9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW1lIGZvciAkcmVtb3ZlXG4gICAgdmFyICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkcmVtb3ZlX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJHJlbW92ZV9xdWV1ZSkgJiYgJHJlbW92ZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRyZW1vdmVfaXRlbTtcbiAgICAgICAgdmFyIHJlbW92ZV9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgJHJlbW92ZV9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfcmVtb3ZlX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBqID0gJHJlbW92ZV9xdWV1ZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgICAgICAgICAkcmVtb3ZlX2l0ZW0gPSAkcmVtb3ZlX3F1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnNhdmUoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRyZW1vdmVfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUoJHJlbW92ZV9pdGVtLCByZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRkaXN0aW5jdF9pZCcgfHwgcHJvcCA9PT0gJyR0b2tlbicgfHwgcHJvcCA9PT0gJyRkZXZpY2VfaWQnIHx8IHByb3AgPT09ICckdXNlcl9pZCcgfHwgcHJvcCA9PT0gJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJztcbn07XG5cbi8vIE1peHBhbmVsUGVvcGxlIEV4cG9ydHNcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0J10gICAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0X29uY2UnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bnNldCddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2luY3JlbWVudCddICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2FwcGVuZCddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3JlbW92ZSddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3VuaW9uJ10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndHJhY2tfY2hhcmdlJ10gID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnY2xlYXJfY2hhcmdlcyddID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXM7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2RlbGV0ZV91c2VyJ10gICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlcjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vKiogQGNvbnN0ICovIHZhciBTRVRfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBzJztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX1FVRVVFX0tFWSAgICAgPSAnX19tcHNvJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHVzJztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcGEnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX1FVRVVFX0tFWSAgICAgICA9ICdfX21wYXAnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX1FVRVVFX0tFWSAgICAgICA9ICdfX21wcic7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1Jztcbi8vIFRoaXMga2V5IGlzIGRlcHJlY2F0ZWQsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBpdCB0byBzZWUgd2hldGhlciBhbGlhc2luZyBpcyBhbGxvd2VkLlxuLyoqIEBjb25zdCAqLyB2YXIgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSA9ICckcGVvcGxlX2Rpc3RpbmN0X2lkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFMSUFTX0lEX0tFWSAgICAgICAgICAgPSAnX19hbGlhcyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBFVkVOVF9USU1FUlNfS0VZXG5dO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlcnNpc3RlbmNlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlcnNpc3RlbmNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xuICAgIHRoaXMuY2FtcGFpZ25fcGFyYW1zX3NhdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sndG9rZW4nXSArICdfbWl4cGFuZWwnO1xuICAgIH1cblxuICAgIHZhciBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ107XG4gICAgaWYgKHN0b3JhZ2VfdHlwZSAhPT0gJ2Nvb2tpZScgJiYgc3RvcmFnZV90eXBlICE9PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgdGhpcy5sb2FkKCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHJlc2VydmVkIHByb3BlcnRpZXNcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoIV8uaW5jbHVkZShSRVNFUlZFRF9QUk9QRVJUSUVTLCBrKSkge1xuICAgICAgICAgICAgcFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuc3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbJ3Byb3BzJ10gPSBfLmV4dGVuZCh7fSwgZW50cnkpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkX2Nvb2tpZSxcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZTtcblxuICAgIC8vIGlmIHRyYW5zZmVycmluZyBmcm9tIGNvb2tpZSB0byBsb2NhbFN0b3JhZ2Ugb3IgdmljZS12ZXJzYSwgY29weSBleGlzdGluZ1xuICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgb3ZlciB0byBuZXcgc3RvcmFnZSBtb2RlXG4gICAgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgb2xkX2Nvb2tpZSA9IF8uY29va2llLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSk7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChvbGRfY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2Nvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5jb29raWUpIHtcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgaWYgKG9sZF9sb2NhbHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfbG9jYWxzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgSlNPTlN0cmluZ2lmeSh0aGlzWydwcm9wcyddKSxcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyxcbiAgICAgICAgdGhpcy5jcm9zc19zdWJkb21haW4sXG4gICAgICAgIHRoaXMuc2VjdXJlLFxuICAgICAgICB0aGlzLmNyb3NzX3NpdGUsXG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpblxuICAgICk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5sb2FkX3Byb3AgPSBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcmVtb3ZlIGJvdGggZG9tYWluIGFuZCBzdWJkb21haW4gY29va2llc1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCBmYWxzZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbn07XG5cbi8vIHJlbW92ZXMgdGhlIHN0b3JhZ2UgZW50cnkgYW5kIGRlbGV0ZXMgYWxsIGxvYWRlZCBkYXRhXG4vLyBmb3JjZWQgbmFtZSBmb3IgdGVzdHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7Kj19IGRlZmF1bHRfdmFsdWVcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7IGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7IH1cbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuXG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbJ3Byb3BzJ10uaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpc1sncHJvcHMnXVtwcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3Byb3BzJ11bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICBfLmV4dGVuZCh0aGlzWydwcm9wcyddLCBwcm9wcyk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIGlmIChwcm9wIGluIHRoaXNbJ3Byb3BzJ10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bcHJvcF07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZCA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgdGhpcy5yZWdpc3RlcihfLmluZm8uc2VhcmNoSW5mbyhyZWZlcnJlcikpO1xufTtcblxuLy8gRVhQT1JURUQgTUVUSE9ELCB3ZSB0ZXN0IHRoaXMgZGlyZWN0bHkuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgLy8gSWYgcmVmZXJyZXIgZG9lc24ndCBleGlzdCwgd2Ugd2FudCB0byBub3RlIHRoZSBmYWN0IHRoYXQgaXQgd2FzIHR5cGUtaW4gdHJhZmZpYy5cbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiByZWZlcnJlciB8fCAnJGRpcmVjdCcsXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihyZWZlcnJlcikgfHwgJyRkaXJlY3QnXG4gICAgfSwgJycpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyZXInXSxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJ11cbiAgICB9KTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRfZXhwaXJ5ID0gdGhpcy5leHBpcmVfZGF5cyA9IGNvbmZpZ1snY29va2llX2V4cGlyYXRpb24nXTtcbiAgICB0aGlzLnNldF9kaXNhYmxlZChjb25maWdbJ2Rpc2FibGVfcGVyc2lzdGVuY2UnXSk7XG4gICAgdGhpcy5zZXRfY29va2llX2RvbWFpbihjb25maWdbJ2Nvb2tpZV9kb21haW4nXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc2l0ZShjb25maWdbJ2Nyb3NzX3NpdGVfY29va2llJ10pO1xuICAgIHRoaXMuc2V0X2Nyb3NzX3N1YmRvbWFpbihjb25maWdbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfc2VjdXJlKGNvbmZpZ1snc2VjdXJlX2Nvb2tpZSddKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9kaXNhYmxlZCA9IGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nvb2tpZV9kb21haW4gPSBmdW5jdGlvbihjb29raWVfZG9tYWluKSB7XG4gICAgaWYgKGNvb2tpZV9kb21haW4gIT09IHRoaXMuY29va2llX2RvbWFpbikge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW4gPSBjb29raWVfZG9tYWluO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY3Jvc3Nfc2l0ZSA9IGZ1bmN0aW9uKGNyb3NzX3NpdGUpIHtcbiAgICBpZiAoY3Jvc3Nfc2l0ZSAhPT0gdGhpcy5jcm9zc19zaXRlKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSA9IGNyb3NzX3NpdGU7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zdWJkb21haW4gPSBmdW5jdGlvbihjcm9zc19zdWJkb21haW4pIHtcbiAgICBpZiAoY3Jvc3Nfc3ViZG9tYWluICE9PSB0aGlzLmNyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbiA9IGNyb3NzX3N1YmRvbWFpbjtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNyb3NzX3N1YmRvbWFpbjtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9zZWN1cmUgPSBmdW5jdGlvbihzZWN1cmUpIHtcbiAgICBpZiAoc2VjdXJlICE9PSB0aGlzLnNlY3VyZSkge1xuICAgICAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2FkZF90b19wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxX2tleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpLFxuICAgICAgICBxX2RhdGEgPSBkYXRhW3F1ZXVlXSxcbiAgICAgICAgc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9BQ1RJT04pLFxuICAgICAgICBzZXRfb25jZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04pLFxuICAgICAgICB1bnNldF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShVTlNFVF9BQ1RJT04pLFxuICAgICAgICBhZGRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoQUREX0FDVElPTiksXG4gICAgICAgIHVuaW9uX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOSU9OX0FDVElPTiksXG4gICAgICAgIHJlbW92ZV9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCBbXSksXG4gICAgICAgIGFwcGVuZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBbXSk7XG5cbiAgICBpZiAocV9rZXkgPT09IFNFVF9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXQgcXVldWUgLSB3ZSBjYW4gb3ZlcnJpZGUgYW55IGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICBfLmV4dGVuZChzZXRfcSwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyBpbmNyZW1lbnQsIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHBlbmRpbmcgdW5pb24sIG92ZXJyaWRlIGl0XG4gICAgICAgIC8vIHdpdGggdGhlIHNldC5cbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOSU9OX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBTRVRfT05DRV9RVUVVRV9LRVkpIHtcbiAgICAgICAgLy8gb25seSBxdWV1ZSB0aGUgZGF0YSBpZiB0aGVyZSBpcyBub3QgYWxyZWFkeSBhIHNldF9vbmNlIGNhbGwgZm9yIGl0LlxuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIShrIGluIHNldF9vbmNlX3EpKSB7XG4gICAgICAgICAgICAgICAgc2V0X29uY2VfcVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbihwcm9wKSB7XG5cbiAgICAgICAgICAgIC8vIHVuZG8gcHJldmlvdXNseS1xdWV1ZWQgYWN0aW9ucyBvbiB0aGlzIGtleVxuICAgICAgICAgICAgXy5lYWNoKFtzZXRfcSwgc2V0X29uY2VfcSwgYWRkX3EsIHVuaW9uX3FdLCBmdW5jdGlvbihlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBlbnF1ZXVlZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVucXVldWVkX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF8uZWFjaChhcHBlbmRfcSwgZnVuY3Rpb24oYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGFwcGVuZF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFwcGVuZF9vYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVuc2V0X3FbcHJvcF0gPSB0cnVlO1xuXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFERF9RVUVVRV9LRVkpIHtcbiAgICAgICAgXy5lYWNoKHFfZGF0YSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgLy8gSWYgaXQgZXhpc3RzIGluIHRoZSBzZXQgcXVldWUsIGluY3JlbWVudFxuICAgICAgICAgICAgLy8gdGhlIHZhbHVlXG4gICAgICAgICAgICBpZiAoayBpbiBzZXRfcSkge1xuICAgICAgICAgICAgICAgIHNldF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHVwZGF0ZSB0aGUgYWRkXG4gICAgICAgICAgICAgICAgLy8gcXVldWVcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIGFkZF9xKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRfcVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZF9xW2tdICs9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFVOSU9OX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoayBpbiB1bmlvbl9xKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlvbl9xW2tdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIF8uZWFjaCh2LCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pbmNsdWRlKHVuaW9uX3Fba10sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlvbl9xW2tdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gUkVNT1ZFX1FVRVVFX0tFWSkge1xuICAgICAgICByZW1vdmVfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShBUFBFTkRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IEFQUEVORF9RVUVVRV9LRVkpIHtcbiAgICAgICAgYXBwZW5kX3EucHVzaChxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH1cblxuICAgIGNvbnNvbGUkMS5sb2coJ01JWFBBTkVMIFBFT1BMRSBSRVFVRVNUIChRVUVVRUQsIFBFTkRJTkcgSURFTlRJRlkpOicpO1xuICAgIGNvbnNvbGUkMS5sb2coZGF0YSk7XG5cbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGF0YSkge1xuICAgIHZhciBxID0gdGhpc1sncHJvcHMnXVt0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHEpKSB7XG4gICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04gfHwgcXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnM6IG9ubHkgcmVtb3ZlIGlmIGJvdGggayt2IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gZS5nLiByZW1vdmUgc2hvdWxkIG5vdCBvdmVycmlkZSBhcHBlbmQgaW4gYSBjYXNlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQoe2ZvbzogJ2Jhcid9KTsgcmVtb3ZlKHtmb286ICdxdXgnfSlcbiAgICAgICAgICAgICAgICBfLmVhY2gocSwgZnVuY3Rpb24ocXVldWVkX2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVkX2FjdGlvbltrXSA9PT0gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlZF9hY3Rpb25ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHFba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRfcHJvcCh0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKSk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X3F1ZXVlX2tleSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgaWYgKHF1ZXVlID09PSBTRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFNFVF9PTkNFX0FDVElPTikge1xuICAgICAgICByZXR1cm4gU0VUX09OQ0VfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOU0VUX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5TRVRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IEFERF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIEFERF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQVBQRU5EX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBSRU1PVkVfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBSRU1PVkVfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFVOSU9OX0FDVElPTikge1xuICAgICAgICByZXR1cm4gVU5JT05fUVVFVUVfS0VZO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBxdWV1ZTonLCBxdWV1ZSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9vcl9jcmVhdGVfcXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgZGVmYXVsdF92YWwpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSk7XG4gICAgZGVmYXVsdF92YWwgPSBfLmlzVW5kZWZpbmVkKGRlZmF1bHRfdmFsKSA/IHt9IDogZGVmYXVsdF92YWw7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XSB8fCAodGhpc1sncHJvcHMnXVtrZXldID0gZGVmYXVsdF92YWwpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSwgdGltZXN0YW1wKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHRpbWVyc1tldmVudF9uYW1lXSA9IHRpbWVzdGFtcDtcbiAgICB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldID0gdGltZXJzO1xuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlX2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHZhciB0aW1lcnMgPSB0aGlzLmxvYWRfcHJvcChFVkVOVF9USU1FUlNfS0VZKSB8fCB7fTtcbiAgICB2YXIgdGltZXN0YW1wID0gdGltZXJzW2V2ZW50X25hbWVdO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0aW1lc3RhbXApKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW0VWRU5UX1RJTUVSU19LRVldW2V2ZW50X25hbWVdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIE1peHBhbmVsIEpTIExpYnJhcnlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgTWl4cGFuZWwsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZFxuICogaHR0cDovL21peHBhbmVsLmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBwb3J0aW9ucyBvZiBVbmRlcnNjb3JlLmpzXG4gKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gKiAoYykgMjAxMSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG4vLyBhbGxvdyBidW5kbGVycyB0byBzcGVjaWZ5IGhvdyBleHRyYSBjb2RlIChyZWNvcmRlciBidW5kbGUpIHNob3VsZCBiZSBsb2FkZWRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGxvYWRfZXh0cmFfYnVuZGxlID0gZnVuY3Rpb24oc3JjLCBfb25sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNyYyArICcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJ1aWxkLicpO1xufTtcblxudmFyIG1peHBhbmVsX21hc3RlcjsgLy8gbWFpbiBtaXhwYW5lbCBpbnN0YW5jZSAvIG9iamVjdFxudmFyIElOSVRfTU9EVUxFICA9IDA7XG52YXIgSU5JVF9TTklQUEVUID0gMTtcblxudmFyIElERU5USVRZX0ZVTkMgPSBmdW5jdGlvbih4KSB7cmV0dXJuIHg7fTtcblxuLyoqIEBjb25zdCAqLyB2YXIgUFJJTUFSWV9JTlNUQU5DRV9OQU1FID0gJ21peHBhbmVsJztcbi8qKiBAY29uc3QgKi8gdmFyIFBBWUxPQURfVFlQRV9CQVNFNjQgICA9ICdiYXNlNjQnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0pTT04gICAgID0gJ2pzb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgREVWSUNFX0lEX1BSRUZJWCAgICAgID0gJyRkZXZpY2U6JztcblxuXG4vKlxuICogRHluYW1pYy4uLiBjb25zdGFudHM/IElzIHRoYXQgYW4gb3h5bW9yb24/XG4gKi9cbi8vIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vWE1MSHR0cFJlcXVlc3Qjd2l0aENyZWRlbnRpYWxzXG52YXIgVVNFX1hIUiA9ICh3aW4uWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpO1xuXG4vLyBJRTwxMCBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiBYSFIncyBidXQgc2NyaXB0IHRhZ3Ncbi8vIHdpdGggZGVmZXIgd29uJ3QgYmxvY2sgd2luZG93Lm9ubG9hZDsgRU5RVUVVRV9SRVFVRVNUU1xuLy8gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgT3BlcmE8MTJcbnZhciBFTlFVRVVFX1JFUVVFU1RTID0gIVVTRV9YSFIgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgPT09IC0xKSAmJiAodXNlckFnZW50LmluZGV4T2YoJ01vemlsbGEnKSA9PT0gLTEpO1xuXG4vLyBzYXZlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBzbyBpdCBjYW4gYmUgbWluaWZpZWRcbnZhciBzZW5kQmVhY29uID0gbnVsbDtcbmlmIChuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXSkge1xuICAgIHNlbmRCZWFjb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbGF0ZSByZWZlcmVuY2UgdG8gbmF2aWdhdG9yLnNlbmRCZWFjb24gdG8gYWxsb3cgcGF0Y2hpbmcvc3B5aW5nXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3NlbmRCZWFjb24nXS5hcHBseShuYXZpZ2F0b3IsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIERFRkFVTFRfQVBJX1JPVVRFUyA9IHtcbiAgICAndHJhY2snOiAndHJhY2svJyxcbiAgICAnZW5nYWdlJzogJ2VuZ2FnZS8nLFxuICAgICdncm91cHMnOiAnZ3JvdXBzLycsXG4gICAgJ3JlY29yZCc6ICdyZWNvcmQvJ1xufTtcblxuLypcbiAqIE1vZHVsZS1sZXZlbCBnbG9iYWxzXG4gKi9cbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICAnYXBpX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gICAgJ2FwaV9yb3V0ZXMnOiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfQVBJX1JPVVRFUyxcbiAgICAnYXBpX21ldGhvZCc6ICAgICAgICAgICAgICAgICAgICAgICAgJ1BPU1QnLFxuICAgICdhcGlfdHJhbnNwb3J0JzogICAgICAgICAgICAgICAgICAgICAnWEhSJyxcbiAgICAnYXBpX3BheWxvYWRfZm9ybWF0JzogICAgICAgICAgICAgICAgUEFZTE9BRF9UWVBFX0JBU0U2NCxcbiAgICAnYXBwX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vbWl4cGFuZWwuY29tJyxcbiAgICAnYXV0b2NhcHR1cmUnOiAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Nkbic6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20nLFxuICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6ICAgICAgICAgICAgdHJ1ZSxcbiAgICAnZXJyb3JfcmVwb3J0ZXInOiAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdwZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgICAgICAgICAnY29va2llJyxcbiAgICAncGVyc2lzdGVuY2VfbmFtZSc6ICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9kb21haW4nOiAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfbmFtZSc6ICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnbG9hZGVkJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdtcF9sb2FkZXInOiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICd0cmFja19tYXJrZXRpbmcnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0cmFja19wYWdldmlldyc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnOiAgICAgICAgZmFsc2UsXG4gICAgJ3N0b3JlX2dvb2dsZSc6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzYXZlX3JlZmVycmVyJzogICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0ZXN0JzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndmVyYm9zZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2ltZyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkZWJ1Zyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndHJhY2tfbGlua3NfdGltZW91dCc6ICAgICAgICAgICAgICAgMzAwLFxuICAgICdjb29raWVfZXhwaXJhdGlvbic6ICAgICAgICAgICAgICAgICAzNjUsXG4gICAgJ3VwZ3JhZGUnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NlY3VyZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpcCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnOiAgICAgICBmYWxzZSxcbiAgICAnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JzogICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZSc6ICdsb2NhbFN0b3JhZ2UnLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnOiAgICBudWxsLFxuICAgICdwcm9wZXJ0eV9ibGFja2xpc3QnOiAgICAgICAgICAgICAgICBbXSxcbiAgICAneGhyX2hlYWRlcnMnOiAgICAgICAgICAgICAgICAgICAgICAge30sIC8vIHsgaGVhZGVyOiB2YWx1ZSwgaGVhZGVyMjogdmFsdWUgfVxuICAgICdpZ25vcmVfZG50JzogICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnYmF0Y2hfcmVxdWVzdHMnOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnYmF0Y2hfc2l6ZSc6ICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogICAgICAgICAgIDUwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6ICAgICAgICAgIDkwMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdob29rcyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAncmVjb3JkX2Jsb2NrX2NsYXNzJzogICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1ibG9ja3xmcy1leGNsdWRlfGFtcC1ibG9ja3xyci1ibG9ja3xwaC1uby1jYXB0dXJlKSQnKSxcbiAgICAncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJzogICAgICAgICAgICAgJ2ltZywgdmlkZW8nLFxuICAgICdyZWNvcmRfY2FudmFzJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2NvbGxlY3RfZm9udHMnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9pZGxlX3RpbWVvdXRfbXMnOiAgICAgICAgICAgIDMwICogNjAgKiAxMDAwLCAvLyAzMCBtaW51dGVzXG4gICAgJ3JlY29yZF9tYXNrX3RleHRfY2xhc3MnOiAgICAgICAgICAgIG5ldyBSZWdFeHAoJ14obXAtbWFza3xmcy1tYXNrfGFtcC1tYXNrfHJyLW1hc2t8cGgtbWFzaykkJyksXG4gICAgJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InOiAgICAgICAgICcqJyxcbiAgICAncmVjb3JkX21heF9tcyc6ICAgICAgICAgICAgICAgICAgICAgTUFYX1JFQ09SRElOR19NUyxcbiAgICAncmVjb3JkX21pbl9tcyc6ICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnOiAgICAgICAgICAgMCxcbiAgICAncmVjb3JkZXJfc3JjJzogICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbS9saWJzL21peHBhbmVsLXJlY29yZGVyLm1pbi5qcydcbn07XG5cbnZhciBET01fTE9BREVEID0gZmFsc2U7XG5cbi8qKlxuICogTWl4cGFuZWwgTGlicmFyeSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxMaWIgPSBmdW5jdGlvbigpIHt9O1xuXG5cbi8qKlxuICogY3JlYXRlX21wbGliKHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBpbml0IG1ldGhvZCBvZiBNaXhwYW5lbExpYiBvYmplY3RzXG4gKiBhcyB3ZWxsIGFzIHRoZSBtYWluIGluaXRpYWxpemVyIGF0IHRoZSBlbmQgb2YgdGhlIEpTTGliICh0aGF0XG4gKiBpbml0aWFsaXplcyBkb2N1bWVudC5taXhwYW5lbCBhcyB3ZWxsIGFzIGFueSBhZGRpdGlvbmFsIGluc3RhbmNlc1xuICogZGVjbGFyZWQgYmVmb3JlIHRoaXMgZmlsZSBoYXMgbG9hZGVkKS5cbiAqL1xudmFyIGNyZWF0ZV9tcGxpYiA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICB2YXIgaW5zdGFuY2UsXG4gICAgICAgIHRhcmdldCA9IChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbWl4cGFuZWxfbWFzdGVyIDogbWl4cGFuZWxfbWFzdGVyW25hbWVdO1xuXG4gICAgaWYgKHRhcmdldCAmJiBpbml0X3R5cGUgPT09IElOSVRfTU9EVUxFKSB7XG4gICAgICAgIGluc3RhbmNlID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgIV8uaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgaW5pdGlhbGl6ZWQgJyArIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlID0gbmV3IE1peHBhbmVsTGliKCk7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuX2NhY2hlZF9ncm91cHMgPSB7fTsgLy8gY2FjaGUgZ3JvdXBzIGluIGEgcG9vbFxuXG4gICAgaW5zdGFuY2UuX2luaXQodG9rZW4sIGNvbmZpZywgbmFtZSk7XG5cbiAgICBpbnN0YW5jZVsncGVvcGxlJ10gPSBuZXcgTWl4cGFuZWxQZW9wbGUoKTtcbiAgICBpbnN0YW5jZVsncGVvcGxlJ10uX2luaXQoaW5zdGFuY2UpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5nZXRfY29uZmlnKCdza2lwX2ZpcnN0X3RvdWNoX21hcmtldGluZycpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgbnVsbCBVVE0gcGFyYW1zIGluIHRoZSBvYmplY3QgYmVjYXVzZVxuICAgICAgICAvLyBVVE0gcGFyYW1ldGVycyBhY3QgYXMgYSB0dXBsZS4gSWYgYW55IFVUTSBwYXJhbVxuICAgICAgICAvLyBpcyBwcmVzZW50LCB0aGVuIHdlIHNldCBhbGwgVVRNIHBhcmFtcyBpbmNsdWRpbmdcbiAgICAgICAgLy8gZW1wdHkgb25lcyB0b2dldGhlclxuICAgICAgICB2YXIgdXRtX3BhcmFtcyA9IF8uaW5mby5jYW1wYWlnblBhcmFtcyhudWxsKTtcbiAgICAgICAgdmFyIGluaXRpYWxfdXRtX3BhcmFtcyA9IHt9O1xuICAgICAgICB2YXIgaGFzX3V0bSA9IGZhbHNlO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24odXRtX3ZhbHVlLCB1dG1fa2V5KSB7XG4gICAgICAgICAgICBpbml0aWFsX3V0bV9wYXJhbXNbJ2luaXRpYWxfJyArIHV0bV9rZXldID0gdXRtX3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHV0bV92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc191dG0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc191dG0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlWydwZW9wbGUnXS5zZXRfb25jZShpbml0aWFsX3V0bV9wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYW55IGluc3RhbmNlIG9uIHRoZSBwYWdlIGhhcyBkZWJ1ZyA9IHRydWUsIHdlIHNldCB0aGVcbiAgICAvLyBnbG9iYWwgZGVidWcgdG8gYmUgdHJ1ZVxuICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCBpbnN0YW5jZS5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuXG4gICAgLy8gaWYgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkLCB3ZSBjYWxsZWQgaW5pdCBhZnRlciB0aGUgbGliIGFscmVhZHlcbiAgICAvLyBsb2FkZWQsIHNvIHRoZXJlIHdvbid0IGJlIGFuIGFycmF5IG9mIHRoaW5ncyB0byBleGVjdXRlXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldCkgJiYgXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgLy8gQ3J1bmNoIHRocm91Z2ggdGhlIHBlb3BsZSBxdWV1ZSBmaXJzdCAtIHdlIHF1ZXVlIHRoaXMgZGF0YSB1cCAmXG4gICAgICAgIC8vIGZsdXNoIG9uIGlkZW50aWZ5LCBzbyBpdCdzIGJldHRlciB0byBkbyBhbGwgdGhlc2Ugb3BlcmF0aW9ucyBmaXJzdFxuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheS5jYWxsKGluc3RhbmNlWydwZW9wbGUnXSwgdGFyZ2V0WydwZW9wbGUnXSk7XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gSW5pdGlhbGl6YXRpb24gbWV0aG9kc1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIE1peHBhbmVsIHRyYWNraW5nIG9iamVjdC5cbiAqIEFsbCBuZXcgaW5zdGFuY2VzIGFyZSBhZGRlZCB0byB0aGUgbWFpbiBtaXhwYW5lbCBvYmplY3QgYXMgc3ViIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIG1peHBhbmVsLmxpYnJhcnlfbmFtZSkgYW5kIGFsc28gcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi4gVG8gZGVmaW5lIGFcbiAqIHNlY29uZCBpbnN0YW5jZSBvbiB0aGUgcGFnZSwgeW91IHdvdWxkIGNhbGw6XG4gKlxuICogICAgIG1peHBhbmVsLmluaXQoJ25ldyB0b2tlbicsIHsgeW91cjogJ2NvbmZpZycgfSwgJ2xpYnJhcnlfbmFtZScpO1xuICpcbiAqIGFuZCB1c2UgaXQgbGlrZSBzbzpcbiAqXG4gKiAgICAgbWl4cGFuZWwubGlicmFyeV9uYW1lLnRyYWNrKC4uLik7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuICAgWW91ciBNaXhwYW5lbCBBUEkgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSAgQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlLiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21peHBhbmVsL21peHBhbmVsLWpzL2Jsb2IvdjIuNDYuMC9zcmMvbWl4cGFuZWwtY29yZS5qcyNMODgtTDEyN1wiPlNlZSBhIGxpc3Qgb2YgZGVmYXVsdCBjb25maWcgb3B0aW9uczwvYT4uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdICAgIFRoZSBuYW1lIGZvciB0aGUgbmV3IG1peHBhbmVsIGluc3RhbmNlIHRoYXQgeW91IHdhbnQgY3JlYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBtdXN0IG5hbWUgeW91ciBuZXcgbGlicmFyeTogaW5pdCh0b2tlbiwgY29uZmlnLCBuYW1lKScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBtdXN0IGluaXRpYWxpemUgdGhlIG1haW4gbWl4cGFuZWwgb2JqZWN0IHJpZ2h0IGFmdGVyIHlvdSBpbmNsdWRlIHRoZSBNaXhwYW5lbCBqcyBzbmlwcGV0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuX2xvYWRlZCgpO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxuLy8gbWl4cGFuZWwuX2luaXQodG9rZW46c3RyaW5nLCBjb25maWc6b2JqZWN0LCBuYW1lOnN0cmluZylcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIHNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIG1peHBhbmVsXG4vLyBsaWJyYXJ5LiAgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQgdGhlIGluaXQoLi4uKVxuLy8gbWV0aG9kIGlzIHRoaXMgb25lIGluaXRpYWxpemVzIHRoZSBhY3R1YWwgaW5zdGFuY2UsIHdoZXJlYXMgdGhlXG4vLyBpbml0KC4uLikgbWV0aG9kIHNldHMgdXAgYSBuZXcgbGlicmFyeSBhbmQgY2FsbHMgX2luaXQgb24gaXQuXG4vL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgIHRoaXNbJ19fbG9hZGVkJ10gPSB0cnVlO1xuICAgIHRoaXNbJ2NvbmZpZyddID0ge307XG5cbiAgICB2YXIgdmFyaWFibGVfZmVhdHVyZXMgPSB7fTtcblxuICAgIC8vIGRlZmF1bHQgdG8gSlNPTiBwYXlsb2FkIGZvciBzdGFuZGFyZCBtaXhwYW5lbC5jb20gQVBJIGhvc3RzXG4gICAgaWYgKCEoJ2FwaV9wYXlsb2FkX2Zvcm1hdCcgaW4gY29uZmlnKSkge1xuICAgICAgICB2YXIgYXBpX2hvc3QgPSBjb25maWdbJ2FwaV9ob3N0J10gfHwgREVGQVVMVF9DT05GSUdbJ2FwaV9ob3N0J107XG4gICAgICAgIGlmIChhcGlfaG9zdC5tYXRjaCgvXFwubWl4cGFuZWxcXC5jb20vKSkge1xuICAgICAgICAgICAgdmFyaWFibGVfZmVhdHVyZXNbJ2FwaV9wYXlsb2FkX2Zvcm1hdCddID0gUEFZTE9BRF9UWVBFX0pTT047XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldF9jb25maWcoXy5leHRlbmQoe30sIERFRkFVTFRfQ09ORklHLCB2YXJpYWJsZV9mZWF0dXJlcywgY29uZmlnLCB7XG4gICAgICAgICduYW1lJzogbmFtZSxcbiAgICAgICAgJ3Rva2VuJzogdG9rZW4sXG4gICAgICAgICdjYWxsYmFja19mbic6ICgobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG5hbWUgOiBQUklNQVJZX0lOU1RBTkNFX05BTUUgKyAnLicgKyBuYW1lKSArICcuX2pzYydcbiAgICB9KSk7XG5cbiAgICB0aGlzWydfanNjJ10gPSBOT09QX0ZVTkM7XG5cbiAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlID0gW107XG4gICAgdGhpcy5fX2Rpc2FibGVkX2V2ZW50cyA9IFtdO1xuICAgIHRoaXMuX2ZsYWdzID0ge1xuICAgICAgICAnZGlzYWJsZV9hbGxfZXZlbnRzJzogZmFsc2UsXG4gICAgICAgICdpZGVudGlmeV9jYWxsZWQnOiBmYWxzZVxuICAgIH07XG5cbiAgICAvLyBzZXQgdXAgcmVxdWVzdCBxdWV1ZWluZy9iYXRjaGluZ1xuICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycyA9IHt9O1xuICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdGhpcy5nZXRfY29uZmlnKCdiYXRjaF9yZXF1ZXN0cycpO1xuICAgIGlmICh0aGlzLl9iYXRjaF9yZXF1ZXN0cykge1xuICAgICAgICBpZiAoIV8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCh0cnVlKSB8fCAhVVNFX1hIUikge1xuICAgICAgICAgICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2coJ1R1cm5pbmcgb2ZmIE1peHBhbmVsIHJlcXVlc3QtcXVldWVpbmc7IG5lZWRzIFhIUiBhbmQgbG9jYWxTdG9yYWdlIHN1cHBvcnQnKTtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmdldF9iYXRjaGVyX2NvbmZpZ3MoKSwgZnVuY3Rpb24oYmF0Y2hlcl9jb25maWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlJDEubG9nKCdDbGVhcmluZyBiYXRjaCBxdWV1ZSAnICsgYmF0Y2hlcl9jb25maWcucXVldWVfa2V5KTtcbiAgICAgICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5yZW1vdmUoYmF0Y2hlcl9jb25maWcucXVldWVfa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0X2JhdGNoZXJzKCk7XG4gICAgICAgICAgICBpZiAoc2VuZEJlYWNvbiAmJiB3aW4uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSBwYWdlIGNsb3NlcyBvciBoaWRlcyAodXNlciB0YWJzIGF3YXkgZXRjKSwgYXR0ZW1wdCB0byBmbHVzaCBhbnkgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gcXVldWVkIHVwIHZpYSBuYXZpZ2F0b3Iuc2VuZEJlYWNvbi4gU2luY2Ugc2VuZEJlYWNvbiBkb2Vzbid0IHJlcG9ydCBzdWNjZXNzL2ZhaWx1cmUsXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIHdpbGwgbm90IGJlIHJlbW92ZWQgZnJvbSB0aGUgcGVyc2lzdGVudCBzdG9yZTsgaWYgdGhlIHNpdGUgaXMgbG9hZGVkIGFnYWluLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBldmVudHMgd2lsbCBiZSBmbHVzaGVkIGFnYWluIG9uIHN0YXJ0dXAgYW5kIGRlZHVwbGljYXRlZCBvbiB0aGUgTWl4cGFuZWwgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gc2lkZS5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyByZWxpYWJsZSB3YXkgdG8gY2FwdHVyZSBvbmx5IHBhZ2UgY2xvc2UgZXZlbnRzLCBzbyB3ZSBsZWFuIG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHljaGFuZ2UgYW5kIHBhZ2VoaWRlIGV2ZW50cyBhcyByZWNvbW1lbmRlZCBhdFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvdW5sb2FkX2V2ZW50I3VzYWdlX25vdGVzLlxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBmaXJlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGF3YXkgZnJvbSB0aGUgY3VycmVudCBwYWdlL3RhYiwgc28gd2lsbCBvY2N1clxuICAgICAgICAgICAgICAgIC8vIG1vcmUgZnJlcXVlbnRseSB0aGFuIHBhZ2UgdW5sb2FkLCBidXQgYXJlIHRoZSBvbmx5IG1lY2hhbmlzbSBjdXJyZW50bHkgZm9yIGNhcHR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2NlbmFyaW8gc29tZXdoYXQgcmVsaWFibHkuXG4gICAgICAgICAgICAgICAgdmFyIGZsdXNoX29uX3VubG9hZCA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuZmx1c2goe3VubG9hZGluZzogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2WydwZXJzaXN0ZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfb25fdW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQkMVsndmlzaWJpbGl0eVN0YXRlJ10gPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaF9vbl91bmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXSA9IHRoaXNbJ2Nvb2tpZSddID0gbmV3IE1peHBhbmVsUGVyc2lzdGVuY2UodGhpc1snY29uZmlnJ10pO1xuICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyA9IHt9O1xuICAgIHRoaXMuX2dkcHJfaW5pdCgpO1xuXG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICBpZiAoIXRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCkpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgdGhlIGRpc3RpbmN0IGlkXG4gICAgICAgIC8vIG9yIHRoZSBkZXZpY2UgaWQgaWYgc29tZXRoaW5nIHdhcyBhbHJlYWR5IHN0b3JlZFxuICAgICAgICAvLyBpbiB0aGUgcGVyc2l0ZW5jZVxuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogREVWSUNFX0lEX1BSRUZJWCArIHV1aWQsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IHV1aWRcbiAgICAgICAgfSwgJycpO1xuICAgIH1cblxuICAgIHRoaXMuYXV0b2NhcHR1cmUgPSBuZXcgQXV0b2NhcHR1cmUodGhpcyk7XG4gICAgdGhpcy5hdXRvY2FwdHVyZS5pbml0KCk7XG5cbiAgICB0aGlzLl9pbml0X3RhYl9pZCgpO1xuICAgIHRoaXMuX2NoZWNrX2FuZF9zdGFydF9zZXNzaW9uX3JlY29yZGluZygpO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zIGEgdW5pcXVlIFVVSUQgdG8gdGhpcyB0YWIgLyB3aW5kb3cgYnkgbGV2ZXJhZ2luZyBzZXNzaW9uU3RvcmFnZS5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgZm9yIHNlc3Npb24gcmVjb3JkaW5nLCB3aGVyZSBkYXRhIG11c3QgYmUgaXNvbGF0ZWQgdG8gdGhlIGN1cnJlbnQgdGFiLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXRfdGFiX2lkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBrZXlfc3VmZml4ID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJykgKyAnXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgdGFiX2lkX2tleSA9ICdtcF90YWJfaWRfJyArIGtleV9zdWZmaXg7XG5cbiAgICAgICAgICAgIC8vIEEgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBzZXNzaW9uU3RvcmFnZSBpcyBjb3BpZWQgb3ZlciBhbmQgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIG5ldyB0YWIgSUQuXG4gICAgICAgICAgICAvLyBUaGlzIGVuZm9yY2VzIGEgdW5pcXVlIElEIGluIHRoZSBjYXNlcyBsaWtlIGR1cGxpY2F0ZWQgdGFiLCB3aW5kb3cub3BlbiguLi4pXG4gICAgICAgICAgICB2YXIgc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5ID0gJ21wX2dlbl9uZXdfdGFiX2lkXycgKyBrZXlfc3VmZml4O1xuICAgICAgICAgICAgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSkgfHwgIV8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHRhYl9pZF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQodGFiX2lkX2tleSwgJyR0YWItJyArIF8uVVVJRCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQoc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5LCAnMScpO1xuICAgICAgICAgICAgdGhpcy50YWJfaWQgPSBfLnNlc3Npb25TdG9yYWdlLmdldCh0YWJfaWRfa2V5KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmbGFnIHdoZW4gdGhlIHRhYiBpcyB1bmxvYWRlZCB0byBpbmRpY2F0ZSB0aGUgc3RvcmVkIHRhYiBJRCBjYW4gYmUgcmV1c2VkLiBUaGlzIGV2ZW50IGlzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgYWxsIHBhZ2UgdW5sb2FkcyxcbiAgICAgICAgICAgIC8vIGJ1dCByZWxpYWJsZSBpbiBjYXNlcyB3aGVyZSB0aGUgdXNlciByZW1haW5zIGluIHRoZSB0YWIgZS5nLiBhIHJlZnJlc2ggb3IgaHJlZiBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGZsYWcgaXMgYWJzZW50LCB0aGlzIGluZGljYXRlcyB0byB0aGUgbmV4dCBTREsgaW5zdGFuY2UgdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHN0b3JlZCB0YWJfaWQuXG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF8uc2Vzc2lvblN0b3JhZ2UucmVtb3ZlKHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdFcnJvciBpbml0aWFsaXppbmcgdGFiIGlkJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdTZXNzaW9uIHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCwgY2Fubm90IGtlZXAgdHJhY2sgb2YgdW5pcXVlIHRhYiBJRC4nKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3RhYl9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJfaWQgfHwgbnVsbDtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2hvdWxkX2xvYWRfcmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY29yZGluZ19yZWdpc3RyeV9pZGIgPSBuZXcgSURCU3RvcmFnZVdyYXBwZXIoUkVDT1JESU5HX1JFR0lTVFJZX1NUT1JFX05BTUUpO1xuICAgIHZhciB0YWJfaWQgPSB0aGlzLmdldF90YWJfaWQoKTtcbiAgICByZXR1cm4gcmVjb3JkaW5nX3JlZ2lzdHJ5X2lkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZGluZ19yZWdpc3RyeV9pZGIuZ2V0QWxsKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgZXhwaXJlZCByZWNvcmRpbmdzIGluIHRoZSByZWdpc3RyeSwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGZsdXNoIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcmVjb3JkaW5nIGZvciB0aGlzIHRhYiBpZCwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGNvbnRpbnVlIHRoZSByZWNvcmRpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvcmRpbmdFeHBpcmVkKHJlY29yZGluZ3NbaV0pIHx8IHJlY29yZGluZ3NbaV1bJ3RhYklkJ10gPT09IHRhYl9pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHJlY29yZGluZyByZWdpc3RyeScsIGVycik7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihmb3JjZV9zdGFydCkge1xuICAgIGlmICghd2luWydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTXV0YXRpb25PYnNlcnZlcjsgc2tpcHBpbmcgc2Vzc2lvbiByZWNvcmRpbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb2FkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgICAgIHZhciBoYW5kbGVMb2FkZWRSZWNvcmRlciA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3Jlc3VtZVJlY29yZGluZyddKHN0YXJ0TmV3SWZJbmFjdGl2ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdpblsnX19tcF9yZWNvcmRlciddKSkge1xuICAgICAgICAgICAgbG9hZF9leHRyYV9idW5kbGUodGhpcy5nZXRfY29uZmlnKCdyZWNvcmRlcl9zcmMnKSwgaGFuZGxlTG9hZGVkUmVjb3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTG9hZGVkUmVjb3JkZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVzZXIgaXMgc2FtcGxlZCBvciBzdGFydF9zZXNzaW9uX3JlY29yZGluZyBpcyBjYWxsZWQsIHdlIGFsd2F5cyBsb2FkIHRoZSByZWNvcmRlciBzaW5jZSBpdCdzIGd1YXJhbnRlZWQgYSByZWNvcmRpbmcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIE90aGVyd2lzZSwgaWYgdGhlIHJlY29yZGluZyByZWdpc3RyeSBoYXMgYW55IHJlY29yZHMgdGhlbiBpdCdzIGxpa2VseSB0aGVyZSdzIGEgcmVjb3JkaW5nIGluIHByb2dyZXNzIG9yIG9ycGhhbmVkIGRhdGEgdGhhdCBuZWVkcyB0byBiZSBmbHVzaGVkLlxuICAgICAqL1xuICAgIHZhciBpc19zYW1wbGVkID0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpID4gMCAmJiBNYXRoLnJhbmRvbSgpICogMTAwIDw9IHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnKTtcbiAgICBpZiAoZm9yY2Vfc3RhcnQgfHwgaXNfc2FtcGxlZCkge1xuICAgICAgICBsb2FkUmVjb3JkZXIodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvdWxkX2xvYWRfcmVjb3JkZXIoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkUmVjb3JkZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nKHRydWUpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydzdG9wUmVjb3JkaW5nJ10oKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucGF1c2Vfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydwYXVzZVJlY29yZGluZyddKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc3VtZV9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3Jlc3VtZVJlY29yZGluZyddKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHByb3BzWyckbXBfcmVwbGF5X2lkJ10gPSByZXBsYXlfaWQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfdXJsID0gbnVsbDtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICB2YXIgcXVlcnlfcGFyYW1zID0gXy5IVFRQQnVpbGRRdWVyeSh7XG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5X2lkLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogdGhpcy5nZXRfZGlzdGluY3RfaWQoKSxcbiAgICAgICAgICAgICd0b2tlbic6IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGF5X3VybCA9ICdodHRwczovL21peHBhbmVsLmNvbS9wcm9qZWN0cy9yZXBsYXktcmVkaXJlY3Q/JyArIHF1ZXJ5X3BhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV91cmw7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dldF9zZXNzaW9uX3JlcGxheV9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X2lkID0gbnVsbDtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmVwbGF5X2lkID0gdGhpcy5fcmVjb3JkZXJbJ3JlcGxheUlkJ107XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfaWQgfHwgbnVsbDtcbn07XG5cbi8vIFwicHJpdmF0ZVwiIHB1YmxpYyBtZXRob2QgdG8gcmVhY2ggaW50byB0aGUgcmVjb3JkZXIgaW4gdGVzdCBjYXNlc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9fZ2V0X3JlY29yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNvcmRlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0X2NvbmZpZygnbG9hZGVkJykodGhpcyk7XG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuICAgIHRoaXNbJ3Blb3BsZSddLnNldF9vbmNlKHRoaXNbJ3BlcnNpc3RlbmNlJ10uZ2V0X3JlZmVycmVyX2luZm8oKSk7XG5cbiAgICAvLyBgc3RvcmVfZ29vZ2xlYCBpcyBub3cgZGVwcmVjYXRlZCBhbmQgcHJldmlvdXNseSBzdG9yZWQgVVRNIHBhcmFtZXRlcnMgYXJlIGNsZWFyZWRcbiAgICAvLyBmcm9tIHBlcnNpc3RlbmNlIGJ5IGRlZmF1bHQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24oX3V0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHBlcnNpc3RlZCBVVE0gcGFyYW1ldGVycyBzbyBvbGQgdmFsdWVzXG4gICAgICAgICAgICAvLyBhcmUgbm90IG1peGVkIHdpdGggdGhlIG5ldyBVVE0gcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHV0bV9rZXkpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbi8vIHVwZGF0ZSBwZXJzaXN0ZW5jZSB3aXRoIGluZm8gb24gcmVmZXJyZXIsIFVUTSBwYXJhbXMsIGV0Y1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfc2VhcmNoX2tleXdvcmQoZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgLy8gUmVnaXN0ZXJpbmcgc3VwZXIgcHJvcGVydGllcyBmb3IgVVRNIHBlcnNpc3RlbmNlIGJ5ICdzdG9yZV9nb29nbGUnIGlzIGRlcHJlY2F0ZWQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgIXRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5jYW1wYWlnblBhcmFtcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9kb21fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgXy5lYWNoKHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrX2RvbS5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuX19yZXF1ZXN0X3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZTtcbiAgICBkZWxldGUgdGhpcy5fX3JlcXVlc3RfcXVldWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX2RvbSA9IGZ1bmN0aW9uKERvbUNsYXNzLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBjYW5cXCd0IHVzZSBET00gdHJhY2tpbmcgZnVuY3Rpb25zIHdpdGggaW1nID0gdHJ1ZS4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghRE9NX0xPQURFRCkge1xuICAgICAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZS5wdXNoKFtEb21DbGFzcywgYXJnc10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGR0ID0gbmV3IERvbUNsYXNzKCkuaW5pdCh0aGlzKTtcbiAgICByZXR1cm4gZHQudHJhY2suYXBwbHkoZHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBfcHJlcGFyZV9jYWxsYmFjaygpIHNob3VsZCBiZSBjYWxsZWQgYnkgY2FsbGVycyBvZiBfc2VuZF9yZXF1ZXN0IGZvciB1c2VcbiAqIGFzIHRoZSBjYWxsYmFjayBhcmd1bWVudC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBjYWxsYmFjaywgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBYSFIvWERSIHJlcXVlc3RzLCB0aGlzIHJldHVybnMgYSBmdW5jdGlvbi5cbiAqIElmIHdlIGFyZSBnb2luZyB0byB1c2Ugc2NyaXB0IHRhZ3MsIHRoaXMgcmV0dXJucyBhIHN0cmluZyB0byB1c2UgYXMgdGhlXG4gKiBjYWxsYmFjayBHRVQgcGFyYW0uXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcHJlcGFyZV9jYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHZhciBjYWxsYmFja19mdW5jdGlvbiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19mdW5jdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBnaXZlcyB1cyBhIGNhbGxiYWNrLCB3ZSBzdG9yZSBhcyBhIHJhbmRvbVxuICAgICAgICAvLyBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlcyBqc2MgZnVuY3Rpb24gYW5kIHVwZGF0ZSBvdXJcbiAgICAgICAgLy8gY2FsbGJhY2sgc3RyaW5nIHRvIHJlZmxlY3QgdGhhdC5cbiAgICAgICAgdmFyIGpzYyA9IHRoaXNbJ19qc2MnXTtcbiAgICAgICAgdmFyIHJhbmRvbWl6ZWRfY2IgPSAnJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIHZhciBjYWxsYmFja19zdHJpbmcgPSB0aGlzLmdldF9jb25maWcoJ2NhbGxiYWNrX2ZuJykgKyAnWycgKyByYW5kb21pemVkX2NiICsgJ10nO1xuICAgICAgICBqc2NbcmFuZG9taXplZF9jYl0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgZGVsZXRlIGpzY1tyYW5kb21pemVkX2NiXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX3N0cmluZztcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICAgIGlmIChFTlFVRVVFX1JFUVVFU1RTKSB7XG4gICAgICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICB9XG5cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX21ldGhvZCcpLFxuICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3RyYW5zcG9ydCcpLFxuICAgICAgICB2ZXJib3NlOiB0aGlzLmdldF9jb25maWcoJ3ZlcmJvc2UnKVxuICAgIH07XG4gICAgdmFyIGJvZHlfZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5leHRlbmQoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICB9XG4gICAgdmFyIHVzZV9wb3N0ID0gb3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJztcbiAgICB2YXIgdXNlX3NlbmRCZWFjb24gPSBzZW5kQmVhY29uICYmIHVzZV9wb3N0ICYmIG9wdGlvbnMudHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdzZW5kYmVhY29uJztcblxuICAgIC8vIG5lZWRlZCB0byBjb3JyZWN0bHkgZm9ybWF0IHJlc3BvbnNlc1xuICAgIHZhciB2ZXJib3NlX21vZGUgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgaWYgKGRhdGFbJ3ZlcmJvc2UnXSkgeyB2ZXJib3NlX21vZGUgPSB0cnVlOyB9XG5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHsgZGF0YVsndGVzdCddID0gMTsgfVxuICAgIGlmICh2ZXJib3NlX21vZGUpIHsgZGF0YVsndmVyYm9zZSddID0gMTsgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7IGRhdGFbJ2ltZyddID0gMTsgfVxuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX21vZGUgfHwgdGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHtcbiAgICAgICAgICAgIC8vIFZlcmJvc2Ugb3V0cHV0IChmcm9tIHZlcmJvc2UgbW9kZSwgb3IgYW4gZXJyb3IgaW4gdGVzdCBtb2RlKSBpcyBhIGpzb24gYmxvYixcbiAgICAgICAgICAgIC8vIHdoaWNoIGJ5IGl0c2VsZiBpcyBub3QgdmFsaWQgamF2YXNjcmlwdC4gV2l0aG91dCBhIGNhbGxiYWNrLCB0aGlzIHZlcmJvc2Ugb3V0cHV0IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIHdoZW4gcmV0dXJuZWQgdmlhIGpzb25wLCBzbyB3ZSBmb3JjZSBhIG5vLW9wIGNhbGxiYWNrIHBhcmFtLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBFQ01BIHNjcmlwdCBzcGVjOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTIuNFxuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9ICcoZnVuY3Rpb24oKXt9KSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhWydpcCddID0gdGhpcy5nZXRfY29uZmlnKCdpcCcpPzE6MDtcbiAgICBkYXRhWydfJ10gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygpO1xuXG4gICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgIGJvZHlfZGF0YSA9ICdkYXRhPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVsnZGF0YSddKTtcbiAgICAgICAgZGVsZXRlIGRhdGFbJ2RhdGEnXTtcbiAgICB9XG5cbiAgICB1cmwgKz0gJz8nICsgXy5IVFRQQnVpbGRRdWVyeShkYXRhKTtcblxuICAgIHZhciBsaWIgPSB0aGlzO1xuICAgIGlmICgnaW1nJyBpbiBkYXRhKSB7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudCQxLmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHVzZV9zZW5kQmVhY29uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBzZW5kQmVhY29uKHVybCwgYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzdWNjZWVkZWQgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZ2V0X2NvbmZpZygneGhyX2hlYWRlcnMnKTtcbiAgICAgICAgICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyVmFsdWUsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dF9tcyAmJiB0eXBlb2YgcmVxLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VuZCB0aGUgbXBfb3B0b3V0IGNvb2tpZVxuICAgICAgICAgICAgLy8gd2l0aENyZWRlbnRpYWxzIGNhbm5vdCBiZSBtb2RpZmllZCB1bnRpbCBhZnRlciBjYWxsaW5nIC5vcGVuIG9uIEFuZHJvaWQgYW5kIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gWE1MSHR0cFJlcXVlc3QuRE9ORSA9PSA0LCBleGNlcHQgaW4gc2FmYXJpIDRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF8uSlNPTkRlY29kZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZV9qc29uX2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhOdW1iZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudGltZW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXEuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lID49IHJlcS50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd0aW1lb3V0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnQmFkIEhUVFAgc3RhdHVzOiAnICsgcmVxLnN0YXR1cyArICcgJyArIHJlcS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9oZWFkZXJzID0gcmVxWydyZXNwb25zZUhlYWRlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogMCwgaHR0cFN0YXR1c0NvZGU6IHJlcVsnc3RhdHVzJ10sIGVycm9yOiBlcnJvciwgcmV0cnlBZnRlcjogcmVzcG9uc2VfaGVhZGVyc1snUmV0cnktQWZ0ZXInXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZChib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG4vKipcbiAqIF9leGVjdXRlX2FycmF5KCkgZGVhbHMgd2l0aCBwcm9jZXNzaW5nIGFueSBtaXhwYW5lbCBmdW5jdGlvblxuICogY2FsbHMgdGhhdCB3ZXJlIGNhbGxlZCBiZWZvcmUgdGhlIE1peHBhbmVsIGxpYnJhcnkgd2VyZSBsb2FkZWRcbiAqIChhbmQgYXJlIHRodXMgc3RvcmVkIGluIGFuIGFycmF5IHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBsYXRlcilcbiAqXG4gKiBOb3RlOiB3ZSBmaXJlIG9mZiBhbGwgdGhlIG1peHBhbmVsIGZ1bmN0aW9uIGNhbGxzICYmIHVzZXIgZGVmaW5lZFxuICogZnVuY3Rpb25zIEJFRk9SRSB3ZSBmaXJlIG9mZiBtaXhwYW5lbCB0cmFja2luZyBjYWxscy4gVGhpcyBpcyBzb1xuICogaWRlbnRpZnkvcmVnaXN0ZXIvc2V0X2NvbmZpZyBjYWxscyBjYW4gcHJvcGVybHkgbW9kaWZ5IGVhcmx5XG4gKiB0cmFja2luZyBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V4ZWN1dGVfYXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBmbl9uYW1lLCBhbGlhc19jYWxscyA9IFtdLCBvdGhlcl9jYWxscyA9IFtdLCB0cmFja2luZ19jYWxscyA9IFtdO1xuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm5fbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZuX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTsgLy8gY2hhaW5lZCBjYWxsIGUuZy4gbWl4cGFuZWwuZ2V0X2dyb3VwKCkuc2V0KClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGl0ZW0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgICAgIGFsaWFzX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xICYmIHR5cGVvZih0aGlzW2ZuX25hbWVdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBleGVjdXRlID0gZnVuY3Rpb24oY2FsbHMsIGNvbnRleHQpIHtcbiAgICAgICAgXy5lYWNoKGNhbGxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGl0ZW1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCBjYWxsXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uKGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gY2FsbGVyW2NhbGxbMF1dLmFwcGx5KGNhbGxlciwgY2FsbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaXRlbVswXV0uYXBwbHkodGhpcywgaXRlbS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBleGVjdXRlKGFsaWFzX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKG90aGVyX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKHRyYWNraW5nX2NhbGxzLCB0aGlzKTtcbn07XG5cbi8vIHJlcXVlc3QgcXVldWVpbmcgdXRpbHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2JhdGNoZXJfY29uZmlncyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWV1ZV9wcmVmaXggPSAnX19tcHFfJyArIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICB2YXIgYXBpX3JvdXRlcyA9IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpO1xuICAgIHRoaXMuX2JhdGNoZXJfY29uZmlncyA9IHRoaXMuX2JhdGNoZXJfY29uZmlncyB8fCB7XG4gICAgICAgIGV2ZW50czoge3R5cGU6ICdldmVudHMnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1sndHJhY2snXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2V2J30sXG4gICAgICAgIHBlb3BsZToge3R5cGU6ICdwZW9wbGUnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1snZW5nYWdlJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19wcCd9LFxuICAgICAgICBncm91cHM6IHt0eXBlOiAnZ3JvdXBzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2dyb3VwcyddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfZ3InfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2JhdGNoZXJfY29uZmlncztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0X2JhdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHZhciBiYXRjaGVyX2ZvciA9IF8uYmluZChmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0QmF0Y2hlcihcbiAgICAgICAgICAgICAgICBhdHRycy5xdWV1ZV9rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaWJDb25maWc6IHRoaXNbJ2NvbmZpZyddLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJyksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogXy5iaW5kKGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgYXR0cnMuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNiLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVNlbmRIb29rOiBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgYXR0cnMudHlwZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQWxsQmF0Y2hpbmdGdW5jOiBfLmJpbmQodGhpcy5zdG9wX2JhdGNoX3NlbmRlcnMsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICB1c2VQZXJzaXN0ZW5jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIGJhdGNoZXJfY29uZmlncyA9IHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ldmVudHMpLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MucGVvcGxlKSxcbiAgICAgICAgICAgIGdyb3VwczogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmdyb3VwcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbmNvZGVkX2RhdGEgPSBKU09OU3RyaW5naWZ5KGRhdGEpO1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2FwaV9wYXlsb2FkX2Zvcm1hdCcpID09PSBQQVlMT0FEX1RZUEVfQkFTRTY0KSB7XG4gICAgICAgIGVuY29kZWRfZGF0YSA9IF8uYmFzZTY0RW5jb2RlKGVuY29kZWRfZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7J2RhdGEnOiBlbmNvZGVkX2RhdGF9O1xufTtcblxuLy8gaW50ZXJuYWwgbWV0aG9kIGZvciBoYW5kbGluZyB0cmFjayB2cyBiYXRjaC1lbnF1ZXVlIGxvZ2ljXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX29yX2JhdGNoID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1bmNhdGVkX2RhdGEgPSBfLnRydW5jYXRlKG9wdGlvbnMuZGF0YSwgMjU1KTtcbiAgICB2YXIgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50O1xuICAgIHZhciBiYXRjaGVyID0gb3B0aW9ucy5iYXRjaGVyO1xuICAgIHZhciBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSA9IG9wdGlvbnMuc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9vcHRpb25zID0gb3B0aW9ucy5zZW5kX3JlcXVlc3Rfb3B0aW9ucyB8fCB7fTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IE5PT1BfRlVOQztcblxuICAgIHZhciByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHRydWU7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZW5kX3JlcXVlc3Rfb3B0aW9ucy5za2lwX2hvb2tzKSB7XG4gICAgICAgICAgICB0cnVuY2F0ZWRfZGF0YSA9IHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgb3B0aW9ucy50eXBlLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRydW5jYXRlZF9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicpO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZyh0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KHRydW5jYXRlZF9kYXRhKSxcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNhbGxiYWNrLCB0cnVuY2F0ZWRfZGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzICYmICFzaG91bGRfc2VuZF9pbW1lZGlhdGVseSkge1xuICAgICAgICBiYXRjaGVyLmVucXVldWUodHJ1bmNhdGVkX2RhdGEpLnRoZW4oZnVuY3Rpb24oc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soMSwgdHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgPSBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgJiYgdHJ1bmNhdGVkX2RhdGE7XG59O1xuXG4vKipcbiAqIFRyYWNrIGFuIGV2ZW50LiBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBhbmRcbiAqIGZyZXF1ZW50bHkgdXNlZCBNaXhwYW5lbCBmdW5jdGlvbi5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqICAgICAvLyB0cmFjayBhbiBldmVudCB1c2luZyBuYXZpZ2F0b3Iuc2VuZEJlYWNvblxuICogICAgIG1peHBhbmVsLnRyYWNrKCdMZWZ0IHBhZ2UnLCB7J2R1cmF0aW9uX3NlY29uZHMnOiAzNX0sIHt0cmFuc3BvcnQ6ICdzZW5kQmVhY29uJ30pO1xuICpcbiAqIFRvIHRyYWNrIGxpbmsgY2xpY2tzIG9yIGZvcm0gc3VibWlzc2lvbnMsIHNlZSB0cmFja19saW5rcygpIG9yIHRyYWNrX2Zvcm1zKCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhpcyB0cmFjayByZXF1ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyYW5zcG9ydF0gVHJhbnNwb3J0IG1ldGhvZCBmb3IgbmV0d29yayByZXF1ZXN0ICgneGhyJyBvciAnc2VuZEJlYWNvbicpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZW5kX2ltbWVkaWF0ZWx5XSBXaGV0aGVyIHRvIGJ5cGFzcyBiYXRjaGluZy9xdWV1ZWluZyBhbmQgc2VuZCB0cmFjayByZXF1ZXN0IGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2sgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHJhbnNwb3J0ID0gb3B0aW9uc1sndHJhbnNwb3J0J107IC8vIGV4dGVybmFsIEFQSSwgZG9uJ3QgbWluaWZ5ICd0cmFuc3BvcnQnIHByb3BcbiAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0ID0gdHJhbnNwb3J0OyAvLyAndHJhbnNwb3J0JyBwcm9wIG5hbWUgY2FuIGJlIG1pbmlmaWVkIGludGVybmFsbHlcbiAgICB9XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9uc1snc2VuZF9pbW1lZGlhdGVseSddO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBOT09QX0ZVTkM7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudHJhY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgcHJvcGVydGllc1sndG9rZW4nXSA9IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIC8vIHNldCAkZHVyYXRpb24gaWYgdGltZV9ldmVudCB3YXMgcHJldmlvdXNseSBjYWxsZWQgZm9yIHRoaXMgZXZlbnRcbiAgICB2YXIgc3RhcnRfdGltZXN0YW1wID0gdGhpc1sncGVyc2lzdGVuY2UnXS5yZW1vdmVfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSk7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHN0YXJ0X3RpbWVzdGFtcCkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uX2luX21zID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lc3RhbXA7XG4gICAgICAgIHByb3BlcnRpZXNbJyRkdXJhdGlvbiddID0gcGFyc2VGbG9hdCgoZHVyYXRpb25faW5fbXMgLyAxMDAwKS50b0ZpeGVkKDMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG5cbiAgICB2YXIgbWFya2V0aW5nX3Byb3BlcnRpZXMgPSB0aGlzLmdldF9jb25maWcoJ3RyYWNrX21hcmtldGluZycpXG4gICAgICAgID8gXy5pbmZvLm1hcmtldGluZ1BhcmFtcygpXG4gICAgICAgIDoge307XG5cbiAgICAvLyBub3RlOiBleHRlbmQgd3JpdGVzIHRvIHRoZSBmaXJzdCBvYmplY3QsIHNvIGxldHMgbWFrZSBzdXJlIHdlXG4gICAgLy8gZG9uJ3Qgd3JpdGUgdG8gdGhlIHBlcnNpc3RlbmNlIHByb3BlcnRpZXMgb2JqZWN0IGFuZCBpbmZvXG4gICAgLy8gcHJvcGVydGllcyBvYmplY3QgYnkgcGFzc2luZyBpbiBhIG5ldyBvYmplY3RcblxuICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzIHdpdGggcGFnZXZpZXcgaW5mbyBhbmQgc3VwZXItcHJvcGVydGllc1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wcm9wZXJ0aWVzKHsnbXBfbG9hZGVyJzogdGhpcy5nZXRfY29uZmlnKCdtcF9sb2FkZXInKX0pLFxuICAgICAgICBtYXJrZXRpbmdfcHJvcGVydGllcyxcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5wcm9wZXJ0aWVzKCksXG4gICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyxcbiAgICAgICAgdGhpcy5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcygpLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHZhciBwcm9wZXJ0eV9ibGFja2xpc3QgPSB0aGlzLmdldF9jb25maWcoJ3Byb3BlcnR5X2JsYWNrbGlzdCcpO1xuICAgIGlmIChfLmlzQXJyYXkocHJvcGVydHlfYmxhY2tsaXN0KSkge1xuICAgICAgICBfLmVhY2gocHJvcGVydHlfYmxhY2tsaXN0LCBmdW5jdGlvbihibGFja2xpc3RlZF9wcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJvcGVydGllc1tibGFja2xpc3RlZF9wcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3BlcnR5X2JsYWNrbGlzdCBjb25maWc6ICcgKyBwcm9wZXJ0eV9ibGFja2xpc3QpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAnZXZlbnQnOiBldmVudF9uYW1lLFxuICAgICAgICAncHJvcGVydGllcyc6IHByb3BlcnRpZXNcbiAgICB9O1xuICAgIHZhciByZXQgPSB0aGlzLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdldmVudHMnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgdGhpcy5nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ3RyYWNrJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMsXG4gICAgICAgIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5OiBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSxcbiAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnM6IG9wdGlvbnNcbiAgICB9LCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcmV0O1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIGN1cnJlbnQgdXNlciBpbnRvIG9uZS9tYW55IGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCBbJ21peHBhbmVsJywgJ2dvb2dsZSddKSAvLyBhbiBhcnJheSBvZiBJRHNcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgMTI4NzQ2MzEyKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xOdW1iZXJ9IGdyb3VwX2lkcyBBbiBhcnJheSBvZiBncm91cCBJRHMsIG9yIGEgc2luZ3VsYXIgZ3JvdXAgSURcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShncm91cF9pZHMpKSB7XG4gICAgICAgIGdyb3VwX2lkcyA9IFtncm91cF9pZHNdO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIHByb3BbZ3JvdXBfa2V5XSA9IGdyb3VwX2lkcztcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5zZXQoZ3JvdXBfa2V5LCBncm91cF9pZHMsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIEFkZCBhIG5ldyBncm91cCBmb3IgdGhpcyB1c2VyLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLmFkZF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7Kn0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjaykge1xuICAgIHZhciBvbGRfdmFsdWVzID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIGlmIChvbGRfdmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcFtncm91cF9rZXldID0gW2dyb3VwX2lkXTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2xkX3ZhbHVlcy5pbmRleE9mKGdyb3VwX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZXMucHVzaChncm91cF9pZCk7XG4gICAgICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBvbGRfdmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10udW5pb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgZ3JvdXAgZnJvbSB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwucmVtb3ZlX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZSA9IHRoaXMuZ2V0X3Byb3BlcnR5KGdyb3VwX2tleSk7XG4gICAgLy8gaWYgdGhlIHZhbHVlIGRvZXNuJ3QgZXhpc3QsIHRoZSBwZXJzaXN0ZW50IHN0b3JlIGlzIHVuY2hhbmdlZFxuICAgIGlmIChvbGRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaWR4ID0gb2xkX3ZhbHVlLmluZGV4T2YoZ3JvdXBfaWQpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoe2dyb3VwX2tleTogb2xkX3ZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZF92YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcihncm91cF9rZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5yZW1vdmUoZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQgd2l0aCBzcGVjaWZpYyBncm91cHMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwudHJhY2tfd2l0aF9ncm91cHMoJ3B1cmNoYXNlJywgeydwcm9kdWN0JzogJ2lwaG9uZSd9LCB7J1VuaXZlcnNpdHknOiBbJ1VDQicsICdVQ0xBJ119KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcgKHNlZSBgbWl4cGFuZWwudHJhY2soKWApXG4gKiBAcGFyYW0ge09iamVjdD19IGdyb3VwcyBBbiBvYmplY3QgbWFwcGluZyBncm91cCBuYW1lIGtleXMgdG8gb25lIG9yIG1vcmUgdmFsdWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHMgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJhY2tpbmdfcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyB8fCB7fSk7XG4gICAgXy5lYWNoKGdyb3VwcywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAodiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNraW5nX3Byb3BzW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKGV2ZW50X25hbWUsIHRyYWNraW5nX3Byb3BzLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9jcmVhdGVfbWFwX2tleSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgcmV0dXJuIGdyb3VwX2tleSArICdfJyArIEpTT04uc3RyaW5naWZ5KGdyb3VwX2lkKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcmVtb3ZlX2dyb3VwX2Zyb21fY2FjaGUgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRfZ3JvdXBzW3RoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpXTtcbn07XG5cbi8qKlxuICogTG9vayB1cCByZWZlcmVuY2UgdG8gYSBNaXhwYW5lbCBncm91cFxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoZ3JvdXBfa2V5LCBncm91cF9pZClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHtPYmplY3R9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHJldHVybnMge09iamVjdH0gQSBNaXhwYW5lbEdyb3VwIGlkZW50aWZpZXJcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cCA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgdmFyIG1hcF9rZXkgPSB0aGlzLl9jcmVhdGVfbWFwX2tleShncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jYWNoZWRfZ3JvdXBzW21hcF9rZXldO1xuICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkIHx8IGdyb3VwLl9ncm91cF9rZXkgIT09IGdyb3VwX2tleSB8fCBncm91cC5fZ3JvdXBfaWQgIT09IGdyb3VwX2lkKSB7XG4gICAgICAgIGdyb3VwID0gbmV3IE1peHBhbmVsR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAuX2luaXQodGhpcywgZ3JvdXBfa2V5LCBncm91cF9pZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV0gPSBncm91cDtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xufTtcblxuLyoqXG4gKiBUcmFjayBhIGRlZmF1bHQgTWl4cGFuZWwgcGFnZSB2aWV3IGV2ZW50LCB3aGljaCBpbmNsdWRlcyBleHRyYSBkZWZhdWx0IGV2ZW50IHByb3BlcnRpZXMgdG9cbiAqIGltcHJvdmUgcGFnZSB2aWV3IGRhdGEuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBhIGRlZmF1bHQgJG1wX3dlYl9wYWdlX3ZpZXcgZXZlbnRcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldygpO1xuICpcbiAqICAgICAvLyB0cmFjayBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGVydGllc1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsnYWJfdGVzdF92YXJpYW50JzogJ2NhcmQtbGF5b3V0LWInfSk7XG4gKlxuICogICAgIC8vIGV4YW1wbGUgYXBwcm9hY2ggdG8gdHJhY2sgcGFnZSB2aWV3cyBvbiBkaWZmZXJlbnQgcGFnZSB0eXBlcyBhcyBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ3ByaWNpbmcnfSk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2hvbWVwYWdlJ30pO1xuICpcbiAqICAgICAvLyBVTkNPTU1PTjogVHJhY2tpbmcgYSBwYWdlIHZpZXcgZXZlbnQgd2l0aCBhIGN1c3RvbSBldmVudF9uYW1lIG9wdGlvbi4gTk9UIGV4cGVjdGVkIHRvIGJlIHVzZWQgZm9yXG4gKiAgICAgLy8gaW5kaXZpZHVhbCBwYWdlcyBvbiB0aGUgc2FtZSBzaXRlIG9yIHByb2R1Y3QuIFVzZSBjYXNlcyBmb3IgY3VzdG9tIGV2ZW50X25hbWUgbWF5IGJlIHBhZ2VcbiAqICAgICAvLyB2aWV3cyBvbiBkaWZmZXJlbnQgcHJvZHVjdHMgb3IgaW50ZXJuYWwgYXBwbGljYXRpb25zIHRoYXQgYXJlIGNvbnNpZGVyZWQgY29tcGxldGVseSBzZXBhcmF0ZVxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdjdXN0b21lci1zZWFyY2gnfSwgeydldmVudF9uYW1lJzogJ1tpbnRlcm5hbF0gQWRtaW4gUGFnZSBWaWV3J30pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGUgYGNvbmZpZy50cmFja19wYWdldmlld2Agb3B0aW9uIGZvciA8YSBocmVmPVwiI21peHBhbmVsaW5pdFwiPm1peHBhbmVsLmluaXQoKTwvYT5cbiAqIG1heSBiZSB0dXJuZWQgb24gZm9yIHRyYWNraW5nIHBhZ2UgbG9hZHMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAgICAgLy8gdHJhY2sgb25seSBwYWdlIGxvYWRzXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6IHRydWV9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMgaW4gYW55IG1hbm5lclxuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAnZnVsbC11cmwnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIFVSTCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgY2hhbmdlcyBpbiB0aGUgaGFzaCBwYXJ0XG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIHBhdGggY2hhbmdlcywgaWdub3JpbmcgYW55IHF1ZXJ5IHBhcmFtZXRlciBvciBoYXNoIGNoYW5nZXNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgnfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBvcHRpb25hbCBzZXQgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIHNlbmQgd2l0aCB0aGUgcGFnZSB2aWV3IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBhZ2UgdmlldyB0cmFja2luZyBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXZlbnRfbmFtZV0gLSBBbHRlcm5hdGUgbmFtZSBmb3IgdGhlIHRyYWNraW5nIGV2ZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxPYmplY3R9IElmIHRoZSB0cmFja2luZyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhdGVkL3F1ZXVlZCwgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSB0cmFja2luZyBwYXlsb2FkIHNlbnQgdG8gdGhlIEFQSSBzZXJ2ZXIgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBldmVudF9uYW1lID0gb3B0aW9uc1snZXZlbnRfbmFtZSddIHx8ICckbXBfd2ViX3BhZ2Vfdmlldyc7XG5cbiAgICB2YXIgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAgXy5pbmZvLm1wUGFnZVZpZXdQcm9wZXJ0aWVzKCksXG4gICAgICAgIF8uaW5mby5jYW1wYWlnblBhcmFtcygpLFxuICAgICAgICBfLmluZm8uY2xpY2tQYXJhbXMoKVxuICAgICk7XG5cbiAgICB2YXIgZXZlbnRfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgZXZlbnRfcHJvcGVydGllcyk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBjbGlja3Mgb24gYSBzZXQgb2YgZG9jdW1lbnQgZWxlbWVudHMuIFNlbGVjdG9yIG11c3QgYmUgYVxuICogdmFsaWQgcXVlcnkuIEVsZW1lbnRzIG11c3QgZXhpc3Qgb24gdGhlIHBhZ2UgYXQgdGhlIHRpbWUgdHJhY2tfbGlua3MgaXMgY2FsbGVkLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgY2xpY2sgZm9yIGxpbmsgaWQgI25hdlxuICogICAgIG1peHBhbmVsLnRyYWNrX2xpbmtzKCcjbmF2JywgJ0NsaWNrZWQgTmF2IExpbmsnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgTWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZC4gSWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIEEgcHJvcGVydGllcyBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGljdGlvbmFyeSBvZiBwcm9wZXJ0aWVzIHdoZW4gcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgTGlua1RyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRyYWNrIGZvcm0gc3VibWlzc2lvbnMuIFNlbGVjdG9yIG11c3QgYmUgYSB2YWxpZCBxdWVyeS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIHN1Ym1pc3Npb24gZm9yIGZvcm0gaWQgJ3JlZ2lzdGVyJ1xuICogICAgIG1peHBhbmVsLnRyYWNrX2Zvcm1zKCcjcmVnaXN0ZXInLCAnQ3JlYXRlZCBBY2NvdW50Jyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIG1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQsIGlmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBUaGlzIGNhbiBiZSBhIHNldCBvZiBwcm9wZXJ0aWVzLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBwcm9wZXJ0aWVzIGFmdGVyIGJlaW5nIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2Zvcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIEZvcm1UcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUaW1lIGFuIGV2ZW50IGJ5IGluY2x1ZGluZyB0aGUgdGltZSBiZXR3ZWVuIHRoaXMgY2FsbCBhbmQgYVxuICogbGF0ZXIgJ3RyYWNrJyBjYWxsIGZvciB0aGUgc2FtZSBldmVudCBpbiB0aGUgcHJvcGVydGllcyBzZW50XG4gKiB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRpbWUgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudGltZV9ldmVudCgnUmVnaXN0ZXJlZCcpO1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqIFdoZW4gY2FsbGVkIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgdGhlIG5leHQgdHJhY2sgY2FsbCBmb3IgdGhhdCBldmVudFxuICogbmFtZSB3aWxsIGluY2x1ZGUgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRoZSAndGltZV9ldmVudCcgYW5kICd0cmFjaydcbiAqIGNhbGxzLiBUaGlzIHZhbHVlIGlzIHN0b3JlZCBhcyBzZWNvbmRzIGluIHRoZSAnJGR1cmF0aW9uJyBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50aW1lX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRpbWVfZXZlbnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSwgIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbn07XG5cbnZhciBSRUdJU1RFUl9ERUZBVUxUUyA9IHtcbiAgICAncGVyc2lzdGVudCc6IHRydWVcbn07XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBvcHRpb25zIHBhcmFtIGZvciByZWdpc3RlciBtZXRob2RzLCBtYWludGFpbmluZ1xuICogbGVnYWN5IHN1cHBvcnQgZm9yIHBsYWluIFwiZGF5c1wiIHBhcmFtIGluc3RlYWQgb2Ygb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gJ2RheXMnIG9wdGlvbiAoTnVtYmVyKSwgb3IgT3B0aW9ucyBvYmplY3QgZm9yIHJlZ2lzdGVyIG1ldGhvZHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKi9cbnZhciBvcHRpb25zX2Zvcl9yZWdpc3RlciA9IGZ1bmN0aW9uKGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChfLmlzT2JqZWN0KGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRheXNfb3Jfb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsnZGF5cyc6IGRheXNfb3Jfb3B0aW9uc307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gXy5leHRlbmQoe30sIFJFR0lTVEVSX0RFRkFVTFRTLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcywgd2hpY2ggYXJlIGluY2x1ZGVkIHdpdGggYWxsXG4gKiBldmVudHMuIFRoaXMgd2lsbCBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgJ0dlbmRlcicgYXMgYSBzdXBlciBwcm9wZXJ0eVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnR2VuZGVyJzogJ0ZlbWFsZSd9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgc2V2ZXJhbCBzdXBlciBwcm9wZXJ0aWVzIHdoZW4gYSB1c2VyIHNpZ25zIHVwXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoe1xuICogICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbScsXG4gKiAgICAgICAgICdBY2NvdW50IFR5cGUnOiAnRnJlZSdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J05hbWUnOiAnUGF0J30sIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcihwcm9wcywgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsIHByb3BzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMgb25seSBvbmNlLiBUaGlzIHdpbGwgbm90XG4gKiBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2UgcmVnaXN0ZXIoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIGEgc3VwZXIgcHJvcGVydHkgZm9yIHRoZSBmaXJzdCB0aW1lIG9ubHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25jZSwgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IGludGVyYWN0aW9uIHRpbWUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9LCAnTm9uZScsIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiBkZWZhdWx0X3ZhbHVlIGlzIHNwZWNpZmllZCwgY3VycmVudCBzdXBlciBwcm9wZXJ0aWVzXG4gKiB3aXRoIHRoYXQgdmFsdWUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSBWYWx1ZSB0byBvdmVycmlkZSBpZiBhbHJlYWR5IHNldCBpbiBzdXBlciBwcm9wZXJ0aWVzIChleDogJ0ZhbHNlJykgRGVmYXVsdDogJ05vbmUnXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcl9vbmNlKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGEgc3VwZXIgcHJvcGVydHkgc3RvcmVkIHdpdGggdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBsb29rIGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udW5yZWdpc3Rlcihwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wZXJ0eV07XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZWdpc3Rlcl9zaW5nbGUgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHByb3BzW3Byb3BdID0gdmFsdWU7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wcyk7XG59O1xuXG4vKipcbiAqIElkZW50aWZ5IGEgdXNlciB3aXRoIGEgdW5pcXVlIElEIHRvIHRyYWNrIHVzZXIgYWN0aXZpdHkgYWNyb3NzXG4gKiBkZXZpY2VzLCB0aWUgYSB1c2VyIHRvIHRoZWlyIGV2ZW50cywgYW5kIGNyZWF0ZSBhIHVzZXIgcHJvZmlsZS5cbiAqIElmIHlvdSBuZXZlciBjYWxsIHRoaXMgbWV0aG9kLCB1bmlxdWUgdmlzaXRvcnMgYXJlIHRyYWNrZWQgdXNpbmdcbiAqIGEgVVVJRCBnZW5lcmF0ZWQgdGhlIGZpcnN0IHRpbWUgdGhleSB2aXNpdCB0aGUgc2l0ZS5cbiAqXG4gKiBDYWxsIGlkZW50aWZ5IHdoZW4geW91IGtub3cgdGhlIGlkZW50aXR5IG9mIHRoZSBjdXJyZW50IHVzZXIsXG4gKiB0eXBpY2FsbHkgYWZ0ZXIgbG9naW4gb3Igc2lnbnVwLiBXZSByZWNvbW1lbmQgYWdhaW5zdCB1c2luZ1xuICogaWRlbnRpZnkgZm9yIGFub255bW91cyB2aXNpdG9ycyB0byB5b3VyIHNpdGUuXG4gKlxuICogIyMjIE5vdGVzOlxuICogSWYgeW91ciBwcm9qZWN0IGhhc1xuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgaWRlbnRpZnkgbWV0aG9kIHdpbGwgY29ubmVjdCBwcmUtIGFuZFxuICogcG9zdC1hdXRoZW50aWNhdGlvbiBldmVudHMgd2hlbiBhcHByb3ByaWF0ZS5cbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZSBJRCBNZXJnZSBlbmFibGVkLCBpZGVudGlmeSB3aWxsXG4gKiBjaGFuZ2UgdGhlIHVzZXIncyBsb2NhbCBkaXN0aW5jdF9pZCB0byB0aGUgdW5pcXVlIElEIHlvdSBwYXNzLlxuICogRXZlbnRzIHRyYWNrZWQgcHJpb3IgdG8gYXV0aGVudGljYXRpb24gd2lsbCBub3QgYmUgY29ubmVjdGVkXG4gKiB0byB0aGUgc2FtZSB1c2VyIGlkZW50aXR5LiBJZiBJRCBNZXJnZSBpcyBkaXNhYmxlZCwgYWxpYXMgY2FuXG4gKiBiZSB1c2VkIHRvIGNvbm5lY3QgcHJlLSBhbmQgcG9zdC1yZWdpc3RyYXRpb24gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pcXVlX2lkXSBBIHN0cmluZyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSB1c2VyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkaXN0aW5jdF9pZCBjdXJyZW50bHkgaW4gdGhlIHBlcnNpc3RlbnQgc3RvcmUgKGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UpIHdpbGwgYmUgdXNlZC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24oXG4gICAgbmV3X2Rpc3RpbmN0X2lkLCBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgLy8gIF9zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0IHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FkZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhZGQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYXBwZW5kX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFwcGVuZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9zZXRfb25jZV9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXRfb25jZSBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bmlvbl9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bmlvbiBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bnNldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bnNldCBxdWV1ZSBpcyBmbHVzaGVkXG5cbiAgICB2YXIgcHJldmlvdXNfZGlzdGluY3RfaWQgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgJiYgcHJldmlvdXNfZGlzdGluY3RfaWQgIT09IG5ld19kaXN0aW5jdF9pZCkge1xuICAgICAgICAvLyB3ZSBhbGxvdyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBpZiBwcmV2aW91cyBkaXN0aW5jdF9pZCBpcyBzYW1lIGFzIG5ld19kaXN0aW5jdF9pZFxuICAgICAgICAvLyBzbyB0aGF0IHlvdSBjYW4gZm9yY2UgZmx1c2ggcGVvcGxlIHVwZGF0ZXMgZm9yIGFub255bW91cyBwcm9maWxlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfZGlzdGluY3RfaWQgPT09ICdzdHJpbmcnICYmIG5ld19kaXN0aW5jdF9pZC5pbmRleE9mKERFVklDRV9JRF9QUkVGSVgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignZGlzdGluY3RfaWQgY2Fubm90IGhhdmUgJGRldmljZTogcHJlZml4Jyk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7JyR1c2VyX2lkJzogbmV3X2Rpc3RpbmN0X2lkfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpKSB7XG4gICAgICAgIC8vIFRoZSBwZXJzaXN0ZWQgZGlzdGluY3QgaWQgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgZGV2aWNlIGlkIGF0IGFsbFxuICAgICAgICAvLyBpdCBtaWdodCBiZSBhIGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyIGZyb20gYmVmb3JlXG4gICAgICAgIHZhciBkZXZpY2VfaWQgPSBwcmV2aW91c19kaXN0aW5jdF9pZDtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc6IHRydWUsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IGRldmljZV9pZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpZnkgb25seSBjaGFuZ2VzIHRoZSBkaXN0aW5jdCBpZCBpZiBpdCBkb2Vzbid0IG1hdGNoIGVpdGhlciB0aGUgZXhpc3Rpbmcgb3IgdGhlIGFsaWFzO1xuICAgIC8vIGlmIGl0J3MgbmV3LCBibG93IGF3YXkgdGhlIGFsaWFzIGFzIHdlbGwuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQgJiYgbmV3X2Rpc3RpbmN0X2lkICE9PSB0aGlzLmdldF9wcm9wZXJ0eShBTElBU19JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcihBTElBU19JRF9LRVkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyBGbHVzaCBhbnkgcXVldWVkIHVwIHBlb3BsZSByZXF1ZXN0c1xuICAgIHRoaXNbJ3Blb3BsZSddLl9mbHVzaChfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrKTtcblxuICAgIC8vIHNlbmQgYW4gJGlkZW50aWZ5IGV2ZW50IGFueSB0aW1lIHRoZSBkaXN0aW5jdF9pZCBpcyBjaGFuZ2luZyAtIGxvZ2ljIG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyB3aWxsIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBkbyBhbnl0aGluZyB3aXRoIGl0LlxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIHRoaXMudHJhY2soJyRpZGVudGlmeScsIHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZCxcbiAgICAgICAgICAgICckYW5vbl9kaXN0aW5jdF9pZCc6IHByZXZpb3VzX2Rpc3RpbmN0X2lkXG4gICAgICAgIH0sIHtza2lwX2hvb2tzOiB0cnVlfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgc3VwZXIgcHJvcGVydGllcyBhbmQgZ2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBkaXN0aW5jdF9pZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqIFVzZWZ1bCBmb3IgY2xlYXJpbmcgZGF0YSB3aGVuIGEgdXNlciBsb2dzIG91dC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5jbGVhcigpO1xuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgJ2Rpc3RpbmN0X2lkJzogREVWSUNFX0lEX1BSRUZJWCArIHV1aWQsXG4gICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgIH0sICcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlci4gVGhpcyBpcyBlaXRoZXIgdGhlIGlkIGF1dG9tYXRpY2FsbHlcbiAqIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeSBvciB0aGUgaWQgdGhhdCBoYXMgYmVlbiBwYXNzZWQgYnkgYSBjYWxsIHRvIGlkZW50aWZ5KCkuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9kaXN0aW5jdF9pZCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBzZXQgZGlzdGluY3RfaWQgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgZGlzdGluY3RfaWQgPSBtaXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X3Byb3BlcnR5KCdkaXN0aW5jdF9pZCcpO1xufTtcblxuLyoqXG4gKiBUaGUgYWxpYXMgbWV0aG9kIGNyZWF0ZXMgYW4gYWxpYXMgd2hpY2ggTWl4cGFuZWwgd2lsbCB1c2UgdG9cbiAqIHJlbWFwIG9uZSBpZCB0byBhbm90aGVyLiBNdWx0aXBsZSBhbGlhc2VzIGNhbiBwb2ludCB0byB0aGVcbiAqIHNhbWUgaWRlbnRpZmllci5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgdXNlIG9mIGFsaWFzOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUgaWQgYWxpYXNlcyB0byB0aGUgZXhpc3RpbmcgSURcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbiBhbHNvIGJlIGNoYWluZWQgLSB0aGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIGNoYWluIG5ld2VyX2lkIC0gbmV3X2lkIC0gZXhpc3RpbmdfaWRcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnbmV3X2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW5ub3QgcG9pbnQgdG8gbXVsdGlwbGUgaWRlbnRpZmllcnMgLSB0aGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHdpbGwgbm90IHdvcms6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyB0aGlzIGlzIGludmFsaWQgYXMgJ25ld19pZCcgYWxyZWFkeSBwb2ludHMgdG8gJ2V4aXN0aW5nX2lkJ1xuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnbmV3ZXJfaWQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmVcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gY2FsbCBhbGlhcyBvbmNlIHdoZW4gYSB1bmlxdWVcbiAqIElEIGlzIGZpcnN0IGNyZWF0ZWQgZm9yIGEgdXNlciAoZS5nLiwgd2hlbiBhIHVzZXIgZmlyc3QgcmVnaXN0ZXJzXG4gKiBmb3IgYW4gYWNjb3VudCkuIERvIG5vdCB1c2UgYWxpYXMgbXVsdGlwbGUgdGltZXMgZm9yIGEgc2luZ2xlXG4gKiB1c2VyIHdpdGhvdXQgSUQgTWVyZ2UgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWxpYXMgQSB1bmlxdWUgaWRlbnRpZmllciB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgdGhpcyB1c2VyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29yaWdpbmFsXSBUaGUgY3VycmVudCBpZGVudGlmaWVyIGJlaW5nIHVzZWQgZm9yIHRoaXMgdXNlci5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24oYWxpYXMsIG9yaWdpbmFsKSB7XG4gICAgLy8gSWYgdGhlICRwZW9wbGVfZGlzdGluY3RfaWQga2V5IGV4aXN0cyBpbiBwZXJzaXN0ZW5jZSwgdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgIC8vIG1peHBhbmVsLnBlb3BsZS5pZGVudGlmeSgpIGNhbGwgbWFkZSBmb3IgdGhpcyB1c2VyLiBJdCBpcyBWRVJZIEJBRCB0byBtYWtlIGFuIGFsaWFzIHdpdGhcbiAgICAvLyB0aGlzIElELCBhcyBpdCB3aWxsIGR1cGxpY2F0ZSB1c2Vycy5cbiAgICBpZiAoYWxpYXMgPT09IHRoaXMuZ2V0X3Byb3BlcnR5KFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhbGlhcyBmb3IgZXhpc3RpbmcgUGVvcGxlIHVzZXIgLSBhYm9ydGluZy4nKTtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3JpZ2luYWwpKSB7XG4gICAgICAgIG9yaWdpbmFsID0gdGhpcy5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICB9XG4gICAgaWYgKGFsaWFzICE9PSBvcmlnaW5hbCkge1xuICAgICAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoQUxJQVNfSURfS0VZLCBhbGlhcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKCckY3JlYXRlX2FsaWFzJywge1xuICAgICAgICAgICAgJ2FsaWFzJzogYWxpYXMsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBvcmlnaW5hbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBza2lwX2hvb2tzOiB0cnVlXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRmx1c2ggdGhlIHBlb3BsZSBxdWV1ZVxuICAgICAgICAgICAgX3RoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignYWxpYXMgbWF0Y2hlcyBjdXJyZW50IGRpc3RpbmN0X2lkIC0gc2tpcHBpbmcgYXBpIGNhbGwuJyk7XG4gICAgICAgIHRoaXMuaWRlbnRpZnkoYWxpYXMpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlIGEgc3RyaW5nIHRvIHJlY29nbml6ZSB0aGUgdXNlciBieS4gVGhlIHN0cmluZyBwYXNzZWQgdG9cbiAqIHRoaXMgbWV0aG9kIHdpbGwgYXBwZWFyIGluIHRoZSBNaXhwYW5lbCBTdHJlYW1zIHByb2R1Y3QgcmF0aGVyXG4gKiB0aGFuIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG5hbWUuIE5hbWUgdGFncyBkbyBub3QgaGF2ZSB0b1xuICogYmUgdW5pcXVlLlxuICpcbiAqIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlIGluY2x1ZGVkIGluIFN0cmVhbXMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZV90YWcgQSBodW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdXNlclxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm5hbWVfdGFnID0gZnVuY3Rpb24obmFtZV90YWcpIHtcbiAgICB0aGlzLl9yZWdpc3Rlcl9zaW5nbGUoJ21wX25hbWVfdGFnJywgbmFtZV90YWcpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBtaXhwYW5lbCBsaWJyYXJ5IGluc3RhbmNlLlxuICpcbiAqIFRoZSBkZWZhdWx0IGNvbmZpZyBpczpcbiAqXG4gKiAgICAge1xuICogICAgICAgLy8gaG9zdCBmb3IgcmVxdWVzdHMgKGN1c3RvbWl6YWJsZSBmb3IgZS5nLiBhIGxvY2FsIHByb3h5KVxuICogICAgICAgYXBpX2hvc3Q6ICdodHRwczovL2FwaS1qcy5taXhwYW5lbC5jb20nLFxuICpcbiAqICAgICAgIC8vIGVuZHBvaW50cyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHJlcXVlc3RzXG4gKiAgICAgICBhcGlfcm91dGVzOiB7XG4gKiAgICAgICAgIHRyYWNrOiAndHJhY2svJyxcbiAqICAgICAgICAgZW5nYWdlOiAnZW5nYWdlLycsXG4gKiAgICAgICAgIGdyb3VwczogJ2dyb3Vwcy8nLFxuICogICAgICAgfVxuICpcbiAqICAgICAgIC8vIEhUVFAgbWV0aG9kIGZvciB0cmFja2luZyByZXF1ZXN0c1xuICogICAgICAgYXBpX21ldGhvZDogJ1BPU1QnXG4gKlxuICogICAgICAgLy8gdHJhbnNwb3J0IGZvciBzZW5kaW5nIHJlcXVlc3RzICgnWEhSJyBvciAnc2VuZEJlYWNvbicpXG4gKiAgICAgICAvLyBOQjogc2VuZEJlYWNvbiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzY2VuYXJpb3Mgc3VjaCBhc1xuICogICAgICAgLy8gcGFnZSB1bmxvYWQgd2hlcmUgYSBcImJlc3QtZWZmb3J0XCIgYXR0ZW1wdCB0byBzZW5kIGlzXG4gKiAgICAgICAvLyBhY2NlcHRhYmxlOyB0aGUgc2VuZEJlYWNvbiBBUEkgZG9lcyBub3Qgc3VwcG9ydCBjYWxsYmFja3NcbiAqICAgICAgIC8vIG9yIGFueSB3YXkgdG8ga25vdyB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LiBNaXhwYW5lbFxuICogICAgICAgLy8gdHJhY2tpbmcgdmlhIHNlbmRCZWFjb24gd2lsbCBub3Qgc3VwcG9ydCBhbnkgZXZlbnQtXG4gKiAgICAgICAvLyBiYXRjaGluZyBvciByZXRyeSBtZWNoYW5pc21zLlxuICogICAgICAgYXBpX3RyYW5zcG9ydDogJ1hIUidcbiAqXG4gKiAgICAgICAvLyByZXF1ZXN0LWJhdGNoaW5nL3F1ZXVlaW5nL3JldHJ5XG4gKiAgICAgICBiYXRjaF9yZXF1ZXN0czogdHJ1ZSxcbiAqXG4gKiAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBldmVudHMvdXBkYXRlcyB0byBzZW5kIGluIGEgc2luZ2xlXG4gKiAgICAgICAvLyBuZXR3b3JrIHJlcXVlc3RcbiAqICAgICAgIGJhdGNoX3NpemU6IDUwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gc2VuZGluZyBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXM6IDUwMDAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIG5ldHdvcmsgcmVzcG9uc2VzIHRvIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICAvLyBiZWZvcmUgdGhleSBhcmUgY29uc2lkZXJlZCB0aW1lZC1vdXQgYW5kIHJldHJpZWRcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RfdGltZW91dF9tczogOTAwMDAsXG4gKlxuICogICAgICAgLy8gb3ZlcnJpZGUgdmFsdWUgZm9yIGNvb2tpZSBkb21haW4sIG9ubHkgdXNlZnVsIGZvciBlbnN1cmluZ1xuICogICAgICAgLy8gY29ycmVjdCBjcm9zcy1zdWJkb21haW4gY29va2llcyBvbiB1bnVzdWFsIGRvbWFpbnMgbGlrZVxuICogICAgICAgLy8gc3ViZG9tYWluLm1haW5zaXRlLmF2b2NhdC5mcjsgTkIgdGhpcyBjYW5ub3QgYmUgdXNlZCB0b1xuICogICAgICAgLy8gc2V0IGNvb2tpZXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgb3JpZ2luXG4gKiAgICAgICBjb29raWVfZG9tYWluOiAnJ1xuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgY29va2llIGV4cGlyYXRpb24gKGluIGRheXMpXG4gKiAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzY1XG4gKlxuICogICAgICAgLy8gaWYgdHJ1ZSwgY29va2llIHdpbGwgYmUgc2V0IHdpdGggU2FtZVNpdGU9Tm9uZTsgU2VjdXJlXG4gKiAgICAgICAvLyB0aGlzIGlzIG9ubHkgdXNlZnVsIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgbGlrZSBlbWJlZGRlZFxuICogICAgICAgLy8gM3JkLXBhcnR5IGlmcmFtZXMgdGhhdCBzZXQgdXAgYSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgICAgY3Jvc3Nfc2l0ZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBzcGFuIHN1YmRvbWFpbnNcbiAqICAgICAgIGNyb3NzX3N1YmRvbWFpbl9jb29raWU6IHRydWVcbiAqXG4gKiAgICAgICAvLyBkZWJ1ZyBtb2RlXG4gKiAgICAgICBkZWJ1ZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIHRoZSBtaXhwYW5lbCBjb29raWUgb3IgbG9jYWxTdG9yYWdlIGVudHJ5XG4gKiAgICAgICAvLyB3aWxsIGJlIGRlbGV0ZWQsIGFuZCBubyB1c2VyIHBlcnNpc3RlbmNlIHdpbGwgdGFrZSBwbGFjZVxuICogICAgICAgZGlzYWJsZV9wZXJzaXN0ZW5jZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIE1peHBhbmVsIHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqICAgICAgIC8vIENpdHksIFJlZ2lvbiBhbmQgQ291bnRyeSBkYXRhIHVzaW5nIHRoZSBJUCBhZGRyZXNzIG9mXG4gKiAgICAgICAvL3RoZSBjbGllbnRcbiAqICAgICAgIGlwOiB0cnVlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiB0cmFja2luZyBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIGJyb3dzZXIgZGF0YSBzdG9yYWdlIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHMgLSBjb29raWVcbiAqICAgICAgIC8vIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogICAgICAgb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlOiAnbG9jYWxTdG9yYWdlJ1xuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZSB0aGUgbmFtZSBvZiBjb29raWUvbG9jYWxTdG9yYWdlIHNldCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXg6IG51bGxcbiAqXG4gKiAgICAgICAvLyB0eXBlIG9mIHBlcnNpc3RlbnQgc3RvcmUgZm9yIHN1cGVyIHByb3BlcnRpZXMgKGNvb2tpZS9cbiAqICAgICAgIC8vIGxvY2FsU3RvcmFnZSkgaWYgc2V0IHRvICdsb2NhbFN0b3JhZ2UnLCBhbnkgZXhpc3RpbmdcbiAqICAgICAgIC8vIG1peHBhbmVsIGNvb2tpZSB2YWx1ZSB3aXRoIHRoZSBzYW1lIHBlcnNpc3RlbmNlX25hbWVcbiAqICAgICAgIC8vIHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gbG9jYWxTdG9yYWdlIGFuZCBkZWxldGVkXG4gKiAgICAgICBwZXJzaXN0ZW5jZTogJ2Nvb2tpZSdcbiAqXG4gKiAgICAgICAvLyBuYW1lIGZvciBzdXBlciBwcm9wZXJ0aWVzIHBlcnNpc3RlbnQgc3RvcmVcbiAqICAgICAgIHBlcnNpc3RlbmNlX25hbWU6ICcnXG4gKlxuICogICAgICAgLy8gbmFtZXMgb2YgcHJvcGVydGllcy9zdXBlcnByb3BlcnRpZXMgd2hpY2ggc2hvdWxkIG5ldmVyXG4gKiAgICAgICAvLyBiZSBzZW50IHdpdGggdHJhY2soKSBjYWxsc1xuICogICAgICAgcHJvcGVydHlfYmxhY2tsaXN0OiBbXVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgbWl4cGFuZWwgY29va2llcyB3aWxsIGJlIG1hcmtlZCBhc1xuICogICAgICAgLy8gc2VjdXJlLCBtZWFuaW5nIHRoZXkgd2lsbCBvbmx5IGJlIHRyYW5zbWl0dGVkIG92ZXIgaHR0cHNcbiAqICAgICAgIHNlY3VyZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gZGlzYWJsZXMgZW5yaWNoaW5nIHVzZXIgcHJvZmlsZXMgd2l0aCBmaXJzdCB0b3VjaCBtYXJrZXRpbmcgZGF0YVxuICogICAgICAgc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIHRyYWNrX2xpbmtzIHdpbGxcbiAqICAgICAgIC8vIHdhaXQgZm9yIE1peHBhbmVsJ3Mgc2VydmVycyB0byByZXNwb25kXG4gKiAgICAgICB0cmFja19saW5rc190aW1lb3V0OiAzMDBcbiAqXG4gKiAgICAgICAvLyBhZGRzIGFueSBVVE0gcGFyYW1ldGVycyBhbmQgY2xpY2sgSURzIHByZXNlbnQgb24gdGhlIHBhZ2UgdG8gYW55IGV2ZW50cyBmaXJlZFxuICogICAgICAgdHJhY2tfbWFya2V0aW5nOiB0cnVlXG4gKlxuICogICAgICAgLy8gZW5hYmxlcyBhdXRvbWF0aWMgcGFnZSB2aWV3IHRyYWNraW5nIHVzaW5nIGRlZmF1bHQgcGFnZSB2aWV3IGV2ZW50cyB0aHJvdWdoXG4gKiAgICAgICAvLyB0aGUgdHJhY2tfcGFnZXZpZXcoKSBtZXRob2RcbiAqICAgICAgIHRyYWNrX3BhZ2V2aWV3OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGlmIHlvdSBzZXQgdXBncmFkZSB0byBiZSB0cnVlLCB0aGUgbGlicmFyeSB3aWxsIGNoZWNrIGZvclxuICogICAgICAgLy8gYSBjb29raWUgZnJvbSBvdXIgb2xkIGpzIGxpYnJhcnkgYW5kIGltcG9ydCBzdXBlclxuICogICAgICAgLy8gcHJvcGVydGllcyBmcm9tIGl0LCB0aGVuIHRoZSBvbGQgY29va2llIGlzIGRlbGV0ZWRcbiAqICAgICAgIC8vIFRoZSB1cGdyYWRlIGNvbmZpZyBvcHRpb24gb25seSB3b3JrcyBpbiB0aGUgaW5pdGlhbGl6YXRpb24sXG4gKiAgICAgICAvLyBzbyBtYWtlIHN1cmUgeW91IHNldCBpdCB3aGVuIHlvdSBjcmVhdGUgdGhlIGxpYnJhcnkuXG4gKiAgICAgICB1cGdyYWRlOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGV4dHJhIEhUVFAgcmVxdWVzdCBoZWFkZXJzIHRvIHNldCBmb3IgZWFjaCBBUEkgcmVxdWVzdCwgaW5cbiAqICAgICAgIC8vIHRoZSBmb3JtYXQgeydIZWFkZXItTmFtZSc6IHZhbHVlfVxuICogICAgICAgeGhyX2hlYWRlcnM6IHt9XG4gKlxuICogICAgICAgLy8gd2hldGhlciB0byBpZ25vcmUgb3IgcmVzcGVjdCB0aGUgd2ViIGJyb3dzZXIncyBEbyBOb3QgVHJhY2sgc2V0dGluZ1xuICogICAgICAgaWdub3JlX2RudDogZmFsc2VcbiAqICAgICB9XG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQSBkaWN0aW9uYXJ5IG9mIG5ldyBjb25maWd1cmF0aW9uIHZhbHVlcyB0byB1cGRhdGVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICBpZiAoXy5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ2NvbmZpZyddLCBjb25maWcpO1xuXG4gICAgICAgIHZhciBuZXdfYmF0Y2hfc2l6ZSA9IGNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgICAgICBpZiAobmV3X2JhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVyLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdwZXJzaXN0ZW5jZV9uYW1lJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydwZXJzaXN0ZW5jZV9uYW1lJ10gPSB0aGlzWydjb25maWcnXVsnY29va2llX25hbWUnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgICAgICB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9wZXJzaXN0ZW5jZSddID0gdGhpc1snY29uZmlnJ11bJ2Rpc2FibGVfY29va2llJ107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpc1sncGVyc2lzdGVuY2UnXSkge1xuICAgICAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfY29uZmlnKHRoaXNbJ2NvbmZpZyddKTtcbiAgICAgICAgfVxuICAgICAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgdGhpcy5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuXG4gICAgICAgIGlmICgnYXV0b2NhcHR1cmUnIGluIGNvbmZpZyAmJiB0aGlzLmF1dG9jYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jYXB0dXJlLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgY3VycmVudCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGlicmFyeS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihwcm9wX25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1snY29uZmlnJ11bcHJvcF9uYW1lXTtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBob29rIGZ1bmN0aW9uIGZyb20gY29uZmlnLCB3aXRoIHNhZmUgZGVmYXVsdCwgYW5kIHJ1biBpdFxuICogYWdhaW5zdCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9va19uYW1lIHdoaWNoIGhvb2sgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIHthbnl8bnVsbH0gcmV0dXJuIHZhbHVlIG9mIHVzZXItcHJvdmlkZWQgaG9vaywgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyByZXR1cm5lZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3J1bl9ob29rID0gZnVuY3Rpb24oaG9va19uYW1lKSB7XG4gICAgdmFyIHJldCA9ICh0aGlzWydjb25maWcnXVsnaG9va3MnXVtob29rX25hbWVdIHx8IElERU5USVRZX0ZVTkMpLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKGhvb2tfbmFtZSArICcgaG9vayBkaWQgbm90IHJldHVybiBhIHZhbHVlJyk7XG4gICAgICAgIHJldCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSBuYW1lZCBwcm9wZXJ0eV9uYW1lLiBJZiBubyBzdWNoXG4gKiBwcm9wZXJ0eSBpcyBzZXQsIGdldF9wcm9wZXJ0eSgpIHdpbGwgcmV0dXJuIHRoZSB1bmRlZmluZWQgdmFsdWUuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9wcm9wZXJ0eSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBncmFiIHZhbHVlIGZvciAndXNlcl9pZCcgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgdXNlcl9pZCA9IG1peHBhbmVsLmdldF9wcm9wZXJ0eSgndXNlcl9pZCcpO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5X25hbWUgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHlvdSB3YW50IHRvIHJldHJpZXZlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eV9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3BlcnNpc3RlbmNlJ10ubG9hZF9wcm9wKFtwcm9wZXJ0eV9uYW1lXSk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0X2NvbmZpZygnbmFtZScpO1xuICAgIGlmIChuYW1lICE9PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHtcbiAgICAgICAgbmFtZSA9IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9ldmVudF9pc19kaXNhYmxlZCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICByZXR1cm4gXy5pc0Jsb2NrZWRVQSh1c2VyQWdlbnQpIHx8XG4gICAgICAgIHRoaXMuX2ZsYWdzLmRpc2FibGVfYWxsX2V2ZW50cyB8fFxuICAgICAgICBfLmluY2x1ZGUodGhpcy5fX2Rpc2FibGVkX2V2ZW50cywgZXZlbnRfbmFtZSk7XG59O1xuXG4vLyBwZXJmb3JtIHNvbWUgaG91c2VrZWVwaW5nIGFyb3VuZCBHRFBSIG9wdC1pbi9vdXQgc3RhdGVcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgPSB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpID09PSAnbG9jYWxTdG9yYWdlJztcblxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG9wdC1pbi9vdXQgY29va2llcyB0byBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfaW5fdHJhY2tpbmcoeydlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkgJiYgdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7J2NsZWFyX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJyxcbiAgICAgICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBhbHJlYWR5IG9wdGVkIG91dCAtIGlmIHNvLCBjbGVhciAmIGRpc2FibGUgcGVyc2lzdGVuY2VcbiAgICBpZiAodGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWV9KTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgd2Ugc2hvdWxkIG9wdCBvdXQgYnkgZGVmYXVsdFxuICAgIC8vIG5vdGU6IHdlIGRvbid0IGNsZWFyIHBlcnNpc3RlbmNlIGhlcmUgYnkgZGVmYXVsdCBzaW5jZSBvcHQtb3V0IGRlZmF1bHQgc3RhdGUgaXMgb2Z0ZW5cbiAgICAvLyAgICAgICB1c2VkIGFzIGFuIGluaXRpYWwgc3RhdGUgd2hpbGUgR0RQUiBpbmZvcm1hdGlvbiBpcyBiZWluZyBjb2xsZWN0ZWRcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIChcbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnKSB8fCBfLmNvb2tpZS5nZXQoJ21wX29wdG91dCcpXG4gICAgKSkge1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUoJ21wX29wdG91dCcpO1xuICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoe1xuICAgICAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3BlcnNpc3RlbmNlX2J5X2RlZmF1bHQnKVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIHBlcnNpc3RlbmNlIGJhc2VkIG9uIG9wdGlvbnNcbiAqIG9ubHkgZW5hYmxlL2Rpc2FibGUgaWYgcGVyc2lzdGVuY2UgaXMgbm90IGFscmVhZHkgaW4gdGhpcyBzdGF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgYWxsIGRhdGEgc3RvcmVkIGJ5IHRoZSBzZGsgaW4gcGVyc2lzdGVuY2UgYW5kIGRpc2FibGUgaXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZGlzYWJsZWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snY2xlYXJfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2VuYWJsZV9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykgJiYgdGhpc1sncGVyc2lzdGVuY2UnXS5kaXNhYmxlZCAhPT0gZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnN0b3BfYmF0Y2hfc2VuZGVycygpO1xuICAgICAgICB0aGlzLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHN0YXJ0IGJhdGNoZXJzIGFmdGVyIG9wdC1pbiBpZiB0aGV5IGhhdmUgcHJldmlvdXNseSBiZWVuIHN0YXJ0ZWRcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgdW5pbnRlbnRpb25hbGx5IHN0YXJ0aW5nIHVwIGJhdGNoaW5nIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy5fYmF0Y2hlcnNfd2VyZV9zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGNhbGwgYSBiYXNlIGdkcHIgZnVuY3Rpb24gYWZ0ZXIgY29uc3RydWN0aW5nIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBhbmQgb3B0aW9ucyBhcmdzXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfY2FsbF9mdW5jID0gZnVuY3Rpb24oZnVuYywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICd0cmFjayc6IF8uYmluZCh0aGlzLnRyYWNrLCB0aGlzKSxcbiAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpLFxuICAgICAgICAnY29va2llX3ByZWZpeCc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4JyksXG4gICAgICAgICdjb29raWVfZXhwaXJhdGlvbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2V4cGlyYXRpb24nKSxcbiAgICAgICAgJ2Nyb3NzX3NpdGVfY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdjcm9zc19zaXRlX2Nvb2tpZScpLFxuICAgICAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZScpLFxuICAgICAgICAnY29va2llX2RvbWFpbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2RvbWFpbicpLFxuICAgICAgICAnc2VjdXJlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnc2VjdXJlX2Nvb2tpZScpLFxuICAgICAgICAnaWdub3JlX2RudCc6IHRoaXMuZ2V0X2NvbmZpZygnaWdub3JlX2RudCcpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBpZiBsb2NhbFN0b3JhZ2UgY2FuIGJlIHVzZWQgZm9yIHJlY29yZGluZyBvcHQgb3V0IHN0YXR1cywgZmFsbCBiYWNrIHRvIGNvb2tpZSBpZiBub3RcbiAgICBpZiAoIV8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSA9ICdjb29raWUnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jKHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKSwge1xuICAgICAgICB0cmFjazogb3B0aW9uc1sndHJhY2snXSxcbiAgICAgICAgdHJhY2tFdmVudE5hbWU6IG9wdGlvbnNbJ3RyYWNrX2V2ZW50X25hbWUnXSxcbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzOiBvcHRpb25zWyd0cmFja19wcm9wZXJ0aWVzJ10sXG4gICAgICAgIHBlcnNpc3RlbmNlVHlwZTogb3B0aW9uc1sncGVyc2lzdGVuY2VfdHlwZSddLFxuICAgICAgICBwZXJzaXN0ZW5jZVByZWZpeDogb3B0aW9uc1snY29va2llX3ByZWZpeCddLFxuICAgICAgICBjb29raWVEb21haW46IG9wdGlvbnNbJ2Nvb2tpZV9kb21haW4nXSxcbiAgICAgICAgY29va2llRXhwaXJhdGlvbjogb3B0aW9uc1snY29va2llX2V4cGlyYXRpb24nXSxcbiAgICAgICAgY3Jvc3NTaXRlQ29va2llOiBvcHRpb25zWydjcm9zc19zaXRlX2Nvb2tpZSddLFxuICAgICAgICBjcm9zc1N1YmRvbWFpbkNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddLFxuICAgICAgICBzZWN1cmVDb29raWU6IG9wdGlvbnNbJ3NlY3VyZV9jb29raWUnXSxcbiAgICAgICAgaWdub3JlRG50OiBvcHRpb25zWydpZ25vcmVfZG50J11cbiAgICB9KTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBpblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBpbiB3aXRoIHNwZWNpZmljIGV2ZW50IG5hbWUsIHByb3BlcnRpZXMsIGNvb2tpZSBjb25maWd1cmF0aW9uXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKHtcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfbmFtZTogJ1VzZXIgb3B0ZWQgaW4nLFxuICogICAgICAgICB0cmFja19ldmVudF9wcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSBGdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvbiAoZGVmYXVsdCBpcyB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgdHJhY2sgbWV0aG9kKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrX2V2ZW50X25hbWU9JG9wdF9pbl0gRXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrX3Byb3BlcnRpZXNdIFNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0SW4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXRcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dCB3aXRoIGRpZmZlcmVudCBjb29raWUgY29uZmlndXJhdGlvbiBmcm9tIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlbGV0ZV91c2VyPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIHRoZSBjdXJyZW50bHkgaWRlbnRpZmllZCB1c2VyJ3MgcHJvZmlsZSBhbmQgY2xlYXIgYWxsIGNoYXJnZXMgYWZ0ZXIgb3B0aW5nIHRoZSB1c2VyIG91dFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWUsXG4gICAgICAgICdkZWxldGVfdXNlcic6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIGRlbGV0ZSB1c2VyIGFuZCBjbGVhciBjaGFyZ2VzIHNpbmNlIHRoZXNlIG1ldGhvZHMgbWF5IGJlIGRpc2FibGVkIGJ5IG9wdC1vdXRcbiAgICBpZiAob3B0aW9uc1snZGVsZXRlX3VzZXInXSAmJiB0aGlzWydwZW9wbGUnXSAmJiB0aGlzWydwZW9wbGUnXS5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uZGVsZXRlX3VzZXIoKTtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uY2xlYXJfY2hhcmdlcygpO1xuICAgIH1cblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdE91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX2luID0gbWl4cGFuZWwuaGFzX29wdGVkX2luX3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9pbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LWluIHN0YXR1c1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZEluLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX291dCA9IG1peHBhbmVsLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX291dCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LW91dCBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkT3V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXMgd2l0aCBzcGVjaWZpYyBjb29raWUgY29uZmlndXJhdGlvbiAtIHNob3VsZCBtYXRjaFxuICogICAgIC8vIGNvbmZpZ3VyYXRpb24gdXNlZCB3aGVuIG9wdF9pbl90cmFja2luZy9vcHRfb3V0X3RyYWNraW5nIG1ldGhvZHMgd2VyZSBjYWxsZWQuXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoY2xlYXJPcHRJbk91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVwb3J0X2Vycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBjb25zb2xlJDEuZXJyb3IuYXBwbHkoY29uc29sZSQxLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuXG4vLyBNaXhwYW5lbExpYiBFeHBvcnRzXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2luaXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZXNldCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2Rpc2FibGUnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0aW1lX2V2ZW50J10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2snXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19saW5rcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3M7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2Zvcm1zJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3Jtcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfcGFnZXZpZXcnXSAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyX29uY2UnXSAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd1bnJlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaWRlbnRpZnknXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhbGlhcyddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ25hbWVfdGFnJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfcHJvcGVydHknXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZGlzdGluY3RfaWQnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX2luX3RyYWNraW5nJ10gICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnY2xlYXJfb3B0X2luX291dF90cmFja2luZyddICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2FkZF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlbW92ZV9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3dpdGhfZ3JvdXBzJ10gICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3Vwcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RhcnRfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3BfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3BhdXNlX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5wYXVzZV9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVzdW1lX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc3VtZV9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMnXSAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZXBsYXlfdXJsJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVwbGF5X3VybDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3RhYl9pZCddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF90YWJfaWQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ0RFRkFVTFRfQVBJX1JPVVRFUyddICAgICAgICAgICAgICAgICA9IERFRkFVTFRfQVBJX1JPVVRFUztcblxuLy8gRXhwb3J0cyBpbnRlbmRlZCBvbmx5IGZvciB0ZXN0aW5nXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ19fZ2V0X3JlY29yZGVyJ10gICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5fX2dldF9yZWNvcmRlcjtcblxuLy8gTWl4cGFuZWxQZXJzaXN0ZW5jZSBFeHBvcnRzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsncHJvcGVydGllcyddICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9zZWFyY2hfa2V5d29yZCddID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9yZWZlcnJlcl9pbmZvJ10gID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm87XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnZ2V0X2Nyb3NzX3N1YmRvbWFpbiddICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2NsZWFyJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXI7XG5cblxudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGV4dGVuZF9tcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFkZCBhbGwgdGhlIHN1YiBtaXhwYW5lbCBpbnN0YW5jZXNcbiAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7IG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlOyB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcHJpdmF0ZSBmdW5jdGlvbnMgYXMgX1xuICAgIG1peHBhbmVsX21hc3RlclsnXyddID0gXztcbn07XG5cbnZhciBvdmVycmlkZV9tcF9pbml0X2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGUgc25pcHBldHMgaW5pdCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYVxuICAgIC8vIHVzZXIgaW5pdGlhbGl6ZXMgdGhlIG1peHBhbmVsIGxpYnJhcnkgYWZ0ZXIgdGhlIHNjcmlwdCBsb2FkcyAmIHJ1bnNcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgYSBzdWIgbGlicmFyeVxuICAgICAgICAgICAgaWYgKCFtaXhwYW5lbF9tYXN0ZXJbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZXNbbmFtZV0gPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdLl9sb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBtaXhwYW5lbF9tYXN0ZXI7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSkge1xuICAgICAgICAgICAgICAgIC8vIG1haW4gbWl4cGFuZWwgbGliIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGludGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBsaWJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBQUklNQVJZX0lOU1RBTkNFX05BTUUpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXIgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbml0X3R5cGUgPT09IElOSVRfU05JUFBFVCkge1xuICAgICAgICAgICAgICAgIHdpbltQUklNQVJZX0lOU1RBTkNFX05BTUVdID0gbWl4cGFuZWxfbWFzdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kX21wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDcm9zcyBicm93c2VyIERPTSBMb2FkZWQgc3VwcG9ydFxuICAgIGZ1bmN0aW9uIGRvbV9sb2FkZWRfaGFuZGxlcigpIHtcbiAgICAgICAgLy8gZnVuY3Rpb24gZmxhZyBzaW5jZSB3ZSBvbmx5IHdhbnQgdG8gZXhlY3V0ZSB0aGlzIG9uY2VcbiAgICAgICAgaWYgKGRvbV9sb2FkZWRfaGFuZGxlci5kb25lKSB7IHJldHVybjsgfVxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgRE9NX0xPQURFRCA9IHRydWU7XG4gICAgICAgIEVOUVVFVUVfUkVRVUVTVFMgPSBmYWxzZTtcblxuICAgICAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0KSB7XG4gICAgICAgICAgICBpbnN0Ll9kb21fbG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvX3Njcm9sbF9jaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKCdsZWZ0Jyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChkb19zY3JvbGxfY2hlY2ssIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZG9jdW1lbnQkMS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAvLyBzYWZhcmkgNCBjYW4gZmlyZSB0aGUgRE9NQ29udGVudExvYWRlZCBldmVudCBiZWZvcmUgbG9hZGluZyBhbGxcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIEpTIChpbmNsdWRpbmcgdGhpcyBmaWxlKS4geW91IHdpbGwgc2VlIHNvbWUgY29weXBhc3RhXG4gICAgICAgICAgICAvLyBvbiB0aGUgaW50ZXJuZXQgdGhhdCBjaGVja3MgZm9yICdjb21wbGV0ZScgYW5kICdsb2FkZWQnLCBidXRcbiAgICAgICAgICAgIC8vICdsb2FkZWQnIGlzIGFuIElFIHRoaW5nXG4gICAgICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRvbV9sb2FkZWRfaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudCQxLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIC8vIElFXG4gICAgICAgIGRvY3VtZW50JDEuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGRvbV9sb2FkZWRfaGFuZGxlcik7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFybid0IGluIGEgZnJhbWVcbiAgICAgICAgdmFyIHRvcGxldmVsID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IHdpbi5mcmFtZUVsZW1lbnQgPT09IG51bGw7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsKSB7XG4gICAgICAgICAgICBkb19zY3JvbGxfY2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGhhbmRsZXIsIGFsd2F5cyB3aWxsIHdvcmtcbiAgICBfLnJlZ2lzdGVyX2V2ZW50KHdpbiwgJ2xvYWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gaW5pdF9hc19tb2R1bGUoYnVuZGxlX2xvYWRlcikge1xuICAgIGxvYWRfZXh0cmFfYnVuZGxlID0gYnVuZGxlX2xvYWRlcjtcbiAgICBpbml0X3R5cGUgPSBJTklUX01PRFVMRTtcbiAgICBtaXhwYW5lbF9tYXN0ZXIgPSBuZXcgTWl4cGFuZWxMaWIoKTtcblxuICAgIG92ZXJyaWRlX21wX2luaXRfZnVuYygpO1xuICAgIG1peHBhbmVsX21hc3RlclsnaW5pdCddKCk7XG4gICAgYWRkX2RvbV9sb2FkZWRfaGFuZGxlcigpO1xuXG4gICAgcmV0dXJuIG1peHBhbmVsX21hc3Rlcjtcbn1cblxuLy8gRm9yIGxvYWRpbmcgc2VwYXJhdGUgYnVuZGxlcyBhc3luY2hyb25vdXNseSB2aWEgc2NyaXB0IHRhZ1xuLy8gc28gdGhhdCB3ZSBkb24ndCBsb2FkIHRoZW0gdW50aWwgdGhleSBhcmUgbmVlZGVkIGF0IHJ1bnRpbWUuXG5cbi8vIEZvciBidWlsZHMgdGhhdCBoYXZlIGV2ZXJ5dGhpbmcgaW4gb25lIGJ1bmRsZSwgbm8gZXh0cmEgd29yay5cbmZ1bmN0aW9uIGxvYWROb29wIChfc3JjLCBvbmxvYWQpIHtcbiAgICBvbmxvYWQoKTtcbn1cblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgbWl4cGFuZWwgPSBpbml0X2FzX21vZHVsZShsb2FkTm9vcCk7XG5cbmV4cG9ydCB7IG1peHBhbmVsIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzP2QxOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcz80Yzg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/Y2NhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/MDJjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2Y0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/OGYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./src/services/chat-websocket-client.js":
/*!***********************************************!*\
  !*** ./src/services/chat-websocket-client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChatWebSocketClient)\n/* harmony export */ });\n/* harmony import */ var _utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shopify-settings-storage.util */ \"./src/utils/shopify-settings-storage.util.js\");\n/* harmony import */ var _utils_state_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/state-util */ \"./src/utils/state-util.js\");\n/* harmony import */ var _utils_ui_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ui-util */ \"./src/utils/ui-util.js\");\n/* harmony import */ var _utils_chat_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/chat-util */ \"./src/utils/chat-util.js\");\n// wsClient.js\n\n\n\n\n\nclass ChatWebSocketClient {\n    constructor(\n        wsUrl = \"wss://chatbot.stryk.ai/api/v4/websocket\",\n        maxReconnectAttempts = 5\n    ) {\n        this.wsUrl = wsUrl;\n        this.ws = null;\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = maxReconnectAttempts;\n        this.shouldReconnect = true;\n\n        // bind handlers\n        this._onOpen = this._onOpen.bind(this);\n        this._onMessage = this._onMessage.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onClose = this._onClose.bind(this);\n\n        // clean up on page refresh/close\n        window.addEventListener(\"beforeunload\", () => this.disconnect());\n    }\n\n    /** Public: open socket if not already OPEN or CONNECTING */\n    connect() {\n        if (this.ws?.readyState === WebSocket.OPEN || this.isConnecting) {\n            console.warn(\"WebSocket already open or connecting—skipping connect.\");\n            return;\n        }\n        if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {\n            console.warn(\"WebSocket not fully closed yet—waiting before reconnect.\");\n            return;\n        }\n\n        this.shouldReconnect = true;\n        this._initiateConnection();\n    }\n\n    /** Public: cleanly close and prevent auto-reconnect */\n    disconnect() {\n        if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n            console.warn(\"WebSocket already closed.\");\n            return;\n        }\n        this.shouldReconnect = false;\n        this.ws.close(1000, \"Client requested disconnect\");\n    }\n\n    /** Internal: actually spins up a new WebSocket */\n    _initiateConnection() {\n        this.isConnecting = true;\n        this.ws = new WebSocket(this.wsUrl);\n\n        this.ws.onopen = this._onOpen;\n        this.ws.onmessage = this._onMessage;\n        this.ws.onerror = this._onError;\n        this.ws.onclose = this._onClose;\n    }\n\n    async _onOpen(event) {\n        console.log(\"WebSocket opened\");\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n\n        // send auth\n        const authMessage = {\n            seq: 1,\n            action: \"authentication_challenge\",\n            data: {token: (await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.getStoredUserInfo)()).accessToken},\n        };\n        this.ws.send(JSON.stringify(authMessage));\n    }\n\n    async _onMessage(event) {\n        let messageData;\n        try {\n            messageData = JSON.parse(event.data);\n        } catch (e) {\n            console.error(\"Failed to parse WS message\", e);\n            return;\n        }\n\n        switch (messageData.event) {\n            case \"hello\":\n                console.log(\"Server says hello\");\n                break;\n\n            case \"ping\":\n                this.ws.send(JSON.stringify({action: \"pong\"}));\n                console.log(\"Pong sent\");\n                break;\n\n            case \"posted\": {\n                const post = JSON.parse(messageData.data.post);\n                if (post.user_id === await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.getStoredUserInfo)().userId) return;\n\n                if (post.props?.switchedToHumanNotification) {\n                    await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.setStoredChatType)(\"human\");\n                    await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.storeChannelId)(post.props.humanChannelId);\n                    await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.setAgentInfo)(post.props.agentInfo);\n                    (0,_utils_state_util__WEBPACK_IMPORTED_MODULE_1__.setAgentOnlineStatus)(post.props.status);\n                    await (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.switchAgentUI)();\n                    (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.removeAllMessages)();\n                    await (0,_utils_chat_util__WEBPACK_IMPORTED_MODULE_3__.checkForExistingChannel)();\n                    (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.hideLoadingSpinner)();\n                    return;\n                }\n\n                await (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.renderMessage)(post);\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.scrollToBottom)();\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.hideTypingIndicator)();\n\n                if (post.props?.TRIAL_MESSAGE_LIMIT_REACHED) {\n                    (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.hideChatInputContainer)();\n                    break;\n                }\n\n                if (!post.props?.temporaryMessage && !post.props?.hideFromUI) {\n                    (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.playNotificationSound)();\n                }\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.createChatToggleAction)();\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.getUiElements)().chatInput.disabled = false;\n            }\n                break;\n\n            case \"status_change\": {\n                const {user_id, status} = messageData.data;\n                if (await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.isHumanChat)() && await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_0__.getAgentInfo)()?.id === user_id) {\n                    (0,_utils_state_util__WEBPACK_IMPORTED_MODULE_1__.setAgentOnlineStatus)(status);\n                }\n            }\n                break;\n\n            case \"typing\":\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.showTypingIndicator)();\n                break;\n\n            case \"post_deleted\":\n                // handle if desired\n                break;\n\n            case \"group_added\":\n                // handle if desired\n                break;\n\n            case \"post_edited\": {\n                const edited = JSON.parse(messageData.data.post);\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.editMessage)(edited);\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.createChatToggleAction)();\n            }\n                break;\n\n            default:\n                console.log(\"Unhandled WS event:\", messageData.event, messageData);\n        }\n    }\n\n    _onError(err) {\n        console.error(\"WebSocket error:\", err);\n    }\n\n    _onClose(event) {\n        console.log(\"WebSocket closed:\", event.reason);\n        this.isConnecting = false;\n\n        if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n            const delay = Math.pow(2, this.reconnectAttempts) * 1000;\n            console.log(`Reconnecting in ${delay / 1000}s…`);\n            setTimeout(() => {\n                this.reconnectAttempts++;\n                this._initiateConnection();\n            }, delay);\n        } else if (!this.shouldReconnect) {\n            console.log(\"Manual disconnect—no more reconnect attempts.\");\n        } else {\n            console.error(\"Max reconnect attempts reached. Giving up.\");\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvY2hhdC13ZWJzb2NrZXQtY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFRQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvY2hhdC13ZWJzb2NrZXQtY2xpZW50LmpzPzhmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gd3NDbGllbnQuanNcbmltcG9ydCB7XG4gICAgZ2V0QWdlbnRJbmZvLFxuICAgIGdldFN0b3JlZFVzZXJJbmZvLFxuICAgIGlzSHVtYW5DaGF0LFxuICAgIHNldEFnZW50SW5mbyxcbiAgICBzZXRTdG9yZWRDaGF0VHlwZSxcbiAgICBzdG9yZUNoYW5uZWxJZFxufSBmcm9tIFwiLi4vdXRpbHMvc2hvcGlmeS1zZXR0aW5ncy1zdG9yYWdlLnV0aWxcIjtcbmltcG9ydCB7c2V0QWdlbnRPbmxpbmVTdGF0dXN9IGZyb20gXCIuLi91dGlscy9zdGF0ZS11dGlsXCI7XG5pbXBvcnQge1xuICAgIGNyZWF0ZUNoYXRUb2dnbGVBY3Rpb24sXG4gICAgZWRpdE1lc3NhZ2UsXG4gICAgZ2V0VWlFbGVtZW50cyxcbiAgICBoaWRlQ2hhdElucHV0Q29udGFpbmVyLFxuICAgIGhpZGVMb2FkaW5nU3Bpbm5lcixcbiAgICBoaWRlVHlwaW5nSW5kaWNhdG9yLFxuICAgIHBsYXlOb3RpZmljYXRpb25Tb3VuZCxcbiAgICByZW1vdmVBbGxNZXNzYWdlcyxcbiAgICByZW5kZXJNZXNzYWdlLFxuICAgIHNjcm9sbFRvQm90dG9tLFxuICAgIHNob3dUeXBpbmdJbmRpY2F0b3IsXG4gICAgc3dpdGNoQWdlbnRVSVxufSBmcm9tIFwiLi4vdXRpbHMvdWktdXRpbFwiO1xuaW1wb3J0IHtjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbH0gZnJvbSBcIi4uL3V0aWxzL2NoYXQtdXRpbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGF0V2ViU29ja2V0Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgd3NVcmwgPSBcIndzczovL2NoYXRib3Quc3RyeWsuYWkvYXBpL3Y0L3dlYnNvY2tldFwiLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDVcbiAgICApIHtcbiAgICAgICAgdGhpcy53c1VybCA9IHdzVXJsO1xuICAgICAgICB0aGlzLndzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMgPSBtYXhSZWNvbm5lY3RBdHRlbXB0cztcbiAgICAgICAgdGhpcy5zaG91bGRSZWNvbm5lY3QgPSB0cnVlO1xuXG4gICAgICAgIC8vIGJpbmQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5fb25PcGVuID0gdGhpcy5fb25PcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uTWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vbkNsb3NlID0gdGhpcy5fb25DbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwIG9uIHBhZ2UgcmVmcmVzaC9jbG9zZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB0aGlzLmRpc2Nvbm5lY3QoKSk7XG4gICAgfVxuXG4gICAgLyoqIFB1YmxpYzogb3BlbiBzb2NrZXQgaWYgbm90IGFscmVhZHkgT1BFTiBvciBDT05ORUNUSU5HICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZWJTb2NrZXQgYWxyZWFkeSBvcGVuIG9yIGNvbm5lY3RpbmfigJRza2lwcGluZyBjb25uZWN0LlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldlYlNvY2tldCBub3QgZnVsbHkgY2xvc2VkIHlldOKAlHdhaXRpbmcgYmVmb3JlIHJlY29ubmVjdC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3VsZFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXRpYXRlQ29ubmVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKiBQdWJsaWM6IGNsZWFubHkgY2xvc2UgYW5kIHByZXZlbnQgYXV0by1yZWNvbm5lY3QgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZWJTb2NrZXQgYWxyZWFkeSBjbG9zZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoMTAwMCwgXCJDbGllbnQgcmVxdWVzdGVkIGRpc2Nvbm5lY3RcIik7XG4gICAgfVxuXG4gICAgLyoqIEludGVybmFsOiBhY3R1YWxseSBzcGlucyB1cCBhIG5ldyBXZWJTb2NrZXQgKi9cbiAgICBfaW5pdGlhdGVDb25uZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMud3NVcmwpO1xuXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5fb25PcGVuO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5fb25FcnJvcjtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5fb25DbG9zZTtcbiAgICB9XG5cbiAgICBhc3luYyBfb25PcGVuKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV2ViU29ja2V0IG9wZW5lZFwiKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG5cbiAgICAgICAgLy8gc2VuZCBhdXRoXG4gICAgICAgIGNvbnN0IGF1dGhNZXNzYWdlID0ge1xuICAgICAgICAgICAgc2VxOiAxLFxuICAgICAgICAgICAgYWN0aW9uOiBcImF1dGhlbnRpY2F0aW9uX2NoYWxsZW5nZVwiLFxuICAgICAgICAgICAgZGF0YToge3Rva2VuOiAoYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKSkuYWNjZXNzVG9rZW59LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoYXV0aE1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBhc3luYyBfb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlRGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBXUyBtZXNzYWdlXCIsIGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChtZXNzYWdlRGF0YS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImhlbGxvXCI6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2ZXIgc2F5cyBoZWxsb1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe2FjdGlvbjogXCJwb25nXCJ9KSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQb25nIHNlbnRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJwb3N0ZWRcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3QgPSBKU09OLnBhcnNlKG1lc3NhZ2VEYXRhLmRhdGEucG9zdCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QudXNlcl9pZCA9PT0gYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKS51c2VySWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChwb3N0LnByb3BzPy5zd2l0Y2hlZFRvSHVtYW5Ob3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0U3RvcmVkQ2hhdFR5cGUoXCJodW1hblwiKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RvcmVDaGFubmVsSWQocG9zdC5wcm9wcy5odW1hbkNoYW5uZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldEFnZW50SW5mbyhwb3N0LnByb3BzLmFnZW50SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEFnZW50T25saW5lU3RhdHVzKHBvc3QucHJvcHMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3dpdGNoQWdlbnRVSSgpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGxNZXNzYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlTG9hZGluZ1NwaW5uZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbmRlck1lc3NhZ2UocG9zdCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgICAgICAgICBoaWRlVHlwaW5nSW5kaWNhdG9yKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zdC5wcm9wcz8uVFJJQUxfTUVTU0FHRV9MSU1JVF9SRUFDSEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVDaGF0SW5wdXRDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFwb3N0LnByb3BzPy50ZW1wb3JhcnlNZXNzYWdlICYmICFwb3N0LnByb3BzPy5oaWRlRnJvbVVJKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXlOb3RpZmljYXRpb25Tb3VuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjcmVhdGVDaGF0VG9nZ2xlQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgZ2V0VWlFbGVtZW50cygpLmNoYXRJbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3RhdHVzX2NoYW5nZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge3VzZXJfaWQsIHN0YXR1c30gPSBtZXNzYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBpc0h1bWFuQ2hhdCgpICYmIGF3YWl0IGdldEFnZW50SW5mbygpPy5pZCA9PT0gdXNlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBZ2VudE9ubGluZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInR5cGluZ1wiOlxuICAgICAgICAgICAgICAgIHNob3dUeXBpbmdJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInBvc3RfZGVsZXRlZFwiOlxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBpZiBkZXNpcmVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJncm91cF9hZGRlZFwiOlxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBpZiBkZXNpcmVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJwb3N0X2VkaXRlZFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdGVkID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhLnBvc3QpO1xuICAgICAgICAgICAgICAgIGVkaXRNZXNzYWdlKGVkaXRlZCk7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ2hhdFRvZ2dsZUFjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5oYW5kbGVkIFdTIGV2ZW50OlwiLCBtZXNzYWdlRGF0YS5ldmVudCwgbWVzc2FnZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX29uRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXZWJTb2NrZXQgZXJyb3I6XCIsIGVycik7XG4gICAgfVxuXG4gICAgX29uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJXZWJTb2NrZXQgY2xvc2VkOlwiLCBldmVudC5yZWFzb24pO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdCAmJiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnBvdygyLCB0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSAqIDEwMDA7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVjb25uZWN0aW5nIGluICR7ZGVsYXkgLyAxMDAwfXPigKZgKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWF0ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zaG91bGRSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFudWFsIGRpc2Nvbm5lY3TigJRubyBtb3JlIHJlY29ubmVjdCBhdHRlbXB0cy5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF4IHJlY29ubmVjdCBhdHRlbXB0cyByZWFjaGVkLiBHaXZpbmcgdXAuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/chat-websocket-client.js\n");

/***/ }),

/***/ "./src/services/general.service.js":
/*!*****************************************!*\
  !*** ./src/services/general.service.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkHeartbeat: () => (/* binding */ checkHeartbeat),\n/* harmony export */   reachedSeatLimit: () => (/* binding */ reachedSeatLimit)\n/* harmony export */ });\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util */ \"./src/utils/util.js\");\n\n\nasync function checkHeartbeat() {\n    const retryInterval = 2000;\n    // Function to check the heartbeat endpoint\n    while (true) {\n        try {\n            const response = await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/heart-beat`, 'GET');\n            if (response === \"alive\") {\n                // Heartbeat succeeded\n                console.log(\"Heartbeat check succeeded.\");\n                return true;\n            } else {\n                console.warn(\"Heartbeat check failed. Retrying in 2 seconds...\");\n            }\n        } catch (error) {\n            console.error(\"Error during heartbeat check:\", error);\n        }\n        // Wait for the retry interval before trying again\n        await new Promise(resolve => setTimeout(resolve, retryInterval));\n    }\n}\n\nasync function reachedSeatLimit() {\n    const sd = window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID;\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/sl?sd=${sd}`, 'GET');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvZ2VuZXJhbC5zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9nZW5lcmFsLnNlcnZpY2UuanM/N2M2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FwaUNhbGwsIGdldEFwaVVybH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrSGVhcnRiZWF0KCkge1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAyMDAwO1xuICAgIC8vIEZ1bmN0aW9uIHRvIGNoZWNrIHRoZSBoZWFydGJlYXQgZW5kcG9pbnRcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKGAke2dldEFwaVVybCgpfS9oZWFydC1iZWF0YCwgJ0dFVCcpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBcImFsaXZlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBIZWFydGJlYXQgc3VjY2VlZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJIZWFydGJlYXQgY2hlY2sgc3VjY2VlZGVkLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSGVhcnRiZWF0IGNoZWNrIGZhaWxlZC4gUmV0cnlpbmcgaW4gMiBzZWNvbmRzLi4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBoZWFydGJlYXQgY2hlY2s6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmV0cnkgaW50ZXJ2YWwgYmVmb3JlIHRyeWluZyBhZ2FpblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlJbnRlcnZhbCkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWNoZWRTZWF0TGltaXQoKSB7XG4gICAgY29uc3Qgc2QgPSB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRDtcbiAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbChgJHtnZXRBcGlVcmwoKX0vc2w/c2Q9JHtzZH1gLCAnR0VUJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/general.service.js\n");

/***/ }),

/***/ "./src/services/mattermost.service.js":
/*!********************************************!*\
  !*** ./src/services/mattermost.service.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canSwitchChat: () => (/* binding */ canSwitchChat),\n/* harmony export */   createNewGuestUser: () => (/* binding */ createNewGuestUser),\n/* harmony export */   getAgentStatus: () => (/* binding */ getAgentStatus),\n/* harmony export */   getFiles: () => (/* binding */ getFiles),\n/* harmony export */   getOrCreatNewChannel: () => (/* binding */ getOrCreatNewChannel),\n/* harmony export */   pollAgentStatus: () => (/* binding */ pollAgentStatus),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage),\n/* harmony export */   talkToBot: () => (/* binding */ talkToBot),\n/* harmony export */   talkToHuman: () => (/* binding */ talkToHuman)\n/* harmony export */ });\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util */ \"./src/utils/util.js\");\n/* harmony import */ var _utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/shopify-settings-storage.util */ \"./src/utils/shopify-settings-storage.util.js\");\n/* harmony import */ var _utils_ui_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ui-util */ \"./src/utils/ui-util.js\");\n/* harmony import */ var _utils_state_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/state-util */ \"./src/utils/state-util.js\");\n\n\n\n\n\nasync function createNewGuestUser(name) {\n    const shopDomain = window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID;\n\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/start-chat`, 'POST', {\n        name,\n        store: shopDomain\n    })\n}\n\n/*\n* Example Response\n*\n* {\n    \"userChannel\": \"id33i3sxjby15pb86xdmxqz66o\",\n    \"channelMessages\": {\n        \"messages\": {\n            \"6n4wgkdn1frjufzkkwns4t4q8r\": {\n                \"id\": \"6n4wgkdn1frjufzkkwns4t4q8r\",\n                \"create_at\": 1729802529674,\n                \"update_at\": 1729802529674,\n                \"edit_at\": 0,\n                \"delete_at\": 0,\n                \"is_pinned\": false,\n                \"user_id\": \"hs71p1611jgfpg7pkpbda34bpe\",\n                \"channel_id\": \"id33i3sxjby15pb86xdmxqz66o\",\n                \"root_id\": \"\",\n                \"original_id\": \"\",\n                \"message\": \"this is a message test from api 2\",\n                \"type\": \"\",\n                \"props\": {},\n                \"hashtags\": \"\",\n                \"pending_post_id\": \"\",\n                \"remote_id\": \"\",\n                \"reply_count\": 0,\n                \"last_reply_at\": 0,\n                \"participants\": null,\n                \"metadata\": {}\n            },\n\n        },\n        \"hasMore\": false,\n        \"nextPostId\": \"\",\n        \"order\": [\n            \"6n4wgkdn1frjufzkkwns4t4q8r\"\n        ]\n    }\n}\n* */\nasync function getOrCreatNewChannel(userId, accessToken) {\n    const talkToHuman = await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.isHumanChat)()\n    const shopDomain = window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID;\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/user-channel`, 'POST', {\n        userId,\n        accessToken,\n        talkToHuman,\n        shopDomain\n    });\n}\n\nasync function getFiles(fileIds) {\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/files`, 'POST', {fileIds})\n}\n\nasync function sendMessage(userId, message, channelId, accessToken) {\n    const customProps = {\n        toGpt: !await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.isHumanChat)(),\n        store_id: window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID\n    };\n\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/send-chat`, 'POST', {\n        userId,\n        message,\n        channelId,\n        accessToken,\n        customProps\n    });\n}\n\nasync function talkToHuman() {\n    const {accessToken, userId} = await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.getStoredUserInfo)()\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/talk-to-human`, 'POST', {\n        gptChannelId: await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.getStoredGptChannelId)(),\n        userId: userId,\n        accessToken: accessToken,\n        shopDomain: window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID\n    })\n}\n\nasync function talkToBot() {\n    if (!await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.isUserCreated)() || await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.getStoredChatType)() !== \"human\") return;\n    const {accessToken, userId} = await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.getStoredUserInfo)()\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/talk-to-bot`, 'POST', {\n        userId: userId,\n        accessToken: accessToken,\n        shopDomain: window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID\n    })\n}\n\nasync function getAgentStatus(agentId) {\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/agent-status/${agentId}`, 'GET')\n}\n\nfunction pollAgentStatus(agentId) {\n    // Create a polling function\n    const poll = async () => {\n        if (await (0,_utils_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_1__.isHumanChat)() && !!agentId) {\n            try {\n                // Call getAgentStatus function with the provided agentId\n                const onlineStatusInfo = await getAgentStatus(agentId);\n                (0,_utils_state_util__WEBPACK_IMPORTED_MODULE_3__.setAgentOnlineStatus)(onlineStatusInfo?.status)\n                // Perform any additional actions with the agent status here\n            } catch (error) {\n                console.error(\"Error fetching agent status:\", error);\n            } finally {\n                (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_2__.updateDisplayedOnlineStatus)((0,_utils_state_util__WEBPACK_IMPORTED_MODULE_3__.getAgentOnlineStatus)())\n            }\n\n            // Schedule the next poll after 30 seconds\n            setTimeout(poll, 30000);\n        } else {\n            console.log(\"Polling stopped: not a human chat\");\n        }\n    };\n\n    // Start polling\n    poll();\n}\n\nasync function canSwitchChat() {\n    const shopDomain = window?.Shopify?.shop || ChatWidgetConfig?.TEAM_ID\n    return await (0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.apiCall)(`${(0,_utils_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}/mattermost/can-switch-chat/${shopDomain}`, 'GET')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvbWF0dGVybW9zdC5zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZpY2VzL21hdHRlcm1vc3Quc2VydmljZS5qcz8yYjNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXBpQ2FsbCwgZ2V0QXBpVXJsfSBmcm9tIFwiLi4vdXRpbHMvdXRpbFwiO1xuaW1wb3J0IHtcbiAgICBnZXRTdG9yZWRDaGF0VHlwZSxcbiAgICBnZXRTdG9yZWRHcHRDaGFubmVsSWQsXG4gICAgZ2V0U3RvcmVkVXNlckluZm8sXG4gICAgaXNIdW1hbkNoYXQsXG4gICAgaXNVc2VyQ3JlYXRlZFxufSBmcm9tIFwiLi4vdXRpbHMvc2hvcGlmeS1zZXR0aW5ncy1zdG9yYWdlLnV0aWxcIjtcbmltcG9ydCB7dXBkYXRlRGlzcGxheWVkT25saW5lU3RhdHVzfSBmcm9tIFwiLi4vdXRpbHMvdWktdXRpbFwiO1xuaW1wb3J0IHtnZXRBZ2VudE9ubGluZVN0YXR1cywgc2V0QWdlbnRPbmxpbmVTdGF0dXN9IGZyb20gXCIuLi91dGlscy9zdGF0ZS11dGlsXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVOZXdHdWVzdFVzZXIobmFtZSkge1xuICAgIGNvbnN0IHNob3BEb21haW4gPSB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRDtcblxuICAgIHJldHVybiBhd2FpdCBhcGlDYWxsKGAke2dldEFwaVVybCgpfS9zdGFydC1jaGF0YCwgJ1BPU1QnLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0b3JlOiBzaG9wRG9tYWluXG4gICAgfSlcbn1cblxuLypcbiogRXhhbXBsZSBSZXNwb25zZVxuKlxuKiB7XG4gICAgXCJ1c2VyQ2hhbm5lbFwiOiBcImlkMzNpM3N4amJ5MTVwYjg2eGRteHF6NjZvXCIsXG4gICAgXCJjaGFubmVsTWVzc2FnZXNcIjoge1xuICAgICAgICBcIm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgIFwiNm40d2drZG4xZnJqdWZ6a2t3bnM0dDRxOHJcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2bjR3Z2tkbjFmcmp1Znpra3duczR0NHE4clwiLFxuICAgICAgICAgICAgICAgIFwiY3JlYXRlX2F0XCI6IDE3Mjk4MDI1Mjk2NzQsXG4gICAgICAgICAgICAgICAgXCJ1cGRhdGVfYXRcIjogMTcyOTgwMjUyOTY3NCxcbiAgICAgICAgICAgICAgICBcImVkaXRfYXRcIjogMCxcbiAgICAgICAgICAgICAgICBcImRlbGV0ZV9hdFwiOiAwLFxuICAgICAgICAgICAgICAgIFwiaXNfcGlubmVkXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwidXNlcl9pZFwiOiBcImhzNzFwMTYxMWpnZnBnN3BrcGJkYTM0YnBlXCIsXG4gICAgICAgICAgICAgICAgXCJjaGFubmVsX2lkXCI6IFwiaWQzM2kzc3hqYnkxNXBiODZ4ZG14cXo2Nm9cIixcbiAgICAgICAgICAgICAgICBcInJvb3RfaWRcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdpbmFsX2lkXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlXCI6IFwidGhpcyBpcyBhIG1lc3NhZ2UgdGVzdCBmcm9tIGFwaSAyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJwcm9wc1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcImhhc2h0YWdzXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nX3Bvc3RfaWRcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcInJlbW90ZV9pZFwiOiBcIlwiLFxuICAgICAgICAgICAgICAgIFwicmVwbHlfY291bnRcIjogMCxcbiAgICAgICAgICAgICAgICBcImxhc3RfcmVwbHlfYXRcIjogMCxcbiAgICAgICAgICAgICAgICBcInBhcnRpY2lwYW50c1wiOiBudWxsLFxuICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge31cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgfSxcbiAgICAgICAgXCJoYXNNb3JlXCI6IGZhbHNlLFxuICAgICAgICBcIm5leHRQb3N0SWRcIjogXCJcIixcbiAgICAgICAgXCJvcmRlclwiOiBbXG4gICAgICAgICAgICBcIjZuNHdna2RuMWZyanVmemtrd25zNHQ0cThyXCJcbiAgICAgICAgXVxuICAgIH1cbn1cbiogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0TmV3Q2hhbm5lbCh1c2VySWQsIGFjY2Vzc1Rva2VuKSB7XG4gICAgY29uc3QgdGFsa1RvSHVtYW4gPSBhd2FpdCBpc0h1bWFuQ2hhdCgpXG4gICAgY29uc3Qgc2hvcERvbWFpbiA9IHdpbmRvdz8uU2hvcGlmeT8uc2hvcCB8fCBDaGF0V2lkZ2V0Q29uZmlnPy5URUFNX0lEO1xuICAgIHJldHVybiBhd2FpdCBhcGlDYWxsKGAke2dldEFwaVVybCgpfS91c2VyLWNoYW5uZWxgLCAnUE9TVCcsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBhY2Nlc3NUb2tlbixcbiAgICAgICAgdGFsa1RvSHVtYW4sXG4gICAgICAgIHNob3BEb21haW5cbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVzKGZpbGVJZHMpIHtcbiAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbChgJHtnZXRBcGlVcmwoKX0vZmlsZXNgLCAnUE9TVCcsIHtmaWxlSWRzfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKHVzZXJJZCwgbWVzc2FnZSwgY2hhbm5lbElkLCBhY2Nlc3NUb2tlbikge1xuICAgIGNvbnN0IGN1c3RvbVByb3BzID0ge1xuICAgICAgICB0b0dwdDogIWF3YWl0IGlzSHVtYW5DaGF0KCksXG4gICAgICAgIHN0b3JlX2lkOiB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbChgJHtnZXRBcGlVcmwoKX0vc2VuZC1jaGF0YCwgJ1BPU1QnLCB7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgY2hhbm5lbElkLFxuICAgICAgICBhY2Nlc3NUb2tlbixcbiAgICAgICAgY3VzdG9tUHJvcHNcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRhbGtUb0h1bWFuKCkge1xuICAgIGNvbnN0IHthY2Nlc3NUb2tlbiwgdXNlcklkfSA9IGF3YWl0IGdldFN0b3JlZFVzZXJJbmZvKClcbiAgICByZXR1cm4gYXdhaXQgYXBpQ2FsbChgJHtnZXRBcGlVcmwoKX0vdGFsay10by1odW1hbmAsICdQT1NUJywge1xuICAgICAgICBncHRDaGFubmVsSWQ6IGF3YWl0IGdldFN0b3JlZEdwdENoYW5uZWxJZCgpLFxuICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuLFxuICAgICAgICBzaG9wRG9tYWluOiB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRFxuICAgIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0YWxrVG9Cb3QoKSB7XG4gICAgaWYgKCFhd2FpdCBpc1VzZXJDcmVhdGVkKCkgfHwgYXdhaXQgZ2V0U3RvcmVkQ2hhdFR5cGUoKSAhPT0gXCJodW1hblwiKSByZXR1cm47XG4gICAgY29uc3Qge2FjY2Vzc1Rva2VuLCB1c2VySWR9ID0gYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKVxuICAgIHJldHVybiBhd2FpdCBhcGlDYWxsKGAke2dldEFwaVVybCgpfS90YWxrLXRvLWJvdGAsICdQT1NUJywge1xuICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuLFxuICAgICAgICBzaG9wRG9tYWluOiB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRFxuICAgIH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBZ2VudFN0YXR1cyhhZ2VudElkKSB7XG4gICAgcmV0dXJuIGF3YWl0IGFwaUNhbGwoYCR7Z2V0QXBpVXJsKCl9L2FnZW50LXN0YXR1cy8ke2FnZW50SWR9YCwgJ0dFVCcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2xsQWdlbnRTdGF0dXMoYWdlbnRJZCkge1xuICAgIC8vIENyZWF0ZSBhIHBvbGxpbmcgZnVuY3Rpb25cbiAgICBjb25zdCBwb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXdhaXQgaXNIdW1hbkNoYXQoKSAmJiAhIWFnZW50SWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBnZXRBZ2VudFN0YXR1cyBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhZ2VudElkXG4gICAgICAgICAgICAgICAgY29uc3Qgb25saW5lU3RhdHVzSW5mbyA9IGF3YWl0IGdldEFnZW50U3RhdHVzKGFnZW50SWQpO1xuICAgICAgICAgICAgICAgIHNldEFnZW50T25saW5lU3RhdHVzKG9ubGluZVN0YXR1c0luZm8/LnN0YXR1cylcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGFueSBhZGRpdGlvbmFsIGFjdGlvbnMgd2l0aCB0aGUgYWdlbnQgc3RhdHVzIGhlcmVcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGFnZW50IHN0YXR1czpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXNwbGF5ZWRPbmxpbmVTdGF0dXMoZ2V0QWdlbnRPbmxpbmVTdGF0dXMoKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgcG9sbCBhZnRlciAzMCBzZWNvbmRzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIDMwMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUG9sbGluZyBzdG9wcGVkOiBub3QgYSBodW1hbiBjaGF0XCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IHBvbGxpbmdcbiAgICBwb2xsKCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5Td2l0Y2hDaGF0KCkge1xuICAgIGNvbnN0IHNob3BEb21haW4gPSB3aW5kb3c/LlNob3BpZnk/LnNob3AgfHwgQ2hhdFdpZGdldENvbmZpZz8uVEVBTV9JRFxuICAgIHJldHVybiBhd2FpdCBhcGlDYWxsKGAke2dldEFwaVVybCgpfS9tYXR0ZXJtb3N0L2Nhbi1zd2l0Y2gtY2hhdC8ke3Nob3BEb21haW59YCwgJ0dFVCcpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/mattermost.service.js\n");

/***/ }),

/***/ "./src/services/shopify-settings.service.js":
/*!**************************************************!*\
  !*** ./src/services/shopify-settings.service.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearSettings: () => (/* binding */ clearSettings),\n/* harmony export */   fetchSettings: () => (/* binding */ fetchSettings),\n/* harmony export */   saveSettings: () => (/* binding */ saveSettings)\n/* harmony export */ });\n/* harmony import */ var _utils_authFetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/authFetch */ \"./src/utils/authFetch.js\");\n/* harmony import */ var _utils_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/shopify-settings-cache.util */ \"./src/utils/shopify-settings-cache.util.js\");\n\n\n\nfunction fetchSettings() {\n    return (0,_utils_authFetch__WEBPACK_IMPORTED_MODULE_0__.authFetch)(`/shopify/settings`)\n        .then(res => {\n            if (!res.ok) throw new Error(res.statusText);\n            return res.json();\n        });\n}\n\nasync function saveSettings(updates) {\n    await (0,_utils_authFetch__WEBPACK_IMPORTED_MODULE_0__.authFetch)(`/shopify/settings`, {\n        method: 'POST',\n        body: JSON.stringify(updates),\n    })\n        .then(async res => {\n            if (!res.ok) throw new Error(res.statusText);\n            const newSettings = await res.json();\n            (0,_utils_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_1__.updateCacheAfterSave)(newSettings)\n            return newSettings;\n        });\n\n\n}\n\nasync function clearSettings() {\n    await (0,_utils_authFetch__WEBPACK_IMPORTED_MODULE_0__.authFetch)(`/shopify/settings`, {\n        method: 'DELETE',\n    })\n        .then(res => {\n            if (!res.ok) throw new Error(res.statusText);\n            return res.json();\n        });\n\n    await (0,_utils_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_1__.clearSettingsCache)()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvc2hvcGlmeS1zZXR0aW5ncy5zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvc2hvcGlmeS1zZXR0aW5ncy5zZXJ2aWNlLmpzPzQxZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthdXRoRmV0Y2h9IGZyb20gXCIuLi91dGlscy9hdXRoRmV0Y2hcIjtcbmltcG9ydCB7Y2xlYXJTZXR0aW5nc0NhY2hlLCB1cGRhdGVDYWNoZUFmdGVyU2F2ZX0gZnJvbSBcIi4uL3V0aWxzL3Nob3BpZnktc2V0dGluZ3MtY2FjaGUudXRpbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gYXV0aEZldGNoKGAvc2hvcGlmeS9zZXR0aW5nc2ApXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVTZXR0aW5ncyh1cGRhdGVzKSB7XG4gICAgYXdhaXQgYXV0aEZldGNoKGAvc2hvcGlmeS9zZXR0aW5nc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZXMpLFxuICAgIH0pXG4gICAgICAgIC50aGVuKGFzeW5jIHJlcyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIHVwZGF0ZUNhY2hlQWZ0ZXJTYXZlKG5ld1NldHRpbmdzKVxuICAgICAgICAgICAgcmV0dXJuIG5ld1NldHRpbmdzO1xuICAgICAgICB9KTtcblxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhclNldHRpbmdzKCkge1xuICAgIGF3YWl0IGF1dGhGZXRjaChgL3Nob3BpZnkvc2V0dGluZ3NgLCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgfSlcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgYXdhaXQgY2xlYXJTZXR0aW5nc0NhY2hlKClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/services/shopify-settings.service.js\n");

/***/ }),

/***/ "./src/utils/authFetch.js":
/*!********************************!*\
  !*** ./src/utils/authFetch.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authFetch: () => (/* binding */ authFetch)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/utils/util.js\");\n\n\n/**\n * A helper to clear a cookie by name on the current host.\n */\nfunction clearCookie(name) {\n    document.cookie = `${name}=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT`;\n}\n\n/**\n * WHEN _NOT_ TO USE the Shopify App Proxy (i.e. bypass authFetch):\n *  • Running locally (localhost)\n *  • On our super-sales-demo staging site\n *  • In any “dev” environment (per isDev())\n *  • When previewing a theme (preview_theme cookie present) — we’ll auto‐clear it here\n *\n * @param {string} path   — e.g. \"/shopify/settings\"\n * @param {RequestInit} [options]\n */\nasync function authFetch(path, options = {}) {\n    // 1️⃣ Detect & remove preview cookie if present\n    const cookies = document.cookie.split(\";\").map(c => c.trim());\n    const isPreview = cookies.some(c => c.startsWith(\"preview_theme=\"));\n    if (isPreview) {\n        clearCookie(\"preview_theme\");\n        console.info(\"🔄 preview_theme cookie cleared so App Proxy can run\");\n    }\n\n    // 2️⃣ Decide direct vs. proxy\n    const useDirectApi = (0,_util__WEBPACK_IMPORTED_MODULE_0__.isOutsideShopify)();\n\n    // 3️⃣ Build the URL\n    const endpoint = useDirectApi\n        ? `${(0,_util__WEBPACK_IMPORTED_MODULE_0__.getApiUrl)()}${path.startsWith(\"/\") ? path : \"/\" + path}`\n        : `/apps/stryk-ai${path.startsWith(\"/\") ? path : \"/\" + path}`;\n\n    // 4️⃣ Prepare fetch options\n    const fetchOpts = {\n        ...options,\n        credentials: useDirectApi ? \"include\" : \"same-origin\",\n    };\n\n    // 5️⃣ Only set JSON headers when sending a body\n    if (fetchOpts.body != null) {\n        fetchOpts.headers = {\n            \"Content-Type\": \"application/json\",\n            'Access-Control-Allow-Origin': '*',\n            'ngrok-skip-browser-warning': 'true',\n            ...(options.headers || {}),\n        };\n    }\n\n    fetchOpts.headers = {\n        ...fetchOpts.headers,\n        'X-Chat-GuestId': window.ChatWidgetConfig.GUEST_ID,\n    }\n\n    // 6️⃣ Fire the request\n    const res = await fetch(endpoint, fetchOpts);\n\n    // 7️⃣ Error handling\n    if (!res.ok) {\n        const text = await res.text();\n        console.error(`authFetch error on ${endpoint}: ${res.status}`, text);\n        throw new Error(`Request failed: ${res.status}`);\n    }\n\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvYXV0aEZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2F1dGhGZXRjaC5qcz8yY2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0QXBpVXJsLCBpc091dHNpZGVTaG9waWZ5fSBmcm9tIFwiLi91dGlsXCI7XG5cbi8qKlxuICogQSBoZWxwZXIgdG8gY2xlYXIgYSBjb29raWUgYnkgbmFtZSBvbiB0aGUgY3VycmVudCBob3N0LlxuICovXG5mdW5jdGlvbiBjbGVhckNvb2tpZShuYW1lKSB7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09OyBQYXRoPS87IEV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVRgO1xufVxuXG4vKipcbiAqIFdIRU4gX05PVF8gVE8gVVNFIHRoZSBTaG9waWZ5IEFwcCBQcm94eSAoaS5lLiBieXBhc3MgYXV0aEZldGNoKTpcbiAqICDigKIgUnVubmluZyBsb2NhbGx5IChsb2NhbGhvc3QpXG4gKiAg4oCiIE9uIG91ciBzdXBlci1zYWxlcy1kZW1vIHN0YWdpbmcgc2l0ZVxuICogIOKAoiBJbiBhbnkg4oCcZGV24oCdIGVudmlyb25tZW50IChwZXIgaXNEZXYoKSlcbiAqICDigKIgV2hlbiBwcmV2aWV3aW5nIGEgdGhlbWUgKHByZXZpZXdfdGhlbWUgY29va2llIHByZXNlbnQpIOKAlCB3ZeKAmWxsIGF1dG/igJBjbGVhciBpdCBoZXJlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggICDigJQgZS5nLiBcIi9zaG9waWZ5L3NldHRpbmdzXCJcbiAqIEBwYXJhbSB7UmVxdWVzdEluaXR9IFtvcHRpb25zXVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aEZldGNoKHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIDHvuI/ig6MgRGV0ZWN0ICYgcmVtb3ZlIHByZXZpZXcgY29va2llIGlmIHByZXNlbnRcbiAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKS5tYXAoYyA9PiBjLnRyaW0oKSk7XG4gICAgY29uc3QgaXNQcmV2aWV3ID0gY29va2llcy5zb21lKGMgPT4gYy5zdGFydHNXaXRoKFwicHJldmlld190aGVtZT1cIikpO1xuICAgIGlmIChpc1ByZXZpZXcpIHtcbiAgICAgICAgY2xlYXJDb29raWUoXCJwcmV2aWV3X3RoZW1lXCIpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCLwn5SEIHByZXZpZXdfdGhlbWUgY29va2llIGNsZWFyZWQgc28gQXBwIFByb3h5IGNhbiBydW5cIik7XG4gICAgfVxuXG4gICAgLy8gMu+4j+KDoyBEZWNpZGUgZGlyZWN0IHZzLiBwcm94eVxuICAgIGNvbnN0IHVzZURpcmVjdEFwaSA9IGlzT3V0c2lkZVNob3BpZnkoKTtcblxuICAgIC8vIDPvuI/ig6MgQnVpbGQgdGhlIFVSTFxuICAgIGNvbnN0IGVuZHBvaW50ID0gdXNlRGlyZWN0QXBpXG4gICAgICAgID8gYCR7Z2V0QXBpVXJsKCl9JHtwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gcGF0aCA6IFwiL1wiICsgcGF0aH1gXG4gICAgICAgIDogYC9hcHBzL3N0cnlrLWFpJHtwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gcGF0aCA6IFwiL1wiICsgcGF0aH1gO1xuXG4gICAgLy8gNO+4j+KDoyBQcmVwYXJlIGZldGNoIG9wdGlvbnNcbiAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiB1c2VEaXJlY3RBcGkgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICB9O1xuXG4gICAgLy8gNe+4j+KDoyBPbmx5IHNldCBKU09OIGhlYWRlcnMgd2hlbiBzZW5kaW5nIGEgYm9keVxuICAgIGlmIChmZXRjaE9wdHMuYm9keSAhPSBudWxsKSB7XG4gICAgICAgIGZldGNoT3B0cy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgICAgICAgJ25ncm9rLXNraXAtYnJvd3Nlci13YXJuaW5nJzogJ3RydWUnLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZmV0Y2hPcHRzLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmZldGNoT3B0cy5oZWFkZXJzLFxuICAgICAgICAnWC1DaGF0LUd1ZXN0SWQnOiB3aW5kb3cuQ2hhdFdpZGdldENvbmZpZy5HVUVTVF9JRCxcbiAgICB9XG5cbiAgICAvLyA277iP4oOjIEZpcmUgdGhlIHJlcXVlc3RcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwgZmV0Y2hPcHRzKTtcblxuICAgIC8vIDfvuI/ig6MgRXJyb3IgaGFuZGxpbmdcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgYXV0aEZldGNoIGVycm9yIG9uICR7ZW5kcG9pbnR9OiAke3Jlcy5zdGF0dXN9YCwgdGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdCBmYWlsZWQ6ICR7cmVzLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/authFetch.js\n");

/***/ }),

/***/ "./src/utils/chat-expirey.js":
/*!***********************************!*\
  !*** ./src/utils/chat-expirey.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkChatValid: () => (/* binding */ checkChatValid),\n/* harmony export */   resetChatExpiry: () => (/* binding */ resetChatExpiry)\n/* harmony export */ });\n/* harmony import */ var _chat_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chat-util */ \"./src/utils/chat-util.js\");\n/* harmony import */ var _shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shopify-settings-cache.util */ \"./src/utils/shopify-settings-cache.util.js\");\n/* harmony import */ var _services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/shopify-settings.service */ \"./src/services/shopify-settings.service.js\");\n// Function to set a new expiry time (4 hours from now) in localStorage\n\n\n\n\nasync function resetChatExpiry() {\n    const fourHoursInMs = 4 * 60 * 60 * 1000;\n    const newExpiry = new Date().getTime() + fourHoursInMs;\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_2__.saveSettings)({chatExpiry: newExpiry})\n}\n\n// Function that checks if the stored expiry time is passed or not\nasync function checkChatValid() {\n    const {chatExpiry} = await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_1__.loadSettings)();\n\n    // If there is no expiry set, just set it and exit the function.\n    if (!chatExpiry && (0,_chat_util__WEBPACK_IMPORTED_MODULE_0__.getChatStates)().isChatInitialized) {\n        await (0,_chat_util__WEBPACK_IMPORTED_MODULE_0__.resetChat)();\n        return;\n    }\n\n    const now = new Date().getTime();\n    const expiryTime = parseInt(chatExpiry, 10);\n\n    if (now >= expiryTime) {\n        // If the current time is past the expiry, clear localStorage.\n        try {\n            await (0,_chat_util__WEBPACK_IMPORTED_MODULE_0__.resetChat)();\n        } catch (e) {\n            console.log(\"failed to reset chat after expiry\", e)\n        }\n    } else {\n        // If it's not expired, reset the timer\n        await resetChatExpiry();\n        return true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvY2hhdC1leHBpcmV5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvY2hhdC1leHBpcmV5LmpzP2RjNmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnVuY3Rpb24gdG8gc2V0IGEgbmV3IGV4cGlyeSB0aW1lICg0IGhvdXJzIGZyb20gbm93KSBpbiBsb2NhbFN0b3JhZ2VcbmltcG9ydCB7Z2V0Q2hhdFN0YXRlcywgcmVzZXRDaGF0fSBmcm9tIFwiLi9jaGF0LXV0aWxcIjtcbmltcG9ydCB7bG9hZFNldHRpbmdzfSBmcm9tIFwiLi9zaG9waWZ5LXNldHRpbmdzLWNhY2hlLnV0aWxcIjtcbmltcG9ydCB7c2F2ZVNldHRpbmdzfSBmcm9tIFwiLi4vc2VydmljZXMvc2hvcGlmeS1zZXR0aW5ncy5zZXJ2aWNlXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNldENoYXRFeHBpcnkoKSB7XG4gICAgY29uc3QgZm91ckhvdXJzSW5NcyA9IDQgKiA2MCAqIDYwICogMTAwMDtcbiAgICBjb25zdCBuZXdFeHBpcnkgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGZvdXJIb3Vyc0luTXM7XG4gICAgYXdhaXQgc2F2ZVNldHRpbmdzKHtjaGF0RXhwaXJ5OiBuZXdFeHBpcnl9KVxufVxuXG4vLyBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgc3RvcmVkIGV4cGlyeSB0aW1lIGlzIHBhc3NlZCBvciBub3RcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0NoYXRWYWxpZCgpIHtcbiAgICBjb25zdCB7Y2hhdEV4cGlyeX0gPSBhd2FpdCBsb2FkU2V0dGluZ3MoKTtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGV4cGlyeSBzZXQsIGp1c3Qgc2V0IGl0IGFuZCBleGl0IHRoZSBmdW5jdGlvbi5cbiAgICBpZiAoIWNoYXRFeHBpcnkgJiYgZ2V0Q2hhdFN0YXRlcygpLmlzQ2hhdEluaXRpYWxpemVkKSB7XG4gICAgICAgIGF3YWl0IHJlc2V0Q2hhdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgZXhwaXJ5VGltZSA9IHBhcnNlSW50KGNoYXRFeHBpcnksIDEwKTtcblxuICAgIGlmIChub3cgPj0gZXhwaXJ5VGltZSkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0aW1lIGlzIHBhc3QgdGhlIGV4cGlyeSwgY2xlYXIgbG9jYWxTdG9yYWdlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcmVzZXRDaGF0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHJlc2V0IGNoYXQgYWZ0ZXIgZXhwaXJ5XCIsIGUpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBpdCdzIG5vdCBleHBpcmVkLCByZXNldCB0aGUgdGltZXJcbiAgICAgICAgYXdhaXQgcmVzZXRDaGF0RXhwaXJ5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/chat-expirey.js\n");

/***/ }),

/***/ "./src/utils/chat-util.js":
/*!********************************!*\
  !*** ./src/utils/chat-util.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkForExistingChannel: () => (/* binding */ checkForExistingChannel),\n/* harmony export */   getChatStates: () => (/* binding */ getChatStates),\n/* harmony export */   handleMessageSend: () => (/* binding */ handleMessageSend),\n/* harmony export */   handleTalkToHumanClick: () => (/* binding */ handleTalkToHumanClick),\n/* harmony export */   isMarkdown: () => (/* binding */ isMarkdown),\n/* harmony export */   resetChat: () => (/* binding */ resetChat),\n/* harmony export */   setupChatConnection: () => (/* binding */ setupChatConnection),\n/* harmony export */   updateChatStates: () => (/* binding */ updateChatStates)\n/* harmony export */ });\n/* harmony import */ var mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixpanel-browser */ \"./node_modules/mixpanel-browser/dist/mixpanel.module.js\");\n/* harmony import */ var _ui_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui-util */ \"./src/utils/ui-util.js\");\n/* harmony import */ var _services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/mattermost.service */ \"./src/services/mattermost.service.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/utils/util.js\");\n/* harmony import */ var _shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shopify-settings-storage.util */ \"./src/utils/shopify-settings-storage.util.js\");\n/* harmony import */ var _services_general_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../services/general.service */ \"./src/services/general.service.js\");\n/* harmony import */ var _services_chat_websocket_client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../services/chat-websocket-client */ \"./src/services/chat-websocket-client.js\");\n/* harmony import */ var _chat_expirey__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chat-expirey */ \"./src/utils/chat-expirey.js\");\n/* harmony import */ var _services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../services/shopify-settings.service */ \"./src/services/shopify-settings.service.js\");\n\n\n\n\n\n\n\n\n\n\nconst INIT_STATE = {\n    nameValidationInProgress: false,\n    isChatInitialized: false,\n    sentFirstMessage: false,\n    canStartConversation: true,\n    plan: 0,\n    updatePlanUI: false,\n}\nlet STATE_FLAGS = {\n    ...INIT_STATE\n}\nconst wsClient = new _services_chat_websocket_client__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n\nasync function setupChatConnection() {\n    await (0,_chat_expirey__WEBPACK_IMPORTED_MODULE_7__.checkChatValid)();\n    if (!await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isUserCreated)()) {\n        // promptForName(null, false);\n        const inputName = `guest-${crypto.randomUUID()}`\n        const newUser = await (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.createNewGuestUser)(inputName);\n        if (newUser) {\n            await (0,_chat_expirey__WEBPACK_IMPORTED_MODULE_7__.resetChatExpiry)();\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)()\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredUserInfo)(newUser);\n            await checkForExistingChannel();\n        }\n    } else {\n        await checkForExistingChannel();\n    }\n}\n\nasync function checkForExistingChannel() {\n    updateChatStates({canStartConversation: !(await (0,_services_general_service__WEBPACK_IMPORTED_MODULE_5__.reachedSeatLimit)())})\n\n    let {userId, name, accessToken} = await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)();\n    if (userId) {\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.showLoadingSpinner)();\n        mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identify(userId)\n        mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].people.set({'$name': name});\n\n        const {userChannel, channelMessages, trialLimitReached, plan} = await (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.getOrCreatNewChannel)(userId, accessToken);\n        updateChatStates({plan: plan})\n        ;(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.updatePlanUI)()\n        ;(0,_util__WEBPACK_IMPORTED_MODULE_3__.trackEvent)(\"User connection\", {\n            userChannel,\n            messagesCount: channelMessages.length,\n        });\n        await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.storeChannelId)(userChannel)\n        updateChatStates({sentFirstMessage: !!channelMessages?.order?.length})\n        if (channelMessages?.order?.length) {\n            const orderedMessages = getOrderedMessages(channelMessages)\n            ;(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderPreviousMessages)(orderedMessages);\n        } else {\n            if (!(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.getUiElements)().chatMessages?.childElementCount) {\n                (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)()\n                await (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderMessage)({\n                    // message: `Hi ${name}, how can I help you today?`,\n                    message: `Hi, how can I help you today?`,\n                    nameOfSender: \"System\"\n                })\n            }\n\n            updateChatStates({isChatInitialized: true});\n        }\n        wsClient.connect();\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideLoadingSpinner)();\n        if (trialLimitReached) {\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideChatInputContainer)();\n            await (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderMessage)({\n                message: \"Message limit reached\",\n                nameOfSender: \"System\"\n            })\n        } else {\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.createChatToggleAction)();\n        }\n    } else {\n        // promptForName(null, false);\n        const inputName = `guest-${crypto.randomUUID()}`\n        const newUser = await (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.createNewGuestUser)(inputName);\n        if (newUser) {\n            await (0,_chat_expirey__WEBPACK_IMPORTED_MODULE_7__.resetChatExpiry)();\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)()\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredUserInfo)(newUser);\n            await checkForExistingChannel();\n        }\n    }\n}\n\nfunction promptForName(text, forceReinit = false) {\n    if (!getChatStates().canStartConversation) {\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)();\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideChatInputContainer)();\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderMessage)({nameOfSender: \"System\", message: \"Monthly seat limit reached, please talk to sales to upgrade\"});\n        return\n    }\n    const welcomeMessage = window.ChatWidgetConfig.THEME_SETTINGS?.welcomeMessage\n    if (getChatStates().isChatInitialized && !forceReinit) return;\n    if (!text) {\n        text = welcomeMessage\n            ? welcomeMessage.replace(/\\n/g, \"<br>\")\n            : `\n            <p>Please share your name to get started with the chat</p>\n            <p>اكتب اسمك عشان اقدر اساعدك</p>\n            `\n    }\n    (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderMessage)({nameOfSender: \"System\", message: text});\n    updateChatStates({isChatInitialized: true});\n}\n\nasync function handleMessageSend() {\n    const {chatInput} = (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.getUiElements)();\n    await (0,_chat_expirey__WEBPACK_IMPORTED_MODULE_7__.checkChatValid)();\n\n    if (!await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isUserCreated)()) {\n        // return await handleNameValidation();\n        const inputName = `guest-${crypto.randomUUID()}`\n        const newUser = await (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.createNewGuestUser)(inputName);\n        if (newUser) {\n            await (0,_chat_expirey__WEBPACK_IMPORTED_MODULE_7__.resetChatExpiry)();\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)()\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredUserInfo)(newUser);\n            await checkForExistingChannel();\n        }\n    }\n    const message = chatInput.value.trim();\n    if (!message) return;\n    chatInput.value = \"\";\n    (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.autoResize)(chatInput);\n    const {userId, accessToken} = await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)();\n    try {\n        if (!getChatStates().sentFirstMessage) {\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.showLoadingSpinner)()\n            updateChatStates({sentFirstMessage: true});\n            (0,_util__WEBPACK_IMPORTED_MODULE_3__.trackEvent)(\"First Message Sent\", {\n                type: await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isHumanChat)() ? \"human\" : \"bot\",\n                channelId: await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getCurrentChannelId)(),\n                userId: userId,\n                message: message\n            })\n        }\n        const channelId = await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getCurrentChannelId)();\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeQuickChatAction)()\n        try {\n            await (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.sendMessage)(userId, message, channelId, accessToken)\n        } catch (e) {\n            console.error(e);\n        }\n\n\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n    } finally {\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideLoadingSpinner)()\n    }\n}\n\n// async function handleNameValidation() {\n//     if (getChatStates().nameValidationInProgress) {\n//         return;\n//     }\n//\n//     updateChatStates({nameValidationInProgress: true})\n//\n//     try {\n//         const {chatInput} = getUiElements();\n//         const inputName = chatInput.value.trim();\n//         await renderMessage({message: inputName, userInfoInput: true})\n//         showLoadingSpinner();\n//         chatInput.value = \"\"; // Clear input\n//\n//         // Regex to allow names with letters, spaces, and hyphens from any language (supporting Unicode)\n//         if (inputName && /^[\\p{L}\\s\\-]+$/u.test(inputName)) {\n//             const newUser = await createNewGuestUser(inputName);\n//             if (newUser) {\n//                 await resetChatExpiry();\n//                 removeAllMessages()\n//                 // const displayedMessage = isArabic(inputName)\n//                 //     ? `مرحبا ${newUser.name} كيف ممكن اساعدك `\n//                 //     : `Hi ${newUser.name}, how can I help you today?`;\n//                 //\n//                 // await renderMessage({\n//                 //     message: displayedMessage,\n//                 //     nameOfSender: \"System\"\n//                 // })\n//                 await setStoredUserInfo(newUser);\n//                 await checkForExistingChannel();\n//             } else {\n//                 promptForName(undefined, true);\n//             }\n//\n//         } else {\n//             promptForName(\n//                 `<p>\n//                                 Hmm, that doesn't look like a name. Could you try again with just your name?\n//                                </p>\n//                                <p>\n//                                 ممكن تحاول مرة تانية وتكتبلي بس اسمك؟\n//                                 </p>`,\n//                 true);\n//         }\n//     } catch (error) {\n//         console.error(\"Error during name validation:\", error);\n//     } finally {\n//         hideLoadingSpinner()\n//         updateChatStates({nameValidationInProgress: false});\n//         await switchAgentUI();\n//     }\n// }\n\nfunction getOrderedMessages(channelMessages) {\n    const {order, messages} = channelMessages;\n\n    // Map the order array to the actual messages from the messages object\n    return order\n        .reverse()\n        .map(messageId => messages[messageId])\n    // .filter(message => !message?.props?.hideFromUI);\n}\n\nfunction getChatStates() {\n    return {...STATE_FLAGS}\n}\n\nfunction updateChatStates(updatedFlags) {\n    STATE_FLAGS = {\n        ...STATE_FLAGS,\n        ...updatedFlags\n    }\n}\n\nfunction resetChatStates() {\n    STATE_FLAGS = {\n        ...INIT_STATE\n    }\n}\n\nfunction isMarkdown(content) {\n    // Simple regex patterns to detect common Markdown syntax\n    const markdownPatterns = [\n        /(^|\\s)(#+\\s)/,         // Headers (e.g., #, ##, ###)\n        /(\\*\\*|__)(.*?)\\1/,     // Bold text (e.g., **bold** or __bold__)\n        /(\\*|_)(.*?)\\1/,        // Italics (e.g., *italic* or _italic_)\n        /\\[(.*?)\\]\\((.*?)\\)/,   // Links (e.g., [text](url))\n        /(```[\\s\\S]*?```)/,     // Code blocks (e.g., ```code```)\n        /(^|\\s)-\\s/,            // Lists (e.g., - item)\n    ];\n\n    // Check if any of the patterns match the content\n    return markdownPatterns.some((pattern) => pattern.test(content));\n}\n\nasync function handleTalkToHumanClick() {\n    if (!await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isUserCreated)() || await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredChatType)() === \"human\") return;\n    const talkToHumanMessage = \"talk-to-human-loading\"\n    await (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.renderMessage)({\n        id: talkToHumanMessage,\n        user_id: (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId,\n        props: {\n            temporaryMessage: true\n        }\n    })\n\n    ;(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.showLoadingSpinner)()\n    ;(0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.talkToHuman)()\n        .then(async (res) => {\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredChatType)(\"human\");\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.storeChannelId)(res.humanChannelId);\n            await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setAgentInfo)(res.agentInfo)\n            updateChatStates(res.status);\n            await (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.switchAgentUI)();\n            // removeMessageFromDOM(containerId)\n            (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)();\n            await checkForExistingChannel()\n            ;(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideLoadingSpinner)();\n        }).catch(error => {\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeMessageFromDOM)(talkToHumanMessage)\n        ;(0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.hideLoadingSpinner)();\n        (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.createChatToggleAction)()\n    })\n}\n\n\nasync function resetChat() {\n    wsClient.disconnect();\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_8__.clearSettings)()\n    resetChatStates();\n    (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.removeAllMessages)();\n    await (0,_ui_util__WEBPACK_IMPORTED_MODULE_1__.switchAgentUI)();\n    checkForExistingChannel();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvY2hhdC11dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFlQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9jaGF0LXV0aWwuanM/MjEzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWl4cGFuZWwgZnJvbSAnbWl4cGFuZWwtYnJvd3NlcidcbmltcG9ydCB7XG4gICAgYXV0b1Jlc2l6ZSxcbiAgICBjcmVhdGVDaGF0VG9nZ2xlQWN0aW9uLFxuICAgIGdldFVpRWxlbWVudHMsXG4gICAgaGlkZUNoYXRJbnB1dENvbnRhaW5lcixcbiAgICBoaWRlTG9hZGluZ1NwaW5uZXIsXG4gICAgcmVtb3ZlQWxsTWVzc2FnZXMsXG4gICAgcmVtb3ZlTWVzc2FnZUZyb21ET00sXG4gICAgcmVtb3ZlUXVpY2tDaGF0QWN0aW9uLFxuICAgIHJlbmRlck1lc3NhZ2UsXG4gICAgcmVuZGVyUHJldmlvdXNNZXNzYWdlcyxcbiAgICBzaG93TG9hZGluZ1NwaW5uZXIsXG4gICAgc3dpdGNoQWdlbnRVSSxcbiAgICB1cGRhdGVQbGFuVUlcbn0gZnJvbSBcIi4vdWktdXRpbFwiO1xuaW1wb3J0IHtjcmVhdGVOZXdHdWVzdFVzZXIsIGdldE9yQ3JlYXROZXdDaGFubmVsLCBzZW5kTWVzc2FnZSwgdGFsa1RvSHVtYW59IGZyb20gXCIuLi9zZXJ2aWNlcy9tYXR0ZXJtb3N0LnNlcnZpY2VcIjtcbmltcG9ydCB7aXNBcmFiaWMsIHRyYWNrRXZlbnR9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7XG4gICAgZ2V0Q3VycmVudENoYW5uZWxJZCxcbiAgICBnZXRTdG9yZWRDaGF0VHlwZSxcbiAgICBnZXRTdG9yZWRVc2VySW5mbyxcbiAgICBpc0h1bWFuQ2hhdCxcbiAgICBpc1VzZXJDcmVhdGVkLFxuICAgIHNldEFnZW50SW5mbyxcbiAgICBzZXRTdG9yZWRDaGF0VHlwZSxcbiAgICBzZXRTdG9yZWRVc2VySW5mbyxcbiAgICBzdG9yZUNoYW5uZWxJZFxufSBmcm9tIFwiLi9zaG9waWZ5LXNldHRpbmdzLXN0b3JhZ2UudXRpbFwiO1xuaW1wb3J0IHtyZWFjaGVkU2VhdExpbWl0fSBmcm9tIFwiLi4vc2VydmljZXMvZ2VuZXJhbC5zZXJ2aWNlXCI7XG5pbXBvcnQgQ2hhdFdlYlNvY2tldENsaWVudCBmcm9tIFwiLi4vc2VydmljZXMvY2hhdC13ZWJzb2NrZXQtY2xpZW50XCI7XG5pbXBvcnQge2NoZWNrQ2hhdFZhbGlkLCByZXNldENoYXRFeHBpcnl9IGZyb20gXCIuL2NoYXQtZXhwaXJleVwiO1xuaW1wb3J0IHtjbGVhclNldHRpbmdzfSBmcm9tIFwiLi4vc2VydmljZXMvc2hvcGlmeS1zZXR0aW5ncy5zZXJ2aWNlXCI7XG5cbmNvbnN0IElOSVRfU1RBVEUgPSB7XG4gICAgbmFtZVZhbGlkYXRpb25JblByb2dyZXNzOiBmYWxzZSxcbiAgICBpc0NoYXRJbml0aWFsaXplZDogZmFsc2UsXG4gICAgc2VudEZpcnN0TWVzc2FnZTogZmFsc2UsXG4gICAgY2FuU3RhcnRDb252ZXJzYXRpb246IHRydWUsXG4gICAgcGxhbjogMCxcbiAgICB1cGRhdGVQbGFuVUk6IGZhbHNlLFxufVxubGV0IFNUQVRFX0ZMQUdTID0ge1xuICAgIC4uLklOSVRfU1RBVEVcbn1cbmNvbnN0IHdzQ2xpZW50ID0gbmV3IENoYXRXZWJTb2NrZXRDbGllbnQoKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldHVwQ2hhdENvbm5lY3Rpb24oKSB7XG4gICAgYXdhaXQgY2hlY2tDaGF0VmFsaWQoKTtcbiAgICBpZiAoIWF3YWl0IGlzVXNlckNyZWF0ZWQoKSkge1xuICAgICAgICAvLyBwcm9tcHRGb3JOYW1lKG51bGwsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgaW5wdXROYW1lID0gYGd1ZXN0LSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gXG4gICAgICAgIGNvbnN0IG5ld1VzZXIgPSBhd2FpdCBjcmVhdGVOZXdHdWVzdFVzZXIoaW5wdXROYW1lKTtcbiAgICAgICAgaWYgKG5ld1VzZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlc2V0Q2hhdEV4cGlyeSgpO1xuICAgICAgICAgICAgcmVtb3ZlQWxsTWVzc2FnZXMoKVxuICAgICAgICAgICAgYXdhaXQgc2V0U3RvcmVkVXNlckluZm8obmV3VXNlcik7XG4gICAgICAgICAgICBhd2FpdCBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgY2hlY2tGb3JFeGlzdGluZ0NoYW5uZWwoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpIHtcbiAgICB1cGRhdGVDaGF0U3RhdGVzKHtjYW5TdGFydENvbnZlcnNhdGlvbjogIShhd2FpdCByZWFjaGVkU2VhdExpbWl0KCkpfSlcblxuICAgIGxldCB7dXNlcklkLCBuYW1lLCBhY2Nlc3NUb2tlbn0gPSBhd2FpdCBnZXRTdG9yZWRVc2VySW5mbygpO1xuICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgc2hvd0xvYWRpbmdTcGlubmVyKCk7XG4gICAgICAgIG1peHBhbmVsLmlkZW50aWZ5KHVzZXJJZClcbiAgICAgICAgbWl4cGFuZWwucGVvcGxlLnNldCh7JyRuYW1lJzogbmFtZX0pO1xuXG4gICAgICAgIGNvbnN0IHt1c2VyQ2hhbm5lbCwgY2hhbm5lbE1lc3NhZ2VzLCB0cmlhbExpbWl0UmVhY2hlZCwgcGxhbn0gPSBhd2FpdCBnZXRPckNyZWF0TmV3Q2hhbm5lbCh1c2VySWQsIGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgdXBkYXRlQ2hhdFN0YXRlcyh7cGxhbjogcGxhbn0pXG4gICAgICAgIHVwZGF0ZVBsYW5VSSgpXG4gICAgICAgIHRyYWNrRXZlbnQoXCJVc2VyIGNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgdXNlckNoYW5uZWwsXG4gICAgICAgICAgICBtZXNzYWdlc0NvdW50OiBjaGFubmVsTWVzc2FnZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3RvcmVDaGFubmVsSWQodXNlckNoYW5uZWwpXG4gICAgICAgIHVwZGF0ZUNoYXRTdGF0ZXMoe3NlbnRGaXJzdE1lc3NhZ2U6ICEhY2hhbm5lbE1lc3NhZ2VzPy5vcmRlcj8ubGVuZ3RofSlcbiAgICAgICAgaWYgKGNoYW5uZWxNZXNzYWdlcz8ub3JkZXI/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJlZE1lc3NhZ2VzID0gZ2V0T3JkZXJlZE1lc3NhZ2VzKGNoYW5uZWxNZXNzYWdlcylcbiAgICAgICAgICAgIHJlbmRlclByZXZpb3VzTWVzc2FnZXMob3JkZXJlZE1lc3NhZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZ2V0VWlFbGVtZW50cygpLmNoYXRNZXNzYWdlcz8uY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxNZXNzYWdlcygpXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVuZGVyTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2U6IGBIaSAke25hbWV9LCBob3cgY2FuIEkgaGVscCB5b3UgdG9kYXk/YCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEhpLCBob3cgY2FuIEkgaGVscCB5b3UgdG9kYXk/YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZU9mU2VuZGVyOiBcIlN5c3RlbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlQ2hhdFN0YXRlcyh7aXNDaGF0SW5pdGlhbGl6ZWQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICB3c0NsaWVudC5jb25uZWN0KCk7XG4gICAgICAgIGhpZGVMb2FkaW5nU3Bpbm5lcigpO1xuICAgICAgICBpZiAodHJpYWxMaW1pdFJlYWNoZWQpIHtcbiAgICAgICAgICAgIGhpZGVDaGF0SW5wdXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGF3YWl0IHJlbmRlck1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTWVzc2FnZSBsaW1pdCByZWFjaGVkXCIsXG4gICAgICAgICAgICAgICAgbmFtZU9mU2VuZGVyOiBcIlN5c3RlbVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3JlYXRlQ2hhdFRvZ2dsZUFjdGlvbigpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJvbXB0Rm9yTmFtZShudWxsLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGlucHV0TmFtZSA9IGBndWVzdC0ke2NyeXB0by5yYW5kb21VVUlEKCl9YFxuICAgICAgICBjb25zdCBuZXdVc2VyID0gYXdhaXQgY3JlYXRlTmV3R3Vlc3RVc2VyKGlucHV0TmFtZSk7XG4gICAgICAgIGlmIChuZXdVc2VyKSB7XG4gICAgICAgICAgICBhd2FpdCByZXNldENoYXRFeHBpcnkoKTtcbiAgICAgICAgICAgIHJlbW92ZUFsbE1lc3NhZ2VzKClcbiAgICAgICAgICAgIGF3YWl0IHNldFN0b3JlZFVzZXJJbmZvKG5ld1VzZXIpO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tGb3JFeGlzdGluZ0NoYW5uZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvbXB0Rm9yTmFtZSh0ZXh0LCBmb3JjZVJlaW5pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFnZXRDaGF0U3RhdGVzKCkuY2FuU3RhcnRDb252ZXJzYXRpb24pIHtcbiAgICAgICAgcmVtb3ZlQWxsTWVzc2FnZXMoKTtcbiAgICAgICAgaGlkZUNoYXRJbnB1dENvbnRhaW5lcigpO1xuICAgICAgICByZW5kZXJNZXNzYWdlKHtuYW1lT2ZTZW5kZXI6IFwiU3lzdGVtXCIsIG1lc3NhZ2U6IFwiTW9udGhseSBzZWF0IGxpbWl0IHJlYWNoZWQsIHBsZWFzZSB0YWxrIHRvIHNhbGVzIHRvIHVwZ3JhZGVcIn0pO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgd2VsY29tZU1lc3NhZ2UgPSB3aW5kb3cuQ2hhdFdpZGdldENvbmZpZy5USEVNRV9TRVRUSU5HUz8ud2VsY29tZU1lc3NhZ2VcbiAgICBpZiAoZ2V0Q2hhdFN0YXRlcygpLmlzQ2hhdEluaXRpYWxpemVkICYmICFmb3JjZVJlaW5pdCkgcmV0dXJuO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICB0ZXh0ID0gd2VsY29tZU1lc3NhZ2VcbiAgICAgICAgICAgID8gd2VsY29tZU1lc3NhZ2UucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKVxuICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICA8cD5QbGVhc2Ugc2hhcmUgeW91ciBuYW1lIHRvIGdldCBzdGFydGVkIHdpdGggdGhlIGNoYXQ8L3A+XG4gICAgICAgICAgICA8cD7Yp9mD2KrYqCDYp9iz2YXZgyDYudi02KfZhiDYp9mC2K/YsSDYp9iz2KfYudiv2YM8L3A+XG4gICAgICAgICAgICBgXG4gICAgfVxuICAgIHJlbmRlck1lc3NhZ2Uoe25hbWVPZlNlbmRlcjogXCJTeXN0ZW1cIiwgbWVzc2FnZTogdGV4dH0pO1xuICAgIHVwZGF0ZUNoYXRTdGF0ZXMoe2lzQ2hhdEluaXRpYWxpemVkOiB0cnVlfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlU2VuZCgpIHtcbiAgICBjb25zdCB7Y2hhdElucHV0fSA9IGdldFVpRWxlbWVudHMoKTtcbiAgICBhd2FpdCBjaGVja0NoYXRWYWxpZCgpO1xuXG4gICAgaWYgKCFhd2FpdCBpc1VzZXJDcmVhdGVkKCkpIHtcbiAgICAgICAgLy8gcmV0dXJuIGF3YWl0IGhhbmRsZU5hbWVWYWxpZGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlucHV0TmFtZSA9IGBndWVzdC0ke2NyeXB0by5yYW5kb21VVUlEKCl9YFxuICAgICAgICBjb25zdCBuZXdVc2VyID0gYXdhaXQgY3JlYXRlTmV3R3Vlc3RVc2VyKGlucHV0TmFtZSk7XG4gICAgICAgIGlmIChuZXdVc2VyKSB7XG4gICAgICAgICAgICBhd2FpdCByZXNldENoYXRFeHBpcnkoKTtcbiAgICAgICAgICAgIHJlbW92ZUFsbE1lc3NhZ2VzKClcbiAgICAgICAgICAgIGF3YWl0IHNldFN0b3JlZFVzZXJJbmZvKG5ld1VzZXIpO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tGb3JFeGlzdGluZ0NoYW5uZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gY2hhdElucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBpZiAoIW1lc3NhZ2UpIHJldHVybjtcbiAgICBjaGF0SW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIGF1dG9SZXNpemUoY2hhdElucHV0KTtcbiAgICBjb25zdCB7dXNlcklkLCBhY2Nlc3NUb2tlbn0gPSBhd2FpdCBnZXRTdG9yZWRVc2VySW5mbygpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZ2V0Q2hhdFN0YXRlcygpLnNlbnRGaXJzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHNob3dMb2FkaW5nU3Bpbm5lcigpXG4gICAgICAgICAgICB1cGRhdGVDaGF0U3RhdGVzKHtzZW50Rmlyc3RNZXNzYWdlOiB0cnVlfSk7XG4gICAgICAgICAgICB0cmFja0V2ZW50KFwiRmlyc3QgTWVzc2FnZSBTZW50XCIsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhd2FpdCBpc0h1bWFuQ2hhdCgpID8gXCJodW1hblwiIDogXCJib3RcIixcbiAgICAgICAgICAgICAgICBjaGFubmVsSWQ6IGF3YWl0IGdldEN1cnJlbnRDaGFubmVsSWQoKSxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWxJZCA9IGF3YWl0IGdldEN1cnJlbnRDaGFubmVsSWQoKTtcbiAgICAgICAgcmVtb3ZlUXVpY2tDaGF0QWN0aW9uKClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHNlbmRNZXNzYWdlKHVzZXJJZCwgbWVzc2FnZSwgY2hhbm5lbElkLCBhY2Nlc3NUb2tlbilcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuXG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyBtZXNzYWdlOlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaGlkZUxvYWRpbmdTcGlubmVyKClcbiAgICB9XG59XG5cbi8vIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5hbWVWYWxpZGF0aW9uKCkge1xuLy8gICAgIGlmIChnZXRDaGF0U3RhdGVzKCkubmFtZVZhbGlkYXRpb25JblByb2dyZXNzKSB7XG4vLyAgICAgICAgIHJldHVybjtcbi8vICAgICB9XG4vL1xuLy8gICAgIHVwZGF0ZUNoYXRTdGF0ZXMoe25hbWVWYWxpZGF0aW9uSW5Qcm9ncmVzczogdHJ1ZX0pXG4vL1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICAgIGNvbnN0IHtjaGF0SW5wdXR9ID0gZ2V0VWlFbGVtZW50cygpO1xuLy8gICAgICAgICBjb25zdCBpbnB1dE5hbWUgPSBjaGF0SW5wdXQudmFsdWUudHJpbSgpO1xuLy8gICAgICAgICBhd2FpdCByZW5kZXJNZXNzYWdlKHttZXNzYWdlOiBpbnB1dE5hbWUsIHVzZXJJbmZvSW5wdXQ6IHRydWV9KVxuLy8gICAgICAgICBzaG93TG9hZGluZ1NwaW5uZXIoKTtcbi8vICAgICAgICAgY2hhdElucHV0LnZhbHVlID0gXCJcIjsgLy8gQ2xlYXIgaW5wdXRcbi8vXG4vLyAgICAgICAgIC8vIFJlZ2V4IHRvIGFsbG93IG5hbWVzIHdpdGggbGV0dGVycywgc3BhY2VzLCBhbmQgaHlwaGVucyBmcm9tIGFueSBsYW5ndWFnZSAoc3VwcG9ydGluZyBVbmljb2RlKVxuLy8gICAgICAgICBpZiAoaW5wdXROYW1lICYmIC9eW1xccHtMfVxcc1xcLV0rJC91LnRlc3QoaW5wdXROYW1lKSkge1xuLy8gICAgICAgICAgICAgY29uc3QgbmV3VXNlciA9IGF3YWl0IGNyZWF0ZU5ld0d1ZXN0VXNlcihpbnB1dE5hbWUpO1xuLy8gICAgICAgICAgICAgaWYgKG5ld1VzZXIpIHtcbi8vICAgICAgICAgICAgICAgICBhd2FpdCByZXNldENoYXRFeHBpcnkoKTtcbi8vICAgICAgICAgICAgICAgICByZW1vdmVBbGxNZXNzYWdlcygpXG4vLyAgICAgICAgICAgICAgICAgLy8gY29uc3QgZGlzcGxheWVkTWVzc2FnZSA9IGlzQXJhYmljKGlucHV0TmFtZSlcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgPyBg2YXYsdit2KjYpyAke25ld1VzZXIubmFtZX0g2YPZitmBINmF2YXZg9mGINin2LPYp9i52K/ZgyBgXG4vLyAgICAgICAgICAgICAgICAgLy8gICAgIDogYEhpICR7bmV3VXNlci5uYW1lfSwgaG93IGNhbiBJIGhlbHAgeW91IHRvZGF5P2A7XG4vLyAgICAgICAgICAgICAgICAgLy9cbi8vICAgICAgICAgICAgICAgICAvLyBhd2FpdCByZW5kZXJNZXNzYWdlKHtcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgbWVzc2FnZTogZGlzcGxheWVkTWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAvLyAgICAgbmFtZU9mU2VuZGVyOiBcIlN5c3RlbVwiXG4vLyAgICAgICAgICAgICAgICAgLy8gfSlcbi8vICAgICAgICAgICAgICAgICBhd2FpdCBzZXRTdG9yZWRVc2VySW5mbyhuZXdVc2VyKTtcbi8vICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpO1xuLy8gICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICBwcm9tcHRGb3JOYW1lKHVuZGVmaW5lZCwgdHJ1ZSk7XG4vLyAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgcHJvbXB0Rm9yTmFtZShcbi8vICAgICAgICAgICAgICAgICBgPHA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhtbSwgdGhhdCBkb2Vzbid0IGxvb2sgbGlrZSBhIG5hbWUuIENvdWxkIHlvdSB0cnkgYWdhaW4gd2l0aCBqdXN0IHlvdXIgbmFtZT9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINmF2YXZg9mGINiq2K3Yp9mI2YQg2YXYsdipINiq2KfZhtmK2Kkg2YjYqtmD2KrYqNmE2Yog2KjYsyDYp9iz2YXZg9ifXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5gLFxuLy8gICAgICAgICAgICAgICAgIHRydWUpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbi8vICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBuYW1lIHZhbGlkYXRpb246XCIsIGVycm9yKTtcbi8vICAgICB9IGZpbmFsbHkge1xuLy8gICAgICAgICBoaWRlTG9hZGluZ1NwaW5uZXIoKVxuLy8gICAgICAgICB1cGRhdGVDaGF0U3RhdGVzKHtuYW1lVmFsaWRhdGlvbkluUHJvZ3Jlc3M6IGZhbHNlfSk7XG4vLyAgICAgICAgIGF3YWl0IHN3aXRjaEFnZW50VUkoKTtcbi8vICAgICB9XG4vLyB9XG5cbmZ1bmN0aW9uIGdldE9yZGVyZWRNZXNzYWdlcyhjaGFubmVsTWVzc2FnZXMpIHtcbiAgICBjb25zdCB7b3JkZXIsIG1lc3NhZ2VzfSA9IGNoYW5uZWxNZXNzYWdlcztcblxuICAgIC8vIE1hcCB0aGUgb3JkZXIgYXJyYXkgdG8gdGhlIGFjdHVhbCBtZXNzYWdlcyBmcm9tIHRoZSBtZXNzYWdlcyBvYmplY3RcbiAgICByZXR1cm4gb3JkZXJcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAubWFwKG1lc3NhZ2VJZCA9PiBtZXNzYWdlc1ttZXNzYWdlSWRdKVxuICAgIC8vIC5maWx0ZXIobWVzc2FnZSA9PiAhbWVzc2FnZT8ucHJvcHM/LmhpZGVGcm9tVUkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhdFN0YXRlcygpIHtcbiAgICByZXR1cm4gey4uLlNUQVRFX0ZMQUdTfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ2hhdFN0YXRlcyh1cGRhdGVkRmxhZ3MpIHtcbiAgICBTVEFURV9GTEFHUyA9IHtcbiAgICAgICAgLi4uU1RBVEVfRkxBR1MsXG4gICAgICAgIC4uLnVwZGF0ZWRGbGFnc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDaGF0U3RhdGVzKCkge1xuICAgIFNUQVRFX0ZMQUdTID0ge1xuICAgICAgICAuLi5JTklUX1NUQVRFXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXJrZG93bihjb250ZW50KSB7XG4gICAgLy8gU2ltcGxlIHJlZ2V4IHBhdHRlcm5zIHRvIGRldGVjdCBjb21tb24gTWFya2Rvd24gc3ludGF4XG4gICAgY29uc3QgbWFya2Rvd25QYXR0ZXJucyA9IFtcbiAgICAgICAgLyhefFxccykoIytcXHMpLywgICAgICAgICAvLyBIZWFkZXJzIChlLmcuLCAjLCAjIywgIyMjKVxuICAgICAgICAvKFxcKlxcKnxfXykoLio/KVxcMS8sICAgICAvLyBCb2xkIHRleHQgKGUuZy4sICoqYm9sZCoqIG9yIF9fYm9sZF9fKVxuICAgICAgICAvKFxcKnxfKSguKj8pXFwxLywgICAgICAgIC8vIEl0YWxpY3MgKGUuZy4sICppdGFsaWMqIG9yIF9pdGFsaWNfKVxuICAgICAgICAvXFxbKC4qPylcXF1cXCgoLio/KVxcKS8sICAgLy8gTGlua3MgKGUuZy4sIFt0ZXh0XSh1cmwpKVxuICAgICAgICAvKGBgYFtcXHNcXFNdKj9gYGApLywgICAgIC8vIENvZGUgYmxvY2tzIChlLmcuLCBgYGBjb2RlYGBgKVxuICAgICAgICAvKF58XFxzKS1cXHMvLCAgICAgICAgICAgIC8vIExpc3RzIChlLmcuLCAtIGl0ZW0pXG4gICAgXTtcblxuICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcGF0dGVybnMgbWF0Y2ggdGhlIGNvbnRlbnRcbiAgICByZXR1cm4gbWFya2Rvd25QYXR0ZXJucy5zb21lKChwYXR0ZXJuKSA9PiBwYXR0ZXJuLnRlc3QoY29udGVudCkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlVGFsa1RvSHVtYW5DbGljaygpIHtcbiAgICBpZiAoIWF3YWl0IGlzVXNlckNyZWF0ZWQoKSB8fCBhd2FpdCBnZXRTdG9yZWRDaGF0VHlwZSgpID09PSBcImh1bWFuXCIpIHJldHVybjtcbiAgICBjb25zdCB0YWxrVG9IdW1hbk1lc3NhZ2UgPSBcInRhbGstdG8taHVtYW4tbG9hZGluZ1wiXG4gICAgYXdhaXQgcmVuZGVyTWVzc2FnZSh7XG4gICAgICAgIGlkOiB0YWxrVG9IdW1hbk1lc3NhZ2UsXG4gICAgICAgIHVzZXJfaWQ6IChhd2FpdCBnZXRTdG9yZWRVc2VySW5mbygpKS51c2VySWQsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0ZW1wb3JhcnlNZXNzYWdlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgc2hvd0xvYWRpbmdTcGlubmVyKClcbiAgICB0YWxrVG9IdW1hbigpXG4gICAgICAgIC50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHNldFN0b3JlZENoYXRUeXBlKFwiaHVtYW5cIik7XG4gICAgICAgICAgICBhd2FpdCBzdG9yZUNoYW5uZWxJZChyZXMuaHVtYW5DaGFubmVsSWQpO1xuICAgICAgICAgICAgYXdhaXQgc2V0QWdlbnRJbmZvKHJlcy5hZ2VudEluZm8pXG4gICAgICAgICAgICB1cGRhdGVDaGF0U3RhdGVzKHJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgYXdhaXQgc3dpdGNoQWdlbnRVSSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlTWVzc2FnZUZyb21ET00oY29udGFpbmVySWQpXG4gICAgICAgICAgICByZW1vdmVBbGxNZXNzYWdlcygpO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tGb3JFeGlzdGluZ0NoYW5uZWwoKVxuICAgICAgICAgICAgaGlkZUxvYWRpbmdTcGlubmVyKCk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcmVtb3ZlTWVzc2FnZUZyb21ET00odGFsa1RvSHVtYW5NZXNzYWdlKVxuICAgICAgICBoaWRlTG9hZGluZ1NwaW5uZXIoKTtcbiAgICAgICAgY3JlYXRlQ2hhdFRvZ2dsZUFjdGlvbigpXG4gICAgfSlcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzZXRDaGF0KCkge1xuICAgIHdzQ2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICBhd2FpdCBjbGVhclNldHRpbmdzKClcbiAgICByZXNldENoYXRTdGF0ZXMoKTtcbiAgICByZW1vdmVBbGxNZXNzYWdlcygpO1xuICAgIGF3YWl0IHN3aXRjaEFnZW50VUkoKTtcbiAgICBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/chat-util.js\n");

/***/ }),

/***/ "./src/utils/shopify-settings-cache.util.js":
/*!**************************************************!*\
  !*** ./src/utils/shopify-settings-cache.util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearSettingsCache: () => (/* binding */ clearSettingsCache),\n/* harmony export */   loadSettings: () => (/* binding */ loadSettings),\n/* harmony export */   refreshSettingsCache: () => (/* binding */ refreshSettingsCache),\n/* harmony export */   updateCacheAfterSave: () => (/* binding */ updateCacheAfterSave)\n/* harmony export */ });\n/* harmony import */ var _services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/shopify-settings.service */ \"./src/services/shopify-settings.service.js\");\n\n\nlet settings = null;\n\nasync function loadSettings() {\n    if (!settings) {\n        settings = await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_0__.fetchSettings)(); // your authFetch wrapper\n    }\n    return settings;\n}\n\nfunction updateCacheAfterSave(newCache) {\n    clearSettingsCache()\n    settings = newCache;\n}\n\nfunction clearSettingsCache() {\n    settings = null;\n}\n\nasync function refreshSettingsCache() {\n    clearSettingsCache()\n    await loadSettings()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvc2hvcGlmeS1zZXR0aW5ncy1jYWNoZS51dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3Nob3BpZnktc2V0dGluZ3MtY2FjaGUudXRpbC5qcz9hYjcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZmV0Y2hTZXR0aW5nc30gZnJvbSBcIi4uL3NlcnZpY2VzL3Nob3BpZnktc2V0dGluZ3Muc2VydmljZVwiO1xuXG5sZXQgc2V0dGluZ3MgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFNldHRpbmdzKCkge1xuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBhd2FpdCBmZXRjaFNldHRpbmdzKCk7IC8vIHlvdXIgYXV0aEZldGNoIHdyYXBwZXJcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ2FjaGVBZnRlclNhdmUobmV3Q2FjaGUpIHtcbiAgICBjbGVhclNldHRpbmdzQ2FjaGUoKVxuICAgIHNldHRpbmdzID0gbmV3Q2FjaGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNldHRpbmdzQ2FjaGUoKSB7XG4gICAgc2V0dGluZ3MgPSBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFNldHRpbmdzQ2FjaGUoKSB7XG4gICAgY2xlYXJTZXR0aW5nc0NhY2hlKClcbiAgICBhd2FpdCBsb2FkU2V0dGluZ3MoKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/shopify-settings-cache.util.js\n");

/***/ }),

/***/ "./src/utils/shopify-settings-storage.util.js":
/*!****************************************************!*\
  !*** ./src/utils/shopify-settings-storage.util.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAgentInfo: () => (/* binding */ getAgentInfo),\n/* harmony export */   getCurrentChannelId: () => (/* binding */ getCurrentChannelId),\n/* harmony export */   getStoredChatType: () => (/* binding */ getStoredChatType),\n/* harmony export */   getStoredGptChannelId: () => (/* binding */ getStoredGptChannelId),\n/* harmony export */   getStoredHumanChannelId: () => (/* binding */ getStoredHumanChannelId),\n/* harmony export */   getStoredUserInfo: () => (/* binding */ getStoredUserInfo),\n/* harmony export */   isHumanChat: () => (/* binding */ isHumanChat),\n/* harmony export */   isUserCreated: () => (/* binding */ isUserCreated),\n/* harmony export */   setAgentInfo: () => (/* binding */ setAgentInfo),\n/* harmony export */   setStoredChatType: () => (/* binding */ setStoredChatType),\n/* harmony export */   setStoredGptChannelId: () => (/* binding */ setStoredGptChannelId),\n/* harmony export */   setStoredHumanChannelId: () => (/* binding */ setStoredHumanChannelId),\n/* harmony export */   setStoredUserInfo: () => (/* binding */ setStoredUserInfo),\n/* harmony export */   storeChannelId: () => (/* binding */ storeChannelId)\n/* harmony export */ });\n/* harmony import */ var _shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shopify-settings-cache.util */ \"./src/utils/shopify-settings-cache.util.js\");\n/* harmony import */ var _services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/shopify-settings.service */ \"./src/services/shopify-settings.service.js\");\n\n\n\nasync function getStoredUserInfo() {\n    const storedInfo = (await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__.loadSettings)())?.chatUserInfo\n    if (storedInfo) {\n        const {userId, name, username, accessToken} = storedInfo;\n        return {userId, name, username, accessToken};\n    }\n    return {userId: null, username: null, name: null, accessToken: null};\n}\n\nasync function setStoredUserInfo(userInfo) {\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__.saveSettings)({chatUserInfo: userInfo})\n}\n\nasync function getStoredChatType() {\n    const {chatType} = await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__.loadSettings)()\n    return chatType || null;\n}\n\nasync function isHumanChat() {\n    return await getStoredChatType() === \"human\"\n}\n\nasync function storeChannelId(channelId) {\n    await isHumanChat() ? await setStoredHumanChannelId(channelId) : await setStoredGptChannelId(channelId)\n}\n\nasync function getCurrentChannelId() {\n    return await isHumanChat() ? await getStoredHumanChannelId() : await getStoredGptChannelId()\n}\n\nasync function getStoredGptChannelId() {\n    const {superSalesGptChannel} = await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__.loadSettings)();\n    return superSalesGptChannel || null;\n}\n\nasync function setStoredGptChannelId(channelId) {\n    if (!channelId) {\n        console.error(`Could not set gpt channel id}`)\n        return;\n    }\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__.saveSettings)({superSalesGptChannel: channelId})\n}\n\nasync function getStoredHumanChannelId() {\n    const {superSalesHumanChannel} = await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__.loadSettings)();\n    return superSalesHumanChannel || null;\n}\n\nasync function setStoredHumanChannelId(channelId) {\n    if (!channelId) {\n        console.error(`Could not set human channel id}`)\n        return;\n    }\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__.saveSettings)({superSalesHumanChannel: channelId})\n}\n\nasync function setStoredChatType(type) {\n    if (!type) {\n        console.error(`Could not set chat type}`)\n        return;\n    }\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__.saveSettings)({chatType: type})\n\n}\n\nasync function isUserCreated() {\n    const {userId} = await getStoredUserInfo();\n    return userId != null;\n}\n\nasync function getAgentInfo() {\n    const {agentInfo} = await (0,_shopify_settings_cache_util__WEBPACK_IMPORTED_MODULE_0__.loadSettings)();\n    return agentInfo ? agentInfo : null\n}\n\nasync function setAgentInfo(agentInfo) {\n    await (0,_services_shopify_settings_service__WEBPACK_IMPORTED_MODULE_1__.saveSettings)({agentInfo: agentInfo})\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvc2hvcGlmeS1zZXR0aW5ncy1zdG9yYWdlLnV0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9zaG9waWZ5LXNldHRpbmdzLXN0b3JhZ2UudXRpbC5qcz8zODAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7bG9hZFNldHRpbmdzfSBmcm9tIFwiLi9zaG9waWZ5LXNldHRpbmdzLWNhY2hlLnV0aWxcIjtcbmltcG9ydCB7c2F2ZVNldHRpbmdzfSBmcm9tIFwiLi4vc2VydmljZXMvc2hvcGlmeS1zZXR0aW5ncy5zZXJ2aWNlXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdG9yZWRVc2VySW5mbygpIHtcbiAgICBjb25zdCBzdG9yZWRJbmZvID0gKGF3YWl0IGxvYWRTZXR0aW5ncygpKT8uY2hhdFVzZXJJbmZvXG4gICAgaWYgKHN0b3JlZEluZm8pIHtcbiAgICAgICAgY29uc3Qge3VzZXJJZCwgbmFtZSwgdXNlcm5hbWUsIGFjY2Vzc1Rva2VufSA9IHN0b3JlZEluZm87XG4gICAgICAgIHJldHVybiB7dXNlcklkLCBuYW1lLCB1c2VybmFtZSwgYWNjZXNzVG9rZW59O1xuICAgIH1cbiAgICByZXR1cm4ge3VzZXJJZDogbnVsbCwgdXNlcm5hbWU6IG51bGwsIG5hbWU6IG51bGwsIGFjY2Vzc1Rva2VuOiBudWxsfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFN0b3JlZFVzZXJJbmZvKHVzZXJJbmZvKSB7XG4gICAgYXdhaXQgc2F2ZVNldHRpbmdzKHtjaGF0VXNlckluZm86IHVzZXJJbmZvfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZENoYXRUeXBlKCkge1xuICAgIGNvbnN0IHtjaGF0VHlwZX0gPSBhd2FpdCBsb2FkU2V0dGluZ3MoKVxuICAgIHJldHVybiBjaGF0VHlwZSB8fCBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIdW1hbkNoYXQoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGdldFN0b3JlZENoYXRUeXBlKCkgPT09IFwiaHVtYW5cIlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcmVDaGFubmVsSWQoY2hhbm5lbElkKSB7XG4gICAgYXdhaXQgaXNIdW1hbkNoYXQoKSA/IGF3YWl0IHNldFN0b3JlZEh1bWFuQ2hhbm5lbElkKGNoYW5uZWxJZCkgOiBhd2FpdCBzZXRTdG9yZWRHcHRDaGFubmVsSWQoY2hhbm5lbElkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudENoYW5uZWxJZCgpIHtcbiAgICByZXR1cm4gYXdhaXQgaXNIdW1hbkNoYXQoKSA/IGF3YWl0IGdldFN0b3JlZEh1bWFuQ2hhbm5lbElkKCkgOiBhd2FpdCBnZXRTdG9yZWRHcHRDaGFubmVsSWQoKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVkR3B0Q2hhbm5lbElkKCkge1xuICAgIGNvbnN0IHtzdXBlclNhbGVzR3B0Q2hhbm5lbH0gPSBhd2FpdCBsb2FkU2V0dGluZ3MoKTtcbiAgICByZXR1cm4gc3VwZXJTYWxlc0dwdENoYW5uZWwgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFN0b3JlZEdwdENoYW5uZWxJZChjaGFubmVsSWQpIHtcbiAgICBpZiAoIWNoYW5uZWxJZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc2V0IGdwdCBjaGFubmVsIGlkfWApXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgc2F2ZVNldHRpbmdzKHtzdXBlclNhbGVzR3B0Q2hhbm5lbDogY2hhbm5lbElkfSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZEh1bWFuQ2hhbm5lbElkKCkge1xuICAgIGNvbnN0IHtzdXBlclNhbGVzSHVtYW5DaGFubmVsfSA9IGF3YWl0IGxvYWRTZXR0aW5ncygpO1xuICAgIHJldHVybiBzdXBlclNhbGVzSHVtYW5DaGFubmVsIHx8IG51bGw7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRTdG9yZWRIdW1hbkNoYW5uZWxJZChjaGFubmVsSWQpIHtcbiAgICBpZiAoIWNoYW5uZWxJZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc2V0IGh1bWFuIGNoYW5uZWwgaWR9YClcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBzYXZlU2V0dGluZ3Moe3N1cGVyU2FsZXNIdW1hbkNoYW5uZWw6IGNoYW5uZWxJZH0pXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRTdG9yZWRDaGF0VHlwZSh0eXBlKSB7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzZXQgY2hhdCB0eXBlfWApXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgc2F2ZVNldHRpbmdzKHtjaGF0VHlwZTogdHlwZX0pXG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzVXNlckNyZWF0ZWQoKSB7XG4gICAgY29uc3Qge3VzZXJJZH0gPSBhd2FpdCBnZXRTdG9yZWRVc2VySW5mbygpO1xuICAgIHJldHVybiB1c2VySWQgIT0gbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFnZW50SW5mbygpIHtcbiAgICBjb25zdCB7YWdlbnRJbmZvfSA9IGF3YWl0IGxvYWRTZXR0aW5ncygpO1xuICAgIHJldHVybiBhZ2VudEluZm8gPyBhZ2VudEluZm8gOiBudWxsXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRBZ2VudEluZm8oYWdlbnRJbmZvKSB7XG4gICAgYXdhaXQgc2F2ZVNldHRpbmdzKHthZ2VudEluZm86IGFnZW50SW5mb30pXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/shopify-settings-storage.util.js\n");

/***/ }),

/***/ "./src/utils/state-util.js":
/*!*********************************!*\
  !*** ./src/utils/state-util.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAgentOnlineStatus: () => (/* binding */ getAgentOnlineStatus),\n/* harmony export */   setAgentOnlineStatus: () => (/* binding */ setAgentOnlineStatus)\n/* harmony export */ });\nlet onlineStatus = null;\n\nfunction setAgentOnlineStatus(onlineState) {\n    onlineStatus = onlineState\n}\n\nfunction getAgentOnlineStatus() {\n    return onlineStatus;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvc3RhdGUtdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9zdGF0ZS11dGlsLmpzP2IzMzIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IG9ubGluZVN0YXR1cyA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBZ2VudE9ubGluZVN0YXR1cyhvbmxpbmVTdGF0ZSkge1xuICAgIG9ubGluZVN0YXR1cyA9IG9ubGluZVN0YXRlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZ2VudE9ubGluZVN0YXR1cygpIHtcbiAgICByZXR1cm4gb25saW5lU3RhdHVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/state-util.js\n");

/***/ }),

/***/ "./src/utils/ui-util.js":
/*!******************************!*\
  !*** ./src/utils/ui-util.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoResize: () => (/* binding */ autoResize),\n/* harmony export */   createChatToggleAction: () => (/* binding */ createChatToggleAction),\n/* harmony export */   createTalkToGPTQuickAction: () => (/* binding */ createTalkToGPTQuickAction),\n/* harmony export */   createTalkToHumanQuickAction: () => (/* binding */ createTalkToHumanQuickAction),\n/* harmony export */   createUIElements: () => (/* binding */ createUIElements),\n/* harmony export */   createUIElementsListeners: () => (/* binding */ createUIElementsListeners),\n/* harmony export */   editMessage: () => (/* binding */ editMessage),\n/* harmony export */   existsInDom: () => (/* binding */ existsInDom),\n/* harmony export */   getUiElements: () => (/* binding */ getUiElements),\n/* harmony export */   hideChatInputContainer: () => (/* binding */ hideChatInputContainer),\n/* harmony export */   hideLoadingSpinner: () => (/* binding */ hideLoadingSpinner),\n/* harmony export */   hideTemporarySystemMessage: () => (/* binding */ hideTemporarySystemMessage),\n/* harmony export */   hideTypingIndicator: () => (/* binding */ hideTypingIndicator),\n/* harmony export */   playNotificationSound: () => (/* binding */ playNotificationSound),\n/* harmony export */   removeAllMessages: () => (/* binding */ removeAllMessages),\n/* harmony export */   removeMessageFromDOM: () => (/* binding */ removeMessageFromDOM),\n/* harmony export */   removeQuickChatAction: () => (/* binding */ removeQuickChatAction),\n/* harmony export */   renderMessage: () => (/* binding */ renderMessage),\n/* harmony export */   renderPreviousMessages: () => (/* binding */ renderPreviousMessages),\n/* harmony export */   scrollToBottom: () => (/* binding */ scrollToBottom),\n/* harmony export */   setupUI: () => (/* binding */ setupUI),\n/* harmony export */   showFullImageModal: () => (/* binding */ showFullImageModal),\n/* harmony export */   showLoadingSpinner: () => (/* binding */ showLoadingSpinner),\n/* harmony export */   showTypingIndicator: () => (/* binding */ showTypingIndicator),\n/* harmony export */   switchAgentUI: () => (/* binding */ switchAgentUI),\n/* harmony export */   toggleChatVisibility: () => (/* binding */ toggleChatVisibility),\n/* harmony export */   updateDisplayedOnlineStatus: () => (/* binding */ updateDisplayedOnlineStatus),\n/* harmony export */   updatePlanUI: () => (/* binding */ updatePlanUI)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/utils/util.js\");\n/* harmony import */ var _chat_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chat-util */ \"./src/utils/chat-util.js\");\n/* harmony import */ var _services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/mattermost.service */ \"./src/services/mattermost.service.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shopify-settings-storage.util */ \"./src/utils/shopify-settings-storage.util.js\");\n\n\n\n\n\n\nlet UI_ELEMENTS = {\n    chatButton: null,\n    chatWidget: null,\n    closeChatButton: null,\n    chatButtonSmartBuy: null,\n    chatHeader: null,\n    sendButton: null,\n    chatInput: null,\n    sendButtonIcon: null,\n    chatInputContainer: null,\n    loadingSpinner: null,\n    chatMessages: null,\n    typingIndicator: null\n}\nlet backgroundColor = \"#000000\";\nlet textColor = \"#ffffff\";\nlet secondaryTextColor = \"#666\";\nlet textFont = undefined;\nlet headerText = \"Our virtual assistant is here to help you.\";\nlet welcomeMessage = undefined;\n\nfunction getUiElements() {\n    return UI_ELEMENTS;\n}\n\nasync function createUIElements() {\n    const chatButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [], \"Chat with us\", \"chat-button\")\n    // document.body.appendChild(chatButton)\n    const chatWidget = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"hidden\"], \"\", \"chat-widget\");\n    if (textFont) {\n        chatWidget.style.fontFamily = textFont;\n        chatWidget.style.borderColor = textFont;\n    }\n    document.body.appendChild(chatWidget)\n\n    const closeChatButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n        \"button\",\n        [\"chat-app--close-button\", \"chat-app--close-button--#ffdd00\", \"hidden\"],\n        `\n                    <svg color=\"${textColor}\" fill=\"none\" height=\"31\" viewBox=\"0 0 31 31\" width=\"31\"\n                         xmlns=\"http://www.w3.org/2000/svg\">\n                        <path clip-rule=\"evenodd\" d=\"M17.7159 15.5555L24.2747 8.99673C24.872 8.39937 24.872 7.43381 24.2747 6.83645C23.6773 6.23909 22.7118 6.23909 22.1144 6.83645L15.5556 13.3952L8.99689 6.83645C8.39953 6.23909 7.43398 6.23909 6.83662 6.83645C6.23926 7.43381 6.23926 8.39937 6.83662 8.99673L13.3954 15.5555L6.83662 22.1142C6.23926 22.7116 6.23926 23.6771 6.83662 24.2745C7.13453 24.5724 7.52564 24.7221 7.91676 24.7221C8.30787 24.7221 8.69898 24.5724 8.99689 24.2745L15.5556 17.7158L22.1144 24.2745C22.4123 24.5724 22.8034 24.7221 23.1945 24.7221C23.5856 24.7221 23.9768 24.5724 24.2747 24.2745C24.872 23.6771 24.872 22.7116 24.2747 22.1142L17.7159 15.5555Z\"\n                              fill=\"currentColor\"\n                              fill-rule=\"evenodd\"></path>\n                        <mask height=\"19\" id=\"svg-CancelIcon-1ZgYb6R\" maskUnits=\"userSpaceOnUse\" width=\"19\" x=\"6\"\n                              y=\"6\">\n                            <path clip-rule=\"evenodd\" d=\"M17.7159 15.5555L24.2747 8.99673C24.872 8.39937 24.872 7.43381 24.2747 6.83645C23.6773 6.23909 22.7118 6.23909 22.1144 6.83645L15.5556 13.3952L8.99689 6.83645C8.39953 6.23909 7.43398 6.23909 6.83662 6.83645C6.23926 7.43381 6.23926 8.39937 6.83662 8.99673L13.3954 15.5555L6.83662 22.1142C6.23926 22.7116 6.23926 23.6771 6.83662 24.2745C7.13453 24.5724 7.52564 24.7221 7.91676 24.7221C8.30787 24.7221 8.69898 24.5724 8.99689 24.2745L15.5556 17.7158L22.1144 24.2745C22.4123 24.5724 22.8034 24.7221 23.1945 24.7221C23.5856 24.7221 23.9768 24.5724 24.2747 24.2745C24.872 23.6771 24.872 22.7116 24.2747 22.1142L17.7159 15.5555Z\"\n                                  fill=\"currentColor\"\n                                  fill-rule=\"evenodd\"></path>\n                        </mask>\n                        <g mask=\"url(#svg-CancelIcon-1ZgYb6R)\">\n                            <rect fill=\"none\" height=\"32.0833\" transform=\"translate(0.27771 0.27771)\" width=\"32.0833\"></rect>\n                        </g>\n                    </svg>\n                `,\n        \"close-smart-buy-button\"\n    )\n\n    closeChatButton.style.setProperty('background-color', backgroundColor)\n\n    const chatButtonSmartBuy = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n        \"div\",\n        [],\n        `\n                <button aria-label=\"Chat window\" class=\"chat-toggle chat-toggle--#ffdd00 chat-toggle--icon-button chat-toggle--text-button\"\n                data-spec=\"toggle-button\"\n                style=\"background-color: ${backgroundColor}; color: ${textColor};\"\n                type=\"button\">\n                    <svg data-spec=\"button-icon\" fill=\"none\" height=\"20\" viewBox=\"0 0 20 20\"\n                         width=\"20\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <path clip-rule=\"evenodd\" d=\"M4 9.78374C4 5.84433 4.81543 5 8.62 5H11.38C15.1846 5 16 5.84433 16 9.78374C16 13.7232 15.1846 14.9008 11.38 14.9008H10.8303C10.8025 14.9346 10.7703 14.9666 10.7336 14.9962L8.54286 16.86C8.12929 17.1935 7.5137 16.898 7.5137 16.3667V14.87C4.65254 14.6884 4 13.3078 4 9.78374ZM10 10.6667C10.3682 10.6667 10.6667 10.3682 10.6667 10C10.6667 9.63181 10.3682 9.33333 10 9.33333C9.63181 9.33333 9.33333 9.63181 9.33333 10C9.33333 10.3682 9.63181 10.6667 10 10.6667ZM13.3333 10C13.3333 10.3682 13.0349 10.6667 12.6667 10.6667C12.2985 10.6667 12 10.3682 12 10C12 9.63181 12.2985 9.33333 12.6667 9.33333C13.0349 9.33333 13.3333 9.63181 13.3333 10ZM7.33333 10.6667C7.70152 10.6667 8 10.3682 8 10C8 9.63181 7.70152 9.33333 7.33333 9.33333C6.96514 9.33333 6.66667 9.63181 6.66667 10C6.66667 10.3682 6.96514 10.6667 7.33333 10.6667Z\"\n                              fill=\"${textColor}\"\n                              fill-rule=\"evenodd\"></path>\n                    </svg>\n                    <span class=\"chat-title\" data-spec=\"button-text\">Chat</span>\n                 </button>\n            `,\n        \"\"\n    )\n    const chatRootDiv = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"chat-app\", \"chat-app--is-open\", \"chat-app--\"], \"\", \"\");\n    chatRootDiv.appendChild(chatWidget)\n    chatRootDiv.appendChild(chatButtonSmartBuy)\n    chatRootDiv.appendChild(closeChatButton)\n\n    const chatContainerDev = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"dev\", [\"super-sales-chat-container\"], \"\", \"super-sales-chat-container\");\n    chatContainerDev.appendChild(chatRootDiv);\n    document.body.appendChild(chatContainerDev)\n\n    const typingIndicator = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"hidden\", \"typing-indicator\"], 'Typing...', \"typing-indicator\");\n\n    const chatHeader = createChatHeader();\n\n    const poweredByBanner = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"powered-by-banner\"], \"Powered by Stryk.AI\", \"powered-by-banner\")\n    poweredByBanner.addEventListener(\"click\", async () => {\n        const newWin = window.open(\"\", \"_blank\");\n        newWin.location.href = \"https://www.raizn.com/stryk-ai\";\n    })\n    poweredByBanner.style.setProperty('--text-color', window.ChatWidgetConfig.THEME_SETTINGS?.backgroundColor);\n    poweredByBanner.style.setProperty('--secondary-text-color', window.ChatWidgetConfig.THEME_SETTINGS?.secondaryTextColor);\n\n    chatWidget.append(\n        chatHeader,\n        (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [], \"\", \"chat-messages\"),\n        typingIndicator,\n        poweredByBanner,\n        (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"hidden\", \"loading-spinner\"], \"\", \"loading-spinner\"),\n    )\n\n\n    chatWidget.appendChild((0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\",\n        [],\n        '<textarea id=\"chat-input\" placeholder=\"Type a message...\" autocomplete=\"off\" rows=\"1\"></textarea>\\n' +\n        '            <button id=\"send-button\" class=\"str-chat__send-button\" aria-label=\"Send\" type=\"button\">\\n' +\n        '                <svg id=\"send-button-icon\" fill=\"#cdcdcf\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\\n' +\n        '                    <title>Send</title>\\n' +\n        '                    <path  d=\"M4.00952 22L24 12L4.00952 2L4 9.77778L18.2857 12L4 14.2222L4.00952 22Z\" ></path>\\n' +\n        '                </svg>\\n' +\n        '            </button>',\n        \"chat-input-container\")\n    )\n\n\n    ;(0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"message-container\"]);\n    // const chatButton = document.getElementById(\"chat-button\");\n    const chatMessages = document.getElementById(\"chat-messages\");\n    const chatInput = document.getElementById(\"chat-input\");\n    const sendButton = document.getElementById(\"send-button\");\n    const sendButtonIcon = document.getElementById(\"send-button-icon\");\n    const chatInputContainer = document.getElementById(\"chat-input-container\");\n    const loadingSpinner = document.getElementById(\"loading-spinner\");\n\n    if ([chatButton, chatWidget, chatMessages, chatInput, sendButton, loadingSpinner].some(el => !el)) {\n        console.error(\"Some DOM elements are missing. Please ensure all required elements are present.\");\n        return;\n    }\n\n    console.log(\"Initializing chat widget...\");\n    await switchAgentUI();\n    UI_ELEMENTS = {\n        chatButton,\n        chatWidget,\n        closeChatButton,\n        chatButtonSmartBuy,\n        chatHeader,\n        sendButton,\n        chatInput,\n        sendButtonIcon,\n        chatInputContainer,\n        loadingSpinner,\n        chatMessages,\n        typingIndicator,\n    }\n    return UI_ELEMENTS;\n}\n\nfunction createUIElementsListeners() {\n    if (notFullyInitialized()) {\n        console.error(\"Not all required DOM elements initialized, cannot createUIElementsListeners\");\n        return;\n    }\n\n    const {\n        chatButton,\n        closeChatButton,\n        chatWidget,\n        chatButtonSmartBuy,\n        chatHeader,\n        sendButton,\n        chatInput,\n        sendButtonIcon,\n    } = getUiElements();\n\n    chatButton.addEventListener(\"click\", async () => {\n        closeChatButton.classList.remove(\"hidden\");\n        chatWidget.classList.remove(\"hidden\");\n        chatButton.classList.add(\"hidden\");\n        if (!(0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getCurrentChannelId)()) await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.setupChatConnection)();\n        scrollToBottom();\n    });\n\n    chatButtonSmartBuy.addEventListener(\"click\", async () => {\n        closeChatButton.classList.remove(\"hidden\");\n        chatWidget.classList.remove(\"hidden\");\n        chatButtonSmartBuy.classList.add(\"hidden\");\n        chatButton.classList.add(\"hidden\");\n        if (!(0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getCurrentChannelId)()) await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.setupChatConnection)();\n        scrollToBottom();\n    });\n\n    chatHeader.addEventListener(\"click\", toggleChatVisibility);\n    closeChatButton.addEventListener(\"click\", toggleChatVisibility);\n\n    sendButton.addEventListener(\"click\", async () => await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.handleMessageSend)());\n\n    chatInput.addEventListener(\"keypress\", async (event) => {\n        if (event.key === \"Enter\" && chatInput.value.trim()) {\n            if (event.shiftKey) {\n                // Shift+Enter: allow new line (default behavior)\n                return;\n            }\n            event.preventDefault();\n            await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.handleMessageSend)()\n        }\n    });\n\n    chatInput.addEventListener(\"input\", () => {\n        autoResize(chatInput);\n        if (chatInput?.value?.trim()?.length) {\n            sendButtonIcon.setAttribute('fill', \"rgb(106, 106, 106)\")\n        } else {\n            sendButtonIcon.setAttribute('fill', \"#cdcdcf\")\n        }\n    })\n}\n\nasync function setupUI() {\n    applyCustomStyling();\n    await createUIElements();\n    createUIElementsListeners();\n    return getUiElements();\n}\n\nfunction toggleChatVisibility() {\n    const {closeChatButton, chatButtonSmartBuy, chatWidget, chatButton} = getUiElements();\n    if (!closeChatButton || !chatButtonSmartBuy || !chatWidget || !chatButton) {\n        console.error(\"missing ui elements, cannot toggle chat visibility\");\n        return;\n    }\n    closeChatButton.classList.toggle(\"hidden\");\n    chatButtonSmartBuy.classList.toggle(\"hidden\");\n    chatWidget.classList.toggle(\"hidden\");\n    chatButton.classList.toggle(\"hidden\");\n}\n\nfunction showLoadingSpinner() {\n    const {loadingSpinner, chatMessages} = getUiElements();\n    if (!loadingSpinner) {\n        console.error(\"Loading spinner element not in DOM, cannot show spinner\");\n        return;\n    }\n\n    if (!chatMessages) {\n        console.error(\"chatMessages element not in DOM, cannot show spinner\");\n        return;\n    }\n    loadingSpinner.classList.remove(\"hidden\");\n    chatMessages.classList.add(\"hidden-placeholder\");\n}\n\nfunction hideLoadingSpinner() {\n    const {loadingSpinner, chatMessages} = getUiElements();\n    if (!loadingSpinner) {\n        console.error(\"Loading spinner element not in DOM, cannot hide spinner\");\n        return;\n    }\n    if (!chatMessages) {\n        console.error(\"chatMessages element not in DOM, cannot show spinner\");\n        return;\n    }\n    loadingSpinner.classList.add(\"hidden\");\n    chatMessages.classList.remove(\"hidden-placeholder\");\n}\n\nfunction scrollToBottom() {\n    const {chatMessages} = getUiElements();\n    if (!chatMessages) {\n        console.error(\"Chat messages element not in DOM, cannot scroll to bottom\");\n        return;\n    }\n    chatMessages.scrollTop = chatMessages.scrollHeight;\n}\n\nasync function renderMessage(messageObj) {\n    if (messageObj.props?.hideFromUI) return;\n    if (messageObj?.props?.switchedToHumanNotification) return\n    const {chatInput, chatMessages} = getUiElements();\n    if (!chatInput) {\n        console.error(\"Chat Input element not in DOM, cannot render message\");\n        return;\n    }\n\n    if (!chatMessages) {\n        console.error(\"Chat Messages element not in DOM, cannot render message\");\n        return;\n    }\n\n    if (existsInDom(messageObj.id)) return\n\n    const messageContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"message-container\"], \"\", messageObj?.id);\n    const userInfo = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"user-info\"]);\n    const message = (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.isMarkdown)(messageObj.message) ? (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(messageObj.message) : messageObj.message\n    const messageDiv = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"message\"], message);\n    (0,_util__WEBPACK_IMPORTED_MODULE_0__.addTargetBlankToLinks)(messageDiv);\n\n    if (messageObj.user_id === (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId) {\n        messageContainer.classList.add(\"user-message\", \"smart-buy-user-message\");\n        messageContainer.style.backgroundColor = backgroundColor;\n        messageContainer.style.color = textColor;\n    } else {\n        if (messageObj.userInfoInput) {\n            messageContainer.classList.add(\"user-message\", \"smart-buy-user-message\");\n            messageContainer.style.backgroundColor = backgroundColor;\n            messageContainer.style.color = textColor;\n        } else {\n            messageContainer.classList.add(\"admin-message\");\n            userInfo.appendChild((0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"user-name\"], messageObj.nameOfSender || messageObj?.props?.nameOfSender || await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getAgentInfo)()?.name || \"Admin\"));\n        }\n\n    }\n\n    if (messageObj?.props?.temporaryMessage) {\n        messageContainer.temporaryMessage = true;\n        messageDiv.innerHTML = \"\";\n        const spinner = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"loading-spinner\"], \"\", `${messageObj.id}-spinner`);\n        messageDiv.append(spinner);\n        chatInput.disabled = true;\n        removeQuickChatAction();\n    } else {\n        chatInput.disabled = false;\n    }\n\n    messageContainer.append(userInfo, messageDiv);\n\n    // if(messageObj.file_ids?.length) {\n    //     //TODO: create placeholder for each image, and display it in the chat message bubble\n    //     const thumbnailsDiv = createElement(\"div\", [\"message\"], messageObj.file_ids);\n    //     messageContainer.append(thumbnailsDiv);\n    // }\n\n    if (messageObj.file_ids?.length) {\n        const thumbnailsDiv = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"thumbnails-container\"]);\n\n        // Placeholder for each file\n        messageObj.file_ids.forEach(fileId => {\n            const filePlaceholder = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"thumbnail-placeholder\"]);\n            const spinner = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"loading-spinner\"]);\n            filePlaceholder.appendChild(spinner);\n            thumbnailsDiv.appendChild(filePlaceholder);\n\n            // Fetch and display the thumbnail when loaded\n            (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.getFiles)([fileId]).then(res => {\n                const thumbnailData = res.files.find(file => file.fileId === fileId);\n                if (thumbnailData) {\n                    const imgElement = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"img\", [\"thumbnail-image\"]);\n                    imgElement.src = `data:${thumbnailData.contentType};base64,${thumbnailData.thumbnail}`;\n                    filePlaceholder.innerHTML = ''; // Remove spinner\n                    filePlaceholder.appendChild(imgElement);\n\n                    // Add click event to show modal with full image\n                    imgElement.addEventListener(\"click\", () => showFullImageModal(thumbnailData.fileLink));\n                }\n            }).catch(error => {\n                console.error(\"Error loading thumbnail:\", error);\n            });\n        });\n\n        messageContainer.append(thumbnailsDiv);\n    }\n\n    if (messageObj.create_at) {\n        const messageTime = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"message-time\"], new Date(messageObj.create_at).toLocaleTimeString([], {\n            hour: 'numeric',\n            minute: '2-digit',\n            hour12: true\n        }));\n        if (!messageContainer.classList.contains(\"admin-message\")) {\n            messageTime.style.color = secondaryTextColor;\n        }\n        messageContainer.append(messageTime);\n    }\n\n    if (messageObj.onClick) {\n        messageContainer.addEventListener(\"click\", () => {\n            messageObj.onClick()\n        })\n    }\n\n    if (messageObj.customClasses?.length) {\n        messageContainer.classList.add(...messageObj.customClasses);\n    }\n\n    if (messageObj.id === \"chat-toggle-quick-action\") {\n        messageContainer.style.color = backgroundColor;\n    }\n\n    chatMessages.appendChild(messageContainer);\n}\n\nfunction editMessage(messageObj) {\n    const {chatInput, chatMessages} = getUiElements();\n    if (!chatInput) {\n        console.error(\"Chat Input element not in DOM, cannot render message\");\n        return;\n    }\n\n    if (!chatMessages) {\n        console.error(\"Chat Messages element not in DOM, cannot render message\");\n        return;\n    }\n\n    if (!existsInDom(messageObj.id)) return;\n\n    const messageContainer = document.getElementById(messageObj.id);\n    const isTemporaryMessage = messageObj.props?.temporaryMessage === true || messageObj.props?.temporaryMessage === \"true\";\n    messageContainer.temporaryMessage = isTemporaryMessage;\n    const message = (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.isMarkdown)(messageObj.message) ? (0,marked__WEBPACK_IMPORTED_MODULE_3__.marked)(messageObj.message) : messageObj.message;\n    const messageDiv = messageContainer.getElementsByClassName(\"message\")[0];\n\n    if (isTemporaryMessage) {\n        messageDiv.innerHTML = \"\";\n        const spinner = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"loading-spinner\"], \"\", `${messageObj.id}-spinner`);\n        messageDiv.append(spinner);\n    } else {\n        messageDiv.innerHTML = message;\n    }\n    (0,_util__WEBPACK_IMPORTED_MODULE_0__.addTargetBlankToLinks)(messageDiv);\n\n    // Move the message container to the end of chatMessages\n    if (chatMessages.contains(messageContainer)) {\n        chatMessages.removeChild(messageContainer); // Remove from the current position\n        chatMessages.appendChild(messageContainer);  // Append it back to move it to the end\n    }\n\n    chatInput.disabled = isTemporaryMessage;\n}\n\nasync function renderPreviousMessages(messages) {\n    for (const message of messages\n        .filter(message => !message?.props?.hideFromUI)) {\n        await renderMessage(message);\n    }\n    scrollToBottom();\n}\n\nfunction hideTemporarySystemMessage() {\n    const {chatMessages} = getUiElements();\n    if (!chatMessages) {\n        console.error(\"Chat messages container not in DOM, cannot hide temporary message\");\n        return;\n    }\n\n    const lastMessage = chatMessages.lastElementChild\n    if (lastMessage?.temporaryMessage) {\n        lastMessage.classList.toggle(\"hidden\", true);\n    }\n}\n\nfunction removeMessageFromDOM(messageId) {\n    const messageElement = document.getElementById(messageId);  // Assuming message elements have an ID equal to the message ID\n    if (messageElement) {\n        messageElement.remove();  // Remove the element from the DOM\n    }\n}\n\nfunction removeAllMessages() {\n    const {chatMessages} = getUiElements();\n    if (!chatMessages) {\n        console.error(\"Chat messages container not in DOM, cannot remove messages\");\n        return;\n    }\n\n    // Clear all messages at once\n    chatMessages.replaceChildren();\n}\n\nfunction createChatToggleAction() {\n    (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.canSwitchChat)()\n        .then(async canSwitch => {\n            if (!canSwitch) return\n            if (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isHumanChat)()) {\n                await createTalkToGPTQuickAction();\n            } else {\n                await createTalkToHumanQuickAction();\n            }\n        }).catch(e => {\n        console.log(\"error while checking team plan\", e)\n    })\n\n}\n\nasync function createTalkToHumanQuickAction() {\n    const {chatMessages} = getUiElements();\n\n    if (!chatMessages) {\n        console.error(\"Chat Messages element not in DOM, cannot render quick reply\");\n        return;\n    }\n\n    removeQuickChatAction()\n    const containerId = \"chat-toggle-quick-action\";\n    const messageObj = {\n        id: containerId,\n        message: \"Speak to a Human\",\n        user_id: (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId,\n        onClick: () => {\n            (0,_util__WEBPACK_IMPORTED_MODULE_0__.trackEvent)('Talk to Human', {\n                'source': 'quick-action'\n            })\n            removeQuickChatAction();\n            (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.handleTalkToHumanClick)();\n        },\n        customClasses: [\"quick-reply\", \"smart-buy-quick-reply\"]\n    };\n\n    // Render the request message in the chat\n    await renderMessage(messageObj);\n    scrollToBottom();\n}\n\nasync function createTalkToGPTQuickAction() {\n    const {chatMessages} = getUiElements();\n\n    if (!chatMessages) {\n        console.error(\"Chat Messages element not in DOM, cannot render quick reply\");\n        return;\n    }\n\n    removeQuickChatAction()\n    const containerId = \"chat-toggle-quick-action\";\n    const messageObj = {\n        id: containerId,\n        message: \"Switch to chatbot\",\n        user_id: (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId,\n        onClick: async () => {\n            (0,_util__WEBPACK_IMPORTED_MODULE_0__.trackEvent)('Talk to GPT', {\n                'source': 'quick-action'\n            })\n            removeMessageFromDOM(containerId);\n            await renderMessage({\n                user_id: (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId,\n                props: {\n                    temporaryMessage: true\n                }\n\n            })\n\n            showLoadingSpinner()\n            ;(0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.talkToBot)().then(async (res) => {\n                await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredChatType)(\"bot\");\n                await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.storeChannelId)(res.userChannel);\n                removeAllMessages();\n                await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.checkForExistingChannel)()\n                await switchAgentUI()\n                hideLoadingSpinner();\n            })\n\n        },\n        customClasses: [\"quick-reply\", \"smart-buy-quick-reply\"]\n    };\n\n    // Render the request message in the chat\n    await renderMessage(messageObj);\n    scrollToBottom();\n}\n\nfunction removeQuickChatAction() {\n    removeMessageFromDOM(\"chat-toggle-quick-action\")\n}\n\nfunction notFullyInitialized() {\n    const uiElements = getUiElements();\n    return !uiElements\n        || Object.values(uiElements).filter(e => e == null)?.length\n}\n\nfunction showFullImageModal(fileLink) {\n    const modalOverlay = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"modal-overlay\"]);\n    const modalContent = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"modal-content\"]);\n    const imageContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"modal-image-container\"]);\n    const fullImage = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"img\", [\"full-size-image\"]);\n    fullImage.src = fileLink;\n\n    const closeButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [\"modal-close\"], \"✖\");\n    closeButton.addEventListener(\"click\", () => {\n        document.body.removeChild(modalOverlay);\n    });\n\n    // Close modal when clicking outside the modal content\n    modalOverlay.addEventListener(\"click\", (event) => {\n        if (event.target === modalOverlay) {\n            document.body.removeChild(modalOverlay);\n        }\n    });\n\n    modalContent.appendChild(closeButton);\n    imageContainer.appendChild(fullImage);\n    modalContent.appendChild(imageContainer);\n    modalOverlay.appendChild(modalContent);\n\n    document.body.appendChild(modalOverlay);\n}\n\nfunction playNotificationSound() {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    const oscillator = audioCtx.createOscillator();\n    const gainNode = audioCtx.createGain();\n\n    oscillator.connect(gainNode);\n    gainNode.connect(audioCtx.destination);\n\n    oscillator.type = 'sine'; // Creates a \"ding\"-like tone\n    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // Set frequency to A4 (440 Hz)\n    oscillator.start();\n\n    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.5); // Fade out after 0.5 seconds\n    oscillator.stop(audioCtx.currentTime + 0.5);\n}\n\nfunction showTypingIndicator() {\n    const typingIndicatorDiv = getUiElements().typingIndicator\n    typingIndicatorDiv.classList.remove(\"hidden\");\n\n    // Hide the indicator after a delay\n    setTimeout(() => {\n        hideTypingIndicator();\n    }, 3000);\n}\n\nfunction hideTypingIndicator() {\n    const typingIndicatorDiv = getUiElements().typingIndicator;\n    typingIndicatorDiv.classList.add(\"hidden\");\n}\n\nfunction hideChatInputContainer() {\n    const {sendButton, chatInput, chatInputContainer} = getUiElements();\n    if (chatInput) {\n        chatInput.disabled = true;\n        chatInput.style.display = 'none';\n    }\n    if (sendButton) {\n        sendButton.disabled = true;\n        sendButton.style.display = 'none';\n    }\n\n    if (chatInputContainer) {\n        chatInputContainer.style.display = 'none';\n    }\n\n}\n\nfunction generateRandomId(length = 8) {\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = 'id-';\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n\nfunction existsInDom(elementId) {\n    return !!document.getElementById(elementId);\n}\n\nfunction createChatHeader() {\n    const headerContent = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"chat-header-content\", \"smart-buy-chat-header\"]);\n    headerContent.style.backgroundColor = backgroundColor;\n    headerContent.style.color = textColor;\n\n    // Left section with avatar and info\n    const leftSection = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"header-left-section\"]);\n\n    // Agent avatar\n    const avatarContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"avatar-container\"], \"\", \"avatar-container\");\n    const avatar = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"img\", [\"agent-avatar\"], null, \"agent-avatar\");\n    // avatar.src = \"https://raw.githubusercontent.com/urbullet/super-sales-demo/refs/heads/main/assets/robot.png\";\n    avatarContainer.appendChild(avatar);\n\n    // Add status indicator\n    const statusIndicator = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"status-indicator\", \"hidden-placeholder\"], \"\", \"status-indicator\");\n    avatarContainer.appendChild(avatar);\n    avatarContainer.appendChild(statusIndicator);\n\n    // Agent info\n    const agentInfoContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"agent-info\"]);\n    const agentName = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"agent-name\"], \"\", \"agent-name\");\n    const agentStatus = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"agent-status\"], \"\", \"agent-status\");\n    agentStatus.style.color = secondaryTextColor;\n    agentInfoContainer.append(agentName, agentStatus);\n    leftSection.append(avatarContainer, agentInfoContainer);\n\n    // Right section with controls\n    const rightSection = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"header-controls\"]);\n\n    // Resize widget button (only big screens with width > 800px)\n    // Resize widget button (only big screens with width > 800px)\n    const resizeButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [\"header-control-btn\"], \"\", \"resizeWidgetButton\");\n    resizeButton.style.color = textColor;\n    resizeButton.dataset.state = \"shrunk\";\n\n// Set initial state for expanding\n    resizeButton.innerHTML = `\n  <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path d=\"M7 1H1V7\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                <path d=\"M9 15H15V9\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n  </svg>\n`;\n\n    resizeButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        toggleChatWidgetResize();\n    });\n\n\n    // Minimize button\n    const minimizeButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [\"header-control-btn\"]);\n    minimizeButton.style.color = textColor;\n    minimizeButton.innerHTML = `\n    <svg width=\"16\" height=\"2\" viewBox=\"0 0 16 2\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M1 1H15\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n    </svg>\n  `;\n    minimizeButton.addEventListener(\"click\", (e) => {\n        e.stopPropagation();\n        toggleChatVisibility();\n    });\n\n\n    // Three dots menu\n    const menuContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"menu-container\"]);\n    const menuButton = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [\"header-control-btn\"], \"\", \"menu-button\");\n    const menuDropdown = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"menu-dropdown\", \"hidden\"], \"\", \"menu-dropdown\");\n\n    menuContainer.append(menuButton, menuDropdown);\n    rightSection.append(resizeButton, minimizeButton, menuContainer);\n\n    // Append all sections to header\n    headerContent.append(leftSection, rightSection);\n\n    return headerContent;\n}\n\nfunction createQuickActionsMenu() {\n    const actionsContainer = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", [\"quick-actions\"]);\n    actionsContainer.style.padding = \"16px\";\n    actionsContainer.style.display = \"flex\";\n    actionsContainer.style.flexDirection = \"column\";\n    actionsContainer.style.gap = \"8px\";\n\n    const actions = [\n        {text: \"Review my subscription\", id: \"review-subscription\"},\n        {text: \"Check booking status\", id: \"check-booking\"},\n        {text: \"Vehicle issues or damage\", id: \"vehicle-issues\"},\n        {text: \"Speak with support\", id: \"speak-support\"},\n        {text: \"Knowledgebase & FAQ\", id: \"knowledge-base\"}\n    ];\n\n    actions.forEach(action => {\n        const button = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [\"action-button\"], action.text);\n        button.style.padding = \"12px\";\n        button.style.border = \"1px solid #eee\";\n        button.style.borderRadius = \"8px\";\n        button.style.background = \"white\";\n        button.style.cursor = \"pointer\";\n        button.style.transition = \"background 0.2s\";\n        // button.onclick = () => handleQuickAction(action.id);\n        actionsContainer.appendChild(button);\n    });\n\n    return actionsContainer;\n}\n\nfunction autoResize(textarea) {\n    textarea.style.height = 'auto';\n    textarea.style.height = textarea.scrollHeight + 'px';\n}\n\nasync function switchAgentUI() {\n    const agentName = document.getElementById(\"agent-name\");\n    const agentAvatar = document.getElementById(\"agent-avatar\");\n    const agentStatus = document.getElementById(\"agent-status\");\n    const statusIndicator = document.getElementById(\"status-indicator\");\n    const humanMenuItem = document.getElementById(\"speak-to-human-menu-item\");\n    const chatbotMenuItem = document.getElementById(\"switch-to-chatbot-menu-item\");\n\n    // Map each ID to its retrieved element\n    const elements = {\n        agentName: agentName,\n        agentAvatar: agentAvatar,\n        agentStatus: agentStatus,\n        statusIndicator: statusIndicator,\n    };\n\n\n    // // Filter out the ones that are missing\n    const missing = Object\n        .entries(elements)                // [ ['agentName', elem], ... ]\n        .filter(([_, el]) => !el)         // keep entries where el is null\n        .map(([name, value]) => {\n            return name\n        });// extract only the keys\n\n    if (missing.length > 0) {\n        console.error(\n            `Cannot switch agent UI — missing element${missing.length > 1 ? 's' : ''}: ${missing.join(', ')}`\n        );\n        return;\n    }\n\n    if ((0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.getChatStates)().plan > 0) {\n        if (!humanMenuItem) {\n            console.error(\n                `Cannot switch agent UI — missing element${missing.length > 1 ? 's' : ''}: ${missing.join(', ')}`\n            );\n            return;\n        }\n        if (!chatbotMenuItem) {\n            console.error(\n                `Cannot switch agent UI — missing element${missing.length > 1 ? 's' : ''}: ${missing.join(', ')}`\n            );\n            return;\n\n        }\n    }\n\n\n    // // Check if any required DOM element is missing\n    // if (!agentName || !agentAvatar || !agentStatus || !statusIndicator || !humanMenuItem || !chatbotMenuItem) {\n    //     console.error(\"Cannot switch agent UI, One or more required DOM elements are missing.\");\n    //     return;\n    // }\n\n    if (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isHumanChat)()) {\n        const agentInfo = await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getAgentInfo)();\n\n        if (humanMenuItem) {\n            humanMenuItem.classList.add(\"hidden\");\n        }\n\n        if (chatbotMenuItem) {\n            chatbotMenuItem.classList.remove(\"hidden\");\n        }\n\n        if (agentName) {\n            agentName.innerHTML = agentInfo?.name || \"Admin\"\n            agentAvatar.src = agentInfo?.image\n                ? agentInfo.image\n                : \"https://storage.googleapis.com/super-sales-chat-widget/human-agent.png\";\n        }\n\n        (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.pollAgentStatus)(agentInfo?.id)\n    } else {\n        if ((0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.getChatStates)().plan > 0) {\n            if (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.isUserCreated)()) {\n                humanMenuItem.classList.remove(\"hidden\");\n            } else {\n                humanMenuItem.classList.add(\"hidden\");\n            }\n            chatbotMenuItem.classList.add(\"hidden\");\n        }\n\n        agentName.innerHTML = ChatWidgetConfig?.THEME_SETTINGS?.botName || \"StrykBot\"\n        // Regex to match Shopify's \"no-image\" placeholder\n        const noImageRegex = /shopify\\/assets\\/no-image|invalid url input/i;\n\n\n        // Set the avatar source with a fallback if the \"no-image\" URL is detected or no avatar is set\n        agentAvatar.src =\n            ChatWidgetConfig?.THEME_SETTINGS?.botAvatar &&\n            !noImageRegex.test(window.ChatWidgetConfig.THEME_SETTINGS.botAvatar)\n                ? window.ChatWidgetConfig.THEME_SETTINGS.botAvatar\n                : \"https://raw.githubusercontent.com/urbullet/super-sales-demo/refs/heads/main/assets/robot.png\";\n        // agentAvatar.src = ChatWidgetConfig?.THEME_SETTINGS?.botAvatar || \"https://raw.githubusercontent.com/urbullet/super-sales-demo/refs/heads/main/assets/robot.png\";\n        agentStatus.innerHTML = headerText;\n        statusIndicator.classList.add(\"hidden-placeholder\");\n    }\n}\n\nfunction updateDisplayedOnlineStatus(newStatus) {\n    const agentStatus = document.getElementById(\"agent-status\");\n    const statusIndicator = document.getElementById(\"status-indicator\");\n    agentStatus.classList.remove(\"hidden-placeholder\");\n    agentStatus.innerHTML = newStatus || \"\"\n    statusIndicator.classList.remove(\"hidden-placeholder\")\n    updateAgentStatusIndicator(newStatus)\n}\n\nfunction updateAgentStatusIndicator(status) {\n    const statusIndicator = document.getElementById(\"status-indicator\");\n    if (statusIndicator) {\n        switch (status) {\n            case \"online\":\n                statusIndicator.style.backgroundColor = \"green\";\n                break;\n            case \"away\":\n                statusIndicator.style.backgroundColor = \"orange\";\n                break;\n            case \"dnd\":\n                statusIndicator.style.backgroundColor = \"red\";\n                break;\n            case \"offline\":\n            default:\n                statusIndicator.style.backgroundColor = \"darkgray\";\n                break;\n        }\n    }\n}\n\nfunction applyCustomStyling() {\n    const themeSettings = window.ChatWidgetConfig.THEME_SETTINGS;\n    if (!themeSettings) return;\n\n    if (themeSettings.backgroundColor) backgroundColor = themeSettings.backgroundColor;\n    if (themeSettings.textColor) textColor = themeSettings.textColor;\n    if (themeSettings.secondaryTextColor) secondaryTextColor = themeSettings.secondaryTextColor;\n    // if(themeSettings.textFont) textFont = themeSettings.textFont;\n    if (themeSettings.headerText) headerText = themeSettings.headerText;\n    if (themeSettings.welcomeMessage) welcomeMessage = themeSettings.welcomeMessage;\n}\n\nfunction toggleChatWidgetResize() {\n    const resizeButton = document.getElementById(\"resizeWidgetButton\");\n    if (!resizeButton) {\n        console.error(\"Resize button with id 'resizeWidgetButton' not in the DOM\")\n        return;\n    }\n\n    const chatWidget = document.querySelector(\"#chat-widget\");\n    if (!chatWidget) {\n        console.error(\"Chat widget not in the DOM\")\n        return;\n    }\n\n    const chatInput = document.querySelector(\"#chat-input\");\n    if (!chatInput) {\n        console.error(\"Chat Input not in the DOM\")\n        return;\n    }\n\n    // Toggle resize state\n    if (resizeButton.dataset.state === \"expanded\") {\n        // Change to shrink icon\n        resizeButton.innerHTML = `\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path d=\"M7 1H1V7\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                <path d=\"M9 15H15V9\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n              </svg>\n            `;\n        resizeButton.dataset.state = \"shrunk\";\n\n        chatWidget.classList.remove(\"expanded\");\n        chatWidget.classList.add(\"shrunk\");\n        chatInput.classList.remove(\"expanded\");\n        chatInput.classList.add(\"shrunk\");\n    } else {\n        // Change to expand icon\n        resizeButton.innerHTML = `\n              <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path d=\"M1 1H7V7\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n                <path d=\"M15 15H9V9\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/>\n              </svg>\n            `;\n        resizeButton.dataset.state = \"expanded\";\n\n        chatWidget.classList.remove(\"shrunk\");\n        chatWidget.classList.add(\"expanded\");\n        chatInput.classList.remove(\"shrunk\");\n        chatInput.classList.add(\"expanded\");\n    }\n}\n\nfunction updatePlanUI() {\n    if ((0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.getChatStates)().updatePlanUI) return\n    const menuButton = document.getElementById(\"menu-button\")\n    const menuDropdown = document.getElementById(\"menu-dropdown\")\n    if (!menuDropdown) {\n        console.error(\"updatePlanUI failed -- menuDropdown not found in the DOM\")\n        return\n    }\n    if (!menuButton) {\n        console.error(\"updatePlanUI failed -- menuButton not found in the DOM\")\n        return;\n    }\n    if ((0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.getChatStates)().plan > 0) {\n\n        menuButton.style.color = textColor;\n        menuButton.innerHTML = `\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M8 3.5C8.83 3.5 9.5 2.83 9.5 2C9.5 1.17 8.83 0.5 8 0.5C7.17 0.5 6.5 1.17 6.5 2C6.5 2.83 7.17 3.5 8 3.5ZM8 6.5C7.17 6.5 6.5 7.17 6.5 8C6.5 8.83 7.17 9.5 8 9.5C8.83 9.5 9.5 8.83 9.5 8C9.5 7.17 8.83 6.5 8 6.5ZM8 12.5C7.17 12.5 6.5 13.17 6.5 14C6.5 14.83 7.17 15.5 8 15.5C8.83 15.5 9.5 14.83 9.5 14C9.5 13.17 8.83 12.5 8 12.5Z\" fill=\"currentColor\"/>\n    </svg>\n  `;\n        // Dropdown menu\n        const menuItems = [\n            {\n                id: \"speak-to-human-menu-item\",\n                label: \"Speak to a human\",\n                action: () => {\n                    (0,_util__WEBPACK_IMPORTED_MODULE_0__.trackEvent)('Talk to Human', {\n                        'source': 'menu'\n                    })\n                    removeQuickChatAction();\n                    (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.handleTalkToHumanClick)();\n                },\n            },\n            {\n                id: \"switch-to-chatbot-menu-item\",\n                label: \"Switch to chatbot\",\n                classes: [\"hidden\"],\n                action: async () => {\n                    (0,_util__WEBPACK_IMPORTED_MODULE_0__.trackEvent)('Talk to GPT', {\n                        'source': 'menu'\n                    })\n                    removeQuickChatAction();\n                    await renderMessage({\n                        user_id: (await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.getStoredUserInfo)()).userId,\n                        props: {\n                            temporaryMessage: true,\n                        },\n                    });\n                    showLoadingSpinner();\n                    (0,_services_mattermost_service__WEBPACK_IMPORTED_MODULE_2__.talkToBot)().then(async (res) => {\n                        await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.setStoredChatType)(\"bot\");\n                        await (0,_shopify_settings_storage_util__WEBPACK_IMPORTED_MODULE_4__.storeChannelId)(res.userChannel);\n                        removeAllMessages();\n                        await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.checkForExistingChannel)();\n                        await switchAgentUI()\n                        hideLoadingSpinner();\n                    });\n                },\n            },\n            {\n                id: \"reset-chat-menu-item\",\n                label: \"Reset Chat\",\n                action: async () => await (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.resetChat)()\n            },\n        ];\n\n        menuDropdown.replaceChildren();\n        menuItems.forEach((item) => {\n            const menuItem = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"button\", [...(item.classes || []), \"chat-header-menu-item\"], item.label, item.id);\n            menuItem.addEventListener(\"click\", (e) => {\n                e.stopPropagation();\n                item.action();\n                menuDropdown.classList.add(\"hidden\");\n            });\n            menuDropdown.appendChild(menuItem);\n        });\n\n        // Show menu dropdown\n        if (!menuButton.dataset.listenerAdded) {\n            menuButton.addEventListener(\"click\", (e) => {\n                e.stopPropagation();\n                menuDropdown.classList.toggle(\"hidden\");\n            });\n            menuButton.dataset.listenerAdded = \"true\";\n        }\n\n\n        // Close menu when clicking outside\n        document.addEventListener(\"click\", () => {\n            menuDropdown.classList.add(\"hidden\");\n        });\n        (0,_chat_util__WEBPACK_IMPORTED_MODULE_1__.updateChatStates)(\n            {updatePlanUI: true}\n        )\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvdWktdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvdWktdXRpbC5qcz85NDA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YWRkVGFyZ2V0QmxhbmtUb0xpbmtzLCBjcmVhdGVFbGVtZW50LCB0cmFja0V2ZW50fSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQge1xuICAgIGNoZWNrRm9yRXhpc3RpbmdDaGFubmVsLFxuICAgIGdldENoYXRTdGF0ZXMsXG4gICAgaGFuZGxlTWVzc2FnZVNlbmQsXG4gICAgaGFuZGxlVGFsa1RvSHVtYW5DbGljayxcbiAgICBpc01hcmtkb3duLFxuICAgIHJlc2V0Q2hhdCxcbiAgICBzZXR1cENoYXRDb25uZWN0aW9uLFxuICAgIHVwZGF0ZUNoYXRTdGF0ZXNcbn0gZnJvbSBcIi4vY2hhdC11dGlsXCI7XG5pbXBvcnQge2NhblN3aXRjaENoYXQsIGdldEZpbGVzLCBwb2xsQWdlbnRTdGF0dXMsIHRhbGtUb0JvdH0gZnJvbSBcIi4uL3NlcnZpY2VzL21hdHRlcm1vc3Quc2VydmljZVwiO1xuaW1wb3J0IHttYXJrZWR9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCB7XG4gICAgZ2V0QWdlbnRJbmZvLFxuICAgIGdldEN1cnJlbnRDaGFubmVsSWQsXG4gICAgZ2V0U3RvcmVkVXNlckluZm8sXG4gICAgaXNIdW1hbkNoYXQsXG4gICAgaXNVc2VyQ3JlYXRlZCxcbiAgICBzZXRTdG9yZWRDaGF0VHlwZSxcbiAgICBzdG9yZUNoYW5uZWxJZFxufSBmcm9tIFwiLi9zaG9waWZ5LXNldHRpbmdzLXN0b3JhZ2UudXRpbFwiO1xuXG5sZXQgVUlfRUxFTUVOVFMgPSB7XG4gICAgY2hhdEJ1dHRvbjogbnVsbCxcbiAgICBjaGF0V2lkZ2V0OiBudWxsLFxuICAgIGNsb3NlQ2hhdEJ1dHRvbjogbnVsbCxcbiAgICBjaGF0QnV0dG9uU21hcnRCdXk6IG51bGwsXG4gICAgY2hhdEhlYWRlcjogbnVsbCxcbiAgICBzZW5kQnV0dG9uOiBudWxsLFxuICAgIGNoYXRJbnB1dDogbnVsbCxcbiAgICBzZW5kQnV0dG9uSWNvbjogbnVsbCxcbiAgICBjaGF0SW5wdXRDb250YWluZXI6IG51bGwsXG4gICAgbG9hZGluZ1NwaW5uZXI6IG51bGwsXG4gICAgY2hhdE1lc3NhZ2VzOiBudWxsLFxuICAgIHR5cGluZ0luZGljYXRvcjogbnVsbFxufVxubGV0IGJhY2tncm91bmRDb2xvciA9IFwiIzAwMDAwMFwiO1xubGV0IHRleHRDb2xvciA9IFwiI2ZmZmZmZlwiO1xubGV0IHNlY29uZGFyeVRleHRDb2xvciA9IFwiIzY2NlwiO1xubGV0IHRleHRGb250ID0gdW5kZWZpbmVkO1xubGV0IGhlYWRlclRleHQgPSBcIk91ciB2aXJ0dWFsIGFzc2lzdGFudCBpcyBoZXJlIHRvIGhlbHAgeW91LlwiO1xubGV0IHdlbGNvbWVNZXNzYWdlID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlFbGVtZW50cygpIHtcbiAgICByZXR1cm4gVUlfRUxFTUVOVFM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVVSUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IGNoYXRCdXR0b24gPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtdLCBcIkNoYXQgd2l0aCB1c1wiLCBcImNoYXQtYnV0dG9uXCIpXG4gICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGF0QnV0dG9uKVxuICAgIGNvbnN0IGNoYXRXaWRnZXQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImhpZGRlblwiXSwgXCJcIiwgXCJjaGF0LXdpZGdldFwiKTtcbiAgICBpZiAodGV4dEZvbnQpIHtcbiAgICAgICAgY2hhdFdpZGdldC5zdHlsZS5mb250RmFtaWx5ID0gdGV4dEZvbnQ7XG4gICAgICAgIGNoYXRXaWRnZXQuc3R5bGUuYm9yZGVyQ29sb3IgPSB0ZXh0Rm9udDtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGF0V2lkZ2V0KVxuXG4gICAgY29uc3QgY2xvc2VDaGF0QnV0dG9uID0gY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgW1wiY2hhdC1hcHAtLWNsb3NlLWJ1dHRvblwiLCBcImNoYXQtYXBwLS1jbG9zZS1idXR0b24tLSNmZmRkMDBcIiwgXCJoaWRkZW5cIl0sXG4gICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjb2xvcj1cIiR7dGV4dENvbG9yfVwiIGZpbGw9XCJub25lXCIgaGVpZ2h0PVwiMzFcIiB2aWV3Qm94PVwiMCAwIDMxIDMxXCIgd2lkdGg9XCIzMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMTcuNzE1OSAxNS41NTU1TDI0LjI3NDcgOC45OTY3M0MyNC44NzIgOC4zOTkzNyAyNC44NzIgNy40MzM4MSAyNC4yNzQ3IDYuODM2NDVDMjMuNjc3MyA2LjIzOTA5IDIyLjcxMTggNi4yMzkwOSAyMi4xMTQ0IDYuODM2NDVMMTUuNTU1NiAxMy4zOTUyTDguOTk2ODkgNi44MzY0NUM4LjM5OTUzIDYuMjM5MDkgNy40MzM5OCA2LjIzOTA5IDYuODM2NjIgNi44MzY0NUM2LjIzOTI2IDcuNDMzODEgNi4yMzkyNiA4LjM5OTM3IDYuODM2NjIgOC45OTY3M0wxMy4zOTU0IDE1LjU1NTVMNi44MzY2MiAyMi4xMTQyQzYuMjM5MjYgMjIuNzExNiA2LjIzOTI2IDIzLjY3NzEgNi44MzY2MiAyNC4yNzQ1QzcuMTM0NTMgMjQuNTcyNCA3LjUyNTY0IDI0LjcyMjEgNy45MTY3NiAyNC43MjIxQzguMzA3ODcgMjQuNzIyMSA4LjY5ODk4IDI0LjU3MjQgOC45OTY4OSAyNC4yNzQ1TDE1LjU1NTYgMTcuNzE1OEwyMi4xMTQ0IDI0LjI3NDVDMjIuNDEyMyAyNC41NzI0IDIyLjgwMzQgMjQuNzIyMSAyMy4xOTQ1IDI0LjcyMjFDMjMuNTg1NiAyNC43MjIxIDIzLjk3NjggMjQuNTcyNCAyNC4yNzQ3IDI0LjI3NDVDMjQuODcyIDIzLjY3NzEgMjQuODcyIDIyLjcxMTYgMjQuMjc0NyAyMi4xMTQyTDE3LjcxNTkgMTUuNTU1NVpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsLXJ1bGU9XCJldmVub2RkXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG1hc2sgaGVpZ2h0PVwiMTlcIiBpZD1cInN2Zy1DYW5jZWxJY29uLTFaZ1liNlJcIiBtYXNrVW5pdHM9XCJ1c2VyU3BhY2VPblVzZVwiIHdpZHRoPVwiMTlcIiB4PVwiNlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5PVwiNlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTE3LjcxNTkgMTUuNTU1NUwyNC4yNzQ3IDguOTk2NzNDMjQuODcyIDguMzk5MzcgMjQuODcyIDcuNDMzODEgMjQuMjc0NyA2LjgzNjQ1QzIzLjY3NzMgNi4yMzkwOSAyMi43MTE4IDYuMjM5MDkgMjIuMTE0NCA2LjgzNjQ1TDE1LjU1NTYgMTMuMzk1Mkw4Ljk5Njg5IDYuODM2NDVDOC4zOTk1MyA2LjIzOTA5IDcuNDMzOTggNi4yMzkwOSA2LjgzNjYyIDYuODM2NDVDNi4yMzkyNiA3LjQzMzgxIDYuMjM5MjYgOC4zOTkzNyA2LjgzNjYyIDguOTk2NzNMMTMuMzk1NCAxNS41NTU1TDYuODM2NjIgMjIuMTE0MkM2LjIzOTI2IDIyLjcxMTYgNi4yMzkyNiAyMy42NzcxIDYuODM2NjIgMjQuMjc0NUM3LjEzNDUzIDI0LjU3MjQgNy41MjU2NCAyNC43MjIxIDcuOTE2NzYgMjQuNzIyMUM4LjMwNzg3IDI0LjcyMjEgOC42OTg5OCAyNC41NzI0IDguOTk2ODkgMjQuMjc0NUwxNS41NTU2IDE3LjcxNThMMjIuMTE0NCAyNC4yNzQ1QzIyLjQxMjMgMjQuNTcyNCAyMi44MDM0IDI0LjcyMjEgMjMuMTk0NSAyNC43MjIxQzIzLjU4NTYgMjQuNzIyMSAyMy45NzY4IDI0LjU3MjQgMjQuMjc0NyAyNC4yNzQ1QzI0Ljg3MiAyMy42NzcxIDI0Ljg3MiAyMi43MTE2IDI0LjI3NDcgMjIuMTE0MkwxNy43MTU5IDE1LjU1NTVaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsLXJ1bGU9XCJldmVub2RkXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXNrPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGcgbWFzaz1cInVybCgjc3ZnLUNhbmNlbEljb24tMVpnWWI2UilcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBmaWxsPVwibm9uZVwiIGhlaWdodD1cIjMyLjA4MzNcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMC4yNzc3MSAwLjI3NzcxKVwiIHdpZHRoPVwiMzIuMDgzM1wiPjwvcmVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgYCxcbiAgICAgICAgXCJjbG9zZS1zbWFydC1idXktYnV0dG9uXCJcbiAgICApXG5cbiAgICBjbG9zZUNoYXRCdXR0b24uc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBiYWNrZ3JvdW5kQ29sb3IpXG5cbiAgICBjb25zdCBjaGF0QnV0dG9uU21hcnRCdXkgPSBjcmVhdGVFbGVtZW50KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICBbXSxcbiAgICAgICAgYFxuICAgICAgICAgICAgICAgIDxidXR0b24gYXJpYS1sYWJlbD1cIkNoYXQgd2luZG93XCIgY2xhc3M9XCJjaGF0LXRvZ2dsZSBjaGF0LXRvZ2dsZS0tI2ZmZGQwMCBjaGF0LXRvZ2dsZS0taWNvbi1idXR0b24gY2hhdC10b2dnbGUtLXRleHQtYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBkYXRhLXNwZWM9XCJ0b2dnbGUtYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfTsgY29sb3I6ICR7dGV4dENvbG9yfTtcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBkYXRhLXNwZWM9XCJidXR0b24taWNvblwiIGZpbGw9XCJub25lXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNCA5Ljc4Mzc0QzQgNS44NDQzMyA0LjgxNTQzIDUgOC42MiA1SDExLjM4QzE1LjE4NDYgNSAxNiA1Ljg0NDMzIDE2IDkuNzgzNzRDMTYgMTMuNzIzMiAxNS4xODQ2IDE0LjkwMDggMTEuMzggMTQuOTAwOEgxMC44MzAzQzEwLjgwMjUgMTQuOTM0NiAxMC43NzAzIDE0Ljk2NjYgMTAuNzMzNiAxNC45OTYyTDguNTQyODYgMTYuODZDOC4xMjkyOSAxNy4xOTM1IDcuNTEzNyAxNi44OTggNy41MTM3IDE2LjM2NjdWMTQuODdDNC42NTI1NCAxNC42ODg0IDQgMTMuMzA3OCA0IDkuNzgzNzRaTTEwIDEwLjY2NjdDMTAuMzY4MiAxMC42NjY3IDEwLjY2NjcgMTAuMzY4MiAxMC42NjY3IDEwQzEwLjY2NjcgOS42MzE4MSAxMC4zNjgyIDkuMzMzMzMgMTAgOS4zMzMzM0M5LjYzMTgxIDkuMzMzMzMgOS4zMzMzMyA5LjYzMTgxIDkuMzMzMzMgMTBDOS4zMzMzMyAxMC4zNjgyIDkuNjMxODEgMTAuNjY2NyAxMCAxMC42NjY3Wk0xMy4zMzMzIDEwQzEzLjMzMzMgMTAuMzY4MiAxMy4wMzQ5IDEwLjY2NjcgMTIuNjY2NyAxMC42NjY3QzEyLjI5ODUgMTAuNjY2NyAxMiAxMC4zNjgyIDEyIDEwQzEyIDkuNjMxODEgMTIuMjk4NSA5LjMzMzMzIDEyLjY2NjcgOS4zMzMzM0MxMy4wMzQ5IDkuMzMzMzMgMTMuMzMzMyA5LjYzMTgxIDEzLjMzMzMgMTBaTTcuMzMzMzMgMTAuNjY2N0M3LjcwMTUyIDEwLjY2NjcgOCAxMC4zNjgyIDggMTBDOCA5LjYzMTgxIDcuNzAxNTIgOS4zMzMzMyA3LjMzMzMzIDkuMzMzMzNDNi45NjUxNCA5LjMzMzMzIDYuNjY2NjcgOS42MzE4MSA2LjY2NjY3IDEwQzYuNjY2NjcgMTAuMzY4MiA2Ljk2NTE0IDEwLjY2NjcgNy4zMzMzMyAxMC42NjY3WlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwiJHt0ZXh0Q29sb3J9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoYXQtdGl0bGVcIiBkYXRhLXNwZWM9XCJidXR0b24tdGV4dFwiPkNoYXQ8L3NwYW4+XG4gICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgYCxcbiAgICAgICAgXCJcIlxuICAgIClcbiAgICBjb25zdCBjaGF0Um9vdERpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wiY2hhdC1hcHBcIiwgXCJjaGF0LWFwcC0taXMtb3BlblwiLCBcImNoYXQtYXBwLS1cIl0sIFwiXCIsIFwiXCIpO1xuICAgIGNoYXRSb290RGl2LmFwcGVuZENoaWxkKGNoYXRXaWRnZXQpXG4gICAgY2hhdFJvb3REaXYuYXBwZW5kQ2hpbGQoY2hhdEJ1dHRvblNtYXJ0QnV5KVxuICAgIGNoYXRSb290RGl2LmFwcGVuZENoaWxkKGNsb3NlQ2hhdEJ1dHRvbilcblxuICAgIGNvbnN0IGNoYXRDb250YWluZXJEZXYgPSBjcmVhdGVFbGVtZW50KFwiZGV2XCIsIFtcInN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyXCJdLCBcIlwiLCBcInN1cGVyLXNhbGVzLWNoYXQtY29udGFpbmVyXCIpO1xuICAgIGNoYXRDb250YWluZXJEZXYuYXBwZW5kQ2hpbGQoY2hhdFJvb3REaXYpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hhdENvbnRhaW5lckRldilcblxuICAgIGNvbnN0IHR5cGluZ0luZGljYXRvciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wiaGlkZGVuXCIsIFwidHlwaW5nLWluZGljYXRvclwiXSwgJ1R5cGluZy4uLicsIFwidHlwaW5nLWluZGljYXRvclwiKTtcblxuICAgIGNvbnN0IGNoYXRIZWFkZXIgPSBjcmVhdGVDaGF0SGVhZGVyKCk7XG5cbiAgICBjb25zdCBwb3dlcmVkQnlCYW5uZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcInBvd2VyZWQtYnktYmFubmVyXCJdLCBcIlBvd2VyZWQgYnkgU3RyeWsuQUlcIiwgXCJwb3dlcmVkLWJ5LWJhbm5lclwiKVxuICAgIHBvd2VyZWRCeUJhbm5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdXaW4gPSB3aW5kb3cub3BlbihcIlwiLCBcIl9ibGFua1wiKTtcbiAgICAgICAgbmV3V2luLmxvY2F0aW9uLmhyZWYgPSBcImh0dHBzOi8vd3d3LnJhaXpuLmNvbS9zdHJ5ay1haVwiO1xuICAgIH0pXG4gICAgcG93ZXJlZEJ5QmFubmVyLnN0eWxlLnNldFByb3BlcnR5KCctLXRleHQtY29sb3InLCB3aW5kb3cuQ2hhdFdpZGdldENvbmZpZy5USEVNRV9TRVRUSU5HUz8uYmFja2dyb3VuZENvbG9yKTtcbiAgICBwb3dlcmVkQnlCYW5uZXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tc2Vjb25kYXJ5LXRleHQtY29sb3InLCB3aW5kb3cuQ2hhdFdpZGdldENvbmZpZy5USEVNRV9TRVRUSU5HUz8uc2Vjb25kYXJ5VGV4dENvbG9yKTtcblxuICAgIGNoYXRXaWRnZXQuYXBwZW5kKFxuICAgICAgICBjaGF0SGVhZGVyLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtdLCBcIlwiLCBcImNoYXQtbWVzc2FnZXNcIiksXG4gICAgICAgIHR5cGluZ0luZGljYXRvcixcbiAgICAgICAgcG93ZXJlZEJ5QmFubmVyLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImhpZGRlblwiLCBcImxvYWRpbmctc3Bpbm5lclwiXSwgXCJcIiwgXCJsb2FkaW5nLXNwaW5uZXJcIiksXG4gICAgKVxuXG5cbiAgICBjaGF0V2lkZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIixcbiAgICAgICAgW10sXG4gICAgICAgICc8dGV4dGFyZWEgaWQ9XCJjaGF0LWlucHV0XCIgcGxhY2Vob2xkZXI9XCJUeXBlIGEgbWVzc2FnZS4uLlwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIHJvd3M9XCIxXCI+PC90ZXh0YXJlYT5cXG4nICtcbiAgICAgICAgJyAgICAgICAgICAgIDxidXR0b24gaWQ9XCJzZW5kLWJ1dHRvblwiIGNsYXNzPVwic3RyLWNoYXRfX3NlbmQtYnV0dG9uXCIgYXJpYS1sYWJlbD1cIlNlbmRcIiB0eXBlPVwiYnV0dG9uXCI+XFxuJyArXG4gICAgICAgICcgICAgICAgICAgICAgICAgPHN2ZyBpZD1cInNlbmQtYnV0dG9uLWljb25cIiBmaWxsPVwiI2NkY2RjZlwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHdpZHRoPVwiMjRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XFxuJyArXG4gICAgICAgICcgICAgICAgICAgICAgICAgICAgIDx0aXRsZT5TZW5kPC90aXRsZT5cXG4nICtcbiAgICAgICAgJyAgICAgICAgICAgICAgICAgICAgPHBhdGggIGQ9XCJNNC4wMDk1MiAyMkwyNCAxMkw0LjAwOTUyIDJMNCA5Ljc3Nzc4TDE4LjI4NTcgMTJMNCAxNC4yMjIyTDQuMDA5NTIgMjJaXCIgPjwvcGF0aD5cXG4nICtcbiAgICAgICAgJyAgICAgICAgICAgICAgICA8L3N2Zz5cXG4nICtcbiAgICAgICAgJyAgICAgICAgICAgIDwvYnV0dG9uPicsXG4gICAgICAgIFwiY2hhdC1pbnB1dC1jb250YWluZXJcIilcbiAgICApXG5cblxuICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibWVzc2FnZS1jb250YWluZXJcIl0pO1xuICAgIC8vIGNvbnN0IGNoYXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXQtYnV0dG9uXCIpO1xuICAgIGNvbnN0IGNoYXRNZXNzYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhdC1tZXNzYWdlc1wiKTtcbiAgICBjb25zdCBjaGF0SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXQtaW5wdXRcIik7XG4gICAgY29uc3Qgc2VuZEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VuZC1idXR0b25cIik7XG4gICAgY29uc3Qgc2VuZEJ1dHRvbkljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbmQtYnV0dG9uLWljb25cIik7XG4gICAgY29uc3QgY2hhdElucHV0Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGF0LWlucHV0LWNvbnRhaW5lclwiKTtcbiAgICBjb25zdCBsb2FkaW5nU3Bpbm5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9hZGluZy1zcGlubmVyXCIpO1xuXG4gICAgaWYgKFtjaGF0QnV0dG9uLCBjaGF0V2lkZ2V0LCBjaGF0TWVzc2FnZXMsIGNoYXRJbnB1dCwgc2VuZEJ1dHRvbiwgbG9hZGluZ1NwaW5uZXJdLnNvbWUoZWwgPT4gIWVsKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiU29tZSBET00gZWxlbWVudHMgYXJlIG1pc3NpbmcuIFBsZWFzZSBlbnN1cmUgYWxsIHJlcXVpcmVkIGVsZW1lbnRzIGFyZSBwcmVzZW50LlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIGNoYXQgd2lkZ2V0Li4uXCIpO1xuICAgIGF3YWl0IHN3aXRjaEFnZW50VUkoKTtcbiAgICBVSV9FTEVNRU5UUyA9IHtcbiAgICAgICAgY2hhdEJ1dHRvbixcbiAgICAgICAgY2hhdFdpZGdldCxcbiAgICAgICAgY2xvc2VDaGF0QnV0dG9uLFxuICAgICAgICBjaGF0QnV0dG9uU21hcnRCdXksXG4gICAgICAgIGNoYXRIZWFkZXIsXG4gICAgICAgIHNlbmRCdXR0b24sXG4gICAgICAgIGNoYXRJbnB1dCxcbiAgICAgICAgc2VuZEJ1dHRvbkljb24sXG4gICAgICAgIGNoYXRJbnB1dENvbnRhaW5lcixcbiAgICAgICAgbG9hZGluZ1NwaW5uZXIsXG4gICAgICAgIGNoYXRNZXNzYWdlcyxcbiAgICAgICAgdHlwaW5nSW5kaWNhdG9yLFxuICAgIH1cbiAgICByZXR1cm4gVUlfRUxFTUVOVFM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVSUVsZW1lbnRzTGlzdGVuZXJzKCkge1xuICAgIGlmIChub3RGdWxseUluaXRpYWxpemVkKCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vdCBhbGwgcmVxdWlyZWQgRE9NIGVsZW1lbnRzIGluaXRpYWxpemVkLCBjYW5ub3QgY3JlYXRlVUlFbGVtZW50c0xpc3RlbmVyc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hhdEJ1dHRvbixcbiAgICAgICAgY2xvc2VDaGF0QnV0dG9uLFxuICAgICAgICBjaGF0V2lkZ2V0LFxuICAgICAgICBjaGF0QnV0dG9uU21hcnRCdXksXG4gICAgICAgIGNoYXRIZWFkZXIsXG4gICAgICAgIHNlbmRCdXR0b24sXG4gICAgICAgIGNoYXRJbnB1dCxcbiAgICAgICAgc2VuZEJ1dHRvbkljb24sXG4gICAgfSA9IGdldFVpRWxlbWVudHMoKTtcblxuICAgIGNoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY2xvc2VDaGF0QnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICAgIGNoYXRXaWRnZXQuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgICAgY2hhdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgICAgICBpZiAoIWdldEN1cnJlbnRDaGFubmVsSWQoKSkgYXdhaXQgc2V0dXBDaGF0Q29ubmVjdGlvbigpO1xuICAgICAgICBzY3JvbGxUb0JvdHRvbSgpO1xuICAgIH0pO1xuXG4gICAgY2hhdEJ1dHRvblNtYXJ0QnV5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNsb3NlQ2hhdEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgICBjaGF0V2lkZ2V0LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICAgIGNoYXRCdXR0b25TbWFydEJ1eS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgICAgICBjaGF0QnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgIGlmICghZ2V0Q3VycmVudENoYW5uZWxJZCgpKSBhd2FpdCBzZXR1cENoYXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHNjcm9sbFRvQm90dG9tKCk7XG4gICAgfSk7XG5cbiAgICBjaGF0SGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b2dnbGVDaGF0VmlzaWJpbGl0eSk7XG4gICAgY2xvc2VDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b2dnbGVDaGF0VmlzaWJpbGl0eSk7XG5cbiAgICBzZW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiBhd2FpdCBoYW5kbGVNZXNzYWdlU2VuZCgpKTtcblxuICAgIGNoYXRJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiBjaGF0SW5wdXQudmFsdWUudHJpbSgpKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCtFbnRlcjogYWxsb3cgbmV3IGxpbmUgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZU1lc3NhZ2VTZW5kKClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2hhdElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICAgIGF1dG9SZXNpemUoY2hhdElucHV0KTtcbiAgICAgICAgaWYgKGNoYXRJbnB1dD8udmFsdWU/LnRyaW0oKT8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZW5kQnV0dG9uSWNvbi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBcInJnYigxMDYsIDEwNiwgMTA2KVwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZEJ1dHRvbkljb24uc2V0QXR0cmlidXRlKCdmaWxsJywgXCIjY2RjZGNmXCIpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBVSSgpIHtcbiAgICBhcHBseUN1c3RvbVN0eWxpbmcoKTtcbiAgICBhd2FpdCBjcmVhdGVVSUVsZW1lbnRzKCk7XG4gICAgY3JlYXRlVUlFbGVtZW50c0xpc3RlbmVycygpO1xuICAgIHJldHVybiBnZXRVaUVsZW1lbnRzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDaGF0VmlzaWJpbGl0eSgpIHtcbiAgICBjb25zdCB7Y2xvc2VDaGF0QnV0dG9uLCBjaGF0QnV0dG9uU21hcnRCdXksIGNoYXRXaWRnZXQsIGNoYXRCdXR0b259ID0gZ2V0VWlFbGVtZW50cygpO1xuICAgIGlmICghY2xvc2VDaGF0QnV0dG9uIHx8ICFjaGF0QnV0dG9uU21hcnRCdXkgfHwgIWNoYXRXaWRnZXQgfHwgIWNoYXRCdXR0b24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIm1pc3NpbmcgdWkgZWxlbWVudHMsIGNhbm5vdCB0b2dnbGUgY2hhdCB2aXNpYmlsaXR5XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsb3NlQ2hhdEJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIpO1xuICAgIGNoYXRCdXR0b25TbWFydEJ1eS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIpO1xuICAgIGNoYXRXaWRnZXQuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKTtcbiAgICBjaGF0QnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93TG9hZGluZ1NwaW5uZXIoKSB7XG4gICAgY29uc3Qge2xvYWRpbmdTcGlubmVyLCBjaGF0TWVzc2FnZXN9ID0gZ2V0VWlFbGVtZW50cygpO1xuICAgIGlmICghbG9hZGluZ1NwaW5uZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkxvYWRpbmcgc3Bpbm5lciBlbGVtZW50IG5vdCBpbiBET00sIGNhbm5vdCBzaG93IHNwaW5uZXJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoYXRNZXNzYWdlcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiY2hhdE1lc3NhZ2VzIGVsZW1lbnQgbm90IGluIERPTSwgY2Fubm90IHNob3cgc3Bpbm5lclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkaW5nU3Bpbm5lci5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIGNoYXRNZXNzYWdlcy5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuLXBsYWNlaG9sZGVyXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUxvYWRpbmdTcGlubmVyKCkge1xuICAgIGNvbnN0IHtsb2FkaW5nU3Bpbm5lciwgY2hhdE1lc3NhZ2VzfSA9IGdldFVpRWxlbWVudHMoKTtcbiAgICBpZiAoIWxvYWRpbmdTcGlubmVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2FkaW5nIHNwaW5uZXIgZWxlbWVudCBub3QgaW4gRE9NLCBjYW5ub3QgaGlkZSBzcGlubmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hhdE1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjaGF0TWVzc2FnZXMgZWxlbWVudCBub3QgaW4gRE9NLCBjYW5ub3Qgc2hvdyBzcGlubmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvYWRpbmdTcGlubmVyLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgY2hhdE1lc3NhZ2VzLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW4tcGxhY2Vob2xkZXJcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxUb0JvdHRvbSgpIHtcbiAgICBjb25zdCB7Y2hhdE1lc3NhZ2VzfSA9IGdldFVpRWxlbWVudHMoKTtcbiAgICBpZiAoIWNoYXRNZXNzYWdlcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2hhdCBtZXNzYWdlcyBlbGVtZW50IG5vdCBpbiBET00sIGNhbm5vdCBzY3JvbGwgdG8gYm90dG9tXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoYXRNZXNzYWdlcy5zY3JvbGxUb3AgPSBjaGF0TWVzc2FnZXMuc2Nyb2xsSGVpZ2h0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyTWVzc2FnZShtZXNzYWdlT2JqKSB7XG4gICAgaWYgKG1lc3NhZ2VPYmoucHJvcHM/LmhpZGVGcm9tVUkpIHJldHVybjtcbiAgICBpZiAobWVzc2FnZU9iaj8ucHJvcHM/LnN3aXRjaGVkVG9IdW1hbk5vdGlmaWNhdGlvbikgcmV0dXJuXG4gICAgY29uc3Qge2NoYXRJbnB1dCwgY2hhdE1lc3NhZ2VzfSA9IGdldFVpRWxlbWVudHMoKTtcbiAgICBpZiAoIWNoYXRJbnB1dCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2hhdCBJbnB1dCBlbGVtZW50IG5vdCBpbiBET00sIGNhbm5vdCByZW5kZXIgbWVzc2FnZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2hhdE1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDaGF0IE1lc3NhZ2VzIGVsZW1lbnQgbm90IGluIERPTSwgY2Fubm90IHJlbmRlciBtZXNzYWdlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4aXN0c0luRG9tKG1lc3NhZ2VPYmouaWQpKSByZXR1cm5cblxuICAgIGNvbnN0IG1lc3NhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcIm1lc3NhZ2UtY29udGFpbmVyXCJdLCBcIlwiLCBtZXNzYWdlT2JqPy5pZCk7XG4gICAgY29uc3QgdXNlckluZm8gPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcInVzZXItaW5mb1wiXSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzTWFya2Rvd24obWVzc2FnZU9iai5tZXNzYWdlKSA/IG1hcmtlZChtZXNzYWdlT2JqLm1lc3NhZ2UpIDogbWVzc2FnZU9iai5tZXNzYWdlXG4gICAgY29uc3QgbWVzc2FnZURpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibWVzc2FnZVwiXSwgbWVzc2FnZSk7XG4gICAgYWRkVGFyZ2V0QmxhbmtUb0xpbmtzKG1lc3NhZ2VEaXYpO1xuXG4gICAgaWYgKG1lc3NhZ2VPYmoudXNlcl9pZCA9PT0gKGF3YWl0IGdldFN0b3JlZFVzZXJJbmZvKCkpLnVzZXJJZCkge1xuICAgICAgICBtZXNzYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1c2VyLW1lc3NhZ2VcIiwgXCJzbWFydC1idXktdXNlci1tZXNzYWdlXCIpO1xuICAgICAgICBtZXNzYWdlQ29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5zdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWVzc2FnZU9iai51c2VySW5mb0lucHV0KSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1c2VyLW1lc3NhZ2VcIiwgXCJzbWFydC1idXktdXNlci1tZXNzYWdlXCIpO1xuICAgICAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyLnN0eWxlLmNvbG9yID0gdGV4dENvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYWRtaW4tbWVzc2FnZVwiKTtcbiAgICAgICAgICAgIHVzZXJJbmZvLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1widXNlci1uYW1lXCJdLCBtZXNzYWdlT2JqLm5hbWVPZlNlbmRlciB8fCBtZXNzYWdlT2JqPy5wcm9wcz8ubmFtZU9mU2VuZGVyIHx8IGF3YWl0IGdldEFnZW50SW5mbygpPy5uYW1lIHx8IFwiQWRtaW5cIikpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZU9iaj8ucHJvcHM/LnRlbXBvcmFyeU1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZUNvbnRhaW5lci50ZW1wb3JhcnlNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgbWVzc2FnZURpdi5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBjb25zdCBzcGlubmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJsb2FkaW5nLXNwaW5uZXJcIl0sIFwiXCIsIGAke21lc3NhZ2VPYmouaWR9LXNwaW5uZXJgKTtcbiAgICAgICAgbWVzc2FnZURpdi5hcHBlbmQoc3Bpbm5lcik7XG4gICAgICAgIGNoYXRJbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZVF1aWNrQ2hhdEFjdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXRJbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG1lc3NhZ2VDb250YWluZXIuYXBwZW5kKHVzZXJJbmZvLCBtZXNzYWdlRGl2KTtcblxuICAgIC8vIGlmKG1lc3NhZ2VPYmouZmlsZV9pZHM/Lmxlbmd0aCkge1xuICAgIC8vICAgICAvL1RPRE86IGNyZWF0ZSBwbGFjZWhvbGRlciBmb3IgZWFjaCBpbWFnZSwgYW5kIGRpc3BsYXkgaXQgaW4gdGhlIGNoYXQgbWVzc2FnZSBidWJibGVcbiAgICAvLyAgICAgY29uc3QgdGh1bWJuYWlsc0RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibWVzc2FnZVwiXSwgbWVzc2FnZU9iai5maWxlX2lkcyk7XG4gICAgLy8gICAgIG1lc3NhZ2VDb250YWluZXIuYXBwZW5kKHRodW1ibmFpbHNEaXYpO1xuICAgIC8vIH1cblxuICAgIGlmIChtZXNzYWdlT2JqLmZpbGVfaWRzPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGh1bWJuYWlsc0RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1widGh1bWJuYWlscy1jb250YWluZXJcIl0pO1xuXG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIGZvciBlYWNoIGZpbGVcbiAgICAgICAgbWVzc2FnZU9iai5maWxlX2lkcy5mb3JFYWNoKGZpbGVJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGxhY2Vob2xkZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcInRodW1ibmFpbC1wbGFjZWhvbGRlclwiXSk7XG4gICAgICAgICAgICBjb25zdCBzcGlubmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJsb2FkaW5nLXNwaW5uZXJcIl0pO1xuICAgICAgICAgICAgZmlsZVBsYWNlaG9sZGVyLmFwcGVuZENoaWxkKHNwaW5uZXIpO1xuICAgICAgICAgICAgdGh1bWJuYWlsc0Rpdi5hcHBlbmRDaGlsZChmaWxlUGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgICAvLyBGZXRjaCBhbmQgZGlzcGxheSB0aGUgdGh1bWJuYWlsIHdoZW4gbG9hZGVkXG4gICAgICAgICAgICBnZXRGaWxlcyhbZmlsZUlkXSkudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRodW1ibmFpbERhdGEgPSByZXMuZmlsZXMuZmluZChmaWxlID0+IGZpbGUuZmlsZUlkID09PSBmaWxlSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0aHVtYm5haWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiaW1nXCIsIFtcInRodW1ibmFpbC1pbWFnZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIGltZ0VsZW1lbnQuc3JjID0gYGRhdGE6JHt0aHVtYm5haWxEYXRhLmNvbnRlbnRUeXBlfTtiYXNlNjQsJHt0aHVtYm5haWxEYXRhLnRodW1ibmFpbH1gO1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGxhY2Vob2xkZXIuaW5uZXJIVE1MID0gJyc7IC8vIFJlbW92ZSBzcGlubmVyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQbGFjZWhvbGRlci5hcHBlbmRDaGlsZChpbWdFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2xpY2sgZXZlbnQgdG8gc2hvdyBtb2RhbCB3aXRoIGZ1bGwgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaW1nRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gc2hvd0Z1bGxJbWFnZU1vZGFsKHRodW1ibmFpbERhdGEuZmlsZUxpbmspKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgdGh1bWJuYWlsOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5hcHBlbmQodGh1bWJuYWlsc0Rpdik7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2VPYmouY3JlYXRlX2F0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUaW1lID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJtZXNzYWdlLXRpbWVcIl0sIG5ldyBEYXRlKG1lc3NhZ2VPYmouY3JlYXRlX2F0KS50b0xvY2FsZVRpbWVTdHJpbmcoW10sIHtcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICAgICAgaG91cjEyOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcImFkbWluLW1lc3NhZ2VcIikpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VUaW1lLnN0eWxlLmNvbG9yID0gc2Vjb25kYXJ5VGV4dENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VDb250YWluZXIuYXBwZW5kKG1lc3NhZ2VUaW1lKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZU9iai5vbkNsaWNrKSB7XG4gICAgICAgIG1lc3NhZ2VDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VPYmoub25DbGljaygpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2VPYmouY3VzdG9tQ2xhc3Nlcz8ubGVuZ3RoKSB7XG4gICAgICAgIG1lc3NhZ2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi5tZXNzYWdlT2JqLmN1c3RvbUNsYXNzZXMpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlT2JqLmlkID09PSBcImNoYXQtdG9nZ2xlLXF1aWNrLWFjdGlvblwiKSB7XG4gICAgICAgIG1lc3NhZ2VDb250YWluZXIuc3R5bGUuY29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuXG4gICAgY2hhdE1lc3NhZ2VzLmFwcGVuZENoaWxkKG1lc3NhZ2VDb250YWluZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRpdE1lc3NhZ2UobWVzc2FnZU9iaikge1xuICAgIGNvbnN0IHtjaGF0SW5wdXQsIGNoYXRNZXNzYWdlc30gPSBnZXRVaUVsZW1lbnRzKCk7XG4gICAgaWYgKCFjaGF0SW5wdXQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNoYXQgSW5wdXQgZWxlbWVudCBub3QgaW4gRE9NLCBjYW5ub3QgcmVuZGVyIG1lc3NhZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoYXRNZXNzYWdlcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2hhdCBNZXNzYWdlcyBlbGVtZW50IG5vdCBpbiBET00sIGNhbm5vdCByZW5kZXIgbWVzc2FnZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZXhpc3RzSW5Eb20obWVzc2FnZU9iai5pZCkpIHJldHVybjtcblxuICAgIGNvbnN0IG1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZXNzYWdlT2JqLmlkKTtcbiAgICBjb25zdCBpc1RlbXBvcmFyeU1lc3NhZ2UgPSBtZXNzYWdlT2JqLnByb3BzPy50ZW1wb3JhcnlNZXNzYWdlID09PSB0cnVlIHx8IG1lc3NhZ2VPYmoucHJvcHM/LnRlbXBvcmFyeU1lc3NhZ2UgPT09IFwidHJ1ZVwiO1xuICAgIG1lc3NhZ2VDb250YWluZXIudGVtcG9yYXJ5TWVzc2FnZSA9IGlzVGVtcG9yYXJ5TWVzc2FnZTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNNYXJrZG93bihtZXNzYWdlT2JqLm1lc3NhZ2UpID8gbWFya2VkKG1lc3NhZ2VPYmoubWVzc2FnZSkgOiBtZXNzYWdlT2JqLm1lc3NhZ2U7XG4gICAgY29uc3QgbWVzc2FnZURpdiA9IG1lc3NhZ2VDb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1lc3NhZ2VcIilbMF07XG5cbiAgICBpZiAoaXNUZW1wb3JhcnlNZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2VEaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgY29uc3Qgc3Bpbm5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibG9hZGluZy1zcGlubmVyXCJdLCBcIlwiLCBgJHttZXNzYWdlT2JqLmlkfS1zcGlubmVyYCk7XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kKHNwaW5uZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VEaXYuaW5uZXJIVE1MID0gbWVzc2FnZTtcbiAgICB9XG4gICAgYWRkVGFyZ2V0QmxhbmtUb0xpbmtzKG1lc3NhZ2VEaXYpO1xuXG4gICAgLy8gTW92ZSB0aGUgbWVzc2FnZSBjb250YWluZXIgdG8gdGhlIGVuZCBvZiBjaGF0TWVzc2FnZXNcbiAgICBpZiAoY2hhdE1lc3NhZ2VzLmNvbnRhaW5zKG1lc3NhZ2VDb250YWluZXIpKSB7XG4gICAgICAgIGNoYXRNZXNzYWdlcy5yZW1vdmVDaGlsZChtZXNzYWdlQ29udGFpbmVyKTsgLy8gUmVtb3ZlIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY2hhdE1lc3NhZ2VzLmFwcGVuZENoaWxkKG1lc3NhZ2VDb250YWluZXIpOyAgLy8gQXBwZW5kIGl0IGJhY2sgdG8gbW92ZSBpdCB0byB0aGUgZW5kXG4gICAgfVxuXG4gICAgY2hhdElucHV0LmRpc2FibGVkID0gaXNUZW1wb3JhcnlNZXNzYWdlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuZGVyUHJldmlvdXNNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc1xuICAgICAgICAuZmlsdGVyKG1lc3NhZ2UgPT4gIW1lc3NhZ2U/LnByb3BzPy5oaWRlRnJvbVVJKSkge1xuICAgICAgICBhd2FpdCByZW5kZXJNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzY3JvbGxUb0JvdHRvbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZVRlbXBvcmFyeVN5c3RlbU1lc3NhZ2UoKSB7XG4gICAgY29uc3Qge2NoYXRNZXNzYWdlc30gPSBnZXRVaUVsZW1lbnRzKCk7XG4gICAgaWYgKCFjaGF0TWVzc2FnZXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNoYXQgbWVzc2FnZXMgY29udGFpbmVyIG5vdCBpbiBET00sIGNhbm5vdCBoaWRlIHRlbXBvcmFyeSBtZXNzYWdlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjaGF0TWVzc2FnZXMubGFzdEVsZW1lbnRDaGlsZFxuICAgIGlmIChsYXN0TWVzc2FnZT8udGVtcG9yYXJ5TWVzc2FnZSkge1xuICAgICAgICBsYXN0TWVzc2FnZS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2VGcm9tRE9NKG1lc3NhZ2VJZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVzc2FnZUlkKTsgIC8vIEFzc3VtaW5nIG1lc3NhZ2UgZWxlbWVudHMgaGF2ZSBhbiBJRCBlcXVhbCB0byB0aGUgbWVzc2FnZSBJRFxuICAgIGlmIChtZXNzYWdlRWxlbWVudCkge1xuICAgICAgICBtZXNzYWdlRWxlbWVudC5yZW1vdmUoKTsgIC8vIFJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGxNZXNzYWdlcygpIHtcbiAgICBjb25zdCB7Y2hhdE1lc3NhZ2VzfSA9IGdldFVpRWxlbWVudHMoKTtcbiAgICBpZiAoIWNoYXRNZXNzYWdlcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2hhdCBtZXNzYWdlcyBjb250YWluZXIgbm90IGluIERPTSwgY2Fubm90IHJlbW92ZSBtZXNzYWdlc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFsbCBtZXNzYWdlcyBhdCBvbmNlXG4gICAgY2hhdE1lc3NhZ2VzLnJlcGxhY2VDaGlsZHJlbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhdFRvZ2dsZUFjdGlvbigpIHtcbiAgICBjYW5Td2l0Y2hDaGF0KClcbiAgICAgICAgLnRoZW4oYXN5bmMgY2FuU3dpdGNoID0+IHtcbiAgICAgICAgICAgIGlmICghY2FuU3dpdGNoKSByZXR1cm5cbiAgICAgICAgICAgIGlmIChhd2FpdCBpc0h1bWFuQ2hhdCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlVGFsa1RvR1BUUXVpY2tBY3Rpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlVGFsa1RvSHVtYW5RdWlja0FjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciB3aGlsZSBjaGVja2luZyB0ZWFtIHBsYW5cIiwgZSlcbiAgICB9KVxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYWxrVG9IdW1hblF1aWNrQWN0aW9uKCkge1xuICAgIGNvbnN0IHtjaGF0TWVzc2FnZXN9ID0gZ2V0VWlFbGVtZW50cygpO1xuXG4gICAgaWYgKCFjaGF0TWVzc2FnZXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNoYXQgTWVzc2FnZXMgZWxlbWVudCBub3QgaW4gRE9NLCBjYW5ub3QgcmVuZGVyIHF1aWNrIHJlcGx5XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVtb3ZlUXVpY2tDaGF0QWN0aW9uKClcbiAgICBjb25zdCBjb250YWluZXJJZCA9IFwiY2hhdC10b2dnbGUtcXVpY2stYWN0aW9uXCI7XG4gICAgY29uc3QgbWVzc2FnZU9iaiA9IHtcbiAgICAgICAgaWQ6IGNvbnRhaW5lcklkLFxuICAgICAgICBtZXNzYWdlOiBcIlNwZWFrIHRvIGEgSHVtYW5cIixcbiAgICAgICAgdXNlcl9pZDogKGF3YWl0IGdldFN0b3JlZFVzZXJJbmZvKCkpLnVzZXJJZCxcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgdHJhY2tFdmVudCgnVGFsayB0byBIdW1hbicsIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogJ3F1aWNrLWFjdGlvbidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZW1vdmVRdWlja0NoYXRBY3Rpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZVRhbGtUb0h1bWFuQ2xpY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tQ2xhc3NlczogW1wicXVpY2stcmVwbHlcIiwgXCJzbWFydC1idXktcXVpY2stcmVwbHlcIl1cbiAgICB9O1xuXG4gICAgLy8gUmVuZGVyIHRoZSByZXF1ZXN0IG1lc3NhZ2UgaW4gdGhlIGNoYXRcbiAgICBhd2FpdCByZW5kZXJNZXNzYWdlKG1lc3NhZ2VPYmopO1xuICAgIHNjcm9sbFRvQm90dG9tKCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUYWxrVG9HUFRRdWlja0FjdGlvbigpIHtcbiAgICBjb25zdCB7Y2hhdE1lc3NhZ2VzfSA9IGdldFVpRWxlbWVudHMoKTtcblxuICAgIGlmICghY2hhdE1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDaGF0IE1lc3NhZ2VzIGVsZW1lbnQgbm90IGluIERPTSwgY2Fubm90IHJlbmRlciBxdWljayByZXBseVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZVF1aWNrQ2hhdEFjdGlvbigpXG4gICAgY29uc3QgY29udGFpbmVySWQgPSBcImNoYXQtdG9nZ2xlLXF1aWNrLWFjdGlvblwiO1xuICAgIGNvbnN0IG1lc3NhZ2VPYmogPSB7XG4gICAgICAgIGlkOiBjb250YWluZXJJZCxcbiAgICAgICAgbWVzc2FnZTogXCJTd2l0Y2ggdG8gY2hhdGJvdFwiLFxuICAgICAgICB1c2VyX2lkOiAoYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKSkudXNlcklkLFxuICAgICAgICBvbkNsaWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cmFja0V2ZW50KCdUYWxrIHRvIEdQVCcsIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogJ3F1aWNrLWFjdGlvbidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZW1vdmVNZXNzYWdlRnJvbURPTShjb250YWluZXJJZCk7XG4gICAgICAgICAgICBhd2FpdCByZW5kZXJNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiAoYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKSkudXNlcklkLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFyeU1lc3NhZ2U6IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNob3dMb2FkaW5nU3Bpbm5lcigpXG4gICAgICAgICAgICB0YWxrVG9Cb3QoKS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRTdG9yZWRDaGF0VHlwZShcImJvdFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yZUNoYW5uZWxJZChyZXMudXNlckNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2hlY2tGb3JFeGlzdGluZ0NoYW5uZWwoKVxuICAgICAgICAgICAgICAgIGF3YWl0IHN3aXRjaEFnZW50VUkoKVxuICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nU3Bpbm5lcigpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21DbGFzc2VzOiBbXCJxdWljay1yZXBseVwiLCBcInNtYXJ0LWJ1eS1xdWljay1yZXBseVwiXVxuICAgIH07XG5cbiAgICAvLyBSZW5kZXIgdGhlIHJlcXVlc3QgbWVzc2FnZSBpbiB0aGUgY2hhdFxuICAgIGF3YWl0IHJlbmRlck1lc3NhZ2UobWVzc2FnZU9iaik7XG4gICAgc2Nyb2xsVG9Cb3R0b20oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVF1aWNrQ2hhdEFjdGlvbigpIHtcbiAgICByZW1vdmVNZXNzYWdlRnJvbURPTShcImNoYXQtdG9nZ2xlLXF1aWNrLWFjdGlvblwiKVxufVxuXG5mdW5jdGlvbiBub3RGdWxseUluaXRpYWxpemVkKCkge1xuICAgIGNvbnN0IHVpRWxlbWVudHMgPSBnZXRVaUVsZW1lbnRzKCk7XG4gICAgcmV0dXJuICF1aUVsZW1lbnRzXG4gICAgICAgIHx8IE9iamVjdC52YWx1ZXModWlFbGVtZW50cykuZmlsdGVyKGUgPT4gZSA9PSBudWxsKT8ubGVuZ3RoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93RnVsbEltYWdlTW9kYWwoZmlsZUxpbmspIHtcbiAgICBjb25zdCBtb2RhbE92ZXJsYXkgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcIm1vZGFsLW92ZXJsYXlcIl0pO1xuICAgIGNvbnN0IG1vZGFsQ29udGVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibW9kYWwtY29udGVudFwiXSk7XG4gICAgY29uc3QgaW1hZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcIm1vZGFsLWltYWdlLWNvbnRhaW5lclwiXSk7XG4gICAgY29uc3QgZnVsbEltYWdlID0gY3JlYXRlRWxlbWVudChcImltZ1wiLCBbXCJmdWxsLXNpemUtaW1hZ2VcIl0pO1xuICAgIGZ1bGxJbWFnZS5zcmMgPSBmaWxlTGluaztcblxuICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBbXCJtb2RhbC1jbG9zZVwiXSwgXCLinJZcIik7XG4gICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChtb2RhbE92ZXJsYXkpO1xuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2UgbW9kYWwgd2hlbiBjbGlja2luZyBvdXRzaWRlIHRoZSBtb2RhbCBjb250ZW50XG4gICAgbW9kYWxPdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gbW9kYWxPdmVybGF5KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG1vZGFsT3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vZGFsQ29udGVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gICAgaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoZnVsbEltYWdlKTtcbiAgICBtb2RhbENvbnRlbnQuYXBwZW5kQ2hpbGQoaW1hZ2VDb250YWluZXIpO1xuICAgIG1vZGFsT3ZlcmxheS5hcHBlbmRDaGlsZChtb2RhbENvbnRlbnQpO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtb2RhbE92ZXJsYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGxheU5vdGlmaWNhdGlvblNvdW5kKCkge1xuICAgIGNvbnN0IGF1ZGlvQ3R4ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICBjb25zdCBnYWluTm9kZSA9IGF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKTtcblxuICAgIG9zY2lsbGF0b3IuY29ubmVjdChnYWluTm9kZSk7XG4gICAgZ2Fpbk5vZGUuY29ubmVjdChhdWRpb0N0eC5kZXN0aW5hdGlvbik7XG5cbiAgICBvc2NpbGxhdG9yLnR5cGUgPSAnc2luZSc7IC8vIENyZWF0ZXMgYSBcImRpbmdcIi1saWtlIHRvbmVcbiAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSg0NDAsIGF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTsgLy8gU2V0IGZyZXF1ZW5jeSB0byBBNCAoNDQwIEh6KVxuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcblxuICAgIGdhaW5Ob2RlLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAwMDAxLCBhdWRpb0N0eC5jdXJyZW50VGltZSArIDAuNSk7IC8vIEZhZGUgb3V0IGFmdGVyIDAuNSBzZWNvbmRzXG4gICAgb3NjaWxsYXRvci5zdG9wKGF1ZGlvQ3R4LmN1cnJlbnRUaW1lICsgMC41KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dUeXBpbmdJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgdHlwaW5nSW5kaWNhdG9yRGl2ID0gZ2V0VWlFbGVtZW50cygpLnR5cGluZ0luZGljYXRvclxuICAgIHR5cGluZ0luZGljYXRvckRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuXG4gICAgLy8gSGlkZSB0aGUgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaGlkZVR5cGluZ0luZGljYXRvcigpO1xuICAgIH0sIDMwMDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZVR5cGluZ0luZGljYXRvcigpIHtcbiAgICBjb25zdCB0eXBpbmdJbmRpY2F0b3JEaXYgPSBnZXRVaUVsZW1lbnRzKCkudHlwaW5nSW5kaWNhdG9yO1xuICAgIHR5cGluZ0luZGljYXRvckRpdi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUNoYXRJbnB1dENvbnRhaW5lcigpIHtcbiAgICBjb25zdCB7c2VuZEJ1dHRvbiwgY2hhdElucHV0LCBjaGF0SW5wdXRDb250YWluZXJ9ID0gZ2V0VWlFbGVtZW50cygpO1xuICAgIGlmIChjaGF0SW5wdXQpIHtcbiAgICAgICAgY2hhdElucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgY2hhdElucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIGlmIChzZW5kQnV0dG9uKSB7XG4gICAgICAgIHNlbmRCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBzZW5kQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgaWYgKGNoYXRJbnB1dENvbnRhaW5lcikge1xuICAgICAgICBjaGF0SW5wdXRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChsZW5ndGggPSA4KSB7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gICAgbGV0IHJlc3VsdCA9ICdpZC0nO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHNJbkRvbShlbGVtZW50SWQpIHtcbiAgICByZXR1cm4gISFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGF0SGVhZGVyKCkge1xuICAgIGNvbnN0IGhlYWRlckNvbnRlbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImNoYXQtaGVhZGVyLWNvbnRlbnRcIiwgXCJzbWFydC1idXktY2hhdC1oZWFkZXJcIl0pO1xuICAgIGhlYWRlckNvbnRlbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGhlYWRlckNvbnRlbnQuc3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG5cbiAgICAvLyBMZWZ0IHNlY3Rpb24gd2l0aCBhdmF0YXIgYW5kIGluZm9cbiAgICBjb25zdCBsZWZ0U2VjdGlvbiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wiaGVhZGVyLWxlZnQtc2VjdGlvblwiXSk7XG5cbiAgICAvLyBBZ2VudCBhdmF0YXJcbiAgICBjb25zdCBhdmF0YXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImF2YXRhci1jb250YWluZXJcIl0sIFwiXCIsIFwiYXZhdGFyLWNvbnRhaW5lclwiKTtcbiAgICBjb25zdCBhdmF0YXIgPSBjcmVhdGVFbGVtZW50KFwiaW1nXCIsIFtcImFnZW50LWF2YXRhclwiXSwgbnVsbCwgXCJhZ2VudC1hdmF0YXJcIik7XG4gICAgLy8gYXZhdGFyLnNyYyA9IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3VyYnVsbGV0L3N1cGVyLXNhbGVzLWRlbW8vcmVmcy9oZWFkcy9tYWluL2Fzc2V0cy9yb2JvdC5wbmdcIjtcbiAgICBhdmF0YXJDb250YWluZXIuYXBwZW5kQ2hpbGQoYXZhdGFyKTtcblxuICAgIC8vIEFkZCBzdGF0dXMgaW5kaWNhdG9yXG4gICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJzdGF0dXMtaW5kaWNhdG9yXCIsIFwiaGlkZGVuLXBsYWNlaG9sZGVyXCJdLCBcIlwiLCBcInN0YXR1cy1pbmRpY2F0b3JcIik7XG4gICAgYXZhdGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGF2YXRhcik7XG4gICAgYXZhdGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG5cbiAgICAvLyBBZ2VudCBpbmZvXG4gICAgY29uc3QgYWdlbnRJbmZvQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJhZ2VudC1pbmZvXCJdKTtcbiAgICBjb25zdCBhZ2VudE5hbWUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImFnZW50LW5hbWVcIl0sIFwiXCIsIFwiYWdlbnQtbmFtZVwiKTtcbiAgICBjb25zdCBhZ2VudFN0YXR1cyA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wiYWdlbnQtc3RhdHVzXCJdLCBcIlwiLCBcImFnZW50LXN0YXR1c1wiKTtcbiAgICBhZ2VudFN0YXR1cy5zdHlsZS5jb2xvciA9IHNlY29uZGFyeVRleHRDb2xvcjtcbiAgICBhZ2VudEluZm9Db250YWluZXIuYXBwZW5kKGFnZW50TmFtZSwgYWdlbnRTdGF0dXMpO1xuICAgIGxlZnRTZWN0aW9uLmFwcGVuZChhdmF0YXJDb250YWluZXIsIGFnZW50SW5mb0NvbnRhaW5lcik7XG5cbiAgICAvLyBSaWdodCBzZWN0aW9uIHdpdGggY29udHJvbHNcbiAgICBjb25zdCByaWdodFNlY3Rpb24gPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcImhlYWRlci1jb250cm9sc1wiXSk7XG5cbiAgICAvLyBSZXNpemUgd2lkZ2V0IGJ1dHRvbiAob25seSBiaWcgc2NyZWVucyB3aXRoIHdpZHRoID4gODAwcHgpXG4gICAgLy8gUmVzaXplIHdpZGdldCBidXR0b24gKG9ubHkgYmlnIHNjcmVlbnMgd2l0aCB3aWR0aCA+IDgwMHB4KVxuICAgIGNvbnN0IHJlc2l6ZUJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgW1wiaGVhZGVyLWNvbnRyb2wtYnRuXCJdLCBcIlwiLCBcInJlc2l6ZVdpZGdldEJ1dHRvblwiKTtcbiAgICByZXNpemVCdXR0b24uc3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgcmVzaXplQnV0dG9uLmRhdGFzZXQuc3RhdGUgPSBcInNocnVua1wiO1xuXG4vLyBTZXQgaW5pdGlhbCBzdGF0ZSBmb3IgZXhwYW5kaW5nXG4gICAgcmVzaXplQnV0dG9uLmlubmVySFRNTCA9IGBcbiAgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk03IDFIMVY3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk05IDE1SDE1VjlcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz5cbiAgPC9zdmc+XG5gO1xuXG4gICAgcmVzaXplQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0b2dnbGVDaGF0V2lkZ2V0UmVzaXplKCk7XG4gICAgfSk7XG5cblxuICAgIC8vIE1pbmltaXplIGJ1dHRvblxuICAgIGNvbnN0IG1pbmltaXplQnV0dG9uID0gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBbXCJoZWFkZXItY29udHJvbC1idG5cIl0pO1xuICAgIG1pbmltaXplQnV0dG9uLnN0eWxlLmNvbG9yID0gdGV4dENvbG9yO1xuICAgIG1pbmltaXplQnV0dG9uLmlubmVySFRNTCA9IGBcbiAgICA8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIyXCIgdmlld0JveD1cIjAgMCAxNiAyXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICA8cGF0aCBkPVwiTTEgMUgxNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxuICAgIDwvc3ZnPlxuICBgO1xuICAgIG1pbmltaXplQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0b2dnbGVDaGF0VmlzaWJpbGl0eSgpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBUaHJlZSBkb3RzIG1lbnVcbiAgICBjb25zdCBtZW51Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBbXCJtZW51LWNvbnRhaW5lclwiXSk7XG4gICAgY29uc3QgbWVudUJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgW1wiaGVhZGVyLWNvbnRyb2wtYnRuXCJdLCBcIlwiLCBcIm1lbnUtYnV0dG9uXCIpO1xuICAgIGNvbnN0IG1lbnVEcm9wZG93biA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgW1wibWVudS1kcm9wZG93blwiLCBcImhpZGRlblwiXSwgXCJcIiwgXCJtZW51LWRyb3Bkb3duXCIpO1xuXG4gICAgbWVudUNvbnRhaW5lci5hcHBlbmQobWVudUJ1dHRvbiwgbWVudURyb3Bkb3duKTtcbiAgICByaWdodFNlY3Rpb24uYXBwZW5kKHJlc2l6ZUJ1dHRvbiwgbWluaW1pemVCdXR0b24sIG1lbnVDb250YWluZXIpO1xuXG4gICAgLy8gQXBwZW5kIGFsbCBzZWN0aW9ucyB0byBoZWFkZXJcbiAgICBoZWFkZXJDb250ZW50LmFwcGVuZChsZWZ0U2VjdGlvbiwgcmlnaHRTZWN0aW9uKTtcblxuICAgIHJldHVybiBoZWFkZXJDb250ZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVRdWlja0FjdGlvbnNNZW51KCkge1xuICAgIGNvbnN0IGFjdGlvbnNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFtcInF1aWNrLWFjdGlvbnNcIl0pO1xuICAgIGFjdGlvbnNDb250YWluZXIuc3R5bGUucGFkZGluZyA9IFwiMTZweFwiO1xuICAgIGFjdGlvbnNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIGFjdGlvbnNDb250YWluZXIuc3R5bGUuZmxleERpcmVjdGlvbiA9IFwiY29sdW1uXCI7XG4gICAgYWN0aW9uc0NvbnRhaW5lci5zdHlsZS5nYXAgPSBcIjhweFwiO1xuXG4gICAgY29uc3QgYWN0aW9ucyA9IFtcbiAgICAgICAge3RleHQ6IFwiUmV2aWV3IG15IHN1YnNjcmlwdGlvblwiLCBpZDogXCJyZXZpZXctc3Vic2NyaXB0aW9uXCJ9LFxuICAgICAgICB7dGV4dDogXCJDaGVjayBib29raW5nIHN0YXR1c1wiLCBpZDogXCJjaGVjay1ib29raW5nXCJ9LFxuICAgICAgICB7dGV4dDogXCJWZWhpY2xlIGlzc3VlcyBvciBkYW1hZ2VcIiwgaWQ6IFwidmVoaWNsZS1pc3N1ZXNcIn0sXG4gICAgICAgIHt0ZXh0OiBcIlNwZWFrIHdpdGggc3VwcG9ydFwiLCBpZDogXCJzcGVhay1zdXBwb3J0XCJ9LFxuICAgICAgICB7dGV4dDogXCJLbm93bGVkZ2ViYXNlICYgRkFRXCIsIGlkOiBcImtub3dsZWRnZS1iYXNlXCJ9XG4gICAgXTtcblxuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBidXR0b24gPSBjcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFtcImFjdGlvbi1idXR0b25cIl0sIGFjdGlvbi50ZXh0KTtcbiAgICAgICAgYnV0dG9uLnN0eWxlLnBhZGRpbmcgPSBcIjEycHhcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkICNlZWVcIjtcbiAgICAgICAgYnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiOHB4XCI7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ3aGl0ZVwiO1xuICAgICAgICBidXR0b24uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS50cmFuc2l0aW9uID0gXCJiYWNrZ3JvdW5kIDAuMnNcIjtcbiAgICAgICAgLy8gYnV0dG9uLm9uY2xpY2sgPSAoKSA9PiBoYW5kbGVRdWlja0FjdGlvbihhY3Rpb24uaWQpO1xuICAgICAgICBhY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWN0aW9uc0NvbnRhaW5lcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9SZXNpemUodGV4dGFyZWEpIHtcbiAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgJ3B4Jztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN3aXRjaEFnZW50VUkoKSB7XG4gICAgY29uc3QgYWdlbnROYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZ2VudC1uYW1lXCIpO1xuICAgIGNvbnN0IGFnZW50QXZhdGFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZ2VudC1hdmF0YXJcIik7XG4gICAgY29uc3QgYWdlbnRTdGF0dXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFnZW50LXN0YXR1c1wiKTtcbiAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXR1cy1pbmRpY2F0b3JcIik7XG4gICAgY29uc3QgaHVtYW5NZW51SXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3BlYWstdG8taHVtYW4tbWVudS1pdGVtXCIpO1xuICAgIGNvbnN0IGNoYXRib3RNZW51SXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3dpdGNoLXRvLWNoYXRib3QtbWVudS1pdGVtXCIpO1xuXG4gICAgLy8gTWFwIGVhY2ggSUQgdG8gaXRzIHJldHJpZXZlZCBlbGVtZW50XG4gICAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgICAgIGFnZW50TmFtZTogYWdlbnROYW1lLFxuICAgICAgICBhZ2VudEF2YXRhcjogYWdlbnRBdmF0YXIsXG4gICAgICAgIGFnZW50U3RhdHVzOiBhZ2VudFN0YXR1cyxcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yOiBzdGF0dXNJbmRpY2F0b3IsXG4gICAgfTtcblxuXG4gICAgLy8gLy8gRmlsdGVyIG91dCB0aGUgb25lcyB0aGF0IGFyZSBtaXNzaW5nXG4gICAgY29uc3QgbWlzc2luZyA9IE9iamVjdFxuICAgICAgICAuZW50cmllcyhlbGVtZW50cykgICAgICAgICAgICAgICAgLy8gWyBbJ2FnZW50TmFtZScsIGVsZW1dLCAuLi4gXVxuICAgICAgICAuZmlsdGVyKChbXywgZWxdKSA9PiAhZWwpICAgICAgICAgLy8ga2VlcCBlbnRyaWVzIHdoZXJlIGVsIGlzIG51bGxcbiAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgICAgfSk7Ly8gZXh0cmFjdCBvbmx5IHRoZSBrZXlzXG5cbiAgICBpZiAobWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHN3aXRjaCBhZ2VudCBVSSDigJQgbWlzc2luZyBlbGVtZW50JHttaXNzaW5nLmxlbmd0aCA+IDEgPyAncycgOiAnJ306ICR7bWlzc2luZy5qb2luKCcsICcpfWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnZXRDaGF0U3RhdGVzKCkucGxhbiA+IDApIHtcbiAgICAgICAgaWYgKCFodW1hbk1lbnVJdGVtKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3Qgc3dpdGNoIGFnZW50IFVJIOKAlCBtaXNzaW5nIGVsZW1lbnQke21pc3NpbmcubGVuZ3RoID4gMSA/ICdzJyA6ICcnfTogJHttaXNzaW5nLmpvaW4oJywgJyl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYXRib3RNZW51SXRlbSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgQ2Fubm90IHN3aXRjaCBhZ2VudCBVSSDigJQgbWlzc2luZyBlbGVtZW50JHttaXNzaW5nLmxlbmd0aCA+IDEgPyAncycgOiAnJ306ICR7bWlzc2luZy5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gLy8gQ2hlY2sgaWYgYW55IHJlcXVpcmVkIERPTSBlbGVtZW50IGlzIG1pc3NpbmdcbiAgICAvLyBpZiAoIWFnZW50TmFtZSB8fCAhYWdlbnRBdmF0YXIgfHwgIWFnZW50U3RhdHVzIHx8ICFzdGF0dXNJbmRpY2F0b3IgfHwgIWh1bWFuTWVudUl0ZW0gfHwgIWNoYXRib3RNZW51SXRlbSkge1xuICAgIC8vICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IHN3aXRjaCBhZ2VudCBVSSwgT25lIG9yIG1vcmUgcmVxdWlyZWQgRE9NIGVsZW1lbnRzIGFyZSBtaXNzaW5nLlwiKTtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIGlmIChhd2FpdCBpc0h1bWFuQ2hhdCgpKSB7XG4gICAgICAgIGNvbnN0IGFnZW50SW5mbyA9IGF3YWl0IGdldEFnZW50SW5mbygpO1xuXG4gICAgICAgIGlmIChodW1hbk1lbnVJdGVtKSB7XG4gICAgICAgICAgICBodW1hbk1lbnVJdGVtLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhdGJvdE1lbnVJdGVtKSB7XG4gICAgICAgICAgICBjaGF0Ym90TWVudUl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZ2VudE5hbWUpIHtcbiAgICAgICAgICAgIGFnZW50TmFtZS5pbm5lckhUTUwgPSBhZ2VudEluZm8/Lm5hbWUgfHwgXCJBZG1pblwiXG4gICAgICAgICAgICBhZ2VudEF2YXRhci5zcmMgPSBhZ2VudEluZm8/LmltYWdlXG4gICAgICAgICAgICAgICAgPyBhZ2VudEluZm8uaW1hZ2VcbiAgICAgICAgICAgICAgICA6IFwiaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3N1cGVyLXNhbGVzLWNoYXQtd2lkZ2V0L2h1bWFuLWFnZW50LnBuZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9sbEFnZW50U3RhdHVzKGFnZW50SW5mbz8uaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdldENoYXRTdGF0ZXMoKS5wbGFuID4gMCkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IGlzVXNlckNyZWF0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGh1bWFuTWVudUl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaHVtYW5NZW51SXRlbS5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhdGJvdE1lbnVJdGVtLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBhZ2VudE5hbWUuaW5uZXJIVE1MID0gQ2hhdFdpZGdldENvbmZpZz8uVEhFTUVfU0VUVElOR1M/LmJvdE5hbWUgfHwgXCJTdHJ5a0JvdFwiXG4gICAgICAgIC8vIFJlZ2V4IHRvIG1hdGNoIFNob3BpZnkncyBcIm5vLWltYWdlXCIgcGxhY2Vob2xkZXJcbiAgICAgICAgY29uc3Qgbm9JbWFnZVJlZ2V4ID0gL3Nob3BpZnlcXC9hc3NldHNcXC9uby1pbWFnZXxpbnZhbGlkIHVybCBpbnB1dC9pO1xuXG5cbiAgICAgICAgLy8gU2V0IHRoZSBhdmF0YXIgc291cmNlIHdpdGggYSBmYWxsYmFjayBpZiB0aGUgXCJuby1pbWFnZVwiIFVSTCBpcyBkZXRlY3RlZCBvciBubyBhdmF0YXIgaXMgc2V0XG4gICAgICAgIGFnZW50QXZhdGFyLnNyYyA9XG4gICAgICAgICAgICBDaGF0V2lkZ2V0Q29uZmlnPy5USEVNRV9TRVRUSU5HUz8uYm90QXZhdGFyICYmXG4gICAgICAgICAgICAhbm9JbWFnZVJlZ2V4LnRlc3Qod2luZG93LkNoYXRXaWRnZXRDb25maWcuVEhFTUVfU0VUVElOR1MuYm90QXZhdGFyKVxuICAgICAgICAgICAgICAgID8gd2luZG93LkNoYXRXaWRnZXRDb25maWcuVEhFTUVfU0VUVElOR1MuYm90QXZhdGFyXG4gICAgICAgICAgICAgICAgOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS91cmJ1bGxldC9zdXBlci1zYWxlcy1kZW1vL3JlZnMvaGVhZHMvbWFpbi9hc3NldHMvcm9ib3QucG5nXCI7XG4gICAgICAgIC8vIGFnZW50QXZhdGFyLnNyYyA9IENoYXRXaWRnZXRDb25maWc/LlRIRU1FX1NFVFRJTkdTPy5ib3RBdmF0YXIgfHwgXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vdXJidWxsZXQvc3VwZXItc2FsZXMtZGVtby9yZWZzL2hlYWRzL21haW4vYXNzZXRzL3JvYm90LnBuZ1wiO1xuICAgICAgICBhZ2VudFN0YXR1cy5pbm5lckhUTUwgPSBoZWFkZXJUZXh0O1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZChcImhpZGRlbi1wbGFjZWhvbGRlclwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5ZWRPbmxpbmVTdGF0dXMobmV3U3RhdHVzKSB7XG4gICAgY29uc3QgYWdlbnRTdGF0dXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFnZW50LXN0YXR1c1wiKTtcbiAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXR1cy1pbmRpY2F0b3JcIik7XG4gICAgYWdlbnRTdGF0dXMuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlbi1wbGFjZWhvbGRlclwiKTtcbiAgICBhZ2VudFN0YXR1cy5pbm5lckhUTUwgPSBuZXdTdGF0dXMgfHwgXCJcIlxuICAgIHN0YXR1c0luZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuLXBsYWNlaG9sZGVyXCIpXG4gICAgdXBkYXRlQWdlbnRTdGF0dXNJbmRpY2F0b3IobmV3U3RhdHVzKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBZ2VudFN0YXR1c0luZGljYXRvcihzdGF0dXMpIHtcbiAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXR1cy1pbmRpY2F0b3JcIik7XG4gICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcIm9ubGluZVwiOlxuICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImdyZWVuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXdheVwiOlxuICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIm9yYW5nZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRuZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9mZmxpbmVcIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiZGFya2dyYXlcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlDdXN0b21TdHlsaW5nKCkge1xuICAgIGNvbnN0IHRoZW1lU2V0dGluZ3MgPSB3aW5kb3cuQ2hhdFdpZGdldENvbmZpZy5USEVNRV9TRVRUSU5HUztcbiAgICBpZiAoIXRoZW1lU2V0dGluZ3MpIHJldHVybjtcblxuICAgIGlmICh0aGVtZVNldHRpbmdzLmJhY2tncm91bmRDb2xvcikgYmFja2dyb3VuZENvbG9yID0gdGhlbWVTZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaWYgKHRoZW1lU2V0dGluZ3MudGV4dENvbG9yKSB0ZXh0Q29sb3IgPSB0aGVtZVNldHRpbmdzLnRleHRDb2xvcjtcbiAgICBpZiAodGhlbWVTZXR0aW5ncy5zZWNvbmRhcnlUZXh0Q29sb3IpIHNlY29uZGFyeVRleHRDb2xvciA9IHRoZW1lU2V0dGluZ3Muc2Vjb25kYXJ5VGV4dENvbG9yO1xuICAgIC8vIGlmKHRoZW1lU2V0dGluZ3MudGV4dEZvbnQpIHRleHRGb250ID0gdGhlbWVTZXR0aW5ncy50ZXh0Rm9udDtcbiAgICBpZiAodGhlbWVTZXR0aW5ncy5oZWFkZXJUZXh0KSBoZWFkZXJUZXh0ID0gdGhlbWVTZXR0aW5ncy5oZWFkZXJUZXh0O1xuICAgIGlmICh0aGVtZVNldHRpbmdzLndlbGNvbWVNZXNzYWdlKSB3ZWxjb21lTWVzc2FnZSA9IHRoZW1lU2V0dGluZ3Mud2VsY29tZU1lc3NhZ2U7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZUNoYXRXaWRnZXRSZXNpemUoKSB7XG4gICAgY29uc3QgcmVzaXplQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXNpemVXaWRnZXRCdXR0b25cIik7XG4gICAgaWYgKCFyZXNpemVCdXR0b24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlJlc2l6ZSBidXR0b24gd2l0aCBpZCAncmVzaXplV2lkZ2V0QnV0dG9uJyBub3QgaW4gdGhlIERPTVwiKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhdFdpZGdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY2hhdC13aWRnZXRcIik7XG4gICAgaWYgKCFjaGF0V2lkZ2V0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDaGF0IHdpZGdldCBub3QgaW4gdGhlIERPTVwiKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhdElucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjaGF0LWlucHV0XCIpO1xuICAgIGlmICghY2hhdElucHV0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDaGF0IElucHV0IG5vdCBpbiB0aGUgRE9NXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgcmVzaXplIHN0YXRlXG4gICAgaWYgKHJlc2l6ZUJ1dHRvbi5kYXRhc2V0LnN0YXRlID09PSBcImV4cGFuZGVkXCIpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHRvIHNocmluayBpY29uXG4gICAgICAgIHJlc2l6ZUJ1dHRvbi5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNyAxSDFWN1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNOSAxNUgxNVY5XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+XG4gICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgYDtcbiAgICAgICAgcmVzaXplQnV0dG9uLmRhdGFzZXQuc3RhdGUgPSBcInNocnVua1wiO1xuXG4gICAgICAgIGNoYXRXaWRnZXQuY2xhc3NMaXN0LnJlbW92ZShcImV4cGFuZGVkXCIpO1xuICAgICAgICBjaGF0V2lkZ2V0LmNsYXNzTGlzdC5hZGQoXCJzaHJ1bmtcIik7XG4gICAgICAgIGNoYXRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiZXhwYW5kZWRcIik7XG4gICAgICAgIGNoYXRJbnB1dC5jbGFzc0xpc3QuYWRkKFwic2hydW5rXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoYW5nZSB0byBleHBhbmQgaWNvblxuICAgICAgICByZXNpemVCdXR0b24uaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgICA8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEgMUg3VjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE1IDE1SDlWOVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIGA7XG4gICAgICAgIHJlc2l6ZUJ1dHRvbi5kYXRhc2V0LnN0YXRlID0gXCJleHBhbmRlZFwiO1xuXG4gICAgICAgIGNoYXRXaWRnZXQuY2xhc3NMaXN0LnJlbW92ZShcInNocnVua1wiKTtcbiAgICAgICAgY2hhdFdpZGdldC5jbGFzc0xpc3QuYWRkKFwiZXhwYW5kZWRcIik7XG4gICAgICAgIGNoYXRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwic2hydW5rXCIpO1xuICAgICAgICBjaGF0SW5wdXQuY2xhc3NMaXN0LmFkZChcImV4cGFuZGVkXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVBsYW5VSSgpIHtcbiAgICBpZiAoZ2V0Q2hhdFN0YXRlcygpLnVwZGF0ZVBsYW5VSSkgcmV0dXJuXG4gICAgY29uc3QgbWVudUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVudS1idXR0b25cIilcbiAgICBjb25zdCBtZW51RHJvcGRvd24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1lbnUtZHJvcGRvd25cIilcbiAgICBpZiAoIW1lbnVEcm9wZG93bikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwidXBkYXRlUGxhblVJIGZhaWxlZCAtLSBtZW51RHJvcGRvd24gbm90IGZvdW5kIGluIHRoZSBET01cIilcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghbWVudUJ1dHRvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwidXBkYXRlUGxhblVJIGZhaWxlZCAtLSBtZW51QnV0dG9uIG5vdCBmb3VuZCBpbiB0aGUgRE9NXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdldENoYXRTdGF0ZXMoKS5wbGFuID4gMCkge1xuXG4gICAgICAgIG1lbnVCdXR0b24uc3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgICAgIG1lbnVCdXR0b24uaW5uZXJIVE1MID0gYFxuICAgIDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgICAgPHBhdGggZD1cIk04IDMuNUM4LjgzIDMuNSA5LjUgMi44MyA5LjUgMkM5LjUgMS4xNyA4LjgzIDAuNSA4IDAuNUM3LjE3IDAuNSA2LjUgMS4xNyA2LjUgMkM2LjUgMi44MyA3LjE3IDMuNSA4IDMuNVpNOCA2LjVDNy4xNyA2LjUgNi41IDcuMTcgNi41IDhDNi41IDguODMgNy4xNyA5LjUgOCA5LjVDOC44MyA5LjUgOS41IDguODMgOS41IDhDOS41IDcuMTcgOC44MyA2LjUgOCA2LjVaTTggMTIuNUM3LjE3IDEyLjUgNi41IDEzLjE3IDYuNSAxNEM2LjUgMTQuODMgNy4xNyAxNS41IDggMTUuNUM4LjgzIDE1LjUgOS41IDE0LjgzIDkuNSAxNEM5LjUgMTMuMTcgOC44MyAxMi41IDggMTIuNVpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIvPlxuICAgIDwvc3ZnPlxuICBgO1xuICAgICAgICAvLyBEcm9wZG93biBtZW51XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogXCJzcGVhay10by1odW1hbi1tZW51LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJTcGVhayB0byBhIGh1bWFuXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQoJ1RhbGsgdG8gSHVtYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc291cmNlJzogJ21lbnUnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVF1aWNrQ2hhdEFjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVUYWxrVG9IdW1hbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IFwic3dpdGNoLXRvLWNoYXRib3QtbWVudS1pdGVtXCIsXG4gICAgICAgICAgICAgICAgbGFiZWw6IFwiU3dpdGNoIHRvIGNoYXRib3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiBbXCJoaWRkZW5cIl0sXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQoJ1RhbGsgdG8gR1BUJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZSc6ICdtZW51J1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVRdWlja0NoYXRBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVuZGVyTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyX2lkOiAoYXdhaXQgZ2V0U3RvcmVkVXNlckluZm8oKSkudXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wb3JhcnlNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNob3dMb2FkaW5nU3Bpbm5lcigpO1xuICAgICAgICAgICAgICAgICAgICB0YWxrVG9Cb3QoKS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldFN0b3JlZENoYXRUeXBlKFwiYm90XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RvcmVDaGFubmVsSWQocmVzLnVzZXJDaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja0ZvckV4aXN0aW5nQ2hhbm5lbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3dpdGNoQWdlbnRVSSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlTG9hZGluZ1NwaW5uZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IFwicmVzZXQtY2hhdC1tZW51LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJSZXNldCBDaGF0XCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiBhd2FpdCByZXNldENoYXQoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgICAgICBtZW51RHJvcGRvd24ucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgWy4uLihpdGVtLmNsYXNzZXMgfHwgW10pLCBcImNoYXQtaGVhZGVyLW1lbnUtaXRlbVwiXSwgaXRlbS5sYWJlbCwgaXRlbS5pZCk7XG4gICAgICAgICAgICBtZW51SXRlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgbWVudURyb3Bkb3duLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lbnVEcm9wZG93bi5hcHBlbmRDaGlsZChtZW51SXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3cgbWVudSBkcm9wZG93blxuICAgICAgICBpZiAoIW1lbnVCdXR0b24uZGF0YXNldC5saXN0ZW5lckFkZGVkKSB7XG4gICAgICAgICAgICBtZW51QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgbWVudURyb3Bkb3duLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lbnVCdXR0b24uZGF0YXNldC5saXN0ZW5lckFkZGVkID0gXCJ0cnVlXCI7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENsb3NlIG1lbnUgd2hlbiBjbGlja2luZyBvdXRzaWRlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBtZW51RHJvcGRvd24uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUNoYXRTdGF0ZXMoXG4gICAgICAgICAgICB7dXBkYXRlUGxhblVJOiB0cnVlfVxuICAgICAgICApXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/ui-util.js\n");

/***/ }),

/***/ "./src/utils/util.js":
/*!***************************!*\
  !*** ./src/utils/util.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTargetBlankToLinks: () => (/* binding */ addTargetBlankToLinks),\n/* harmony export */   apiCall: () => (/* binding */ apiCall),\n/* harmony export */   createElement: () => (/* binding */ createElement),\n/* harmony export */   getApiUrl: () => (/* binding */ getApiUrl),\n/* harmony export */   isArabic: () => (/* binding */ isArabic),\n/* harmony export */   isDev: () => (/* binding */ isDev),\n/* harmony export */   isOutsideShopify: () => (/* binding */ isOutsideShopify),\n/* harmony export */   trackEvent: () => (/* binding */ trackEvent)\n/* harmony export */ });\n/* harmony import */ var mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixpanel-browser */ \"./node_modules/mixpanel-browser/dist/mixpanel.module.js\");\n\n\n// Utility function for API calls with error handling\nasync function apiCall(url, method = 'GET', body = null) {\n    const options = {\n        method,\n        headers: {\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*',\n            'ngrok-skip-browser-warning': 'true',\n        },\n        credentials: 'include',\n        body: body ? JSON.stringify(body) : null,\n    };\n\n    let response;\n    try {\n        response = await fetch(url, options);\n    } catch (networkError) {\n        console.error('Network error during API call:', networkError);\n        return null;\n    }\n\n    let payload;\n    try {\n        payload = await response.json();\n    } catch (parseError) {\n        console.error('Failed to parse JSON response:', parseError);\n        // If you want to treat a non-JSON body on 401 as an error too, you could\n        // still throw here if response.status === 401.\n        payload = null;\n    }\n\n    if (!response?.ok) {\n        if (response?.status === 401) {\n            // create and throw an Error that carries status + payload\n            const err = new Error('Unauthorized');\n            err.status  = 401;\n            err.payload = payload;\n            throw err;\n        }\n        // all other HTTP errors just return null\n        console.error(`API call returned HTTP ${response.status}`);\n        return null;\n    }\n\n    return payload;\n}\n\n// Utility function to create DOM elements with classes\nfunction createElement(tag, classNames, content, id) {\n    const element = document.createElement(tag);\n    if (id) element.id = id;\n    if (classNames) element.classList.add(...classNames);\n    if (content) element.innerHTML = content;\n    return element;\n}\n\nconst isArabic = (text) => {\n    // Regular expression to check for Arabic characters\n    const arabicPattern = /[\\u0600-\\u06FF]/;\n    return arabicPattern.test(text);\n}\n\nfunction addTargetBlankToLinks(element) {\n    element.querySelectorAll('a').forEach(link => {\n        link.setAttribute('target', '_blank');\n        link.setAttribute('rel', 'noopener noreferrer');\n        link.addEventListener('click', (e) => {\n            trackEvent('Product Viewed', {\n                productUrl: link.href\n            });\n        })\n    });\n}\n\nfunction getApiUrl() {\n    const API_URL = window.ChatWidgetConfig?.API_URL;\n    if(!API_URL) throw new Error(\"Super Sales API url is not provided\")\n    return API_URL;\n}\n\nfunction isDev() {\n    return localStorage.getItem('environment') === 'dev'\n}\n\nfunction trackEvent(event, customProps) {\n    if(isDev()) return;\n    mixpanel_browser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].track(event, customProps);\n}\n\nconst isOutsideShopify = () => {\n    const onLocalhost = window.location.href.includes(\"localhost\");\n    const onDemoSite = window.location.href.includes(\"super-sales-demo\");\n    return isDev() || onLocalhost || onDemoSite;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvdXRpbC5qcz9hNzM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtaXhwYW5lbCBmcm9tIFwibWl4cGFuZWwtYnJvd3NlclwiO1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciBBUEkgY2FsbHMgd2l0aCBlcnJvciBoYW5kbGluZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwaUNhbGwodXJsLCBtZXRob2QgPSAnR0VUJywgYm9keSA9IG51bGwpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgICAgICAgJ25ncm9rLXNraXAtYnJvd3Nlci13YXJuaW5nJzogJ3RydWUnLFxuICAgICAgICB9LFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBib2R5OiBib2R5ID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBudWxsLFxuICAgIH07XG5cbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKG5ldHdvcmtFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdOZXR3b3JrIGVycm9yIGR1cmluZyBBUEkgY2FsbDonLCBuZXR3b3JrRXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgICBwYXlsb2FkID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2U6JywgcGFyc2VFcnJvcik7XG4gICAgICAgIC8vIElmIHlvdSB3YW50IHRvIHRyZWF0IGEgbm9uLUpTT04gYm9keSBvbiA0MDEgYXMgYW4gZXJyb3IgdG9vLCB5b3UgY291bGRcbiAgICAgICAgLy8gc3RpbGwgdGhyb3cgaGVyZSBpZiByZXNwb25zZS5zdGF0dXMgPT09IDQwMS5cbiAgICAgICAgcGF5bG9hZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFyZXNwb25zZT8ub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuZCB0aHJvdyBhbiBFcnJvciB0aGF0IGNhcnJpZXMgc3RhdHVzICsgcGF5bG9hZFxuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdVbmF1dGhvcml6ZWQnKTtcbiAgICAgICAgICAgIGVyci5zdGF0dXMgID0gNDAxO1xuICAgICAgICAgICAgZXJyLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbCBvdGhlciBIVFRQIGVycm9ycyBqdXN0IHJldHVybiBudWxsXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSBjYWxsIHJldHVybmVkIEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwYXlsb2FkO1xufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBET00gZWxlbWVudHMgd2l0aCBjbGFzc2VzXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZXMsIGNvbnRlbnQsIGlkKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoaWQpIGVsZW1lbnQuaWQgPSBpZDtcbiAgICBpZiAoY2xhc3NOYW1lcykgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIGlmIChjb250ZW50KSBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBpc0FyYWJpYyA9ICh0ZXh0KSA9PiB7XG4gICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIGNoZWNrIGZvciBBcmFiaWMgY2hhcmFjdGVyc1xuICAgIGNvbnN0IGFyYWJpY1BhdHRlcm4gPSAvW1xcdTA2MDAtXFx1MDZGRl0vO1xuICAgIHJldHVybiBhcmFiaWNQYXR0ZXJuLnRlc3QodGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRUYXJnZXRCbGFua1RvTGlua3MoZWxlbWVudCkge1xuICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYScpLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnX2JsYW5rJyk7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdyZWwnLCAnbm9vcGVuZXIgbm9yZWZlcnJlcicpO1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRyYWNrRXZlbnQoJ1Byb2R1Y3QgVmlld2VkJywge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RVcmw6IGxpbmsuaHJlZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcGlVcmwoKSB7XG4gICAgY29uc3QgQVBJX1VSTCA9IHdpbmRvdy5DaGF0V2lkZ2V0Q29uZmlnPy5BUElfVVJMO1xuICAgIGlmKCFBUElfVVJMKSB0aHJvdyBuZXcgRXJyb3IoXCJTdXBlciBTYWxlcyBBUEkgdXJsIGlzIG5vdCBwcm92aWRlZFwiKVxuICAgIHJldHVybiBBUElfVVJMO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXYoKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlbnZpcm9ubWVudCcpID09PSAnZGV2J1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tFdmVudChldmVudCwgY3VzdG9tUHJvcHMpIHtcbiAgICBpZihpc0RldigpKSByZXR1cm47XG4gICAgbWl4cGFuZWwudHJhY2soZXZlbnQsIGN1c3RvbVByb3BzKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzT3V0c2lkZVNob3BpZnkgPSAoKSA9PiB7XG4gICAgY29uc3Qgb25Mb2NhbGhvc3QgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcyhcImxvY2FsaG9zdFwiKTtcbiAgICBjb25zdCBvbkRlbW9TaXRlID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMoXCJzdXBlci1zYWxlcy1kZW1vXCIpO1xuICAgIHJldHVybiBpc0RldigpIHx8IG9uTG9jYWxob3N0IHx8IG9uRGVtb1NpdGU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/util.js\n");

/***/ }),

/***/ "./src/widget.js":
/*!***********************!*\
  !*** ./src/widget.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n/* harmony import */ var _utils_ui_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/ui-util */ \"./src/utils/ui-util.js\");\n/* harmony import */ var _utils_chat_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/chat-util */ \"./src/utils/chat-util.js\");\n/* harmony import */ var _services_general_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/general.service */ \"./src/services/general.service.js\");\n/* harmony import */ var mixpanel_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mixpanel-browser */ \"./node_modules/mixpanel-browser/dist/mixpanel.module.js\");\n/* harmony import */ var _utils_chat_expirey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/chat-expirey */ \"./src/utils/chat-expirey.js\");\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/util */ \"./src/utils/util.js\");\n\n\n\n\n\n\n\n\n(async function (config) {\n\n    if ((0,_utils_util__WEBPACK_IMPORTED_MODULE_6__.isOutsideShopify)()) {\n        const storedGuestId = localStorage.getItem(\"guestId\")\n        if (storedGuestId) {\n            config.GUEST_ID = storedGuestId;\n        } else {\n            const guestId = crypto.randomUUID();\n            config.GUEST_ID = guestId\n            localStorage.setItem(\"guestId\", guestId);\n        }\n    }\n    // 1) Wait for GUEST_ID to arrive on the config object\n    if (!config.GUEST_ID) {\n        await new Promise(resolve => {\n            const interval = setInterval(() => {\n                if (config.GUEST_ID) {\n                    clearInterval(interval);\n                    resolve();\n                }\n            }, 50);\n        });\n    }\n\n    // 2) Wait for the DOM to be loaded\n    if (document.readyState === 'loading') {\n        await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));\n    }\n\n    console.log('[ChatBundle] Starting with config:', config);\n\n    // 3) Your existing initialization\n    await (0,_services_general_service__WEBPACK_IMPORTED_MODULE_3__.checkHeartbeat)();\n\n    mixpanel_browser__WEBPACK_IMPORTED_MODULE_4__[\"default\"].init(\"7f6a8aae29dcc3c1ec5f63e5b27e5850\", {\n        debug: true,\n        track_pageview: true,\n        persistence: \"localStorage\",\n    });\n\n    (0,_utils_chat_util__WEBPACK_IMPORTED_MODULE_2__.updateChatStates)({canStartConversation: !(await (0,_services_general_service__WEBPACK_IMPORTED_MODULE_3__.reachedSeatLimit)())});\n\n    await (0,_utils_chat_expirey__WEBPACK_IMPORTED_MODULE_5__.checkChatValid)();\n\n    await (0,_utils_ui_util__WEBPACK_IMPORTED_MODULE_1__.setupUI)();\n    console.log(\"ui setup complete, creating chat connection\");\n\n    await (0,_utils_chat_util__WEBPACK_IMPORTED_MODULE_2__.setupChatConnection)();\n})(window.ChatWidgetConfig || {});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd2lkZ2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3dpZGdldC5qcz9hMTIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zdHlsZS5zY3NzJztcbmltcG9ydCB7c2V0dXBVSX0gZnJvbSBcIi4vdXRpbHMvdWktdXRpbFwiO1xuaW1wb3J0IHtzZXR1cENoYXRDb25uZWN0aW9uLCB1cGRhdGVDaGF0U3RhdGVzfSBmcm9tIFwiLi91dGlscy9jaGF0LXV0aWxcIjtcbmltcG9ydCB7Y2hlY2tIZWFydGJlYXQsIHJlYWNoZWRTZWF0TGltaXR9IGZyb20gXCIuL3NlcnZpY2VzL2dlbmVyYWwuc2VydmljZVwiO1xuaW1wb3J0IG1peHBhbmVsIGZyb20gXCJtaXhwYW5lbC1icm93c2VyXCI7XG5pbXBvcnQge2NoZWNrQ2hhdFZhbGlkfSBmcm9tIFwiLi91dGlscy9jaGF0LWV4cGlyZXlcIjtcbmltcG9ydCB7aXNPdXRzaWRlU2hvcGlmeX0gZnJvbSBcIi4vdXRpbHMvdXRpbFwiO1xuXG4oYXN5bmMgZnVuY3Rpb24gKGNvbmZpZykge1xuXG4gICAgaWYgKGlzT3V0c2lkZVNob3BpZnkoKSkge1xuICAgICAgICBjb25zdCBzdG9yZWRHdWVzdElkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJndWVzdElkXCIpXG4gICAgICAgIGlmIChzdG9yZWRHdWVzdElkKSB7XG4gICAgICAgICAgICBjb25maWcuR1VFU1RfSUQgPSBzdG9yZWRHdWVzdElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ3Vlc3RJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgICBjb25maWcuR1VFU1RfSUQgPSBndWVzdElkXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImd1ZXN0SWRcIiwgZ3Vlc3RJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMSkgV2FpdCBmb3IgR1VFU1RfSUQgdG8gYXJyaXZlIG9uIHRoZSBjb25maWcgb2JqZWN0XG4gICAgaWYgKCFjb25maWcuR1VFU1RfSUQpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLkdVRVNUX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAyKSBXYWl0IGZvciB0aGUgRE9NIHRvIGJlIGxvYWRlZFxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVzb2x2ZSkpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdbQ2hhdEJ1bmRsZV0gU3RhcnRpbmcgd2l0aCBjb25maWc6JywgY29uZmlnKTtcblxuICAgIC8vIDMpIFlvdXIgZXhpc3RpbmcgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBjaGVja0hlYXJ0YmVhdCgpO1xuXG4gICAgbWl4cGFuZWwuaW5pdChcIjdmNmE4YWFlMjlkY2MzYzFlYzVmNjNlNWIyN2U1ODUwXCIsIHtcbiAgICAgICAgZGVidWc6IHRydWUsXG4gICAgICAgIHRyYWNrX3BhZ2V2aWV3OiB0cnVlLFxuICAgICAgICBwZXJzaXN0ZW5jZTogXCJsb2NhbFN0b3JhZ2VcIixcbiAgICB9KTtcblxuICAgIHVwZGF0ZUNoYXRTdGF0ZXMoe2NhblN0YXJ0Q29udmVyc2F0aW9uOiAhKGF3YWl0IHJlYWNoZWRTZWF0TGltaXQoKSl9KTtcblxuICAgIGF3YWl0IGNoZWNrQ2hhdFZhbGlkKCk7XG5cbiAgICBhd2FpdCBzZXR1cFVJKCk7XG4gICAgY29uc29sZS5sb2coXCJ1aSBzZXR1cCBjb21wbGV0ZSwgY3JlYXRpbmcgY2hhdCBjb25uZWN0aW9uXCIpO1xuXG4gICAgYXdhaXQgc2V0dXBDaGF0Q29ubmVjdGlvbigpO1xufSkod2luZG93LkNoYXRXaWRnZXRDb25maWcgfHwge30pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/widget.js\n");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_0_use_2_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!../node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[0].use[2]!./style.scss */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[0].use[2]!./src/style.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_0_use_2_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_0_use_2_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_0_use_2_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_0_use_2_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGUuc2NzcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlLnNjc3M/MmM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzBdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMF0udXNlWzJdIS4vc3R5bGUuc2Nzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1swXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzBdLnVzZVsyXSEuL3N0eWxlLnNjc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/style.scss\n");

/***/ }),

/***/ "./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v14.1.3 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape$1(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nconst noopTest = { exec: () => null };\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape$1(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape$1(text),\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (/^ {0,3}>/.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n                    .replace(/^ {0,3}>[ \\t]?/gm, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens[tokens.length - 1];\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && /^[ \\t]*$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<[a-z].*>`, 'i');\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(/\\t/g, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(/\\t/g, '    ').search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n[ \\t]*\\n[ \\t]*$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n            list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape$1(cap[1]),\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape$1(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape$1(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape$1(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape$1(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape$1(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n}\n\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(/^\\S*/)?.[0];\n        const code = text.replace(/\\n$/, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape$1(langString)\n            + '\">'\n            + (escaped ? code : escape$1(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${text}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape$1(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvZGVmYXVsdHMudHM/ZDgyZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2VkL3NyYy9oZWxwZXJzLnRzPzYxOGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvVG9rZW5pemVyLnRzPzIxMzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvcnVsZXMudHM/MzYzZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2VkL3NyYy9MZXhlci50cz9kYWYzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZWQvc3JjL1JlbmRlcmVyLnRzP2U3OGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvVGV4dFJlbmRlcmVyLnRzP2EzNWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvUGFyc2VyLnRzPzIwMWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvSG9va3MudHM/ZDFkNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2VkL3NyYy9JbnN0YW5jZS50cz82ZDg5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZWQvc3JjL21hcmtlZC50cz9mNWM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGV4dGVuc2lvbnM6IG51bGwsXG4gICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgaG9va3M6IG51bGwsXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICAgIHRva2VuaXplcjogbnVsbCxcbiAgICAgICAgd2Fsa1Rva2VuczogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGxldCBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VEZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIF9kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzXG4gKi9cbmNvbnN0IGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xuY29uc3QgZXNjYXBlUmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdC5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS87XG5jb25zdCBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3ROb0VuY29kZS5zb3VyY2UsICdnJyk7XG5jb25zdCBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgICBpZiAoZW5jb2RlKSB7XG4gICAgICAgIGlmIChlc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5jb25zdCB1bmVzY2FwZVRlc3QgPSAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnO1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgKF8sIG4pID0+IHtcbiAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG4gPT09ICdjb2xvbicpXG4gICAgICAgICAgICByZXR1cm4gJzonO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG59XG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5leHBvcnQgZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0KSB7XG4gICAgbGV0IHNvdXJjZSA9IHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycgPyByZWdleCA6IHJlZ2V4LnNvdXJjZTtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsU291cmNlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwgOiB2YWwuc291cmNlO1xuICAgICAgICAgICAgdmFsU291cmNlID0gdmFsU291cmNlLnJlcGxhY2UoY2FyZXQsICckMScpO1xuICAgICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UobmFtZSwgdmFsU291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZjtcbn1cbmV4cG9ydCBjb25zdCBub29wVGVzdCA9IHsgZXhlYzogKCkgPT4gbnVsbCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICBjb25zdCByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VyciA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgIH0pLCBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjZWxscy5zcGxpY2UoY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KVxuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQgcGVyIHRoZSBnZm0gc3BlY1xuICAgICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAqIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gKlxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIGNcbiAqIEBwYXJhbSBpbnZlcnQgUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4iLCJpbXBvcnQgeyBfZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLnRzJztcbmltcG9ydCB7IHJ0cmltLCBzcGxpdENlbGxzLCBlc2NhcGUsIGZpbmRDbG9zaW5nQnJhY2tldCwgfSBmcm9tICcuL2hlbHBlcnMudHMnO1xuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIpIHtcbiAgICBjb25zdCBocmVmID0gbGluay5ocmVmO1xuICAgIGNvbnN0IHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG4gICAgY29uc3QgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcbiAgICBpZiAoY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnKSB7XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpLFxuICAgICAgICB9O1xuICAgICAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICByYXcsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0ZXh0OiBlc2NhcGUodGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgX1Rva2VuaXplciB7XG4gICAgb3B0aW9ucztcbiAgICBydWxlczsgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICAgIGxleGVyOyAvLyBzZXQgYnkgdGhlIGxleGVyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2Uoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29kZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eKD86IHsxLDR9fCB7MCwzfVxcdCkvZ20sICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZW5jZXMoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IHJ0cmltKGNhcFswXSwgJ1xcbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBydHJpbShjYXBbMF0sICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbkJsb2NrcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxpbmVzIHVwIHRvIGEgY29udGludWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXiB7MCwzfT4vLnRlc3QobGluZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJsb2NrcXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpbkJsb2NrcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcy5wdXNoKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVzID0gbGluZXMuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhdyA9IGN1cnJlbnRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGN1cnJlbnRSYXdcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlY2VkZSBzZXRleHQgY29udGludWF0aW9uIHdpdGggNCBzcGFjZXMgc28gaXQgaXNuJ3QgYSBzZXRleHRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbiB7MCwzfSgoPzo9K3wtKykgKikoPz1cXG58JCkvZywgJ1xcbiAgICAkMScpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eIHswLDN9PlsgXFx0XT8vZ20sICcnKTtcbiAgICAgICAgICAgICAgICByYXcgPSByYXcgPyBgJHtyYXd9XFxuJHtjdXJyZW50UmF3fWAgOiBjdXJyZW50UmF3O1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0ID8gYCR7dGV4dH1cXG4ke2N1cnJlbnRUZXh0fWAgOiBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBibG9ja3F1b3RlIGxpbmVzIGFzIHRvcCBsZXZlbCB0b2tlbnNcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBwYXJhZ3JhcGhzIGlmIHRoaXMgaXMgYSBjb250aW51YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5ibG9ja1Rva2VucyhjdXJyZW50VGV4dCwgdG9rZW5zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBjb250aW51YXRpb24gdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJsb2NrcXVvdGUgY29udGludWF0aW9uIGNhbm5vdCBiZSBwcmVjZWRlZCBieSBhIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2Jsb2NrcXVvdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY29udGludWF0aW9uIGluIG5lc3RlZCBibG9ja3F1b3RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgJ1xcbicgKyBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmJsb2NrcXVvdGUobmV3VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBuZXdUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gb2xkVG9rZW4ucmF3Lmxlbmd0aCkgKyBuZXdUb2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIG9sZFRva2VuLnRleHQubGVuZ3RoKSArIG5ld1Rva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0VG9rZW4/LnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGNvbnRpbnVhdGlvbiBpbiBuZXN0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRUb2tlbiA9IGxhc3RUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VGV4dCA9IG9sZFRva2VuLnJhdyArICdcXG4nICsgbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Rva2VuID0gdGhpcy5saXN0KG5ld1RleHQpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID0gbmV3VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoMCwgcmF3Lmxlbmd0aCAtIGxhc3RUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gb2xkVG9rZW4ucmF3Lmxlbmd0aCkgKyBuZXdUb2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbmV3VGV4dC5zdWJzdHJpbmcodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5yYXcubGVuZ3RoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdChzcmMpIHtcbiAgICAgICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIHJhdzogJycsXG4gICAgICAgICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBidWxsIDogJ1sqKy1dJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBuZXh0IGxpc3QgaXRlbVxuICAgICAgICAgICAgY29uc3QgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgbGV0IGVuZHNXaXRoQmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHJhdyA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBpdGVtQ29udGVudHMgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMuYmxvY2suaHIudGVzdChzcmMpKSB7IC8vIEVuZCBsaXN0IGlmIGJ1bGxldCB3YXMgYWN0dWFsbHkgSFIgKHBvc3NpYmx5IG1vdmUgaW50byBpdGVtUmVnZXg/KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBjYXBbMl0uc3BsaXQoJ1xcbicsIDEpWzBdLnJlcGxhY2UoL15cXHQrLywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gIWxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCgvW14gXS8pOyAvLyBGaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGluZGVudCA+IDQgPyAxIDogaW5kZW50OyAvLyBUcmVhdCBpbmRlbnRlZCBjb2RlIGJsb2NrcyAoPiA0IHNwYWNlcykgYXMgaGF2aW5nIG9ubHkgMSBpbmRlbnRcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gY2FwWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJsYW5rTGluZSAmJiAvXlsgXFx0XSokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcobmV4dExpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoclJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZW5jZXNCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19PFthLXpdLio+YCwgJ2knKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9sbG93aW5nIGxpbmVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBMaXN0IEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3TGluZSA9IHNyYy5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dExpbmVXaXRob3V0VGFicztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gcmF3TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWFsaWduIHRvIGZvbGxvdyBjb21tb25tYXJrIG5lc3RpbmcgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL14gezEsNH0oPz0oIHs0fSkqW14gXSkvZywgJyAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmVXaXRob3V0VGFicyA9IG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmVXaXRob3V0VGFicyA9IG5leHRMaW5lLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBjb2RlIGZlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGhlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBodG1sIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbEJlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMaW5lV2l0aG91dFRhYnMuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFuZXh0TGluZS50cmltKCkpIHsgLy8gRGVkZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmVXaXRob3V0VGFicy5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBpdGVtIGVuZGVkIHdpdGggYSBibGFuayBsaW5lLCB0aGUgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9cXG5bIFxcdF0qXFxuWyBcXHRdKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3QucmF3ICs9IHJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0udGV4dCA9IGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGxpc3QuaXRlbXNbaV0udGV4dCwgW10pO1xuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBsaXN0IHNob3VsZCBiZSBsb29zZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZSh0ID0+IC9cXG4uKlxcbi8udGVzdCh0LnJhdykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHByZTogY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbM107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWJsZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50YWJsZS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghY2FwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvWzp8XS8udGVzdChjYXBbMl0pKSB7XG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXIgcm93IG11c3QgaGF2ZSBhIHBpcGUgKHwpIG9yIGNvbG9uICg6KSBvdGhlcndpc2UgaXQgaXMgYSBzZXRleHQgaGVhZGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBzcGxpdENlbGxzKGNhcFsxXSk7XG4gICAgICAgIGNvbnN0IGFsaWducyA9IGNhcFsyXS5yZXBsYWNlKC9eXFx8fFxcfCAqJC9nLCAnJykuc3BsaXQoJ3wnKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IGNhcFszXSAmJiBjYXBbM10udHJpbSgpID8gY2FwWzNdLnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdO1xuICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICAgIGFsaWduOiBbXSxcbiAgICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycy5sZW5ndGggIT09IGFsaWducy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhlYWRlciBhbmQgYWxpZ24gY29sdW1ucyBtdXN0IGJlIGVxdWFsLCByb3dzIGNhbiBiZSBkaWZmZXJlbnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhbGlnbiBvZiBhbGlnbnMpIHtcbiAgICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgnY2VudGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5oZWFkZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogaGVhZGVyc1tpXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGhlYWRlcnNbaV0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGl0ZW0ucm93cy5wdXNoKHNwbGl0Q2VsbHMocm93LCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcCgoY2VsbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNlbGwsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2VsbCksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBpdGVtLmFsaWduW2ldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGxoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFncmFwaChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgOiBjYXBbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGV4dChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzBdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZShjYXBbMV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICAgICAgICAgIGluUmF3QmxvY2s6IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayxcbiAgICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogdGl0bGUsXG4gICAgICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rU3RyaW5nID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc1tsaW5rU3RyaW5nLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIgPSAnJykge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ0xEZWxpbS5leGVjKHNyYyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgICAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2goL1tcXHB7TH1cXHB7Tn1dL3UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8ICcnO1xuICAgICAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgICAgICAgLy8gdW5pY29kZSBSZWdleCBjb3VudHMgZW1vamkgYXMgMSBjaGFyOyBzcHJlYWQgaW50byBhcnJheSBmb3IgcHJvcGVyIGNvdW50ICh1c2VkIG11bHRpcGxlIHRpbWVzIGJlbG93KVxuICAgICAgICAgICAgY29uc3QgbExlbmd0aCA9IFsuLi5tYXRjaFswXV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCByRGVsaW0sIHJMZW5ndGgsIGRlbGltVG90YWwgPSBsTGVuZ3RoLCBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ1JEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltVW5kO1xuICAgICAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBDbGlwIG1hc2tlZFNyYyB0byBzYW1lIHNlY3Rpb24gb2Ygc3RyaW5nIGFzIHNyYyAobW92ZSB0byBsZXhlcj8pXG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgICAgICAgIGlmICghckRlbGltKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBzaW5nbGUgKiBpbiBfX2FiYyphYmNfX1xuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBbLi4uckRlbGltXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZERlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBDb21tb25NYXJrIEVtcGhhc2lzIFJ1bGVzIDktMTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxpbVRvdGFsIC09IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gSGF2ZW4ndCBmb3VuZCBlbm91Z2ggY2xvc2luZyBkZWxpbWl0ZXJzXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnMuICphKioqIC0+ICphKlxuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICAgICAgICAgIC8vIGNoYXIgbGVuZ3RoIGNhbiBiZSA+MSBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyTGVuZ3RoID0gWy4uLm1hdGNoWzBdXVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIGxhc3RDaGFyTGVuZ3RoICsgckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGBlbWAgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBvZGQgY2hhciBjb3VudC4gKmEqKipcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2Rlc3BhbihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2Rlc3BhbicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnIoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXV0b2xpbmsoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXJsKHNyYykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBleHRlbmRlZCBhdXRvbGluayBwYXRoIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBsZXQgcHJldkNhcFplcm87XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Q2FwWmVybyA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSk/LlswXSA/PyAnJztcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZWRpdCwgbm9vcFRlc3QsIH0gZnJvbSAnLi9oZWxwZXJzLnRzJztcbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5jb25zdCBuZXdsaW5lID0gL14oPzpbIFxcdF0qKD86XFxufCQpKSsvO1xuY29uc3QgYmxvY2tDb2RlID0gL14oKD86IHs0fXwgezAsM31cXHQpW15cXG5dKyg/Olxcbig/OlsgXFx0XSooPzpcXG58JCkpKik/KSsvO1xuY29uc3QgZmVuY2VzID0gL14gezAsM30oYHszLH0oPz1bXmBcXG5dKig/OlxcbnwkKSl8fnszLH0pKFteXFxuXSopKD86XFxufCQpKD86fChbXFxzXFxTXSo/KSg/OlxcbnwkKSkoPzogezAsM31cXDFbfmBdKiAqKD89XFxufCQpfCQpLztcbmNvbnN0IGhyID0gL14gezAsM30oKD86LVtcXHQgXSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/OlxcKlsgXFx0XSopezMsfSkoPzpcXG4rfCQpLztcbmNvbnN0IGhlYWRpbmcgPSAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvO1xuY29uc3QgYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuY29uc3QgbGhlYWRpbmcgPSBlZGl0KC9eKD8hYnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbCkoKD86LnxcXG4oPyFcXHMqP1xcbnxidWxsIHxibG9ja0NvZGV8ZmVuY2VzfGJsb2NrcXVvdGV8aGVhZGluZ3xodG1sKSkrPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpIC8vIGxpc3RzIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvYmxvY2tDb2RlL2csIC8oPzogezR9fCB7MCwzfVxcdCkvKSAvLyBpbmRlbnRlZCBjb2RlIGJsb2NrcyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2ZlbmNlcy9nLCAvIHswLDN9KD86YHszLH18fnszLH0pLykgLy8gZmVuY2VkIGNvZGUgYmxvY2tzIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvYmxvY2txdW90ZS9nLCAvIHswLDN9Pi8pIC8vIGJsb2NrcXVvdGUgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9oZWFkaW5nL2csIC8gezAsM30jezEsNn0vKSAvLyBBVFggaGVhZGluZyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2h0bWwvZywgLyB7MCwzfTxbXlxcbj5dKz5cXG4vKSAvLyBibG9jayBodG1sIGNhbiBpbnRlcnJ1cHRcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9wYXJhZ3JhcGggPSAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS87XG5jb25zdCBibG9ja1RleHQgPSAvXlteXFxuXSsvO1xuY29uc3QgX2Jsb2NrTGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSsvO1xuY29uc3QgZGVmID0gZWRpdCgvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG5bIFxcdF0qKT8oW148XFxzXVteXFxzXSp8PC4qPz4pKD86KD86ICsoPzpcXG5bIFxcdF0qKT98ICpcXG5bIFxcdF0qKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2Jsb2NrTGFiZWwpXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGxpc3QgPSBlZGl0KC9eKCB7MCwzfWJ1bGwpKFsgXFx0XVteXFxuXSs/KT8oPzpcXG58JCkvKVxuICAgIC5yZXBsYWNlKC9idWxsL2csIGJ1bGxldClcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICAgICsgJ3xmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxLTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lJ1xuICAgICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICAgICsgJ3xwfHBhcmFtfHNlYXJjaHxzZWN0aW9ufHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGUnXG4gICAgKyAnfHRyfHRyYWNrfHVsJztcbmNvbnN0IF9jb21tZW50ID0gLzwhLS0oPzotPz58W1xcc1xcU10qPyg/Oi0tPnwkKSkvO1xuY29uc3QgaHRtbCA9IGVkaXQoJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcblsgXFx0XSopK1xcXFxufCQpJyAvLyAoNilcbiAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcblsgXFx0XSopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsICdpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcGFyYWdyYXBoID0gZWRpdChfcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4dCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYmxvY2txdW90ZSA9IGVkaXQoL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLylcbiAgICAucmVwbGFjZSgncGFyYWdyYXBoJywgcGFyYWdyYXBoKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5jb25zdCBibG9ja05vcm1hbCA9IHtcbiAgICBibG9ja3F1b3RlLFxuICAgIGNvZGU6IGJsb2NrQ29kZSxcbiAgICBkZWYsXG4gICAgZmVuY2VzLFxuICAgIGhlYWRpbmcsXG4gICAgaHIsXG4gICAgaHRtbCxcbiAgICBsaGVhZGluZyxcbiAgICBsaXN0LFxuICAgIG5ld2xpbmUsXG4gICAgcGFyYWdyYXBoLFxuICAgIHRhYmxlOiBub29wVGVzdCxcbiAgICB0ZXh0OiBibG9ja1RleHQsXG59O1xuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5jb25zdCBnZm1UYWJsZSA9IGVkaXQoJ14gKihbXlxcXFxuIF0uKilcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9KCg/OlxcXFx8ICopPzo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSooPzpcXFxcfCAqKT8pJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuKCg/Oig/ISAqXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJykgLy8gQ2VsbHNcbiAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2NvZGUnLCAnKD86IHs0fXwgezAsM31cXHQpW15cXFxcbl0nKVxuICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBibG9ja0dmbSA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICB0YWJsZTogZ2ZtVGFibGUsXG4gICAgcGFyYWdyYXBoOiBlZGl0KF9wYXJhZ3JhcGgpXG4gICAgICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgICAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgICAgIC5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXh0IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAgICAgLnJlcGxhY2UoJ3RhYmxlJywgZ2ZtVGFibGUpIC8vIGludGVycnVwdCBwYXJhZ3JhcGhzIHdpdGggdGFibGVcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAgICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuY29uc3QgYmxvY2tQZWRhbnRpYyA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICAgICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgICAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgICAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICAgIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBsaGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfHRhZycsICcnKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbn07XG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cbmNvbnN0IGVzY2FwZSA9IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvO1xuY29uc3QgaW5saW5lQ29kZSA9IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS87XG5jb25zdCBiciA9IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLztcbmNvbnN0IGlubGluZVRleHQgPSAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvO1xuLy8gbGlzdCBvZiB1bmljb2RlIHB1bmN0dWF0aW9uIG1hcmtzLCBwbHVzIGFueSBtaXNzaW5nIGNoYXJhY3RlcnMgZnJvbSBDb21tb25NYXJrIHNwZWNcbmNvbnN0IF9wdW5jdHVhdGlvbiA9ICdcXFxccHtQfVxcXFxwe1N9JztcbmNvbnN0IHB1bmN0dWF0aW9uID0gZWRpdCgvXigoPyFbKl9dKVtcXHNwdW5jdHVhdGlvbl0pLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBfcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuY29uc3QgYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKCg/OlxcXFwufFteXFxcXFxcKFxcKV18XFwoKD86XFxcXC58W15cXFxcXFwoXFwpXSkqXFwpKSpcXCl8YFteYF0qP2B8PFtePD5dKj8+L2c7XG5jb25zdCBlbVN0cm9uZ0xEZWxpbSA9IGVkaXQoL14oPzpcXCorKD86KCg/IVxcKilbcHVuY3RdKXxbXlxccypdKSl8Xl8rKD86KCg/IV8pW3B1bmN0XSl8KFteXFxzX10pKS8sICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgZW1TdHJvbmdSRGVsaW1Bc3QgPSBlZGl0KCdeW15fKl0qP19fW15fKl0qP1xcXFwqW15fKl0qPyg/PV9fKScgLy8gU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZ1xuICAgICsgJ3xbXipdKyg/PVteKl0pJyAvLyBDb25zdW1lIHRvIGRlbGltXG4gICAgKyAnfCg/IVxcXFwqKVtwdW5jdF0oXFxcXCorKSg/PVtcXFxcc118JCknIC8vICgxKSAjKioqIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfFtecHVuY3RcXFxcc10oXFxcXCorKSg/IVxcXFwqKSg/PVtwdW5jdFxcXFxzXXwkKScgLy8gKDIpIGEqKiojLCBhKioqIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IVxcXFwqKVtwdW5jdFxcXFxzXShcXFxcKispKD89W15wdW5jdFxcXFxzXSknIC8vICgzKSAjKioqYSwgKioqYSBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3xbXFxcXHNdKFxcXFwqKykoPyFcXFxcKikoPz1bcHVuY3RdKScgLy8gKDQpICoqKiMgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXFxcXCopW3B1bmN0XShcXFxcKispKD8hXFxcXCopKD89W3B1bmN0XSknIC8vICg1KSAjKioqIyBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfFtecHVuY3RcXFxcc10oXFxcXCorKSg/PVtecHVuY3RcXFxcc10pJywgJ2d1JykgLy8gKDYpIGEqKiphIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuLy8gKDYpIE5vdCBhbGxvd2VkIGZvciBfXG5jb25zdCBlbVN0cm9uZ1JEZWxpbVVuZCA9IGVkaXQoJ15bXl8qXSo/XFxcXCpcXFxcKlteXypdKj9fW15fKl0qPyg/PVxcXFwqXFxcXCopJyAvLyBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nXG4gICAgKyAnfFteX10rKD89W15fXSknIC8vIENvbnN1bWUgdG8gZGVsaW1cbiAgICArICd8KD8hXylbcHVuY3RdKF8rKSg/PVtcXFxcc118JCknIC8vICgxKSAjX19fIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfFtecHVuY3RcXFxcc10oXyspKD8hXykoPz1bcHVuY3RcXFxcc118JCknIC8vICgyKSBhX19fIywgYV9fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3woPyFfKVtwdW5jdFxcXFxzXShfKykoPz1bXnB1bmN0XFxcXHNdKScgLy8gKDMpICNfX19hLCBfX19hIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfFtcXFxcc10oXyspKD8hXykoPz1bcHVuY3RdKScgLy8gKDQpIF9fXyMgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXylbcHVuY3RdKF8rKSg/IV8pKD89W3B1bmN0XSknLCAnZ3UnKSAvLyAoNSkgI19fXyMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBhbnlQdW5jdHVhdGlvbiA9IGVkaXQoL1xcXFwoW3B1bmN0XSkvLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBhdXRvbGluayA9IGVkaXQoL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LylcbiAgICAucmVwbGFjZSgnc2NoZW1lJywgL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vKVxuICAgIC5yZXBsYWNlKCdlbWFpbCcsIC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgX2lubGluZUNvbW1lbnQgPSBlZGl0KF9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbmNvbnN0IHRhZyA9IGVkaXQoJ15jb21tZW50J1xuICAgICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgKyAnfF48XFxcXD9bXFxcXHNcXFxcU10qP1xcXFw/PicgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZS5nLiA8P3BocCA/PlxuICAgICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nKSAvLyBDREFUQSBzZWN0aW9uXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfaW5saW5lQ29tbWVudClcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgX2lubGluZUxhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbmNvbnN0IGxpbmsgPSBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgLnJlcGxhY2UoJ2hyZWYnLCAvPCg/OlxcXFwufFteXFxuPD5cXFxcXSkrPnxbXlxcc1xceDAwLVxceDFmXSovKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC9cIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnKD86XFxcXCc/fFteJ1xcXFxdKSonfFxcKCg/OlxcXFxcXCk/fFteKVxcXFxdKSpcXCkvKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcmVmbGluayA9IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXFsocmVmKVxcXS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBfYmxvY2tMYWJlbClcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IG5vbGluayA9IGVkaXQoL14hP1xcWyhyZWYpXFxdKD86XFxbXFxdKT8vKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBfYmxvY2tMYWJlbClcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHJlZmxpbmtTZWFyY2ggPSBlZGl0KCdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsICdnJylcbiAgICAucmVwbGFjZSgncmVmbGluaycsIHJlZmxpbmspXG4gICAgLnJlcGxhY2UoJ25vbGluaycsIG5vbGluaylcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZU5vcm1hbCA9IHtcbiAgICBfYmFja3BlZGFsOiBub29wVGVzdCwgLy8gb25seSB1c2VkIGZvciBHRk0gdXJsXG4gICAgYW55UHVuY3R1YXRpb24sXG4gICAgYXV0b2xpbmssXG4gICAgYmxvY2tTa2lwLFxuICAgIGJyLFxuICAgIGNvZGU6IGlubGluZUNvZGUsXG4gICAgZGVsOiBub29wVGVzdCxcbiAgICBlbVN0cm9uZ0xEZWxpbSxcbiAgICBlbVN0cm9uZ1JEZWxpbUFzdCxcbiAgICBlbVN0cm9uZ1JEZWxpbVVuZCxcbiAgICBlc2NhcGUsXG4gICAgbGluayxcbiAgICBub2xpbmssXG4gICAgcHVuY3R1YXRpb24sXG4gICAgcmVmbGluayxcbiAgICByZWZsaW5rU2VhcmNoLFxuICAgIHRhZyxcbiAgICB0ZXh0OiBpbmxpbmVUZXh0LFxuICAgIHVybDogbm9vcFRlc3QsXG59O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVQZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lR2ZtID0ge1xuICAgIC4uLmlubGluZU5vcm1hbCxcbiAgICBlc2NhcGU6IGVkaXQoZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICB1cmw6IGVkaXQoL14oKD86ZnRwfGh0dHBzPyk6XFwvXFwvfHd3d1xcLikoPzpbYS16QS1aMC05XFwtXStcXC4/KStbXlxcczxdKnxeZW1haWwvLCAnaScpXG4gICAgICAgIC5yZXBsYWNlKCdlbWFpbCcsIC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8pXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypfJ1wifigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypfJ1wifildKyg/ISQpKSsvLFxuICAgIGRlbDogL14ofn4/KSg/PVteXFxzfl0pKFtcXHNcXFNdKj9bXlxcc35dKVxcMSg/PVtefl18JCkvLFxuICAgIHRleHQ6IC9eKFtgfl0rfFteYH5dKSg/Oig/PSB7Mix9XFxuKXwoPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCp+X118XFxiX3xodHRwcz86XFwvXFwvfGZ0cDpcXC9cXC98d3d3XFwufCQpfFteIF0oPz0gezIsfVxcbil8W15hLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0oPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKSkvLFxufTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lQnJlYWtzID0ge1xuICAgIC4uLmlubGluZUdmbSxcbiAgICBicjogZWRpdChicikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgICB0ZXh0OiBlZGl0KGlubGluZUdmbS50ZXh0KVxuICAgICAgICAucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJylcbiAgICAgICAgLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJylcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBleHBvcnRzXG4gKi9cbmV4cG9ydCBjb25zdCBibG9jayA9IHtcbiAgICBub3JtYWw6IGJsb2NrTm9ybWFsLFxuICAgIGdmbTogYmxvY2tHZm0sXG4gICAgcGVkYW50aWM6IGJsb2NrUGVkYW50aWMsXG59O1xuZXhwb3J0IGNvbnN0IGlubGluZSA9IHtcbiAgICBub3JtYWw6IGlubGluZU5vcm1hbCxcbiAgICBnZm06IGlubGluZUdmbSxcbiAgICBicmVha3M6IGlubGluZUJyZWFrcyxcbiAgICBwZWRhbnRpYzogaW5saW5lUGVkYW50aWMsXG59O1xuIiwiaW1wb3J0IHsgX1Rva2VuaXplciB9IGZyb20gJy4vVG9rZW5pemVyLnRzJztcbmltcG9ydCB7IF9kZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuaW1wb3J0IHsgYmxvY2ssIGlubGluZSB9IGZyb20gJy4vcnVsZXMudHMnO1xuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5leHBvcnQgY2xhc3MgX0xleGVyIHtcbiAgICB0b2tlbnM7XG4gICAgb3B0aW9ucztcbiAgICBzdGF0ZTtcbiAgICB0b2tlbml6ZXI7XG4gICAgaW5saW5lUXVldWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBUb2tlbkxpc3QgY2Fubm90IGJlIGNyZWF0ZWQgaW4gb25lIGdvXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bGVzID0ge1xuICAgICAgICAgICAgYmxvY2s6IGJsb2NrLm5vcm1hbCxcbiAgICAgICAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5wZWRhbnRpYztcbiAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmJyZWFrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBydWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgaW5saW5lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIGxleChzcmMpIHtcbiAgICAgICAgc3JjID0gc3JjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgbGFzdFRva2VuO1xuICAgICAgICBsZXQgY3V0U3JjO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bm5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS50b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKGN1dFNyYykpKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhcmFncmFwaENsaXBwZWQgJiYgbGFzdFRva2VuPy50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSAoY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgaW5saW5lKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZy9Db21waWxpbmdcbiAgICAgKi9cbiAgICBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgICAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuICAgICAgICAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuICAgICAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIsIHByZXZDaGFyO1xuICAgICAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rcy5pbmNsdWRlcyhtYXRjaFswXS5zbGljZShtYXRjaFswXS5sYXN0SW5kZXhPZignWycpICsgMSwgLTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICAgICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IF9kZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuaW1wb3J0IHsgY2xlYW5VcmwsIGVzY2FwZSwgfSBmcm9tICcuL2hlbHBlcnMudHMnO1xuLyoqXG4gKiBSZW5kZXJlclxuICovXG5leHBvcnQgY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIHBhcnNlcjsgLy8gc2V0IGJ5IHRoZSBwYXJzZXJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZSh0b2tlbikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvZGUoeyB0ZXh0LCBsYW5nLCBlc2NhcGVkIH0pIHtcbiAgICAgICAgY29uc3QgbGFuZ1N0cmluZyA9IChsYW5nIHx8ICcnKS5tYXRjaCgvXlxcUyovKT8uWzBdO1xuICAgICAgICBjb25zdCBjb2RlID0gdGV4dC5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG4gICAgICAgIGlmICghbGFuZ1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS0nXG4gICAgICAgICAgICArIGVzY2FwZShsYW5nU3RyaW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9XG4gICAgYmxvY2txdW90ZSh7IHRva2VucyB9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgICAgICByZXR1cm4gYDxibG9ja3F1b3RlPlxcbiR7Ym9keX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbCh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaGVhZGluZyh7IHRva2VucywgZGVwdGggfSkge1xuICAgICAgICByZXR1cm4gYDxoJHtkZXB0aH0+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvaCR7ZGVwdGh9PlxcbmA7XG4gICAgfVxuICAgIGhyKHRva2VuKSB7XG4gICAgICAgIHJldHVybiAnPGhyPlxcbic7XG4gICAgfVxuICAgIGxpc3QodG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRva2VuLm9yZGVyZWQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4uaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5saXN0aXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydEF0dHIgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRBdHRyICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH1cbiAgICBsaXN0aXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBpdGVtQm9keSA9ICcnO1xuICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHRoaXMuY2hlY2tib3goeyBjaGVja2VkOiAhIWl0ZW0uY2hlY2tlZCB9KTtcbiAgICAgICAgICAgIGlmIChpdGVtLmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBjaGVja2JveCArICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94ICsgJyAnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlci5wYXJzZShpdGVtLnRva2VucywgISFpdGVtLmxvb3NlKTtcbiAgICAgICAgcmV0dXJuIGA8bGk+JHtpdGVtQm9keX08L2xpPlxcbmA7XG4gICAgfVxuICAgIGNoZWNrYm94KHsgY2hlY2tlZCB9KSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKHRva2VuKSB7XG4gICAgICAgIGxldCBoZWFkZXIgPSAnJztcbiAgICAgICAgLy8gaGVhZGVyXG4gICAgICAgIGxldCBjZWxsID0gJyc7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4uaGVhZGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMudGFibGVjZWxsKHRva2VuLmhlYWRlcltqXSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyICs9IHRoaXMudGFibGVyb3coeyB0ZXh0OiBjZWxsIH0pO1xuICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2VuLnJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRva2VuLnJvd3Nbal07XG4gICAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy50YWJsZWNlbGwocm93W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy50YWJsZXJvdyh7IHRleHQ6IGNlbGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpXG4gICAgICAgICAgICBib2R5ID0gYDx0Ym9keT4ke2JvZHl9PC90Ym9keT5gO1xuICAgICAgICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgICAgICAgICArICc8dGhlYWQ+XFxuJ1xuICAgICAgICAgICAgKyBoZWFkZXJcbiAgICAgICAgICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICAgICAgICAgKyBib2R5XG4gICAgICAgICAgICArICc8L3RhYmxlPlxcbic7XG4gICAgfVxuICAgIHRhYmxlcm93KHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiBgPHRyPlxcbiR7dGV4dH08L3RyPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlY2VsbCh0b2tlbikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSB0b2tlbi5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke3Rva2VuLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiBgPGNvZGU+JHt0ZXh0fTwvY29kZT5gO1xuICAgIH1cbiAgICBicih0b2tlbikge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoeyBocmVmLCB0aXRsZSwgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBpbWFnZSh7IGhyZWYsIHRpdGxlLCB0ZXh0IH0pIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSBgPGltZyBzcmM9XCIke2hyZWZ9XCIgYWx0PVwiJHt0ZXh0fVwiYDtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7dGl0bGV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRleHQodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICd0b2tlbnMnIGluIHRva2VuICYmIHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0O1xuICAgIH1cbn1cbiIsIi8qKlxuICogVGV4dFJlbmRlcmVyXG4gKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAqL1xuZXhwb3J0IGNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0oeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHRleHQoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBfUmVuZGVyZXIgfSBmcm9tICcuL1JlbmRlcmVyLnRzJztcbmltcG9ydCB7IF9UZXh0UmVuZGVyZXIgfSBmcm9tICcuL1RleHRSZW5kZXJlci50cyc7XG5pbXBvcnQgeyBfZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLnRzJztcbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5leHBvcnQgY2xhc3MgX1BhcnNlciB7XG4gICAgb3B0aW9ucztcbiAgICByZW5kZXJlcjtcbiAgICB0ZXh0UmVuZGVyZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnBhcnNlciA9IHRoaXM7XG4gICAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYW55VG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3BhY2UodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhlYWRpbmcodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHRoaXMucmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLnJlbmRlcmVyLnRleHQodGV4dFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogW3sgdHlwZTogJ3RleHQnLCByYXc6IGJvZHksIHRleHQ6IGJvZHkgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1thbnlUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1thbnlUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGFueVRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKGFueVRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYW55VG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb25nJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZW0odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZXNwYW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdicic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IF9kZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuaW1wb3J0IHsgX0xleGVyIH0gZnJvbSAnLi9MZXhlci50cyc7XG5pbXBvcnQgeyBfUGFyc2VyIH0gZnJvbSAnLi9QYXJzZXIudHMnO1xuZXhwb3J0IGNsYXNzIF9Ib29rcyB7XG4gICAgb3B0aW9ucztcbiAgICBibG9jaztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFzc1Rocm91Z2hIb29rcyA9IG5ldyBTZXQoW1xuICAgICAgICAncHJlcHJvY2VzcycsXG4gICAgICAgICdwb3N0cHJvY2VzcycsXG4gICAgICAgICdwcm9jZXNzQWxsVG9rZW5zJyxcbiAgICBdKTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIG1hcmtkb3duIGJlZm9yZSBtYXJrZWRcbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzKG1hcmtkb3duKSB7XG4gICAgICAgIHJldHVybiBtYXJrZG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBIVE1MIGFmdGVyIG1hcmtlZCBpcyBmaW5pc2hlZFxuICAgICAqL1xuICAgIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYWxsIHRva2VucyBiZWZvcmUgd2FsayB0b2tlbnNcbiAgICAgKi9cbiAgICBwcm9jZXNzQWxsVG9rZW5zKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGZ1bmN0aW9uIHRvIHRva2VuaXplIG1hcmtkb3duXG4gICAgICovXG4gICAgcHJvdmlkZUxleGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA/IF9MZXhlci5sZXggOiBfTGV4ZXIubGV4SW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGZ1bmN0aW9uIHRvIHBhcnNlIHRva2Vuc1xuICAgICAqL1xuICAgIHByb3ZpZGVQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrID8gX1BhcnNlci5wYXJzZSA6IF9QYXJzZXIucGFyc2VJbmxpbmU7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgX2dldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy50cyc7XG5pbXBvcnQgeyBfTGV4ZXIgfSBmcm9tICcuL0xleGVyLnRzJztcbmltcG9ydCB7IF9QYXJzZXIgfSBmcm9tICcuL1BhcnNlci50cyc7XG5pbXBvcnQgeyBfSG9va3MgfSBmcm9tICcuL0hvb2tzLnRzJztcbmltcG9ydCB7IF9SZW5kZXJlciB9IGZyb20gJy4vUmVuZGVyZXIudHMnO1xuaW1wb3J0IHsgX1Rva2VuaXplciB9IGZyb20gJy4vVG9rZW5pemVyLnRzJztcbmltcG9ydCB7IF9UZXh0UmVuZGVyZXIgfSBmcm9tICcuL1RleHRSZW5kZXJlci50cyc7XG5pbXBvcnQgeyBlc2NhcGUgfSBmcm9tICcuL2hlbHBlcnMudHMnO1xuZXhwb3J0IGNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy5wYXJzZU1hcmtkb3duKHRydWUpO1xuICAgIHBhcnNlSW5saW5lID0gdGhpcy5wYXJzZU1hcmtkb3duKGZhbHNlKTtcbiAgICBQYXJzZXIgPSBfUGFyc2VyO1xuICAgIFJlbmRlcmVyID0gX1JlbmRlcmVyO1xuICAgIFRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG4gICAgTGV4ZXIgPSBfTGV4ZXI7XG4gICAgVG9rZW5pemVyID0gX1Rva2VuaXplcjtcbiAgICBIb29rcyA9IF9Ib29rcztcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMudXNlKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAgICovXG4gICAgd2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRhYmxlVG9rZW4uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZVRva2VuLnJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGxpc3RUb2tlbi5pdGVtcywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnM/LmNoaWxkVG9rZW5zPy5bZ2VuZXJpY1Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmZvckVhY2goKGNoaWxkVG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gZ2VuZXJpY1Rva2VuW2NoaWxkVG9rZW5zXS5mbGF0KEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnZW5lcmljVG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhnZW5lcmljVG9rZW4udG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIHVzZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmRlZmF1bHRzLmV4dGVuc2lvbnMgfHwgeyByZW5kZXJlcnM6IHt9LCBjaGlsZFRva2Vuczoge30gfTtcbiAgICAgICAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgICAgICAgICAvLyBjb3B5IG9wdGlvbnMgdG8gbmV3IG9iamVjdFxuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHsgLi4ucGFjayB9O1xuICAgICAgICAgICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgICAgICAgICAgb3B0cy5hc3luYyA9IHRoaXMuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJhZGRvblwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbnNpb24gbmFtZSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgncmVuZGVyZXInIGluIGV4dCkgeyAvLyBSZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBleHRlbnNpb24gd2l0aCBmdW5jIHRvIHJ1biBuZXcgZXh0ZW5zaW9uIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gZXh0LnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3Rva2VuaXplcicgaW4gZXh0KSB7IC8vIFRva2VuaXplciBFeHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5sZXZlbCB8fCAoZXh0LmxldmVsICE9PSAnYmxvY2snICYmIGV4dC5sZXZlbCAhPT0gJ2lubGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dExldmVsID0gZXh0ZW5zaW9uc1tleHQubGV2ZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0TGV2ZWwudW5zaGlmdChleHQudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQuc3RhcnQpIHsgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5sZXZlbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0LmxldmVsID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZS5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdjaGlsZFRva2VucycgaW4gZXh0ICYmIGV4dC5jaGlsZFRva2VucykgeyAvLyBDaGlsZCB0b2tlbnMgdG8gYmUgdmlzaXRlZCBieSB3YWxrVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwib3ZlcndyaXRlXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gcmVuZGVyZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlbmRlcmVyICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAncGFyc2VyJ10uaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBvcHRpb25zIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclByb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlckZ1bmMgPSBwYWNrLnJlbmRlcmVyW3JlbmRlcmVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3JlbmRlcmVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgcmVuZGVyZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJbcmVuZGVyZXJQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gcmVuZGVyZXJGdW5jLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplciA9IHRoaXMuZGVmYXVsdHMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIHRva2VuaXplcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdG9rZW5pemVyICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAncnVsZXMnLCAnbGV4ZXInXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMsIHJ1bGVzLCBhbmQgbGV4ZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplckZ1bmMgPSBwYWNrLnRva2VuaXplclt0b2tlbml6ZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplclt0b2tlbml6ZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW5ub3QgdHlwZSB0b2tlbml6ZXIgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyW3Rva2VuaXplclByb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSB0b2tlbml6ZXJGdW5jLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBIb29rcyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLmRlZmF1bHRzLmhvb2tzIHx8IG5ldyBfSG9va3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIGhvb2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob29rICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ29wdGlvbnMnLCAnYmxvY2snXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMgYW5kIGJsb2NrIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzRnVuYyA9IHBhY2suaG9va3NbaG9va3NQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkhvb2sgPSBob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX0hvb2tzLnBhc3NUaHJvdWdoSG9va3MuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIGhvb2sgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rc0Z1bmMuY2FsbChob29rcywgYXJnKSkudGhlbihyZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBob29rc0Z1bmMuY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIGhvb2sgZnVuY3Rpb24gZHluYW1pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBob29rc0Z1bmMuYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5ob29rcyA9IGhvb2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSB0aGlzLmRlZmF1bHRzLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja1dhbGt0b2tlbnMgPSBwYWNrLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFja1dhbGt0b2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHQpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0IH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXhlcihzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9MZXhlci5sZXgoc3JjLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZXIodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0aW9ucyA/PyB0aGlzLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgcGFyc2VNYXJrZG93bihibG9ja1R5cGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyc2UgPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9yaWdPcHQgfTtcbiAgICAgICAgICAgIGNvbnN0IHRocm93RXJyb3IgPSB0aGlzLm9uRXJyb3IoISFvcHQuc2lsZW50LCAhIW9wdC5hc3luYyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBhbiBleHRlbnNpb24gc2V0IGFzeW5jIHRvIHRydWUgYnV0IHBhcnNlIHdhcyBjYWxsZWQgd2l0aCBhc3luYzogZmFsc2VcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmFzeW5jID09PSB0cnVlICYmIG9yaWdPcHQuYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogVGhlIGFzeW5jIG9wdGlvbiB3YXMgc2V0IHRvIHRydWUgYnkgYW4gZXh0ZW5zaW9uLiBSZW1vdmUgYXN5bmM6IGZhbHNlIGZyb20gdGhlIHBhcnNlIG9wdGlvbnMgb2JqZWN0IHRvIHJldHVybiBhIFByb21pc2UuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3IgaW4gY2FzZSBvZiBub24gc3RyaW5nIGlucHV0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgICAgICAgICAgICAgICArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5ibG9jayA9IGJsb2NrVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxleGVyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVMZXhlcigpIDogKGJsb2NrVHlwZSA/IF9MZXhlci5sZXggOiBfTGV4ZXIubGV4SW5saW5lKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcm92aWRlUGFyc2VyKCkgOiAoYmxvY2tUeXBlID8gX1BhcnNlci5wYXJzZSA6IF9QYXJzZXIucGFyc2VJbmxpbmUpO1xuICAgICAgICAgICAgaWYgKG9wdC5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKSA6IHNyYylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3JjID0+IGxleGVyKHNyYywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBvcHQud2Fsa1Rva2VucyA/IFByb21pc2UuYWxsKHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKSkudGhlbigoKSA9PiB0b2tlbnMpIDogdG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gcGFyc2VyKHRva2Vucywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oaHRtbCA9PiBvcHQuaG9va3MgPyBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbCkgOiBodG1sKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godGhyb3dFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBodG1sID0gcGFyc2VyKHRva2Vucywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICBvbkVycm9yKHNpbGVudCwgYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG4gICAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgICAgICAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICsgJzwvcHJlPic7XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgX0xleGVyIH0gZnJvbSAnLi9MZXhlci50cyc7XG5pbXBvcnQgeyBfUGFyc2VyIH0gZnJvbSAnLi9QYXJzZXIudHMnO1xuaW1wb3J0IHsgX1Rva2VuaXplciB9IGZyb20gJy4vVG9rZW5pemVyLnRzJztcbmltcG9ydCB7IF9SZW5kZXJlciB9IGZyb20gJy4vUmVuZGVyZXIudHMnO1xuaW1wb3J0IHsgX1RleHRSZW5kZXJlciB9IGZyb20gJy4vVGV4dFJlbmRlcmVyLnRzJztcbmltcG9ydCB7IF9Ib29rcyB9IGZyb20gJy4vSG9va3MudHMnO1xuaW1wb3J0IHsgTWFya2VkIH0gZnJvbSAnLi9JbnN0YW5jZS50cyc7XG5pbXBvcnQgeyBfZ2V0RGVmYXVsdHMsIGNoYW5nZURlZmF1bHRzLCBfZGVmYXVsdHMsIH0gZnJvbSAnLi9kZWZhdWx0cy50cyc7XG5jb25zdCBtYXJrZWRJbnN0YW5jZSA9IG5ldyBNYXJrZWQoKTtcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQpIHtcbiAgICByZXR1cm4gbWFya2VkSW5zdGFuY2UucGFyc2Uoc3JjLCBvcHQpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKi9cbm1hcmtlZC5vcHRpb25zID1cbiAgICBtYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG1hcmtlZEluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgICAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gbWFya2VkO1xuICAgIH07XG4vKipcbiAqIEdldHMgdGhlIG9yaWdpbmFsIG1hcmtlZCBkZWZhdWx0IG9wdGlvbnMuXG4gKi9cbm1hcmtlZC5nZXREZWZhdWx0cyA9IF9nZXREZWZhdWx0cztcbm1hcmtlZC5kZWZhdWx0cyA9IF9kZWZhdWx0cztcbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5tYXJrZWQudXNlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBtYXJrZWRJbnN0YW5jZS51c2UoLi4uYXJncyk7XG4gICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xufTtcbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBDb21waWxlcyBtYXJrZG93biB0byBIVE1MIHdpdGhvdXQgZW5jbG9zaW5nIGBwYCB0YWcuXG4gKlxuICogQHBhcmFtIHNyYyBTdHJpbmcgb2YgbWFya2Rvd24gc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqIEByZXR1cm4gU3RyaW5nIG9mIGNvbXBpbGVkIEhUTUxcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gbWFya2VkSW5zdGFuY2UucGFyc2VJbmxpbmU7XG4vKipcbiAqIEV4cG9zZVxuICovXG5tYXJrZWQuUGFyc2VyID0gX1BhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gX1JlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBfTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBfTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG5tYXJrZWQuSG9va3MgPSBfSG9va3M7XG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5leHBvcnQgY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuZXhwb3J0IGNvbnN0IHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbmV4cG9ydCBjb25zdCB1c2UgPSBtYXJrZWQudXNlO1xuZXhwb3J0IGNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmV4cG9ydCBjb25zdCBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbmV4cG9ydCBjb25zdCBwYXJzZSA9IG1hcmtlZDtcbmV4cG9ydCBjb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuZXhwb3J0IGNvbnN0IGxleGVyID0gX0xleGVyLmxleDtcbmV4cG9ydCB7IF9kZWZhdWx0cyBhcyBkZWZhdWx0cywgX2dldERlZmF1bHRzIGFzIGdldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy50cyc7XG5leHBvcnQgeyBfTGV4ZXIgYXMgTGV4ZXIgfSBmcm9tICcuL0xleGVyLnRzJztcbmV4cG9ydCB7IF9QYXJzZXIgYXMgUGFyc2VyIH0gZnJvbSAnLi9QYXJzZXIudHMnO1xuZXhwb3J0IHsgX1Rva2VuaXplciBhcyBUb2tlbml6ZXIgfSBmcm9tICcuL1Rva2VuaXplci50cyc7XG5leHBvcnQgeyBfUmVuZGVyZXIgYXMgUmVuZGVyZXIgfSBmcm9tICcuL1JlbmRlcmVyLnRzJztcbmV4cG9ydCB7IF9UZXh0UmVuZGVyZXIgYXMgVGV4dFJlbmRlcmVyIH0gZnJvbSAnLi9UZXh0UmVuZGVyZXIudHMnO1xuZXhwb3J0IHsgX0hvb2tzIGFzIEhvb2tzIH0gZnJvbSAnLi9Ib29rcy50cyc7XG5leHBvcnQgeyBNYXJrZWQgfSBmcm9tICcuL0luc3RhbmNlLnRzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/marked/lib/marked.esm.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/widget.js");
/******/ 	
/******/ })()
;